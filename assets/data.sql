--
-- PostgreSQL database dump
--

-- Dumped from database version 9.6.2
-- Dumped by pg_dump version 9.6.2

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SET check_function_bodies = false;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: postgres; Type: COMMENT; Schema: -; Owner: 123
--

COMMENT ON DATABASE postgres IS 'default administrative connection database';


--
-- Name: plpgsql; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS plpgsql WITH SCHEMA pg_catalog;


--
-- Name: EXTENSION plpgsql; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION plpgsql IS 'PL/pgSQL procedural language';


SET search_path = public, pg_catalog;

SET default_tablespace = '';

SET default_with_oids = false;

--
-- Name: problem; Type: TABLE; Schema: public; Owner: 123
--

CREATE TABLE problem (
    id integer NOT NULL,
    checkpoint character varying(255),
    gpid character varying(255),
    lanqiaotitle character varying(255),
    tid character varying(255),
    title character varying(255),
    updatetime date
);


ALTER TABLE problem OWNER TO "123";

--
-- Name: problemdetail; Type: TABLE; Schema: public; Owner: 123
--

CREATE TABLE problemdetail (
    id integer NOT NULL,
    description text,
    refcode_c text,
    refcode_cpp text,
    refcode_java text,
    problem_id integer
);


ALTER TABLE problemdetail OWNER TO "123";

--
-- Name: problemdetail_id_seq; Type: SEQUENCE; Schema: public; Owner: 123
--

CREATE SEQUENCE problemdetail_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE problemdetail_id_seq OWNER TO "123";

--
-- Name: problemdetail_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: 123
--

ALTER SEQUENCE problemdetail_id_seq OWNED BY problemdetail.id;


--
-- Name: problemdetail id; Type: DEFAULT; Schema: public; Owner: 123
--

ALTER TABLE ONLY problemdetail ALTER COLUMN id SET DEFAULT nextval('problemdetail_id_seq'::regclass);


--
-- Data for Name: problem; Type: TABLE DATA; Schema: public; Owner: 123
--

COPY problem (id, checkpoint, gpid, lanqiaotitle, tid, title, updatetime) FROM stdin;
1	入门	T1	A+B问题	BEGIN-1	入门训练 A+B问题	2013-10-09
2	入门 求和公式	T2	序列求和	BEGIN-2	入门训练 序列求和	2013-10-09
3	入门 实数输出	T3	圆的面积	BEGIN-3	入门训练 圆的面积	2013-10-09
4	入门 数列 取模	T4	Fibonacci数列	BEGIN-4	入门训练 Fibonacci数列	2013-10-09
5	条件判断	T5	闰年判断	BASIC-1	基础练习 闰年判断	2013-10-09
6	循环	T6	01字串	BASIC-2	基础练习 01字串	2013-10-09
7	循环 字符串	T7	字母图形	BASIC-3	基础练习 字母图形	2013-10-09
8	循环 最大值 最小值 累加	T8	数列特征	BASIC-4	基础练习 数列特征	2013-10-09
9	循环 判断	T9	查找整数	BASIC-5	基础练习 查找整数	2013-10-09
10	基础练习 二维数组	T10	杨辉三角形	BASIC-6	基础练习 杨辉三角形	2013-10-09
11	排序 查找	T11	区间k大数查询	ALGO-1	算法训练 区间k大数查询	2013-10-16
12	贪心	T12	最大最小公倍数	ALGO-2	算法训练 最大最小公倍数	2013-10-16
13	动态规划	T13	K好数	ALGO-3	算法训练 K好数	2013-10-16
14	树形动态规划	T14	结点选择	ALGO-4	算法训练 结点选择	2013-10-16
15	最短路	T15	最短路	ALGO-5	算法训练 最短路	2013-10-16
16	最小生成树	T16	安慰奶牛	ALGO-6	算法训练 安慰奶牛	2013-10-16
17	平衡二叉树	T17	逆序对	ALGO-7	算法训练 逆序对	2013-10-16
18	线段树	T18	操作格子	ALGO-8	算法训练 操作格子	2013-10-16
19	排序	T19	两条直线	ADV-1	算法提高 两条直线	2013-10-16
20	枚举 贪心	T20	矩阵翻转	ADV-2	算法提高 矩阵翻转	2013-10-16
21	树形动态规划	T21	金属采集	ADV-3	算法提高 金属采集	2013-10-16
22	最短路	T22	道路和航路	ADV-4	算法提高 道路和航路	2013-10-16
23	最小生成树	T23	最小方差生成树	ADV-5	算法提高 最小方差生成树	2013-10-16
24	最小公倍数	T24	核桃的数量	PREV-1	历届试题 核桃的数量	2013-10-19
25	文字图形	T25	打印十字图	PREV-2	历届试题 打印十字图	2013-10-19
26	搜索	T26	带分数	PREV-3	历届试题 带分数	2013-10-19
27	搜索	T27	剪格子	PREV-4	历届试题 剪格子	2013-10-19
28	排序	T28	错误票据	PREV-5	历届试题 错误票据	2013-10-19
29	贪心	T29	翻硬币	PREV-6	历届试题 翻硬币	2013-10-19
30	并查集	T30	连号区间数	PREV-7	历届试题 连号区间数	2013-10-19
31	数论 动态规划	T31	买不到的数目	PREV-8	历届试题 买不到的数目	2013-10-19
32	深度优先遍历	T32	大臣的旅费	PREV-9	历届试题 大臣的旅费	2013-10-19
33	堆	T33	幸运数	PREV-10	历届试题 幸运数	2013-10-19
34	排序二叉树	T34	横向打印二叉树	PREV-11	历届试题 横向打印二叉树	2013-10-20
35	割点	T35	危险系数	PREV-12	历届试题 危险系数	2013-10-20
36	构图	T36	网络寻路	PREV-13	历届试题 网络寻路	2013-10-20
37	博弈论	T37	高僧斗法	PREV-14	历届试题 高僧斗法	2013-10-20
38	动态规划	T38	格子刷油漆	PREV-15	历届试题 格子刷油漆	2013-10-20
39	计算几何	T39	农场阳光	PREV-16	历届试题 农场阳光	2013-10-20
40	博弈论	T40	约数倍数选卡片	PREV-17	历届试题 约数倍数选卡片	2013-10-20
41	计算几何	T41	车轮轴迹	PREV-18	历届试题 车轮轴迹	2013-10-21
42	搜索	T42	九宫重排	PREV-19	历届试题 九宫重排	2013-10-21
43	组合数学	T43	公式求值	PREV-20	历届试题 公式求值	2013-10-21
44	动态规划	T44	摆动序列	ALGO-9	算法训练 摆动序列	2013-10-21
45	搜索	T45	邮票面值设计	ADV-6	算法提高 邮票面值设计	2013-10-21
46	循环 判断 数位	T46	特殊的数字	BASIC-7	基础练习 特殊的数字	2013-11-01
47	循环 判断 回文数	T47	回文数	BASIC-8	基础练习 回文数	2013-11-01
48	回文数 循环 条件语句	T48	特殊回文数	BASIC-9	基础练习 特殊回文数	2013-11-01
49	循环 整除 求余 判断	T49	十进制转十六进制	BASIC-10	基础练习 十进制转十六进制	2013-11-01
50	进制转换 字符处理 判断	T50	十六进制转十进制	BASIC-11	基础练习 十六进制转十进制	2013-11-01
51	进制转换 字符 循环	T51	十六进制转八进制	BASIC-12	基础练习 十六进制转八进制	2013-11-01
52	数组 排序	T52	数列排序	BASIC-13	基础练习 数列排序	2013-11-01
53	数组 排序	T53	集合运算	ALGO-10	算法训练 集合运算	2013-11-01
54	取余 数字字符混合输出	T54	时间转换	BASIC-14	基础练习 时间转换	2013-11-01
55	递归	T55	瓷砖铺放	ALGO-11	算法训练 瓷砖铺放	2013-11-01
56	字符串 大小写	T56	字符串对比	BASIC-15	基础练习 字符串对比	2013-11-01
57	质数分解 循环	T57	分解质因数	BASIC-16	基础练习 分解质因数	2013-11-03
58	二维数组 循环 矩阵	T58	矩阵乘法	BASIC-17	基础练习 矩阵乘法	2013-11-03
59	判断 线段交	T59	矩形面积交	BASIC-18	基础练习 矩形面积交	2013-11-03
60	贪心算法	T60	完美的代价	BASIC-19	基础练习 完美的代价	2013-11-03
61	判断 函数	T61	数的读法	BASIC-20	基础练习 数的读法	2013-11-03
62	字符串 递归 递推	T62	Sine之舞	BASIC-21	基础练习 Sine之舞	2013-11-03
63	字符串 递归	T63	FJ的字符串	BASIC-22	基础练习 FJ的字符串	2013-11-03
64	算法基础 统计 二维数组	T64	芯片测试	BASIC-23	基础练习 芯片测试	2013-11-03
65	数组 模拟	T65	龟兔赛跑预测	BASIC-24	基础练习 龟兔赛跑预测	2013-11-03
66	二维数组 循环	T66	回形取数	BASIC-25	基础练习 回形取数	2013-11-03
67	字符串 条件判断	T67	报时助手	BASIC-26	基础练习 报时助手	2013-11-03
68	八皇后问题 搜索	T68	2n皇后问题	BASIC-27	基础练习 2n皇后问题	2013-11-03
69	贪心 Huffuman	T69	Huffuman树	BASIC-28	基础练习 Huffuman树	2013-11-03
70	数组 高精度	T70	高精度加法	BASIC-29	基础练习 高精度加法	2013-11-03
71	高精度	T71	阶乘计算	BASIC-30	基础练习 阶乘计算	2013-11-03
72	递归	T72	幂方分解	ALGO-12	算法训练 幂方分解	2013-11-07
73	贪心 动态规划	T73	拦截导弹	ALGO-13	算法训练 拦截导弹	2013-11-07
74	模拟 高精度计算	T74	回文数	ALGO-14	算法训练 回文数	2013-11-07
157		T157	乘法运算	ADV-64	算法提高 乘法运算	2014-04-24
75	贪心	T75	旅行家的预算	ALGO-15	算法训练 旅行家的预算	2013-11-07
76	进制转换	T76	进制转换	ALGO-16	算法训练 进制转换	2013-11-07
77	动态规划	T77	乘积最大	ALGO-17	算法训练 乘积最大	2013-11-07
78	搜索	T78	单词接龙	ALGO-18	算法训练 单词接龙	2013-11-07
79	动态规划	T79	方格取数	ALGO-19	算法训练 方格取数	2013-11-07
80	组合	T80	子集选取	ADV-7	算法提高 子集选取	2013-11-07
81	组合	T81	冒泡排序计数	ADV-8	算法提高 冒泡排序计数	2013-11-07
82	递归	T82	求先序排列	ALGO-20	算法训练 求先序排列	2013-11-07
83	动态规划	T83	装箱问题	ALGO-21	算法训练 装箱问题	2013-11-07
84	动态规划	T84	数的划分	ALGO-22	算法训练 数的划分	2013-11-07
85	解方程	T85	一元三次方程求解	ALGO-23	算法训练 一元三次方程求解	2013-11-07
86	字符串	T86	统计单词个数	ALGO-24	算法训练 统计单词个数	2013-11-07
87	最短路	T87	Car的旅行路线	ALGO-25	算法训练 Car的旅行路线	2013-11-07
88	二分 高精度	T88	麦森数	ALGO-26	算法训练 麦森数	2013-11-08
89	树 遍历	T89	FBI树	ALGO-27	算法训练 FBI树	2013-11-08
90	排列生成算法	T90	星际交流	ALGO-28	算法训练 星际交流	2013-11-08
91	区间处理	T91	校门外的树	ALGO-29	算法训练 校门外的树	2013-11-08
92	0/1背包 动态规划	T92	入学考试	ALGO-30	算法训练 入学考试	2013-11-08
93	01背包 动态规划	T93	开心的金明	ALGO-31	算法训练 开心的金明	2013-11-08
94	组合生成	T94	JAM计数法	ALGO-32	算法训练 JAM计数法	2013-11-08
95	数学 进制	T95	数列	ALGO-33	算法训练 数列	2013-11-08
96	贪心 排序	T96	纪念品分组	ALGO-34	算法训练 纪念品分组	2013-11-08
97	动态规划	T97	传球游戏	ALGO-35	算法训练 传球游戏	2013-11-08
98	动态规划	T98	传纸条	ALGO-36	算法训练 传纸条	2013-11-08
99	数论	T99	Hankson的趣味题	ALGO-37	算法训练 Hankson的趣味题	2013-11-08
100	模拟	T100	接水问题	ALGO-38	算法训练 接水问题	2013-11-08
101		T101	数组排序去重	ALGO-39	算法训练 数组排序去重	2014-02-20
103	试用 C++ 入门	T103	A+B Problem	ALGO-43	算法训练 A+B Problem	2014-02-28
104	APIO 2009	T104	采油区域	ALGO-44	算法训练 采油区域	2014-02-28
105	APIO 2009	T105	会议中心	ALGO-40	算法训练 会议中心	2014-02-28
106		T106	送分啦	ALGO-42	算法训练 送分啦	2014-02-28
107		T107	调和数列问题	ALGO-45	算法训练 调和数列问题	2014-03-07
108		T108	Hanoi问题	ALGO-46	算法训练 Hanoi问题	2014-03-19
109		T109	蜜蜂飞舞	ALGO-47	算法训练 蜜蜂飞舞	2014-03-19
110		T110	关联矩阵	ALGO-48	算法训练 关联矩阵	2014-03-19
111		T111	寻找数组中最大值	ALGO-49	算法训练 寻找数组中最大值	2014-03-19
112		T112	递归倒置字符数组	ADV-9	算法提高 递归倒置字符数组	2014-03-20
113		T113	回文数字	PREV-21	历届试题 回文数字	2014-03-25
114		T114	国王的烦恼	PREV-22	历届试题 国王的烦恼	2014-03-25
115		T115	数字游戏	PREV-23	历届试题 数字游戏	2014-03-25
116		T116	邮局	PREV-24	历届试题 邮局	2014-03-25
117		T117	城市建设	PREV-25	历届试题 城市建设	2014-03-25
118		T118	最大子阵	PREV-26	历届试题 最大子阵	2014-03-25
119		T119	蚂蚁感冒	PREV-27	历届试题 蚂蚁感冒	2014-03-25
120		T120	地宫取宝	PREV-28	历届试题 地宫取宝	2014-03-25
121		T121	斐波那契	PREV-29	历届试题 斐波那契	2014-03-25
122		T122	波动数列	PREV-30	历届试题 波动数列	2014-03-25
123		T123	小朋友排队	PREV-31	历届试题 小朋友排队	2014-03-25
124		T124	分糖果	PREV-32	历届试题 分糖果	2014-03-25
125		T125	兰顿蚂蚁	PREV-33	历届试题 兰顿蚂蚁	2014-03-25
126		T126	矩阵翻硬币	PREV-34	历届试题 矩阵翻硬币	2014-03-25
127		T127	立方体截断问题	ADV-10	算法提高 立方体截断问题	2014-04-02
128		T128	数组查找及替换	ALGO-50	算法训练 数组查找及替换	2014-04-02
129		T129	Torry的困惑(基本型)	ALGO-51	算法训练 Torry的困惑(基本型)	2014-04-03
130		T130	Torry的困惑(提高型)	ADV-11	算法提高 Torry的困惑(提高型)	2014-04-03
131		T131	排列问题	ALGO-52	算法训练 排列问题	2014-04-04
132		T132	计算时间	ADV-12	算法提高 计算时间	2014-04-04
133		T133	最小乘积(基本型)	ALGO-53	算法训练 最小乘积(基本型)	2014-04-08
134		T134	最小乘积(提高型)	ADV-13	算法提高 最小乘积(提高型)	2014-04-08
135		T135	卡勒沃夫之弱水路三千(提高型)	ADV-14	算法提高 卡勒沃夫之弱水路三千(提高型)	2014-04-09
136		T136	最大乘积	ADV-15	算法提高 最大乘积	2014-04-10
137		T137	和最大子序列	ADV-16	算法提高 和最大子序列	2014-04-10
138		T138	简单加法(基本型)	ALGO-54	算法训练 简单加法(基本型)	2014-04-11
139		T139	矩阵加法	ALGO-55	算法训练 矩阵加法	2014-04-11
140		T140	统计单词数	ADV-17	算法提高 统计单词数	2014-04-14
141		T141	邮票	ALGO-56	算法训练 邮票	2014-04-14
142		T142	实数相加	ADV-18	算法提高 实数相加	2014-04-15
143		T143	项链	ADV-19	算法提高 项链	2014-04-15
144		T144	删除多余括号	ALGO-57	算法训练 删除多余括号	2014-04-16
145		T145	交换Easy	ADV-20	算法提高 交换Easy	2014-04-16
146		T146	字串逆序	ALGO-58	算法训练 字串逆序	2014-04-17
147		T147	快速排序	ALGO-59	算法训练 快速排序	2014-04-17
148		T148	矩阵乘方	ALGO-60	算法训练 矩阵乘方	2014-04-18
149		T149	奇偶判断	ALGO-61	算法训练 奇偶判断	2014-04-21
150		T150	平方计算	ALGO-62	算法训练 平方计算	2014-04-21
151		T151	乘法表	ALGO-63	算法训练 乘法表	2014-04-21
152		T152	多项式输出	ADV-21	算法提高 多项式输出	2014-04-22
153		T153	大小写判断	ALGO-64	算法训练 大小写判断	2014-04-22
154		T154	矩阵乘方	ADV-61	算法提高 矩阵乘方	2014-04-23
155		T155	夺宝奇兵	ADV-62	算法提高 夺宝奇兵	2014-04-23
156	输入函数，输出函数，基本算数运算	T156	利息计算	ADV-63	算法提高 利息计算	2014-04-24
158		T158	格子位置	ADV-65	算法提高 格子位置	2014-04-25
159		T159	比赛安排	ALGO-65	算法训练 比赛安排	2014-04-25
160		T160	字符串编辑	ALGO-66	算法训练 字符串编辑	2014-04-28
161	数组，逻辑表达式	T161	最大值与最小值的计算	ALGO-67	算法训练 最大值与最小值的计算	2014-04-28
162		T162	阮小二买彩票	ADV-66	算法提高 阮小二买彩票	2014-04-29
163	NOIP2003 提高组搜索	T163	传染病控制	ADV-67	算法提高 传染病控制	2014-04-29
164	if-else结构，数据有效性检查	T164	判定数字	ALGO-68	算法训练 判定数字	2014-04-30
165	循环 逻辑	T165	企业奖金发放	ADV-68	算法提高 企业奖金发放	2014-04-30
166	循环 数论	T166	质因数	ADV-69	算法提高 质因数	2014-05-05
167	排序 数组	T167	冒泡法排序	ADV-70	算法提高 冒泡法排序	2014-05-06
168	字符串	T168	字符串逆序	ALGO-69	算法训练 字符串逆序	2014-05-07
169	字符串 循环	T169	最长字符串	ALGO-70	算法训练 最长字符串	2014-05-08
170	字符串	T170	比较字符串	ALGO-71	算法训练 比较字符串	2014-05-09
171	循环 字符串	T171	判断回文	ADV-71	算法提高 判断回文	2014-05-12
172	输入输出	T172	一元一次方程	ADV-72	算法提高 一元一次方程	2014-05-13
173	分支结构	T173	成绩的等级输出	ALGO-72	算法训练 成绩的等级输出	2014-05-14
174	字符串 循环	T174	统计字符次数	ALGO-73	算法训练 统计字符次数	2014-05-15
175	数组 循环	T175	数组输出	ADV-73	算法提高 数组输出	2014-05-16
176		T176	计算整数因子	ADV-74	算法提高 计算整数因子	2014-05-20
177	语言 switch语句	T177	简单计算器	ADV-75	算法提高 简单计算器	2014-05-21
178	语言 循环	T178	GDP计算	ADV-76	算法提高 GDP计算	2014-05-23
179	语言 二维数组	T179	统计平均成绩	ADV-77	算法提高 统计平均成绩	2014-05-26
180	算法 字符串基本操作	T180	连接字符串	ALGO-74	算法训练 连接字符串	2014-05-27
181	算法 枚举	T181	最长单词	ADV-78	算法提高 最长单词	2014-05-28
182	算法 枚举、标记数组	T182	筛选号码	ALGO-75	算法训练 筛选号码	2014-05-29
183	算法 普通计算	T183	时间转换	ADV-79	算法提高 时间转换	2014-06-03
184	语言 指针	T184	选最大数	ADV-80	算法提高 选最大数	2014-06-04
185	语言 指针	T185	数的运算	ADV-81	算法提高 数的运算	2014-06-05
186	简单计算	T186	填充蛋糕	ADV-82	算法提高 填充蛋糕	2014-06-16
187	进制转换	T187	十进制数转八进制数	ALGO-76	算法训练 十进制数转八进制数	2014-06-23
188		T188	斜率计算	ALGO-77	算法训练 斜率计算	2014-06-30
189		T189	寻找三位数	ADV-83	算法提高 寻找三位数	2014-07-07
190		T190	图形输出	ADV-84	算法提高 图形输出	2014-07-14
191		T191	算术运算	ADV-85	算法提高 算术运算	2014-08-04
192		T192	格式化数据输出	ADV-86	算法提高 格式化数据输出	2014-08-11
193		T193	利息计算	ADV-87	算法提高 利息计算	2014-08-18
194		T194	输出正反三角形	ADV-88	算法提高 输出正反三角形	2014-08-25
195		T195	输出九九乘法表	ADV-89	算法提高 输出九九乘法表	2014-09-01
196		T196	输出日历	ADV-90	算法提高 输出日历	2014-09-09
197		T197	素数判断	ADV-91	算法提高 素数判断	2014-09-15
198		T198	求最大公约数	ADV-92	算法提高 求最大公约数	2014-09-22
199		T199	任意年月日历输出	ADV-93	算法提高 任意年月日历输出	2014-09-29
200		T200	确定元音字母位置	ALGO-78	算法训练 确定元音字母位置	2014-10-08
201		T201	删除数组零元素	ALGO-79	算法训练 删除数组零元素	2014-11-11
202		T202	整数平均值	ALGO-80	算法训练 整数平均值	2014-11-11
203		T203	复数归一化	ADV-94	算法提高 复数归一化	2014-11-12
204		T204	字符串比较	ADV-95	算法提高 字符串比较	2014-11-12
205		T205	动态数组使用	ALGO-81	算法训练 动态数组使用	2014-11-13
206		T206	复数求和	ADV-96	算法提高 复数求和	2014-11-13
207		T207	十进制数转八进制数	ADV-97	算法提高 十进制数转八进制数	2014-11-13
208		T208	输出米字形	ALGO-82	算法训练 输出米字形	2014-11-14
209		T209	约数个数	ADV-98	算法提高 约数个数	2014-11-17
210	循环语句	T210	栅格打印问题	ADV-99	算法提高 栅格打印问题	2014-11-17
211	逻辑判断 循环语句	T211	第二大整数	ADV-100	算法提高 第二大整数	2014-11-17
212	逻辑判断	T212	断案	ADV-101	算法提高 断案	2014-11-18
213	循环语句 数学知识	T213	阶乘	ALGO-83	算法训练 阶乘	2014-11-20
214	字符操作	T214	单词个数统计	ADV-102	算法提高 单词个数统计	2014-11-20
215	循环语句 数组操作	T215	逆序排列	ADV-103	算法提高 逆序排列	2014-11-20
216	字符操作	T216	大小写转换	ALGO-84	算法训练 大小写转换	2014-11-20
217	字符操作 数学知识	T217	进制转换	ALGO-85	算法训练 进制转换	2014-11-21
218		T218	矩阵乘法	ALGO-86	算法训练 矩阵乘法	2014-11-24
219		T219	字串统计	ALGO-87	算法训练 字串统计	2014-11-24
220		T220	字串统计	ALGO-88	算法训练 字串统计	2014-11-25
221	数组运算	T221	字符删除	ALGO-89	算法训练 字符删除	2014-11-26
222	数组运算	T222	出现次数最多的整数	ALGO-90	算法训练 出现次数最多的整数	2014-11-27
223	数组运算 字符操作	T223	Anagrams问题	ALGO-91	算法训练 Anagrams问题	2014-11-27
224		T224	打水问题	ADV-104	算法提高 打水问题	2014-12-11
225	字符操作 数学知识	T225	前缀表达式	ALGO-92	算法训练 前缀表达式	2014-12-16
226	函数设计 字符操作	T226	反置数	ALGO-93	算法训练 反置数	2014-12-16
227		T227	新生舞会	ALGO-94	算法训练 新生舞会	2014-12-17
228	数组运算 字符操作	T228	不同单词个数统计	ADV-105	算法提高 不同单词个数统计	2014-12-18
229		T229	欧拉函数	ADV-106	算法提高 欧拉函数	2014-12-18
231		T231	分数统计	ADV-108	算法提高 分数统计	2014-12-22
232	基本运算 数学知识	T232	征税程序	ADV-109	算法提高 征税程序	2014-12-24
233	基本运算 数学知识	T233	温度转换	ADV-110	算法提高 温度转换	2014-12-24
234	基本运算 数学知识	T234	Quadratic Equation	ADV-111	算法提高 Quadratic Equation	2014-12-25
235		T235	2的次幂表示	ALGO-95	算法训练 2的次幂表示	2014-12-29
236	输出格式	T236	Hello World!	ALGO-96	算法训练 Hello World!	2014-12-29
237		T237	c++_ch02_01	ADV-112	算法提高 c++_ch02_01	2014-12-30
238		T238	c++_ch02_02	ADV-113	算法提高 c++_ch02_02	2014-12-30
239		T239	c++_ch02_03	ADV-114	算法提高 c++_ch02_03	2014-12-31
240		T240	c++_ch03_02	ADV-115	算法提高 c++_ch03_02	2015-01-04
241		T241	c++_ch06_02	ADV-116	算法提高 c++_ch06_02	2015-01-05
242	基本运算 数学知识	T242	进制转换	ADV-117	算法提高 进制转换	2015-01-06
243	循环语句	T243	排序	ALGO-97	算法训练 排序	2015-01-06
244	字符操作 循环语句	T244	数位分离	ALGO-98	算法训练 数位分离	2015-01-07
245	逻辑判断 数学知识	T245	薪水计算	ALGO-99	算法训练 薪水计算	2015-01-08
246	循环语句 数学知识	T246	整除问题	ALGO-100	算法训练 整除问题	2015-01-13
247	循环语句	T247	图形显示	ALGO-101	算法训练 图形显示	2015-01-13
248	循环语句 数学知识	T248	数对	ALGO-102	算法训练 数对	2015-01-14
249	循环语句 数学知识	T249	完数	ALGO-103	算法训练 完数	2015-01-15
250	函数	T250	3-2字符串输入输出函数	ADV-118	算法提高 3-2字符串输入输出函数	2015-01-16
251	字符操作 数学知识	T251	阿尔法乘积	ALGO-104	算法训练 阿尔法乘积	2015-01-19
252	逻辑判断 取余运算 循环语句	T252	黑色星期五	ALGO-105	算法训练 黑色星期五	2015-01-20
253	字符串操作	T253	6-3判定字符位置	ALGO-106	算法训练 6-3判定字符位置	2015-01-21
254	数组操作	T254	6-9删除数组中的0元素	ADV-119	算法提高 6-9删除数组中的0元素	2015-01-22
255		T255	6-17复数四则运算	ADV-120	算法提高 6-17复数四则运算	2015-01-22
256		T256	9-7链表数据求和操作	ALGO-107	算法训练 9-7链表数据求和操作	2015-01-23
257	b字符串 数组	T257	高精度加法	ADV-121	算法提高 高精度加法	2015-01-26
258	字符流处理、循环逻辑	T258	去注释	ADV-122	算法提高 去注释	2015-01-27
259	动态规划	T259	概率计算	ADV-123	算法提高 概率计算	2015-01-27
260		T260	凶手	ADV-124	算法提高 凶手	2015-01-28
261	g背包	T261	最大体积	ALGO-108	算法训练 最大体积	2015-01-29
262	g背包	T262	促销购物	ADV-125	算法提高 促销购物	2015-01-30
263	g背包	T263	貌似化学	ALGO-109	算法训练 貌似化学	2015-02-02
264		T264	扫雷	ADV-126	算法提高 扫雷	2015-02-03
265		T265	日期计算	ADV-127	算法提高 日期计算	2015-02-03
266	字符串的处理 模拟	T266	字符串的展开	ALGO-110	算法训练 字符串的展开	2015-02-04
267	素数筛选	T267	找素数	ADV-128	算法提高 找素数	2015-03-02
268		T268	插入排序	ADV-129	算法提高 插入排序	2015-03-04
269		T269	色盲的民主	ADV-130	算法提高 色盲的民主	2015-03-06
270		T270	选择排序	ADV-131	算法提高 选择排序	2015-03-09
271	NOIP2006 排序	T271	明明的随机数	ALGO-111	算法训练 明明的随机数	2015-03-11
272	NOIP2008提高组	T272	笨小猴	ADV-132	算法提高 笨小猴	2015-03-13
273	一维数组	T273	彩票	ADV-133	算法提高 彩票	2015-03-16
274	数组	T274	校门外的树	ADV-134	算法提高 校门外的树	2015-03-18
275	a基础 顺序	T275	三角形面积	ADV-135	算法提高 三角形面积	2015-03-20
276	二维数组	T276	暗恋	ALGO-112	算法训练 暗恋	2015-03-23
277	高精度加法	T277	大数加法	ADV-136	算法提高 大数加法	2015-03-25
278		T278	数的统计	ALGO-113	算法训练 数的统计	2015-03-27
279	递归 搜索	T279	3000米排名预测	ADV-137	算法提高 3000米排名预测	2015-04-01
280	排序	T280	班级排名	ADV-138	算法提高 班级排名	2015-04-07
281		T281	黑白无常	ALGO-114	算法训练 黑白无常	2015-04-08
282	递归	T282	种树	ADV-139	算法提高 种树	2015-04-09
283	枚举 逻辑	T283	开灯游戏	ADV-140	算法提高 开灯游戏	2015-10-29
284	逻辑题, 第12周	T284	判断名次	ADV-141	算法提高 判断名次	2015-10-29
285	递归搜索	T285	棋盘多项式	ADV-142	算法提高 棋盘多项式	2015-10-30
286	逻辑推理	T286	扶老奶奶过街	ADV-143	算法提高 扶老奶奶过街	2015-10-30
287	小教员	T287	01背包	ADV-144	算法提高 01背包	2015-11-04
288	noip2011	T288	铺地毯	ADV-145	算法提高 铺地毯	2015-11-04
289	二维数组	T289	计算器	ADV-146	算法提高 计算器	2015-11-06
290	搜索, 第14周	T290	和为T	ALGO-115	算法训练 和为T	2015-11-06
291	广搜 bfs 经典问题	T291	学霸的迷宫	ADV-147	算法提高 学霸的迷宫	2015-11-06
292	贪心	T292	排队打水问题	ADV-148	算法提高 排队打水问题	2015-11-10
293	递归 构造 usaco1.5.3	T293	特殊的质数肋骨	ADV-149	算法提高 特殊的质数肋骨	2015-11-10
294	动态规划 资源分配类型（最大乘积）	T294	最大的算式	ALGO-116	算法训练 最大的算式	2015-11-10
295	函数	T295	友好数	ALGO-117	算法训练 友好数	2015-11-16
296	枚举	T296	连续正整数的和	ALGO-118	算法训练 连续正整数的和	2015-11-16
297	字符串处理	T297	周期字串	ADV-150	算法提高 周期字串	2015-11-16
298	循环 数学知识	T298	寂寞的数	ALGO-119	算法训练 寂寞的数	2015-11-16
299	循环	T299	学做菜	ALGO-120	算法训练 学做菜	2015-11-16
300		T300	金陵十三钗	ADV-151	算法提高 金陵十三钗	2015-11-16
301	b2002_3 简单图论 搜索	T301	产生数	ADV-152	算法提高 产生数	2015-11-19
302	递推	T302	猴子分苹果	ALGO-121	算法训练 猴子分苹果	2015-11-19
303	递归 递推	T303	未名湖边的烦恼	ALGO-122	算法训练 未名湖边的烦恼	2015-11-19
304	递归 动规	T304	数的划分	ADV-153	算法提高 数的划分	2015-11-20
305		T305	质数的后代	ADV-154	算法提高 质数的后代	2015-11-20
306		T306	上帝造题五分钟	ADV-155	算法提高 上帝造题五分钟	2015-11-20
307		T307	分分钟的碎碎念	ADV-156	算法提高 分分钟的碎碎念	2015-11-23
308		T308	现代诗如蚯蚓	ADV-157	算法提高 现代诗如蚯蚓	2015-11-23
385		T385	3-1课后习题2	ADV-212	算法提高 3-1课后习题2	2016-05-09
309		T309	新建Microsoft Word文档	ADV-158	算法提高 新建Microsoft Word文档	2015-11-23
310		T310	A+B problem	ALGO-123	算法训练 A+B problem	2015-11-26
311	模拟 高精度	T311	高精度乘法	ADV-159	算法提高 高精度乘法	2015-11-26
312		T312	数字三角形	ALGO-124	算法训练 数字三角形	2015-11-26
313		T313	题目 3 函数求值 	ADV-160	算法提高 题目 3 函数求值 	2015-11-27
314		T314	题目 2 密码锁	ADV-161	算法提高 题目 2 密码锁	2015-11-27
315		T315	题目1 最大最小值	ADV-162	算法提高 题目1 最大最小值	2015-11-27
316	动态规划	T316	能量项链	ADV-163	算法提高 能量项链	2015-12-01
317	动态规划	T317	金明的预算方案	ADV-164	算法提高 金明的预算方案	2015-12-01
318	回溯 递推 递归	T318	超级玛丽	ADV-165	算法提高 超级玛丽	2015-12-02
319	回溯 递归	T319	王、后传说	ALGO-125	算法训练 王、后传说	2015-12-04
320	动规 最长不降序列	T320	聪明的美食家	ADV-166	算法提高 聪明的美食家	2015-12-08
321	贪心 快排	T321	快乐司机	ADV-167	算法提高 快乐司机	2015-12-08
322	动态规划	T322	贪吃的大嘴	ADV-168	算法提高 贪吃的大嘴	2015-12-08
323	拓扑排序	T323	士兵排队问题	ADV-169	算法提高 士兵排队问题	2015-12-08
324	循环 递归	T324	数字黑洞	ADV-170	算法提高 数字黑洞	2015-12-11
325	字符串 模拟	T325	身份证号码升级	ADV-171	算法提高 身份证号码升级	2015-12-11
326	排序	T326	身份证排序	ADV-172	算法提高 身份证排序	2015-12-11
327	字符串 if流	T327	淘淘的名单	ADV-173	算法提高 淘淘的名单	2015-12-15
328	输入输出语法	T328	输入输出格式练习	ADV-174	算法提高 输入输出格式练习	2015-12-15
329	简单排序	T329	三个整数的排序	ADV-175	算法提高 三个整数的排序	2015-12-15
330	循环 if判断	T330	陶陶摘苹果	ADV-176	算法提高 陶陶摘苹果	2015-12-18
331	初等数学	T331	理财计划	ADV-177	算法提高 理财计划	2015-12-18
332	加法	T332	简单加法	ADV-178	算法提高 简单加法	2015-12-18
333	整除	T333	解二元一次方程组	ADV-179	算法提高 解二元一次方程组	2015-12-18
334	判断 分支	T334	水仙花	ALGO-126	算法训练 水仙花	2015-12-25
335	字符串处理  贪心	T335	C*++ Calculations	ALGO-127	算法训练 C*++ Calculations	2015-12-25
336	递推、动态规划	T336	Cowboys	ALGO-128	算法训练 Cowboys	2015-12-25
337	测试	T337	陶陶摘苹果2	ADV-180	算法提高 陶陶摘苹果2	2015-12-25
338	测试	T338	特殊的数字四十	ALGO-129	算法训练 特殊的数字四十	2015-12-25
339	模拟	T339	Entertaining Geodetics	ALGO-130	算法训练 Entertaining Geodetics	2016-01-04
340	排序、贪心	T340	Beaver's Calculator	ALGO-131	算法训练 Beaver's Calculator	2016-01-04
341	测试	T341	质因数2	ADV-181	算法提高 质因数2	2016-01-04
342	测试	T342	前10名	ADV-182	算法提高 前10名	2016-01-04
343	树上统计	T343	Maze	ALGO-132	算法训练 Maze	2016-01-07
344	字符串 KMP	T344	Tricky and Clever Password	ALGO-133	算法训练 Tricky and Clever Password	2016-01-07
345	数组	T345	分苹果	ADV-183	算法提高 分苹果	2016-01-07
346	dp,hash	T346	Don't fear, DravDe is kind	ALGO-134	算法训练 Don't fear, DravDe is kind	2016-01-07
347	构造	T347	Multithreading	ALGO-135	算法训练 Multithreading	2016-01-08
348	循环、筛法	T348	素数求和	ADV-184	算法提高 素数求和	2016-01-08
349	循环、枚举	T349	五次方数	ADV-185	算法提高 五次方数	2016-01-08
350	循环、排序	T350	排列式	ADV-186	算法提高 排列式	2016-01-08
351	循环、枚举	T351	勾股数	ADV-187	算法提高 勾股数	2016-01-08
352	循环、枚举	T352	排列数	ADV-188	算法提高 排列数	2016-01-08
353	循环、排序	T353	连接乘积	ADV-189	算法提高 连接乘积	2016-01-08
354		T354	师座操作系统	ADV-190	算法提高 师座操作系统	2016-01-27
355	二分图匹配  最大流	T355	Buying Sets	ALGO-136	算法训练 Buying Sets	2016-01-27
356	搜索	T356	Lift and Throw	ALGO-137	算法训练 Lift and Throw	2016-01-27
357	字典树 DP	T357	Representative Sampling (30_points)	ALGO-138	算法训练 Representative Sampling (30_points)	2016-01-27
358	链表 文件	T358	洗牌	ADV-191	算法提高 洗牌	2016-01-27
359	递归 排序	T359	盾神与砝码称重	ADV-192	算法提高 盾神与砝码称重	2016-01-27
360	链表	T360	盾神与条状项链	ADV-193	算法提高 盾神与条状项链	2016-01-27
361	贪心	T361	盾神与积木游戏	ADV-194	算法提高 盾神与积木游戏	2016-01-27
362		T362	文化之旅	ADV-195	算法提高 文化之旅	2016-01-27
363		T363	摆花	ADV-196	算法提高 摆花	2016-01-27
364	大数乘法	T364	P1001	ADV-197	算法提高 P1001	2016-01-27
365	网络警察	T365	P1003	ADV-198	算法提高 P1003	2016-01-27
366	递归	T366	s01串	ALGO-139	算法训练 s01串	2016-01-28
367	贪心	T367	线段和点	ADV-199	算法提高 线段和点	2016-01-28
368	动态规划	T368	求最大值	ADV-200	算法提高 求最大值	2016-01-28
369		T369	我们的征途是星辰大海	ADV-201	算法提高 我们的征途是星辰大海	2016-01-28
370	提货单	T370	P1101	ALGO-140	算法训练 P1101	2016-01-28
371	学生信息	T371	P1102	ALGO-141	算法训练 P1102	2016-01-28
372	复数运算	T372	P1103	ALGO-142	算法训练 P1103	2016-01-28
373	DP	T373	最长公共子序列	ADV-202	算法提高 最长公共子序列	2016-05-09
374	DFS	T374	8皇后·改	ADV-203	算法提高 8皇后·改	2016-05-09
375	快速幂	T375	快速幂	ADV-204	算法提高 快速幂	2016-05-09
376	动态规划	T376	拿糖果	ADV-205	算法提高 拿糖果	2016-05-09
377	高精度 精度估计	T377	不大的数	ADV-206	算法提高 不大的数	2016-05-09
378	递归	T378	最长字符序列	ADV-207	算法提高 最长字符序列	2016-05-09
379	字符串	T379	字符串变换	ALGO-143	算法训练 字符串变换	2016-05-09
380	线性代数	T380	矩阵相乘	ADV-208	算法提高 矩阵相乘	2016-05-09
381	循环，输出	T381	c++_ch02_04	ADV-209	算法提高 c++_ch02_04	2016-05-09
382		T382	2-1屏幕打印	ADV-210	算法提高 2-1屏幕打印	2016-05-09
383		T383	2-2整数求和	ADV-211	算法提高 2-2整数求和	2016-05-09
386		T386	3-2求存款	ADV-213	算法提高 3-2求存款	2016-05-09
387		T387	3-3求圆面积表面积体积	ADV-214	算法提高 3-3求圆面积表面积体积	2016-05-09
388		T388	Problem S4: Interesting Numbers 加强版	ADV-215	算法提高 Problem S4: Interesting Numbers 加强版	2016-05-09
389		T389	4-1打印下述图形	ALGO-145	算法训练 4-1打印下述图形	2016-05-09
390		T390	4-2找公倍数	ALGO-146	算法训练 4-2找公倍数	2016-10-25
391		T391	4-3水仙花数	ALGO-147	算法训练 4-3水仙花数	2016-10-25
392		T392	5-1最小公倍数	ALGO-148	算法训练 5-1最小公倍数	2016-11-03
393		T393	5-2求指数	ALGO-149	算法训练 5-2求指数	2016-11-03
394		T394	5-3日历	ADV-216	算法提高 5-3日历	2016-11-03
395	类与对象	T395	c++_ch04_02_修正版	ADV-217	算法提高 c++_ch04_02_修正版	2016-11-03
396	递推 矩阵乘法	T396	递推求值	ADV-218	算法提高 递推求值	2016-11-03
397	组合公式	T397	组合公式求值	ADV-219	算法提高 组合公式求值	2016-11-03
398	堆	T398	幸运顾客	ADV-220	算法提高 幸运顾客	2016-11-03
399		T399	6-1 递归求二项式系数值	ALGO-150	算法训练 6-1 递归求二项式系数值	2016-11-09
400		T400	6-2递归求二进制表示位数	ALGO-151	算法训练 6-2递归求二进制表示位数	2016-11-09
401		T401	7-1用宏求球的体积	ADV-221	算法提高 7-1用宏求球的体积	2016-11-09
402		T402	7-2求arccos值	ADV-222	算法提高 7-2求arccos值	2016-11-21
403		T403	8-1因式分解	ADV-223	算法提高 8-1因式分解	2016-11-21
404		T404	8-2求完数	ALGO-152	算法训练 8-2求完数	2016-11-21
407		T407	C++ CH08 01	ALGO-155	算法训练 C++ CH08 01	2016-11-23
409		T409	9-1九宫格	ADV-224	算法提高 9-1九宫格	2016-12-12
410		T410	9-2 文本加密	ADV-225	算法提高 9-2 文本加密	2016-12-12
411		T411	9-3摩尔斯电码	ADV-226	算法提高 9-3摩尔斯电码	2016-12-12
412	指针	T412	11-1实现strcmp函数	ADV-227	算法提高 11-1实现strcmp函数	2016-12-12
413		T413	11-2删除重复元素	ADV-228	算法提高 11-2删除重复元素	2016-12-12
414	动态规划 DP	T414	合并石子	ADV-229	算法提高 合并石子	2017-01-18
415		T415	12-1三角形	ADV-230	算法提高 12-1三角形	2017-01-18
416		T416	12-2扑克排序	ADV-231	算法提高 12-2扑克排序	2017-01-18
417	动态规划 DP	T417	矩阵乘法	ADV-232	算法提高 矩阵乘法	2017-01-18
418	queue 队列	T418	队列操作	ADV-233	算法提高 队列操作	2017-01-18
419	表达式	T419	表达式计算	ALGO-156	算法训练 表达式计算	2017-01-18
\.


--
-- Data for Name: problemdetail; Type: TABLE DATA; Schema: public; Owner: 123
--

COPY problemdetail (id, description, refcode_c, refcode_cpp, refcode_java, problem_id) FROM stdin;
1	<div class="des"> \n <div class="sec_header">\n  问题描述\n </div> \n <div class="sec_cont">\n  输入A、B，输出A+B。 \n  <div class="sec_note">\n   说明：在“问题描述”这部分，会给出试题的意思，以及所要求的目标。\n  </div> \n </div> \n <div class="sec_header">\n  输入格式\n </div> \n <div class="sec_cont">\n  输入的第一行包括两个整数，由空格分隔，分别表示A、B。 \n  <div class="sec_note"> \n   <p>说明：“输入格式”是描述在测试你的程序时，所给的输入一定满足的格式。</p> \n   <p>做题时你应该假设所给的输入是一定满足输入格式的要求的，所以你不需要对输入的格式进行检查。多余的格式检查可能会适得其反，使用你的程序错误。</p> \n   <p>在测试的时候，系统会自动将输入数据输入到你的程序中，你不能给任何提示。比如，你在输入的时候提示“请输入A、B”之类的话是不需要的，这些多余的输出会使得你的程序被判定为错误。</p> \n  </div> \n </div> \n <div class="sec_header">\n  输出格式\n </div> \n <div class="sec_cont">\n  输出一行，包括一个整数，表示A+B的值。 \n  <div class="sec_note"> \n   <p>说明：“输出格式”是要求你的程序在输出结果的时候必须满足的格式。</p> \n   <p>在输出时，你的程序必须满足这个格式的要求，不能少任何内容，也不能多任何内容。如果你的内容和输出格式要求的不一样，你的程序会被判断为错误，包括你输出了提示信息、中间调试信息、计时或者统计的信息等。</p> \n  </div> \n </div> \n <div class="sec_header">\n  样例输入\n </div> \n <div class="sec_text">\n  12 45 \n  <div class="sec_note"> \n   <p>说明：“样例输入”给出了一组满足“输入格式”要求的输入的例子。</p> \n   <p>这里给出的输入只是可能用来测试你的程序的一个输入，在测试的时候，还会有更多的输入用来测试你的程序。</p> \n  </div> \n </div> \n <div class="sec_header">\n  样例输出\n </div> \n <div class="sec_text">\n  57 \n  <div class="sec_note"> \n   <p>说明：“样例输出”给出了一组满足“输出格式”要求的输出的例子。</p> \n   <p>样例输出中的结果是和样例输入中的是对应的，因此，你可以使用样例的输入输出简单的检查你的程序。</p> \n   <p>要特别指出的是，能够通过样例输入输出的程序并不一定是正确的程序，在测试的时候，会用很多组数据进行测试，而不局限于样例数据。有可能一个程序通过了样例数据，但测试的时候仍只能得0分，可能因为这个程序只在一些类似样例的特例中正确，而不具有通用性，再测试更多数据时会出现错误。</p> \n   <p>比如，对于本题，如果你写一个程序不管输入是什么都输入57，则样例数据是对的，但是测试其他数据，哪怕输入是1和2，这个程序也输出57，则对于其他数据这个程序都不正确。</p> \n  </div> \n </div> \n <div class="sec_header">\n  数据规模与约定\n </div> \n <div class="sec_cont">\n  -10000 &lt;= A, B &lt;= 10000。 \n  <div class="sec_note"> \n   <p>说明：“数据规模与约定”中给出了试题中主要参数的范围。</p> \n   <p>这个范围对于解题非常重要，不同的数据范围会导致试题需要使用不同的解法来解决。比如本题中给的A、B范围不大，可以使用整型(int)来保存，如果范围更大，超过int的范围，则要考虑其他方法来保存大数。</p> \n   <p>有一些范围在方便的时候是在“问题描述”中直接给的，所以在做题时不仅要看这个范围，还要注意问题描述。</p> \n  </div> \n </div> \n <div class="sec_header">\n  提示\n </div> \n <div class="sec_cont"> \n  <p>本题的C++源代码如下：</p> \n  <div class="code codec"> \n   <ol> \n    <li><span class="de">#include &lt;iostream&gt;</span></li> \n    <li>&nbsp;</li> \n    <li><span class="k">using namespace</span> std<span class="s">;</span></li> \n    <li>&nbsp;</li> \n    <li><span class="k">int</span> main<span class="s">()</span></li> \n    <li><span class="s">{</span></li> \n    <li>&nbsp; &nbsp; <span class="k">int</span> a<span class="s">,</span> b<span class="s">;</span></li> \n    <li>&nbsp; &nbsp; cin <span class="s">&gt;&gt;</span> a <span class="s">&gt;&gt;</span> b<span class="s">;</span></li> \n    <li>&nbsp; &nbsp; cout <span class="s">&lt;&lt;</span> a <span class="s">+</span> b<span class="s">;</span></li> \n    <li>&nbsp; &nbsp; <span class="k">return</span> <span class="n">0</span><span class="s">;</span></li> \n    <li><span class="s">}</span></li> \n   </ol> \n  </div> \n  <p>本题的C源代码如下：</p> \n  <div class="code codec"> \n   <ol> \n    <li><span class="de">#include &lt;stdio.h&gt;</span></li> \n    <li>&nbsp;</li> \n    <li><span class="k">int</span> main<span class="s">()</span></li> \n    <li><span class="s">{</span></li> \n    <li>&nbsp; &nbsp; <span class="k">int</span> a<span class="s">,</span> b<span class="s">;</span></li> \n    <li>&nbsp; &nbsp; scanf<span class="s">(</span><span class="st">"%d%d"</span>, <span class="s">&amp;</span>a<span class="s">,</span> <span class="s">&amp;</span>b<span class="s">);</span></li> \n    <li>&nbsp; &nbsp; printf<span class="s">(</span><span class="st">"%d"</span><span class="s">,</span> a<span class="s">+</span>b<span class="s">);</span></li> \n    <li>&nbsp; &nbsp; <span class="k">return</span> <span class="n">0</span><span class="s">;</span></li> \n    <li><span class="s">}</span></li> \n   </ol> \n  </div> \n  <p>本题的Java源代码如下：</p> \n  <div class="code codejava"> \n   <ol> \n    <li><span class="k">import</span> java.util.*;</li> \n    <li>&nbsp;</li> \n    <li><span class="k">public</span> <span class="k">class</span> Main</li> \n    <li><span class="s">{</span></li> \n    <li>&nbsp; &nbsp; <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> main<span class="s">(</span>String args<span class="s">[])</span></li> \n    <li>&nbsp; &nbsp; <span class="s">{</span></li> \n    <li>&nbsp; &nbsp; &nbsp; &nbsp; Scanner sc <span class="s">=</span> <span class="k">new</span> Scanner<span class="s">(</span>System.in<span class="s">);</span></li> \n    <li>&nbsp; &nbsp; &nbsp; &nbsp; Integer a <span class="s">=</span> sc.nextInt<span class="s">();</span></li> \n    <li>&nbsp; &nbsp; &nbsp; &nbsp; Integer b <span class="s">=</span> sc.nextInt<span class="s">();</span></li> \n    <li>&nbsp; &nbsp; &nbsp; &nbsp; System<span class="s">.</span>out<span class="s">.</span>println<span class="s">(</span>a <span class="s">+</span> b<span class="s">)</span><span class="s">;</span></li> \n    <li>&nbsp; &nbsp; <span class="s">}</span></li> \n    <li><span class="s">}</span></li> \n   </ol> \n  </div> \n  <div class="sec_note"> \n   <p>说明：要答题，请点击页面上方的“提交此题”按钮，页面将跳转到提交代码的页面，选择好你的编译语言，将你的编写好的代码粘贴到代码框中，再点击“提交答案”即可。</p> \n   <p>你的答案提交给系统后系统会自动对你的代码进行判分，并跳转到结果的列表里面，你可以直接从列表中看到你提交的代码的状态，一般几秒钟后就可以看到判分的结果。</p> \n   <p>本题作为第一题，在提示中已经分别给了C++和Java的代码，你可以直接把这个代码拷贝过去作为自己的代码提交。</p> \n   <p>请特别注意，Java的主类名必须是Main。</p> \n  </div> \n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint main()\n{\n    int a, b;\n    scanf("%d%d", &amp;a, &amp;b);\n    printf("%d", a+b);\n    return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\nusing namespace std;\nint main()\n{\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n    cout &lt;&lt; a + b;\n    return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nclass Main\n{\n\tpublic static void main(String[] args) throws IOException\n\t{\n\t\targs = new BufferedReader(new InputStreamReader(System.in)).readLine().split(" ");\n\t\tSystem.out.println(Integer.parseInt(args[0])+Integer.parseInt(args[1]));\n\t}\n}\n\r\n</textarea>	1
2	<div class="des"> \n <div class="sec_header">\n   问题描述\n </div> \n <div class="sec_cont">\n   求1+2+3+...+n的值。 \n </div> \n <div class="sec_header">\n   输入格式\n </div> \n <div class="sec_cont">\n   输入包括一个整数n。 \n </div> \n <div class="sec_header">\n   输出格式\n </div> \n <div class="sec_cont">\n   输出一行，包括一个整数，表示1+2+3+...+n的值。 \n </div> \n <div class="sec_header">\n   样例输入\n </div> \n <div class="sec_text">\n   4 \n </div> \n <div class="sec_header">\n   样例输出\n </div> \n <div class="sec_text">\n   10 \n </div> \n <div class="sec_header">\n   样例输入\n </div> \n <div class="sec_text">\n   100 \n  <div class="sec_note"> \n   <p>说明：有一些试题会给出多组样例输入输出以帮助你更好的做题。</p> \n   <p>一般在提交之前所有这些样例都需要测试通过才行，但这不代表这几组样例数据都正确了你的程序就是完全正确的，潜在的错误可能仍然导致你的得分较低。</p> \n  </div> \n </div> \n <div class="sec_header">\n   样例输出\n </div> \n <div class="sec_text">\n   5050 \n </div> \n <div class="sec_header">\n   数据规模与约定\n </div> \n <div class="sec_cont">\n   1 &lt;= n &lt;= 1,000,000,000。 \n  <div class="sec_note"> \n   <p>说明：请注意这里的数据规模。</p> \n   <p>本题直接的想法是直接使用一个循环来累加，然而，当数据规模很大时，这种“暴力”的方法往往会导致超时。此时你需要想想其他方法。你可以试一试，如果使用1000000000作为你的程序的输入，你的程序是不是能在规定的上面规定的时限内运行出来。</p> \n   <p>本题另一个要值得注意的地方是答案的大小不在你的语言默认的整型(int)范围内，如果使用整型来保存结果，会导致结果错误。</p> \n   <p>如果你使用C++或C语言而且准备使用printf输出结果，则你的格式字符串应该写成%I64d以输出long long类型的整数。</p> \n  </div> \n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint main()\n{\n    int n;\n    long long ret = 0, tmp;\n    scanf("%d", &amp;n);\n    tmp = n;\n    printf("%I64d", (1+tmp) * tmp / 2);\n    return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\nusing namespace std;\nint main()\n{\n     long long n;\n    cin &gt;&gt; n;\n    cout &lt;&lt; (1+n) * n / 2;\n    return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\npublic class Main {\r\n    public static void main(String args[]) throws NumberFormatException, IOException{\r\n        BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));\r\n        long i = Integer.parseInt(strin.readLine());\r\n        long sum = (1+i)*i/2;\r\n        System.out.println(sum);\r\n    }\r\n}\r\n</textarea>	2
3	<div class="des"> \n <div class="sec_header">\n   问题描述\n </div> \n <div class="sec_cont">\n   给定圆的半径r，求圆的面积。 \n </div> \n <div class="sec_header">\n   输入格式\n </div> \n <div class="sec_cont">\n   输入包含一个整数r，表示圆的半径。 \n </div> \n <div class="sec_header">\n   输出格式\n </div> \n <div class="sec_cont">\n   输出一行，包含一个实数，四舍五入保留小数点后7位，表示圆的面积。 \n  <div class="sec_note"> \n   <p>说明：在本题中，输入是一个整数，但是输出是一个实数。</p> \n   <p>对于实数输出的问题，请一定看清楚实数输出的要求，比如本题中要求保留小数点后7位，则你的程序必须<b>严格的</b>输出7位小数，输出过多或者过少的小数位数都是不行的，都会被认为错误。</p> \n   <p>实数输出的问题如果没有特别说明，舍入都是按四舍五入进行。</p> \n  </div> \n </div> \n <div class="sec_header">\n   样例输入\n </div> \n <div class="sec_text">\n   4 \n </div> \n <div class="sec_header">\n   样例输出\n </div> \n <div class="sec_text">\n   50.2654825 \n </div> \n <div class="sec_header">\n   数据规模与约定\n </div> \n <div class="sec_cont">\n   1 &lt;= r &lt;= 10000。 \n </div> \n <div class="sec_header">\n   提示\n </div> \n <div class="sec_cont">\n   本题对精度要求较高，请注意π的值应该取较精确的值。你可以使用常量来表示π，比如PI=3.14159265358979323，也可以使用数学公式来求π，比如PI=atan(1.0)*4。 \n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nint main()\n{\n    int r;\n    double s, PI;\n    scanf("%d", &amp;r);\n    PI = atan(1.0) * 4;\n    s = PI * r * r;\n    printf("%.7lf", s);\n    return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\nint main()\n{\n    int r;\n    double s, PI;\n    scanf("%d", &amp;r);\n    PI = atan(1.0) * 4;\n    s = PI * r * r;\n    printf("%.7lf", s);\n    return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.math.BigDecimal;\n\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t * @throws IOException \n\t */\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO Auto-generated method stub\n\t        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n\t        BigDecimal  bg = new BigDecimal(bf.readLine());\n\t        BigDecimal value = bg.multiply(bg.multiply(new BigDecimal(Math.PI))).setScale(7,BigDecimal.ROUND_HALF_UP);\n\t        System.out.println(value);\n\t}\n}\n\r\n</textarea>	3
4	<div class="des"> \n <div class="sec_header">\n   问题描述\n </div> \n <div class="sec_cont"> \n  <p>Fibonacci数列的递推公式为：F<sub>n</sub>=F<sub>n-1</sub>+F<sub>n-2</sub>，其中F<sub>1</sub>=F<sub>2</sub>=1。</p> \n  <p>当n比较大时，F<sub>n</sub>也非常大，现在我们想知道，F<sub>n</sub>除以10007的余数是多少。</p> \n </div> \n <div class="sec_header">\n   输入格式\n </div> \n <div class="sec_cont">\n   输入包含一个整数n。\n </div> \n <div class="sec_header">\n   输出格式\n </div> \n <div class="sec_cont">\n   输出一行，包含一个整数，表示F\n  <sub>n</sub>除以10007的余数。 \n  <div class="sec_note"> \n   <p>说明：在本题中，答案是要求F<sub>n</sub>除以10007的余数，因此我们只要能算出这个余数即可，而不需要先计算出F<sub>n</sub>的准确值，再将计算的结果除以10007取余数，直接计算余数往往比先算出原数再取余简单。</p> \n  </div> \n </div> \n <div class="sec_header">\n   样例输入\n </div> \n <div class="sec_text">\n   10\n </div> \n <div class="sec_header">\n   样例输出\n </div> \n <div class="sec_text">\n   55\n </div> \n <div class="sec_header">\n   样例输入\n </div> \n <div class="sec_text">\n   22\n </div> \n <div class="sec_header">\n   样例输出\n </div> \n <div class="sec_text">\n   7704\n </div> \n <div class="sec_header">\n   数据规模与约定\n </div> \n <div class="sec_cont">\n   1 &lt;= n &lt;= 1,000,000。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#define MOD 10007\n#define MAXN 1000001\nint n, i, F[MAXN];\nint main()\n{\n    scanf("%d", &amp;n);\n    F[1] = 1;\n    F[2] = 1;\n    for (i = 3; i &lt;= n; ++i)\n        F[i] = (F[i-1] + F[i-2]) % MOD;\n    printf("%d\\n", F[n]);\n    return 0;\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#define MOD 10007\n#define MAXN 1000001\nint n, i, F[MAXN];\nint main()\n{\n    scanf("%d", &amp;n);\n    F[1] = 1;\n    F[2] = 1;\n    for (i = 3; i &lt;= n; ++i)\n        F[i] = (F[i-1] + F[i-2]) % MOD;\n    printf("%d\\n", F[n]);\n    return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\npublic class Main {\n\tpublic static void main(String[] args) throws IOException{\n\t    BufferedReader reader=new BufferedReader(new InputStreamReader(System.in));\n\t    String s=reader.readLine();\n\t    int n=Integer.valueOf(s);\n\t    int f1=1,f2=1,f3=0;\n\t    if(n&lt;3){\n\t    \tSystem.out.print("1");\n\t    \treturn;}\n\t    for(int i=3;i&lt;=n;i++)\n\t    {if(f1&gt;10007)f1=f1%10007;\n\t    if(f2&gt;10007)f2=f2%10007;\n\t    f3=f1+f2;\n\t    f1=f2;\n\t    f2=f3;\n\t    }\n\t    System.out.print(f3%10007);\n\t    }\n\t    \n}\r\n</textarea>	4
37	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　古时丧葬活动中经常请高僧做法事。仪式结束后，有时会有“高僧斗法”的趣味节目，以舒缓压抑的气氛。\n  <br> 　　节目大略步骤为：先用粮食（一般是稻米）在地上“画”出若干级台阶（表示N级浮屠）。又有若干小和尚随机地“站”在某个台阶上。最高一级台阶必须站人，其它任意。(如图1所示)\n  <br> 　　两位参加游戏的法师分别指挥某个小和尚向上走任意多级的台阶，但会被站在高级台阶上的小和尚阻挡，不能越过。两个小和尚也不能站在同一台阶，也不能向低级台阶移动。\n  <br> 　　两法师轮流发出指令，最后所有小和尚必然会都挤在高段台阶，再也不能向上移动。轮到哪个法师指挥时无法继续移动，则游戏结束，该法师认输。\n  <br> 　　对于已知的台阶数和小和尚的分布位置，请你计算先发指令的法师该如何决策才能保证胜出。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入数据为一行用空格分开的N个整数，表示小和尚的位置。台阶序号从1算起，所以最后一个小和尚的位置即是台阶的总数。（N&lt;100, 台阶总数&lt;1000）\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出为一行用空格分开的两个整数: A B, 表示把A位置的小和尚移动到B位置。若有多个解，输出A值较小的解，若无解则输出-1。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  1 5 9\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  1 4\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  1 5 8 10\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  1 3\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;   //参考蓝桥杯贴吧 dezhonger\nint main()\n{\n\tint a[105],b[105],i=0,j,k,count,sum;\n\tchar c;\n\twhile(1)\n\t{\n\t\tscanf("%d%c",&amp;a[i++],&amp;c);\n\t\tif(c=='\\n')\n\t\t\tbreak;\n\t}\n\tcount=i;\n\tfor(i = 0;i &lt; count-1;i++)\n\t\tb[i]=a[i+1]-a[i]-1;\n\tb[count-1]=0;\n\tsum=b[0];\n\tfor(i = 2;i &lt; count;i = i+2)\n\t\tsum^=b[i];\n\tif(sum == 0)\n\t\tprintf("-1\\n");\n\telse\n\t{\n\t\tfor(i = 0;i &lt; count;i++)\n\t\t\tfor(j = 1;j &lt;= b[i];j++)\n\t\t\t{\n\t\t\t\tb[i] -= j;\n\t\t\t\tif(i!=0)\n\t\t\t\t\tb[i-1]+=j;\n\t\t\t\tsum = b[0];\n\t\t\t\tfor(k = 2;k &lt; count;k = k+2)\n\t\t\t\t\tsum ^= b[k];\n\t\t\t\tif(sum == 0)\n\t\t\t\t{\n\t\t\t\t\tprintf("%d %d\\n",a[i],a[i]+j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tb[i] += j;\n\t\t\t\tif(i != 0)\n\t\t\t\t\tb[i-1] -= j;\n\t\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n1 3 5 7 12 14 17 26 38 45 66 100\n66 84\n*/\n\r\n</textarea>	<textarea id="codelinescpp">\r\n//2014年1月12日12:29:37\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#define N 1050\nint a[N]; //存放输入数据\nint s[N]; //虚拟石子\nint total = 0;\nint flag= 0;\nint i,j;\n\nint main()\n{\n\tdo\n\t{\n\t\tscanf("%d",&amp;a[total++]);\n\t\tif(total%2==0)\n\t\t\ts[total/2] = a[total-1]-a[total-2]-1;\n\t}while(getchar()!='\\n');\n\n\tfor(i=1;i&lt;=total/2;i++)\n\t{\n\t\tflag^=s[i];\n\t}\n\t//一开始就处于N态\n\tif(!flag) printf("-1");\n\telse\n\t{\n\t\tfor(i=1;i&lt;=total/2;i++)//从最小的开始遍历\n\t\t{\n\t\t\tint temp = s[i];\n\t\t\t//左边上移减少数量\n\t\t\twhile(s[i]--)\n\t\t\t{\n\t\t\t\tflag = 0;\n\t\t\t\tfor(j=1;j&lt;=total/2;j++) //再检测\n\t\t\t\t\tflag^=s[j];\n\t\t\t\t//把对手变成p态!\n\t\t\t\tif(flag==0)\n\t\t\t\t{\n\t\t\t\t\t//第i个移动i步(移动到哪里)\n\t\t\t\t\t//应该是从哪个位置移到哪个位置 跟哪个小和尚没关系\n\t\t\t\t\tprintf("%d %d\\n",a[i*2-2],a[i*2-2]+temp-s[i]);\n\t\t\t\t\texit(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\ts[i] = temp;\n\n\t\t\t//右边上移增加数量\n\t\t\twhile(s[i]-temp &lt;a[i*2]-a[2*i-1]-1)\n\t\t\t{\n\t\t\t\ts[i]++;\n\t\t\t\tflag = 0;\n\t\t\t\tfor(j=1;j&lt;=total/2;j++) //再检测\n\t\t\t\t\tflag^=s[j];\n\t\t\t\tif(flag==0)\n\t\t\t\t{\n\t\t\t\t\tprintf("%d %d\\n",a[i*2-1],a[i*2-1]+s[i]-temp);\n\t\t\t\t\texit(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\ts[i]=temp;\n\t\t}\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\n\npublic class Main {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader bfr=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer tok= new StringTokenizer(bfr.readLine());\n\t\tint i=0,j,flag=1;\n\t\tint[] monk=new int[108];\n\t\twhile(tok.hasMoreTokens()) monk[i++]=Integer.parseInt(tok.nextToken());\n\t\tint N=i-1;\n\t\tint[] A=new int[N];\n\t\tfor(i=0;i&lt;N;i++) A[i]=monk[i+1]-monk[i]-1;\n\t\t\n\t\tint sum=A[0];\n\t\tfor(i=2;i&lt;N;i++,i++) sum^=A[i];\n\t\t\n\t\tif(sum==0) System.out.println(-1);\n\t\telse\n\t\t{\n\t\t\tfor(i=0;i&lt;N;i++)\n\t\t\t{\n\t\t\t\tfor(j=1;j&lt;=A[i];j++)\n\t\t\t\t{\n\t\t\t\t\tint s=sum;\n\t\t\t\t\tA[i]-=j;\n\t\t\t\t\tif(i&gt;0) A[i-1]+=j;\n\t\t\t\t\tif(i%2==0)  { s^=(A[i]+j); s^=A[i]; }\n\t\t\t\t\telse { s^=(A[i-1]-j); s^=A[i-1]; }\n\t\t\t\t\tif(s==0) { System.out.println(monk[i]+" "+(monk[i]+j)); flag=0; break; }\n\t\t\t\t\telse { A[i]+=j; if(i&gt;0) A[i-1]-=j; }\n\t\t\t\t}\n\t\t\t\tif(flag==0) break;\n\t\t\t}\n\t\t}\n\t}\n}\r\n</textarea>	37
5	<div class="des"> \n <div class="sec_header">\n   问题描述\n </div> \n <div class="sec_cont"> \n  <p>给定一个年份，判断这一年是不是闰年。</p> \n  <p>当以下情况之一满足时，这一年是闰年：</p> \n  <p>1. 年份是4的倍数而不是100的倍数；</p> \n  <p>2. 年份是400的倍数。</p> \n  <p>其他的年份都不是闰年。</p> \n </div> \n <div class="sec_header">\n   输入格式\n </div> \n <div class="sec_cont">\n   输入包含一个整数y，表示当前的年份。\n </div> \n <div class="sec_header">\n   输出格式\n </div> \n <div class="sec_cont">\n   输出一行，如果给定的年份是闰年，则输出yes，否则输出no。 \n  <div class="sec_note"> \n   <p>说明：当试题指定你输出一个字符串作为结果（比如本题的yes或者no，你需要严格按照试题中给定的大小写，写错大小写将不得分。 </p>\n  </div> \n </div> \n <div class="sec_header">\n   样例输入\n </div> \n <div class="sec_text">\n   2013\n </div> \n <div class="sec_header">\n   样例输出\n </div> \n <div class="sec_text">\n   no\n </div> \n <div class="sec_header">\n   样例输入\n </div> \n <div class="sec_text">\n   2016\n </div> \n <div class="sec_header">\n   样例输出\n </div> \n <div class="sec_text">\n   yes\n </div> \n <div class="sec_header">\n   数据规模与约定\n </div> \n <div class="sec_cont">\n   1990 &lt;= y &lt;= 2050。\n </div> \n</div>	<textarea id="codelinesc">\r\n  #include &lt;stdio.h&gt;\nint main()\n{\n    int y;\n    scanf("%d", &amp;y);\n    if (y%4==0 &amp;&amp; y%100!=0 || y%400==0)\n        printf("yes");\n    else\n        printf("no");\n    return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\nusing namespace std;\nint main()\n{\n    int y;\n    cin &gt;&gt; y;\n    if (y%4==0 &amp;&amp; y%100!=0 || y%400==0)\n        cout &lt;&lt; "yes" &lt;&lt; endl;\n    else\n        cout &lt;&lt; "no" &lt;&lt; endl;\n    return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\nimport java.util.Scanner;\nimport java.io.InputStreamReader;\nimport java.*;\n\n\n\npublic class Main \n{\t\n\t\n\tpublic static void main(String[] args) throws NumberFormatException, IOException \n\t{\n\t\tBufferedReader bf1=new BufferedReader(new InputStreamReader(System.in));\n\t\tint num=Integer.parseInt(bf1.readLine());\t\t\n\t\t\tif((num%4==0&amp;&amp;num%100!=0)||(num%400==0))\n\t\t\t\tSystem.out.println("yes");\n\t\t\telse\n\t\t\t\tSystem.out.println("no");\t\t\t\n\t\t\n\t\t\n\t}\n}\n\r\n</textarea>	5
6	<div class="des"> \n <div class="sec_header">\n   问题描述\n </div> \n <div class="sec_cont"> \n  <p>对于长度为5位的一个01串，每一位都可能是0或1，一共有32种可能。它们的前几个是：</p> \n  <p>00000</p> \n  <p>00001</p> \n  <p>00010</p> \n  <p>00011</p> \n  <p>00100</p> \n  <p>请按从小到大的顺序输出这32种01串。</p> \n </div> \n <div class="sec_header">\n   输入格式\n </div> \n <div class="sec_cont">\n   本试题没有输入。\n </div> \n <div class="sec_header">\n   输出格式\n </div> \n <div class="sec_cont">\n   输出32行，按从小到大的顺序每行一个长度为5的01串。 \n </div> \n <div class="sec_header">\n   样例输出\n </div> \n <div class="sec_text">\n   00000\n  <br> 00001\n  <br> 00010\n  <br> 00011\n  <br> &lt;以下部分省略&gt; \n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint main()\n{\n    int i, j, k, l, m;\n    for (i = 0; i &lt;= 1; ++i)\n        for (j = 0; j &lt;= 1; ++j)\n            for (k = 0; k &lt;= 1; ++k)\n                for (l = 0; l &lt;= 1; ++l)\n                    for (m = 0; m &lt;= 1; ++m)\n                        printf("%d%d%d%d%d\\n", i, j, k, l, m);\n    return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\nusing namespace std;\nint main()\n{\n    for (int i = 0; i &lt;= 1; ++i)\n        for (int j = 0; j &lt;= 1; ++j)\n            for (int k = 0; k &lt;= 1; ++k)\n                for (int l = 0; l &lt;= 1; ++l)\n                    for (int m = 0; m &lt;= 1; ++m)\n                        cout &lt;&lt; i &lt;&lt; j &lt;&lt; k &lt;&lt; l &lt;&lt; m &lt;&lt; endl;\n    return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\n \npublic class Main{\npublic static void main (String args[]){\n\t\nfor(int a1=0;a1&lt;2;a1++){\n\tfor(int a2=0;a2&lt;2;a2++){\n\t\tfor(int a3=0;a3&lt;2;a3++){\n\t\t\tfor(int a4=0;a4&lt;2;a4++){\n\t\t\t\tfor(int a5=0;a5&lt;2;a5++){\n\t\t\t\t\tStringBuffer s=new StringBuffer();\n\t\t\t\t\tSystem.out.println(s.append(a1).append(a2).append(a3).append(a4).append(a5));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n}\n}\r\n</textarea>	6
7	<div class="des"> \n <div class="sec_header">\n  问题描述\n </div> \n <div class="sec_cont"> \n  <p>利用字母可以组成一些美丽的图形，下面给出了一个例子：</p> \n  <p>ABCDEFG</p> \n  <p>BABCDEF</p> \n  <p>CBABCDE</p> \n  <p>DCBABCD</p> \n  <p>EDCBABC</p> \n  <p>这是一个5行7列的图形，请找出这个图形的规律，并输出一个n行m列的图形。</p> \n </div> \n <div class="sec_header">\n  输入格式\n </div> \n <div class="sec_cont">\n  输入一行，包含两个整数n和m，分别表示你要输出的图形的行数的列数。\n </div> \n <div class="sec_header">\n  输出格式\n </div> \n <div class="sec_cont">\n  输出n行，每个m个字符，为你的图形。\n </div> \n <div class="sec_header">\n  样例输入\n </div> \n <div class="sec_text">\n  5 7\n </div> \n <div class="sec_header">\n  样例输出\n </div> \n <div class="sec_text">\n  ABCDEFG\n  <br> BABCDEF\n  <br> CBABCDE\n  <br> DCBABCD\n  <br> EDCBABC\n </div> \n <div class="sec_header">\n  数据规模与约定\n </div> \n <div class="sec_cont">\n  1 &lt;= n, m &lt;= 26。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#define MAXSIZE 26\n\n//输出\nvoid Print(char matrix[MAXSIZE][MAXSIZE],int n,int m)\n{\n\tint i,j;\n\tfor(i=0;i&lt;n;i++)\n\t{\n\t\tfor(j=0;j&lt;m;j++)\n\t\t{\n\t\t\tprintf("%c",matrix[i][j]);\n\t\t}\n\t\tprintf("\\n");\n\t}\n}\n\n//实现字母图形\nvoid Drawing(int n,int m)\n{\n\tint i,j;\n\tint point=0;\n\tchar str;\n\tchar matrix[MAXSIZE][MAXSIZE];\n\tfor(i=0;i&lt;n;i++)\n\t{\n\t\tstr='A';\n\t\tfor(j=i;j&lt;m;j++)\n\t\t{\n\t\t\tmatrix[i][j]=str++;\n\t\t}\n\t\tstr='A';\n\t\tfor(j=i-1;j&gt;=0;j--)\n\t\t{\n\t\t\tmatrix[i][j]=++str;\n\t\t}\n\t}\n\tPrint(matrix,n,m);\n}\nint main()\n{\n\tint n,m;\n\tscanf("%d%d",&amp;n,&amp;m);\n\tDrawing(n,m);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;cmath&gt;\nusing namespace std;\nint main()\n{\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        for (int j = 0; j &lt; m; ++j)\n            cout &lt;&lt; char('A'+abs(i-j));\n        cout &lt;&lt; endl;\n    }\n    return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nclass Main\n{\n\tpublic static void main(String[] args) throws IOException\n\t{\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tString s=br.readLine();\n\t\tString sa[]=s.split(" ");\n\t\tchar  a[ ]=new char[ Integer.parseInt(sa[1])];\n\t\tint max=Integer.parseInt(sa[0]);      \n\t\tint t=0;\n\t\tfor(int j=0;j&lt;a.length;j++){        \n\t\t   a[ j ]=(char) ('B'+j);  \n\t\t}\n\t\n\t\tfor(int k=0;k&lt;max;k++){                            \n\t\tfor(int i=0;i&lt;a.length;i++){  \n\t\t\t\tif(i&lt;t){\t\n\t\t\t\ta[i]=(char)(a[i]+1);\n\t\t\t\t}else{\n\t\t\t\ta[i]=(char)(a[i]-1);\n\t\t\t\t}\n\t\t\t}\n\t\t    t++;\n\t\t\tSystem.out.print(a);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\r\n</textarea>	7
8	<div class="des"> \n <div class="sec_header">\n  问题描述\n </div> \n <div class="sec_cont"> \n  <p>给出n个数，找出这n个数的最大值，最小值，和。</p> \n </div> \n <div class="sec_header">\n  输入格式\n </div> \n <div class="sec_cont"> \n  <p>第一行为整数n，表示数的个数。</p> \n  <p>第二行有n个数，为给定的n个数，每个数的绝对值都小于10000。</p> \n </div> \n <div class="sec_header">\n  输出格式\n </div> \n <div class="sec_cont">\n  输出三行，每行一个整数。第一行表示这些数中的最大值，第二行表示这些数中的最小值，第三行表示这些数的和。\n </div> \n <div class="sec_header">\n  样例输入\n </div> \n <div class="sec_text">\n  5\n  <br> 1 3 -2 4 5\n </div> \n <div class="sec_header">\n  样例输出\n </div> \n <div class="sec_text">\n  5\n  <br> -2\n  <br> 11\n </div> \n <div class="sec_header">\n  数据规模与约定\n </div> \n <div class="sec_cont">\n  1 &lt;= n &lt;= 10000。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#define MAXSIZE 10000\n\nint main()\n{\n\tint i;\n\tint n;\n\tint value;\n\tint max=-MAXSIZE;\n\tint min=MAXSIZE;\n\tint sum=0;\n\tscanf("%d",&amp;n);\n\tfor(i=0;i&lt;n;i++)\n\t{\n\t\tscanf("%d",&amp;value);\n\t\tif(value&gt;max) max=value;\n\t\tif(value&lt;min) min=value;\n\t\tsum+=value;\n\t}\n\tprintf("%d\\n",max);\n\tprintf("%d\\n",min);\n\tprintf("%d\\n",sum);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstring&gt;\n\nusing namespace std;\n\nint main(){\n    int n;\n    while(cin&gt;&gt;n){\n        int a[10005];\n        int sum=0;\n        for(int i=0;i&lt;n;i++){\n            scanf("%d",&amp;a[i]);\n            sum+=a[i];\n        }\n        sort(a,a+n);\n        cout&lt;&lt;a[n-1]&lt;&lt;endl&lt;&lt;a[0]&lt;&lt;endl&lt;&lt;sum&lt;&lt;endl;\n    }\n    return 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\n\nimport java.io.*;\npublic class Main{\n\tpublic static void main(String args[])throws Exception{\n\t\tint n;\n\t\tint sum=0;\n\t\tString str=null;\n\t\tString str2=null;\n\t\tBufferedReader buf=new BufferedReader(new InputStreamReader(System.in));\n\n\t\tstr=buf.readLine();\n\t\tn=Integer.parseInt(str);\n\t\t\n\t\tstr2=buf.readLine();\n\t\tString a[]=str2.split(" ");\n\t\tint array2[]=new int[n];\n\t\tfor(int i=0;i&lt;n;i++){\n\t\t\n\t\t\tarray2[i]=Integer.parseInt(a[i]);\n\t\t    sum=sum+array2[i];\n\t\t}\n\t\tjava.util.Arrays.sort(array2);\n\t\tSystem.out.println(array2[n-1]);\n\t\tSystem.out.println(array2[0]);\n\t\tSystem.out.println(sum);\n\t}\n    \n}\r\n</textarea>	8
9	<div class="des"> \n <div class="sec_header">\n   问题描述\n </div> \n <div class="sec_cont"> \n  <p>给出一个包含n个整数的数列，问整数a在数列中的第一次出现是第几个。</p> \n </div> \n <div class="sec_header">\n   输入格式\n </div> \n <div class="sec_cont"> \n  <p>第一行包含一个整数n。</p> \n  <p>第二行包含n个非负整数，为给定的数列，数列中的每个数都不大于10000。</p> \n  <p>第三行包含一个整数a，为待查找的数。</p>\n </div> \n <div class="sec_header">\n   输出格式\n </div> \n <div class="sec_cont">\n   如果a在数列中出现了，输出它第一次出现的位置(位置从1开始编号)，否则输出-1。 \n </div> \n <div class="sec_header">\n   样例输入\n </div> \n <div class="sec_text">\n   6\n  <br> 1 9 4 8 3 9\n  <br> 9 \n </div> \n <div class="sec_header">\n   样例输出\n </div> \n <div class="sec_text">\n   2 \n </div> \n <div class="sec_header">\n   数据规模与约定\n </div> \n <div class="sec_cont">\n   1 &lt;= n &lt;= 1000。 \n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#define MAXN 10001\nint n, a, ans;\nint s[MAXN];\nint main()\n{\n    int i;\n    scanf("%d", &amp;n);\n    for (i = 0; i &lt; n; ++i)\n        scanf("%d", &amp;s[i]);\n    scanf("%d", &amp;a);\n    ans = -1;\n    for (i = 0; i &lt; n; ++i)\n    {\n        if (s[i] == a)\n        {\n            ans = i + 1;\n            break;\n        }\n    }\n    printf("%d", ans);\n    return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\nusing namespace std;\nconst int MAXN = 10001;\nint n, a, ans;\nint s[MAXN];\nint main()\n{\n    cin &gt;&gt; n;\n    for (int i = 0; i &lt; n; ++i)\n        cin &gt;&gt; s[i];\n    cin &gt;&gt; a;\n    ans = -1;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        if (s[i] == a)\n        {\n            ans = i + 1;\n            break;\n        }\n    }\n    cout &lt;&lt; ans &lt;&lt; endl;\n    return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.io.InputStreamReader;\n\npublic class Main \n{\n\t\n\tstatic int fun(int[] num,int nn)\n\t{\n\t\tfor(int i=0;i&lt;num.length;i++)\n\t\t{\n\t\t\tif(num[i]==nn)\n\t\t\t\treturn i+1;\t\t\t\t\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tpublic static void main(String[] args) throws NumberFormatException, IOException \n\t{\n\t\tBufferedReader bf1=new BufferedReader(new InputStreamReader(System.in));\n\t\tint n=Integer.parseInt(bf1.readLine());\n\t\tString[] s1=bf1.readLine().split(" ");\n\t\tint[] num=new int[n];\n\t\tfor(int i=0;i&lt;n;i++)\n\t\t\tnum[i]=Integer.parseInt(s1[i]);\n\t\tint nn=Integer.parseInt(bf1.readLine());\n\t\tSystem.out.println(fun(num, nn));\n\t\t\t\n\t}\n\n}\r\n</textarea>	9
10	<div class="des"> \n <div class="sec_header">\n   问题描述\n </div> \n <div class="sec_cont"> \n  <p>杨辉三角形又称Pascal三角形，它的第i+1行是(a+b)<sup>i</sup>的展开式的系数。</p> 　　\n  <p>它的一个重要性质是：三角形中的每个数字等于它两肩上的数字相加。</p> 　　\n  <p>下面给出了杨辉三角形的前4行：</p> 　　\n  <p>&nbsp;&nbsp;&nbsp;1</p> 　　\n  <p>&nbsp;&nbsp;1 1</p> 　　\n  <p>&nbsp;1 2 1</p> 　　\n  <p>1 3 3 1</p> 　　\n  <p>给出n，输出它的前n行。</p> \n </div> \n <div class="sec_header">\n   输入格式\n </div> \n <div class="sec_cont"> \n  <p>输入包含一个数n。</p>\n </div> \n <div class="sec_header">\n   输出格式\n </div> \n <div class="sec_cont">\n   输出杨辉三角形的前n行。每一行从这一行的第一个数开始依次输出，中间使用一个空格分隔。请不要在前面输出多余的空格。 \n </div> \n <div class="sec_header">\n   样例输入\n </div> \n <div class="sec_text">\n   4 \n </div> \n <div class="sec_header">\n   样例输出\n </div> \n <div class="sec_text">\n   1\n  <br> 1 1\n  <br> 1 2 1\n  <br> 1 3 3 1 \n </div> \n <div class="sec_header">\n   数据规模与约定\n </div> \n <div class="sec_cont">\n   1 &lt;= n &lt;= 34。 \n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#define MAXN 40\nint n;\nint a[MAXN][MAXN];\nint main()\n{\n    int i, j;\n    scanf("%d", &amp;n);\n    a[0][0] = 1;\n    for (i = 0; i &lt; n; ++i)\n    {\n        a[i][0] = a[i][i] = 1;\n        for (j = 1; j &lt; i; ++j)\n            a[i][j] = a[i-1][j-1] + a[i-1][j];\n    }\n    for (i = 0; i &lt; n; ++i)\n    {\n        for (j = 0; j &lt;= i; ++j)\n            printf("%d ", a[i][j]);\n        printf("\\n");\n    }\n    return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\nusing namespace std;\nconst int MAXN = 40;\nint n;\nint a[MAXN][MAXN];\nint main()\n{\n    cin &gt;&gt; n;\n    a[0][0] = 1;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        a[i][0] = a[i][i] = 1;\n        for (int j = 1; j &lt; i; ++j)\n            a[i][j] = a[i-1][j-1] + a[i-1][j];\n    }\n    for (int i = 0; i &lt; n; ++i)\n    {\n        for (int j = 0; j &lt;= i; ++j)\n            cout &lt;&lt; a[i][j] &lt;&lt; " ";\n        cout &lt;&lt; endl;\n    }\n    return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;          \n\npublic class Main{\n\tpublic static void main(String args[]) throws IOException{\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t    int n=Integer.parseInt(br.readLine());\n\t    int[][] a=new int[34][34];\n\t    int i=0,j=1;\n\t    while(i&lt;34){\n\t    \ta[i][0]=1;\n\t    \ti++;\n\t    }\n\t    while(j&lt;34){\n\t    \ta[j][j]=1;\n\t    \tj++;\n\t    }\n\t    for(i=2;i&lt;34;i++)\n\t       for(j=1;j&lt;i;j++)\n\t          a[i][j]=a[i-1][j-1]+a[i-1][j];\n\t    for(i=0;i&lt;n;i++)\n\t       {for(j=0;j&lt;=i;j++)\n\t         System.out.print(a[i][j]+" ");\n\t       System.out.println(" ");}\n}\n}\t               \r\n</textarea>	10
11	<div class="des"> \n <div class="sec_header">\n   问题描述\n </div> \n <div class="sec_cont"> \n  <p>给定一个序列，每次询问序列中第l个数到第r个数中第K大的数是哪个。</p> \n </div> \n <div class="sec_header">\n   输入格式\n </div> \n <div class="sec_cont"> \n  <p>第一行包含一个数n，表示序列长度。</p> \n  <p>第二行包含n个正整数，表示给定的序列。</p> \n  <p>第三个包含一个正整数m，表示询问个数。</p> \n  <p>接下来m行，每行三个数l,r,K，表示询问序列从左往右第l个数到第r个数中，从大往小第K大的数是哪个。序列元素从1开始标号。</p> \n </div> \n <div class="sec_header">\n   输出格式\n </div> \n <div class="sec_cont">\n   总共输出m行，每行一个数，表示询问的答案。 \n </div> \n <div class="sec_header">\n   样例输入\n </div> \n <div class="sec_text">\n   5\n  <br> 1 2 3 4 5\n  <br> 2\n  <br> 1 5 2\n  <br> 2 3 2 \n </div> \n <div class="sec_header">\n   样例输出\n </div> \n <div class="sec_text">\n   4\n  <br> 2 \n </div> \n <div class="sec_header">\n   数据规模与约定\n </div> \n <div class="sec_cont"> \n  <p>对于30%的数据，n,m&lt;=100；</p> \n  <p>对于100%的数据，n,m&lt;=1000；</p> \n  <p>保证k&lt;=(r-l+1)，序列中的数&lt;=10<sup>6</sup>。</p> \n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint Split(int *data,int pre,int rear)\n{\n\tint value=data[pre];\n\twhile(pre&lt;rear)\n\t{\n\t\twhile(data[rear]&gt;=value &amp;&amp; pre&lt;rear) rear--;\n\t\tdata[pre]=data[rear];\n\t\twhile(data[pre]&lt;value &amp;&amp; pre&lt;rear) pre++;\n\t\tdata[rear]=data[pre];\n\t}\n\tdata[pre]=value;\n\treturn pre;\n}\n\n//快速排序\nvoid QuickSort(int *data,int pre,int rear,int k)\n{\n\tif(pre&lt;=rear)\n\t{\n\t\tint mid=Split(data,pre,rear);\n\t\tif(mid==k)\n\t\t{\n\t\t\tprintf("%d\\n",data[mid]);\n\t\t}\n\t\telse if(mid&gt;k)\n\t\t{\n\t\t\tQuickSort(data,pre,mid-1,k);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tQuickSort(data,mid+1,rear,k);\n\t\t}\n\t}\n}\n\nvoid Copy(int *data,int n,int *temp)\n{\n\tint i;\n\tfor(i=0;i&lt;n;i++)\n\t{\n\t\ttemp[i]=data[i];\n\t}\n}\n\nint main()\n{\n\tint i;\n\tint n;\n\tint m;\n\tint *data;\n\tscanf("%d",&amp;n);\n\tdata=(int *)malloc(sizeof(int)*n);\n\tfor(i=0;i&lt;n;i++)\n\t{\n\t\tscanf("%d",&amp;data[i]);\n\t}\n\tscanf("%d",&amp;m);\n\twhile(m)\n\t{\n\t\tint pre;\n\t\tint rear;\n\t\tint k;\n\t\tint *temp=(int *)malloc(sizeof(int)*n);\n\t\tscanf("%d%d%d",&amp;pre,&amp;rear,&amp;k);\n\t\tCopy(data,n,temp);\n\t\tQuickSort(temp,pre-1,rear-1,rear-k);\n\t\tm--;\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\r\n#include&lt;algorithm&gt;\r\nusing namespace std;\r\n#define N 10005\r\n\r\nint n,m;\r\nint a[N],tree[15][N],sum[15][N];\r\n\r\nbool cmp(int x,int y)\r\n{\r\n\treturn x&gt;y;\r\n}\r\n\r\nvoid build(int x,int L,int R)\r\n{\r\n\tif(L==R)\treturn;\r\n\tint i;\r\n\tint mid=(L+R)&gt;&gt;1;\r\n\tint lp=L,rp=mid+1,l=mid-L+1;\r\n\tfor(i=L;i&lt;=R;i++)\r\n\t\tif(tree[x][i]&gt;a[mid])\r\n\t\t\tl--;\r\n\tfor(i=L;i&lt;=R;i++)\r\n\t{\r\n\t\tsum[x][i]=i==L?0:sum[x][i-1];\r\n\t\tif(a[mid]==tree[x][i] &amp;&amp; l)\r\n\t\t{\r\n\t\t\tl--;\r\n\t\t\ttree[x+1][lp++]=tree[x][i];\r\n\t\t\tsum[x][i]++;\r\n\t\t}\r\n\t\telse\r\n\t\tif(tree[x][i]&gt;a[mid])\r\n\t\t{\r\n\t\t\ttree[x+1][lp++]=tree[x][i];\r\n\t\t\tsum[x][i]++;\r\n\t\t}\r\n\t\telse\r\n\t\t\ttree[x+1][rp++]=tree[x][i];\r\n\t}\r\n\tbuild(x+1,L,mid);\r\n\tbuild(x+1,mid+1,R);\r\n}\r\n\r\nint query(int x,int L,int R,int l,int r,int k)\r\n{\r\n\tif(l==r)\treturn tree[x][l];\r\n\tint mid=(L+R)&gt;&gt;1;\r\n\tint t,tt;\r\n\tt=l==L?0:sum[x][l-1];\r\n\ttt=sum[x][r]-t;\r\n\tif(k&lt;=tt)\r\n\t\treturn query(x+1,L,mid,L+t,L+t+tt-1,k);\r\n\telse\r\n\t\treturn query(x+1,mid+1,R,mid-L+1+l-t,mid-L+1+r-t-tt,k-tt);\r\n}\r\n\r\nint main()\r\n{\r\n\tscanf("%d",&amp;n);\r\n\tfor(int i=1;i&lt;=n;i++)\r\n\t{\r\n\t\tscanf("%d",&amp;a[i]);\r\n\t\ttree[0][i]=a[i];\r\n\t}\r\n\tsort(a+1,a+1+n,cmp);\r\n\tbuild(0,1,n);\r\n\tscanf("%d",&amp;m);\r\n\tint l,r,k;\r\n\twhile(m--)\r\n\t{\r\n\t\tscanf("%d%d%d",&amp;l,&amp;r,&amp;k);\r\n\t\tprintf("%d\\n",query(0,1,n,l,r,k));\r\n\t}\r\n\treturn 0;\r\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedInputStream;\nimport java.io.IOException;\nimport java.util.Arrays;\n\npublic class Main\n{\n\tprivate static BufferedInputStream in = new BufferedInputStream(System.in);\n\t\n\tpublic static void main(String[] args) throws IOException\n\t{\n\t\tint[] nums = new int[readInt()];\n\t\t\n\t\tfor(int i=0; i&lt;nums.length; i++)\n\t\t{\n\t\t\tnums[i] = readInt();\n\t\t}\n\t\t\n\t\tfor(int i=readInt(); i&gt;0; i--)\n\t\t{\n\t\t\tint a = readInt();\n\t\t\tint b = readInt();\n\t\t\tint c = readInt();\n\t\t\t\n\t\t\tint[] tn = new int[b-a+1];\n\t\t\t\n\t\t\tfor(int j=0; j&lt;tn.length; j++)\n\t\t\t{\n\t\t\t\ttn[j] = nums[a-1+j];\n\t\t\t}\n\t\t\t\n\t\t\tArrays.sort(tn);\n\t\t\t\n\t\t\tSystem.out.println(tn[tn.length-c]);\n\t\t}\n\t}\n\t\n\tprivate static int readInt() throws IOException\n\t{\n\t\tint i,sum=0;\n\t\t\n\t\twhile(((i=in.read())&amp;48) != 48 || i&gt;57);\n\t\t\n\t\tfor(;(i&amp;56) == 48 || (i&amp;62) == 56; i=in.read())\n\t\t\tsum = sum*10 + (i&amp;15);\n\t\t\n\t\treturn sum;\n\t}\n}\n\r\n</textarea>	11
12	<div class="des"> \n <div class="sec_header">\n  问题描述\n </div> \n <div class="sec_cont"> \n  <p>已知一个正整数N，问从1~N中任选出三个数，他们的最小公倍数最大可以为多少。</p> \n </div> \n <div class="sec_header">\n  输入格式\n </div> \n <div class="sec_cont"> \n  <p>输入一个正整数N。</p> \n </div> \n <div class="sec_header">\n  输出格式\n </div> \n <div class="sec_cont">\n  输出一个整数，表示你找到的最小公倍数。\n </div> \n <div class="sec_header">\n  样例输入\n </div> \n <div class="sec_text">\n  9\n </div> \n <div class="sec_header">\n  样例输出\n </div> \n <div class="sec_text">\n  504\n </div> \n <div class="sec_header">\n  数据规模与约定\n </div> \n <div class="sec_cont"> \n  <p>1 &lt;= N &lt;= 10<sup>6</sup>。</p> \n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#define MAXSIZE 10000\n\n//输出值\nvoid Print(char *num,int n)\n{\n\tint i;\n\tfor(i=n-1;i&gt;=0;i--)\n\t{\n\t\tprintf("%c",num[i]);\n\t}\n\tprintf("\\0");\n\tprintf("\\n");\n}\n\n//对字符数组进行初始化\nvoid Init(char *num)\n{\n\tint i;\n\tfor(i=0;i&lt;MAXSIZE;i++) num[i]='0';\n}\n\n//将一个整数转换为字符类型\nint TransformString(char *num,int value)\n{\n\tint num_n=0;\n\twhile(value)\n\t{\n\t\tnum[num_n++]=value%10+'0';\n\t\tvalue/=10;\n\t}\n\treturn num_n;\n}\n\n//两个大整数相乘\nint Multiplication(char *num1,int num1_n,char *num2,int num2_n,char *result,int result_n)\n{\n\tint i,j;\n\tint carry;\n\tint value;\n\tfor(i=0;i&lt;num2_n;i++)\n\t{\n\t\tcarry=0;\n\t\tfor(j=0;j&lt;num1_n;j++)\n\t\t{\n\t\t\tvalue=(num2[i]-'0')*(num1[j]-'0')+(result[i+j]-'0')+carry;\n\t\t\tcarry=value/10;\n\t\t\tresult[i+j]=value%10+'0';\n\t\t}\n\t\tif(carry)\n\t\t{\n\t\t\tresult[i+j]=carry+'0';\n\t\t\tresult_n=i+j+1;\n\t\t}\n\t\telse result_n=i+j;\n\t}\n\treturn result_n;\n}\n\n//判断两个数是否有公约数\nint GCD(int num1,int num2)\n{\n\tint temp;\n\twhile(num2)\n\t{\n\t\ttemp=num1%num2;\n\t\tnum1=num2;\n\t\tnum2=temp;\n\t}\n\tif(num1==1) return 1;\n\telse return 0;\n}\n\n//选出满足条件的值\nvoid Select(int n)\n{\n\tchar num1[MAXSIZE];\n\tchar num2[MAXSIZE];\n\tchar result[MAXSIZE];\n\tint num1_n;\n\tint num2_n;\n\tint result_n=0;\n\tint n1;\n\tint n2;\n\tint n3;\n\n\tif(n%2==1)\n\t{\n\t\tn1=n;\n\t\tn2=n-1;\n\t\tn3=n-2;\n\t}\n\telse\n\t{\n\t\tn1=n;\n\t\tn2=n-1;\n\t\tn3=n-3;\n\n\t\twhile( GCD(n1,n3)!=1 || GCD(n2,n3)!=1) n3--;\n\t\tif(n3!=n-3)\n\t\t{\n\t\t\tn1=n-1;\n\t\t\tn2=n-2;\n\t\t\tn3=n-3;\n\t\t}\n\t}\n\tnum1_n=TransformString(num1,n1);\n\tnum2_n=TransformString(num2,n2);\n\tInit(result);\n\tresult_n=Multiplication(num1,num1_n,num2,num2_n,result,result_n);\n\tnum1_n=TransformString(num1,n3);\n\tInit(num2);\n\tnum2_n=0;\n\tnum2_n=Multiplication(num1,num1_n,result,result_n,num2,num2_n);\n\tPrint(num2,num2_n);\n}\n\nint main()\n{\n\tint n;\n\tscanf("%d",&amp;n);\n\tSelect(n);\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\n\n\n//两个数的最大公约数\nlong long gcd(long long a,long long b)\n{\n    return b?gcd(b,a%b):a;\n}\n\nint main()\n{\n\tlong long n,a,b,r;\n\twhile(cin&gt;&gt;n)\n\t{\n\t\tif(n%2==1)\n\t\t\tcout&lt;&lt;n*(n-1)*(n-2)&lt;&lt;endl;\n\t\telse\n\t\t{\n\t\t\tlong long s1=(n-1)*(n-2)*(n-3);\n\t\t\t\n\t\t\ta=n*(n-1);\n\t\t\twhile(gcd(n-2,a)!=1)n--;\n\t\t\tif((n-2)*a&gt;s1)\n\t\t\t\tcout&lt;&lt;(n-2)*a&lt;&lt;endl;\n\t\t\telse\n\t\t\t\tcout&lt;&lt;s1&lt;&lt;endl;\n\t\t}\n\t}\n\treturn 0;\n} \r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n \npublic class Main{\n\t\tpublic static long gcdivisor(long a,long b)\n\t{\n\t\tlong m=1;\n\t\tif(a&lt;b)\n\t\t{\n\t\t\tm=a;\n\t\t\ta=b;\n\t\t\tb=m;\n\t\t}\n\t\twhile(m!=0)\n\t\t{\n\t\t\tm=a%b;\n\t\t\ta=b;\n\t\t\tb=m;\n\t\t}\n\t\treturn a;\n\t}\n\t\n\tpublic static void main(String args[]) throws IOException{\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tlong n=Long.parseLong(br.readLine());\n\t\tif(n%2==1)\n                   System.out.println(n*(n-1)*(n-2));\n\t\telse\n\t\t{\n\t\t\tif(gcdivisor(n,n-3)!=1)\n\t\t\t  System.out.println((n-1)*(n-2)*(n-3));\n\t\t\telse\n\t\t\t{  \t\n\t\t\t  System.out.println(n*(n-1)*(n-3));   \n\t\t}\n\t}\n}\n}\r\n</textarea>	12
13	<div class="des"> \n <div class="sec_header">\n   问题描述\n </div> \n <div class="sec_cont"> \n  <p>如果一个自然数N的K进制表示中任意的相邻的两位都不是相邻的数字，那么我们就说这个数是K好数。求L位K进制数中K好数的数目。例如K = 4，L = 2的时候，所有K好数为11、13、20、22、30、31、33 共7个。由于这个数目很大，请你输出它对1000000007取模后的值。</p> \n </div> \n <div class="sec_header">\n   输入格式\n </div> \n <div class="sec_cont"> \n  <p>输入包含两个正整数，K和L。</p> \n </div> \n <div class="sec_header">\n   输出格式\n </div> \n <div class="sec_cont">\n   输出一个整数，表示答案对1000000007取模后的值。 \n </div> \n <div class="sec_header">\n   样例输入\n </div> \n <div class="sec_text">\n   4 2 \n </div> \n <div class="sec_header">\n   样例输出\n </div> \n <div class="sec_text">\n   7 \n </div> \n <div class="sec_header">\n   数据规模与约定\n </div> \n <div class="sec_cont"> \n  <p>对于30%的数据，K<sup>L</sup> &lt;= 10<sup>6</sup>；</p> \n  <p>对于50%的数据，K &lt;= 16， L &lt;= 10；</p> \n  <p>对于100%的数据，1 &lt;= K,L &lt;= 100。</p> \n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n\tint i;\n\tint k;\t\t//进制数\n\tint l;\t\t//位数\n\tlong long ka[100];\t\t//前\n\tlong long kb[100];\t\t//当前\n\tlong long cont=0;\t\t//计数\n\tscanf("%d%d",&amp;k,&amp;l);\n\tkb[0]=ka[0]=0;\n\tfor(i=1;i&lt;k;i++)\n\t{\n\t\tkb[i]=ka[i]=1;\n\t}\n\tfor(i=2;i&lt;=l;i++)\n\t{\n\t\tint j;\n\t\tfor(j=0;j&lt;k;j++)\n\t\t{\n\t\t\tint m=0;\n\t\t\tfor(m=0;m&lt;k;m++)\n\t\t\t{\n\t\t\t\tif(m&lt;j-1 || m&gt;j+1)\n\t\t\t\t\tkb[j]+=ka[m];\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tfor(j=0;j&lt;k;j++)\n\t\t{\n\t\t\tka[j]=kb[j];\n\t\t\tka[j]=kb[j]%1000000007;\n\t\t}\n\t}\n\twhile(k--)\n\t{\n\t\tcont+=ka[k];\n\t\tcont=cont%1000000007;\n\t}\n\tprintf("%I64d\\n",cont);\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\nusing namespace std;\n/* run this program using the console pauser or add your own getch, system("pause") or input loop */\n\nint main(int argc, char** argv) {\n\tint k,l;\n\tcin&gt;&gt;k&gt;&gt;l;\n\tlong long table[100][100];\n\tfor(int i=0;i&lt;k;i++)\n\t{\n\t\ttable[0][i]=1ll;\n\t}\n\ttable[0][0]=0ll;\n\tfor(int i=1;i&lt;l;i++)\n\t{\n\t\tfor(int j=0;j&lt;k;j++)\n\t\t{\n\t\t\tlong long  x=0;\n\t\t\tfor(int y=0;y&lt;k;y++)\n\t\t\t{\n\t\t\t\tif(y!=j+1 &amp;&amp; y!=j-1)\n\t\t\t\t{\n\t\t\t\t\tx+=table[i-1][y];\n\t\t\t\t}\n\t\t\t}\n\t\t\ttable[i][j]=x%1000000007ll;\n\t\t}\n\t}\n\tlong long count=0;\n\tfor(int i=0;i&lt;k;i++)\n\t{\n\t\tcount+=table[l-1][i];\n\t}\n\tcout&lt;&lt;(count%1000000007ll);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\npublic class Main {\n\n   public static void main(String[] args) throws IOException {\n        BufferedReader bfr = new BufferedReader(new InputStreamReader(System.in));\n        String s[] = bfr.readLine().split(" +");\n       int K = Integer.valueOf(s[0]);\n        int L = Integer.valueOf(s[1]);\n        int f[][] = new int[L][K];\n        int i,j,k,sum=0;\n        \n       for(j=0;j&lt;K;j++) f[0][j] = 1;\n        f[0][0]=0;\n        if(L&gt;1)\n       {\n              for(i=1;i&lt;L;i++)\n                 {\n               for(j=0;j&lt;K;j++)\n               {\n                   for(k=0;k&lt;K;k++)\n                       if(k!=j-1 &amp;&amp; k!=j+1)\n                       {\n                            f[i][j]+=f[i-1][k];\n                            f[i][j]%=1000000007;\n                        }\n               }\n                 }\n       }\n        for(j=0;j&lt;K;j++) { sum+=f[L-1][j]; sum%=1000000007; }\n        System.out.println(sum);\n    }\n}\n\r\n</textarea>	13
14	<div class="des"> \n <div class="sec_header">\n   问题描述\n </div> \n <div class="sec_cont"> \n  <p>有一棵 n 个节点的树，树上每个节点都有一个正整数权值。如果一个点被选择了，那么在树上和它相邻的点都不能被选择。求选出的点的权值和最大是多少？</p> \n </div> \n <div class="sec_header">\n   输入格式\n </div> \n <div class="sec_cont"> \n  <p>第一行包含一个整数 n 。</p> \n  <p>接下来的一行包含 n 个正整数，第 i 个正整数代表点 i 的权值。</p> \n  <p>接下来一共 n-1 行，每行描述树上的一条边。</p> \n </div> \n <div class="sec_header">\n   输出格式\n </div> \n <div class="sec_cont">\n   输出一个整数，代表选出的点的权值和的最大值。 \n </div> \n <div class="sec_header">\n   样例输入\n </div> \n <div class="sec_text">\n   5\n  <br> 1 2 3 4 5\n  <br> 1 2\n  <br> 1 3\n  <br> 2 4\n  <br> 2 5 \n </div> \n <div class="sec_header">\n   样例输出\n </div> \n <div class="sec_text">\n   12 \n </div> \n <div class="sec_header">\n   样例说明\n </div> \n <div class="sec_cont">\n   选择3、4、5号点，权值和为 3+4+5 = 12 。 \n </div> \n <div class="sec_header">\n   数据规模与约定\n </div> \n <div class="sec_cont"> \n  <p>对于20%的数据， n &lt;= 20。</p> \n  <p>对于50%的数据， n &lt;= 1000。</p> \n  <p>对于100%的数据， n &lt;= 100000。</p> \n  <p>权值均为不超过1000的正整数。</p> \n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#define _Max 100010\n#define max(a, b) a &gt; b ? a : b\n\nstruct point\n{\n    int v, next;   //v指向这条边的另一个结点（父结点），next指向子结点\n} edge[_Max * 2];  //一条边记录两次，分别以一个点做记录\n\nint head[_Max];\nint M;\nint dp[_Max][2];\n\n//添加一个边\nvoid addEdge(int from, int to)\n{\n    //from结点\n    edge[M].v = to;\n    edge[M].next = head[from];    //为-1则定位叶结点，否则，指向另外一条边\n    head[from] = M++;             //指向他的一条边，增加结点\n    //to结点\n    edge[M].v = from;\n    edge[M].next = head[to];      //为-1则定位叶结点，否则，指向另外一条边\n    head[to] = M++;               //指向他的一条边，增加结点\n    return ;\n}\n\n//深度遍历，先深入到叶子结点，然后一层一层往上回升，一直到根结点，即第一个结点（初始pre为－1是因为根结点没有父结点，用－1表示）\nvoid dfs(int x, int pre)\n{\n    int i = head[x], v;\n    for (; i != -1; i = edge[i].next)  //i != -1说明有子结点，则遍历子结点，否则为叶子结点\n    {\n        v = edge[i].v;\n        if (pre == v)  //如果指向的子结点和父结点重合，则说明这个结点是叶子结点，不需要进一步dp\n        {\n            continue;\n        }\n        dfs(v, x);     //x可以理解为父结点\n        //深度遍历到最里面的叶子结点的父结点   如果父结点选择，则子结点不选择，否则子结点可能选择或者不选择，但是要比较两者哪个大选择哪个\n        dp[x][1] += dp[v][0];                   //   父结点（选） ＋＝ 子结点（不选）\n        dp[x][0] += max(dp[v][0], dp[v][1]);    //   父结点（不选） ＋＝ max（子结点（不选），子结点（选））\n    }\n    return ;\n}\nint main(int argc, const char * argv[])\n{\n    int i, n, s, t, tmp;\n    scanf("%d", &amp;n);\n    M = 0;\n    memset(head, -1, sizeof(head));   //初始化每个结点都是独立的没有子结点\n    memset(dp, 0, sizeof(dp));\n    //输入权值，并且记录在dp[i][1]上，i表示第i个结点，1代表取了这个结点\n    for (i = 1; i &lt;= n; i++)\n    {\n        scanf("%d", &amp;dp[i][1]);\n    }\n    //输入边，并且添加edge，一个边添加两个edge\n    for (i = 1; i &lt; n; i++)\n    {\n        scanf("%d %d", &amp;s, &amp;t);\n        addEdge(s, t);\n    }\n    dfs(1, -1);   //深度优先遍历，从第一个结点开始遍历\n    tmp = max(dp[1][0], dp[1][1]);    //求出最大的权值和\n    printf("%d\\n", tmp);\n    return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\nconst int NO=1000005;\nint dp[NO][2];\nint du[NO];\nint first[NO],next[NO],v[NO],num=1;\nbool mark[NO];\nint n,a;\nint t[NO],tip,top;\nint max(int a,int &amp;b){return a&gt;b?a:b;}\nvoid input(int &amp;num)\n{\n\tnum=0;\n\tchar ch=getchar();\n\twhile(ch&lt;'0'||'9'&lt;ch)\n\t\tch=getchar();\n\twhile('0'&lt;=ch&amp;&amp;ch&lt;='9')\n\t{\n\t\tnum=10*num+ch-'0';\n\t\tch=getchar();\n\t}\n}\nvoid add(int &amp;a,int &amp;b)\n{\n\tv[num]=b;\n\tnext[num]=first[a];\n\tfirst[a]=num++;\n\tv[num]=a;\n\tnext[num]=first[b];\n\tfirst[b]=num++;\n}\nint work()\n{\n\tint i;\n\twhile(tip&lt;top)\n\t{\n\t\ta=t[tip++];\n\t\tmark[a]=1;\n\t\tfor(i=first[a];i!=-1;i=next[i])\n\t\t\tif(mark[v[i]])\n\t\t\t{\n\t\t\t\tdp[a][0]+=max(dp[v[i]][0],dp[v[i]][1]);\n\t\t\t\tdp[a][1]+=dp[v[i]][0];\n\t\t\t}\n\t\t\telse if(--du[v[i]]==1)\n\t\t\t\tt[top++]=v[i];\n\t}\n\treturn max(dp[a][0],dp[a][1]);\n}\nint main()\n{\n\tint i,a,b;\n\tscanf("%d",&amp;n);\n\tfor(i=1;i&lt;=n;i++)\n\t\tinput(dp[i][1]),first[i]=-1;\n\tfor(i=1;i&lt;n;i++)\n\t\tinput(a),input(b),add(a,b),du[a]++,du[b]++;\n\tfor(i=1;i&lt;=n;i++)\n\t\tif(du[i]==1)\n\t\t\tt[top++]=i;\n\tprintf("%d\\n",work());\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\n//package practice;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\t\n\tfinal static int MAX_N = 100010;\n\t//final static int MAX_M = 200007;\n\tfinal static long INF = (long)1e16;\n\t\n\tclass Edge {\n\t\tint u, v, nxt;\n\t\tEdge () {\n\t\t\t\n\t\t}\n\t\tEdge (int _u, int _v, int _n) {\n\t\t\tu = _u;\n\t\t\tv = _v;\n\t\t\tnxt = _n;\n\t\t}\n\t}\n\t\n\tint edgecnt;\n\tint dp[][] = new int[MAX_N][2];\n\tEdge E[] = new Edge[MAX_N * 2];\n\tint head[] = new int[MAX_N];\n\tint sta[] = new int[MAX_N * 2];\n\tboolean vis[] = new boolean[MAX_N];\n\t\n\tvoid add(int u, int v) {\n\t\tE[edgecnt] = new Edge(u, v, head[u]);\n\t\thead[u] = edgecnt++;\n\t}\n\t\n\tvoid dfs(int x, int fa) {\n\t\tArrays.fill(vis, false);\n\t\tint top = 0;\n\t\tvis[x] = true;\n\t\tsta[top++] = x;\n\t\twhile (top &gt; 0) {\n\t\t\tint u = sta[top - 1];\n\t\t\tboolean Ed = false;\n\t\t\tfor (int i = head[u]; i + 1 != 0; i = E[i].nxt) {\n\t\t\t\tint v = E[i].v;\n\t\t\t\tif (vis[v]) continue;\n\t\t\t\tEd = true;\n\t\t\t\tsta[top++] = v;\n\t\t\t\tvis[v] = true;\n\t\t\t}\n\t\t\tif (Ed) continue;\n\t\t\t--top;\n\t\t\tfor (int i = head[u]; i + 1 != 0; i = E[i].nxt) {\n\t\t\t\tint v = E[i].v;\n\t\t\t\tdp[v][0] += Math.max(dp[u][0], dp[u][1]);\n\t\t\t\tdp[v][1] += dp[u][0];\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid run() throws IOException {\n\t\tint n = cin.nextInt();\n\t\t\n\t\tfor (int i = 1; i &lt;= n; ++i) \n\t\t\tdp[i][1] = cin.nextInt();\n\t\tArrays.fill(head, -1);\n\t\tfor (int i = 1; i &lt; n; ++i) {\n\t\t\tint u = cin.nextInt();\n\t\t\tint v = cin.nextInt();\n\t\t\tadd(u, v);\n\t\t\tadd(v, u);\n\t\t}\n\t\tdfs(1, -1);\n\t\tint ans = Math.max(dp[1][0], dp[1][1]);\n\t\tout.println(ans);\n\t\tout.close(); \n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tMain() {\n\t\t cin = new InputReader(System.in);\n\t//\tcin = new Scanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t}\n\n\tPrintWriter out;\n\tInputReader cin;\n\t//Scanner cin;\n\n\tclass InputReader {\n\t\tInputReader(InputStream in) {\n\t\t\treader = new BufferedReader(new InputStreamReader(in));\n\t\t\t// try {\n\t\t\t// reader = new BufferedReader(new FileReader("input.txt"));\n\t\t\t// } catch (FileNotFoundException ex) {\n\t\t\t// }\n\t\t\ttokenizer = new StringTokenizer("");\n\t\t}\n\n\t\tprivate String next() throws IOException {\n\t\t\twhile (!tokenizer.hasMoreTokens()) {\n\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\n\t\tpublic Integer nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tprivate BufferedReader reader;\n\t\tprivate StringTokenizer tokenizer;\n\t}\n}\r\n</textarea>	14
15	<div class="des"> \n <div class="sec_header">\n   问题描述\n </div> \n <div class="sec_cont"> \n  <p>给定一个n个顶点，m条边的有向图（其中某些边权可能为负，但保证没有负环）。请你计算从1号点到其他点的最短路（顶点从1到n编号）。</p> \n </div> \n <div class="sec_header">\n   输入格式\n </div> \n <div class="sec_cont"> \n  <p>第一行两个整数n, m。</p> \n  <p>接下来的m行，每行有三个整数u, v, l，表示u到v有一条长度为l的边。</p> \n </div> \n <div class="sec_header">\n   输出格式\n </div> \n <div class="sec_cont">\n   共n-1行，第i行表示1号点到i+1号点的最短路。 \n </div> \n <div class="sec_header">\n   样例输入\n </div> \n <div class="sec_text">\n   3 3\n  <br> 1 2 -1\n  <br> 2 3 -1\n  <br> 3 1 2 \n </div> \n <div class="sec_header">\n   样例输出\n </div> \n <div class="sec_text">\n   -1\n  <br> -2 \n </div> \n <div class="sec_header">\n   数据规模与约定\n </div> \n <div class="sec_cont"> \n  <p>对于10%的数据，n = 2，m = 2。</p> \n  <p>对于30%的数据，n &lt;= 5，m &lt;= 10。</p> \n  <p>对于100%的数据，1 &lt;= n &lt;= 20000，1 &lt;= m &lt;= 200000，-10000 &lt;= l &lt;= 10000，保证从任意顶点都能到达其他所有顶点。</p> \n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;  \n#include&lt;string.h&gt;  \n#define inf 100000  \nstruct In{  \n    int e;  \n    int w;  \n    int next;  \n}map[200010];  \nint dis[20010],Q[20010];  \nint vis[20010],head[20010];  \nvoid SPFA(int n){  \n    int i,j,front,rear,temp;  \n    for(i=1;i&lt;=n;i++){  \n        dis[i]=inf;  \n    }  \n    dis[1]=0;vis[1]=1;  \n    front=0;rear=1;  \n    Q[front]=1;  \n    while(front&lt;rear){  \n        temp=Q[front++];  \n        vis[temp]=0;  \n        j=head[temp];  \n        while(j&gt;0){  \n            if(dis[map[j].e]&gt;map[j].w+dis[temp]){  \n                dis[map[j].e]=map[j].w+dis[temp];  \n                if(!vis[map[j].e]){  \n                    Q[rear++]=map[j].e;  \n                    vis[map[j].e]=1;   \n                }  \n            }  \n            j=map[j].next;  \n        }  \n    }  \n}  \nint main(){  \n    int n,m,i,j,a,b,val;  \n    while(~scanf("%d%d",&amp;n,&amp;m)){  \n        memset(Q,0,sizeof(Q));  \n        memset(head,0,sizeof(head));  \n        memset(vis,0,sizeof(vis));  \n        for(i=1;i&lt;=m;i++){  \n            scanf("%d%d%d",&amp;a,&amp;b,&amp;val);  \n            map[i].e=b;  \n            map[i].w=val;  \n            map[i].next=head[a];  \n            head[a]=i;  \n        }  \n        SPFA(n);  \n        for(i=2;i&lt;=n;i++){  \n            printf("%d\\n",dis[i]);  \n        }  \n    }  \n    return 0;  \n}  \r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cmath&gt;\n#include&lt;algorithm&gt;\n#include&lt;queue&gt;\n#include&lt;cstring&gt;\n#define ENT putchar('\\n')\nusing namespace std;\nconst int maxn=100000+10,INF=-1u&gt;&gt;1;\nstruct Tedge{int x,y,w,next;}adj[maxn*2];int fch[maxn],ms=0;\nvoid AddEdge(int u,int v,int w){\n    adj[++ms]=(Tedge){u,v,w,fch[u]};fch[u]=ms;return;\n}\nbool vis[maxn];int dist[maxn],n,m;\nvoid SPFA(){\n    queue&lt;int&gt;Q;memset(vis,false,sizeof(vis));\n    for(int i=1;i&lt;=n+1;i++)dist[i]=INF;dist[1]=0;\n    Q.push(1);vis[1]=true;\n    while(!Q.empty()){\n        int u=Q.front();Q.pop();vis[u]=false;\n        for(int i=fch[u];i;i=adj[i].next){\n            int v=adj[i].y;\n            if(dist[v]&gt;dist[u]+adj[i].w){\n                dist[v]=dist[u]+adj[i].w;\n                if(!vis[v]) vis[v]=true,Q.push(v);\n            }\n        }\n    } return ;\n}\ninline int read(){\n    int x=0,sig=1;char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-') sig=-1;ch=getchar();}\n    while(isdigit(ch)) x=10*x+ch-'0',ch=getchar();\n    return x*=sig;\n}\ninline void write(int x){\n    if(x==0){putchar('0');return;}if(x&lt;0) putchar('-'),x=-x;\n    int len=0,buf[15];while(x) buf[len++]=x%10,x/=10;\n    for(int i=len-1;i&gt;=0;i--) putchar(buf[i]+'0');return;\n}\nvoid init(){\n    n=read();m=read();int a,b,c;\n    for(int i=1;i&lt;=m;i++){\n        a=read();b=read();c=read();\n        AddEdge(a,b,c);\n    } return;\n}\nvoid work(){\n    SPFA();\n    return;\n}\nvoid print(){\n\tfor(int i=2;i&lt;=n;i++) write(dist[i]),ENT;\n    return;\n}\nint main(){\n    init();work();print();return 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\nimport java.util.*;\nclass Main\n{\n    static int n,m;\n\tstatic int[] u;\n    static int[] v;\n    static int[] w;\n    static int[] d;\n    static int[] first;\n    static int[] next;\n    static Queue&lt;Integer&gt; q=new LinkedList&lt;Integer&gt;();\n    static boolean[] inq; \n\tpublic static void main(String[] args) throws IOException\n\t{\n\t\tint i;\n\t\tBufferedReader bfr=new BufferedReader(new InputStreamReader(System.in));\n\t\tString str = bfr.readLine();\n\t\tString[] s = str.split("\\\\s");\n\t\tn=Integer.parseInt(s[0]);\n\t\tm=Integer.parseInt(s[1]);\n\t\tn++;\n\t\tm++;\n\t\tu=new int[m];\n        v=new int[m];\n        w=new int[m];\n        first=new int[n];\n        next=new int[m];\n        d=new int[n];\n        inq=new boolean[n];    \n\t\tfor(i=1;i&lt;n;i++) \n\t\t\tfirst[i]=-1;\n\t    for(i=1;i&lt;m;i++)\n\t    {\n\t    \tstr = bfr.readLine();\n\t\t\ts = str.split(" ");\n\t\t\tu[i]=Integer.parseInt(s[0]);\n\t\t\tv[i]=Integer.parseInt(s[1]);\n\t    \tw[i]=Integer.parseInt(s[2]);\n\t    \tnext[i]=first[u[i]];\n            first[u[i]]=i;\n\t    }\n\t    spfa(1);\n\t    for(i=2;i&lt;n;i++)   \n\t\t\tSystem.out.println(d[i]);\n\t}\n\tpublic static void spfa(int s)\n\t{\n\t\tint i,x;\n\t    for(i=2;i&lt;n;i++) \n\t\t\td[i]=Integer.MAX_VALUE;\n\t    q.offer(s); \n\t    while(!q.isEmpty())\n\t    {\n\t        x=q.poll();\n\t        inq[x]=false;        \n\t        for(i=first[x];i!=-1;i=next[i])\n                if(d[v[i]]&gt;d[x]+w[i])\n                {\n                    d[v[i]]=d[x]+w[i];\n                    if(!inq[v[i]])\n                    {\n                        inq[v[i]]=true;\n                        q.offer(v[i]);\n                    }\n                }\n\t    }\n\t}\n}\r\n</textarea>	15
16	<div class="des"> \n <div class="sec_header">\n   问题描述\n </div> \n <div class="sec_cont"> \n  <p>Farmer John变得非常懒，他不想再继续维护供奶牛之间供通行的道路。道路被用来连接N个牧场，牧场被连续地编号为1到N。每一个牧场都是一个奶牛的家。FJ计划除去P条道路中尽可能多的道路，但是还要保持牧场之间 的连通性。你首先要决定那些道路是需要保留的N-1条道路。第j条双向道路连接了牧场S<sub>j</sub>和E<sub>j</sub>(1 &lt;= S<sub>j</sub> &lt;= N; 1 &lt;= E<sub>j</sub> &lt;= N; S<sub>j</sub> != E<sub>j</sub>)，而且走完它需要L<sub>j</sub>的时间。没有两个牧场是被一条以上的道路所连接。奶牛们非常伤心，因为她们的交通系统被削减了。你需要到每一个奶牛的住处去安慰她们。每次你到达第i个牧场的时候(即使你已经到过)，你必须花去C<sub>i</sub>的时间和奶牛交谈。你每个晚上都会在同一个牧场(这是供你选择的)过夜，直到奶牛们都从悲伤中缓过神来。在早上 起来和晚上回去睡觉的时候，你都需要和在你睡觉的牧场的奶牛交谈一次。这样你才能完成你的 交谈任务。假设Farmer John采纳了你的建议，请计算出使所有奶牛都被安慰的最少时间。</p> \n </div> \n <div class="sec_header">\n   输入格式\n </div> \n <div class="sec_cont"> \n  <p>第1行包含两个整数N和P。</p> \n  <p>接下来N行，每行包含一个整数C<sub>i</sub>。</p> \n  <p>接下来P行，每行包含三个整数S<sub>j</sub>, E<sub>j</sub>和L<sub>j</sub>。</p> \n </div> \n <div class="sec_header">\n   输出格式\n </div> \n <div class="sec_cont">\n   输出一个整数, 所需要的总时间(包含和在你所在的牧场的奶牛的两次谈话时间)。 \n </div> \n <div class="sec_header">\n   样例输入\n </div> \n <div class="sec_text">\n   5 7\n  <br> 10\n  <br> 10\n  <br> 20\n  <br> 6\n  <br> 30\n  <br> 1 2 5\n  <br> 2 3 5\n  <br> 2 4 12\n  <br> 3 4 17\n  <br> 2 5 15\n  <br> 3 5 6 \n </div> \n <div class="sec_header">\n   样例输出\n </div> \n <div class="sec_text">\n   176 \n </div> \n <div class="sec_header">\n   数据规模与约定\n </div> \n <div class="sec_cont"> \n  <p>5 &lt;= N &lt;= 10000，N-1 &lt;= P &lt;= 100000，0 &lt;= L<sub>j</sub> &lt;= 1000，1 &lt;= C<sub>i</sub> &lt;= 1,000。</p> \n </div> \n</div>	<textarea id="codelinesc">\r\n# include &lt;stdio.h&gt; \n# include &lt;stdlib.h&gt;  \n# define M 100000  \ntypedef struct Node \n{  \n\tint u;  \n\tint v;  \n\tint w; \n} \nNode;  \nNode e[100002]; \nint fa[100002]; \nint c[100002]; \nint rank[100002]; \nint sum = 0; \nint n, m;  \nint cmp(const void *a, const void *b) \n{  \n\tNode *c = (Node *)a;  \n\tNode *d = (Node *)b;  \n\treturn c-&gt;w-d-&gt;w; \n}  \nint find(int x) \n{  \n\tint i, k, r;  \n\tr = x;  \n\twhile (fa[r]&gt;=0)   \n\tr = fa[r];  \n\tk = x;  \n\twhile (k != r)  \n\t{   \n\t\ti = fa[k];   \n\t\tfa[k] = r;   \n\t\tk = i;  \n\t}  \n\treturn r;  \n/*\tif (x != fa[x])   \n\tfa[x] = find(fa[x]);  \n\treturn fa[x];*/ \n}  \nvoid Union(int u, int v) { \n/* \tif (rank[u] &gt; rank[v])   \n\tfa[v] = u;  \n\telse  \n\t{   \n\t\tif (rank[u] == rank[v])    \n\t\t\trank[v]++;   \n\t\tfa[u] = v;  \n\t}*/  \n\tint r1,r2; \n    int num;     \n\tr1=find(u);     \n\tr2=find(v); \n    num=fa[r1]+fa[r2];     \n\tif(fa[r1]&lt;fa[r2])     \n\t{ \n        fa[r2]=r1;         \n\t\tfa[r1]=num;     \n\t\t}     \n\t\telse     \n\t\t{ \n        fa[r1]=r2;         \n\t\tfa[r2]=num;     \n\t\t} \n}  \nint Kruskal() \n{ \n    int i;     \n\tint u,v; \n    int sumweight=0,count=0;     \n\tfor(i=0;i&lt;n;i++)         \n\t\tfa[i]=-1; \n    qsort(e,m,sizeof(e[0]),cmp);     \n\tfor(i=0;i&lt;m;i++)     \n\t{ \n        u=e[i].u;         \n\t\tv=e[i].v; \n        if(find(u)!=find(v))         \n\t\t{ \n            sumweight+=e[i].w;             \n\t\t\tUnion(u,v);             \n\t\t\tcount++; \n            if(count&gt;=n-1)                 \n\t\t\tbreak;         \n\t\t}     \n\t} \n    return sumweight; \n}  \nint main () \n{  \n\tscanf ("%d%d", &amp;n, &amp;m);  \n\tint i, j, min = M;  \n\tfor (i = 0; i &lt; n; i++) \n\t{ \n\t\tscanf ("%d", &amp;c[i]); \n\t\tif (c[i] &lt; min)  \n\t\tmin = c[i]; \n\t}  \n\tfor (i = 0; i &lt; m; i++) \n\t{  \n\t\tint u, v, w;  \n\t\tscanf("%d%d%d",&amp;u,&amp;v,&amp;w);  \n\t\te[i].u=u-1;  \n\t\te[i].v=v-1;  \n\t\te[i].w=w*2+c[u-1]+c[v-1];  \n\t}  \n\tprintf ("%d\\n", min+Kruskal());  \n\treturn 0; \n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cstring&gt;\n#include&lt;cmath&gt;\n#include&lt;ctime&gt;\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int INF=999999999;\nstruct wjj\n{\n    int x,y,w;       \n}edge[100005];\nint v[10005],N,P,father[10005],Min=INF;\nint _getfather(int x)\n{\n    if(x!=father[x]) father[x]=_getfather(father[x]);\n    return father[x];\n}\nvoid _in(int &amp;x)\n{\n    char t=getchar();\n    while(t&lt;'0'||'9'&lt;t) t=getchar();\n    for(x=t-'0',t=getchar();'0'&lt;=t&amp;&amp;t&lt;='9';x=x*10+t-'0',t=getchar());\n}\nvoid _init()\n{\n    _in(N);_in(P);\n    for(int i=1;i&lt;=N;i++)\n    {\n        father[i]=i;\n        _in(v[i]);\n        Min=min(Min,v[i]);\n    }\n    for(int i=1;i&lt;=P;i++)\n    {\n        _in(edge[i].x);_in(edge[i].y);_in(edge[i].w);\n        edge[i].w&lt;&lt;=1;\n        edge[i].w+=v[edge[i].x]+v[edge[i].y]; //重新计算边的权值！！！ \n    }\n}\nvoid _qst_w(int l,int r)\n{\n    int i=l,j=r,mw=edge[(i+j)&gt;&gt;1].w;\n    while(i&lt;=j)\n    {\n        while(edge[i].w&lt;mw) i++;\n        while(edge[j].w&gt;mw) j--;\n        if(i&lt;=j)\n        {\n            swap(edge[i],edge[j]);\n            i++;j--;\n        }\n    }\n    if(l&lt;j) _qst_w(l,j);\n    if(i&lt;r) _qst_w(i,r);\n}\nvoid _solve()//Kruskal\n{\n    _qst_w(1,P);\n    int fx,fy,k,cnt,tot;\n    k=cnt=tot=0;\n    while(cnt&lt;N-1)\n    {\n        k++;\n        fx=_getfather(edge[k].x);\n        fy=_getfather(edge[k].y);\n        if(fx!=fy)\n        {\n            father[fx]=fy;\n            tot+=edge[k].w;\n            cnt++;\n        }\n    }\n    printf("%d\\n",tot+Min);  //不要忘记最后加上起点的权值（点的最小权值） \n}\nint main()\n{\n    _init();\n    _solve();\n    return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.StringTokenizer;\n\nclass Reader3{\n    static BufferedReader reader;\n    static StringTokenizer tokenizer;\n    \n    static void init(InputStream input){\n        reader=new BufferedReader(new InputStreamReader(input));\n        tokenizer=new StringTokenizer("");\n    }\n    \n    static String next() throws IOException{\n        while (!tokenizer.hasMoreElements()) {\n            tokenizer = new StringTokenizer(reader.readLine(\n));\n        }\n        return tokenizer.nextToken();\n    }\n    \n    static int nextInt() throws IOException{\n        return Integer.parseInt(next());\n    }\n    static double nextDouble() throws IOException{\n        return Double.parseDouble(next());\n    }\n}\nclass KruskalDui{\n    int a,b,l;\n}\npublic class Main{\n\n    /**\n     * @param args\n     * @throws IOException \n     */\n    static int father[]=new int[100000];\n    static ArrayList&lt;KruskalDui&gt; path =new ArrayList&lt;KruskalDui&gt;();\n    \n    public static int getfather(int x) {\n        if (x!=father[x]) {\n            father[x]=getfather(father[x]);\n        }\n        return father[x];\n    }\n    public static void _qst_w(int l,int r)  {  \n        int i=l,j=r,mw=path.get((i+j)/2).l;  \n        while(i&lt;=j){  \n            while(path.get(i).l&lt;mw) i++;  \n            while(path.get(j).l&gt;mw) j--;  \n            if(i&lt;=j){  \n                Collections.swap(path,i,j);  \n                i++;j--;  \n            }  \n        }  \n        if(l&lt;j) _qst_w(l,j);  \n        if(i&lt;r) _qst_w(i,r);  \n    }  \n    public static void main(String[] args) throws IOException {\n        // TODO Auto-generated method stub\n        Reader3.init(System.in);\n        int n=Reader3.nextInt();\n        int p=Reader3.nextInt();\n        int d[]=new int [n+1];\n        int minD=Integer.MAX_VALUE;\n        for (int i = 1; i &lt; n+1; i++) {\n            d[i]=Reader3.nextInt();\n            father[i]=i;\n            if (d[i]&lt;minD) {\n                minD=d[i];\n            }\n        }\n        for (int i = 0; i &lt; p; i++) {\n            KruskalDui k=new KruskalDui();\n            k.a=Reader3.nextInt();\n            k.b=Reader3.nextInt();\n            k.l=Reader3.nextInt();\n            k.l=k.l*2+d[k.a]+d[k.b];\n            path.add(k);\n        }\n        _qst_w(0,p-1);\n        int fx,fy,result=minD,count=0,k=0;\n        while(count&lt;n-1){\n            fx=getfather(path.get(k).a);  \n            fy=getfather(path.get(k).b);  \n            if(fx!=fy){  \n                father[fx]=fy;  \n                result+=path.get(k).l;  \n                count++;  \n            }  \n            k++;\n        }\n        System.out.println(result);\n    }\n}\r\n</textarea>	16
17	<div class="des"> \n <div class="sec_header">\n   问题描述\n </div> \n <div class="sec_cont"> \n  <p>Alice是一个让人非常愉跃的人!他总是去学习一些他不懂的问题，然后再想出许多稀奇古怪的题目。这几天，Alice又沉浸在逆序对的快乐当中，他已近学会了如何求逆序对对数，动态维护逆序对对数等等题目，他认为把这些题让你做简直是太没追求了，于是，经过一天的思考和完善，Alice终于拿出了一道他认为差不多的题目：</p> \n  <p>有一颗2n-1个节点的二叉树，它有恰好n个叶子节点，每个节点上写了一个整数。如果将这棵树的所有叶子节点上的数从左到右写下来，便得到一个序列a[1]…a[n]。现在想让这个序列中的逆序对数量最少，但唯一的操作就是选树上一个非叶子节点，将它的左右两颗子树交换。他可以做任意多次这个操作。求在最优方案下，该序列的逆序对数最少有多少。</p> \n  <p>Alice自己已近想出了题目的正解，他打算拿来和你分享，他要求你在最短的时间内完成。</p> \n </div> \n <div class="sec_header">\n   输入格式\n </div> \n <div class="sec_cont"> \n  <p>第一行一个整数n。</p> \n  <p>下面每行，一个数x。</p> \n  <p>如果x=0，表示这个节点非叶子节点，递归地向下读入其左孩子和右孩子的信息，如果x≠0，表示这个节点是叶子节点，权值为x。</p> \n </div> \n <div class="sec_header">\n   输出格式\n </div> \n <div class="sec_cont">\n   输出一个整数，表示最少有多少逆序对。 \n </div> \n <div class="sec_header">\n   样例输入\n </div> \n <div class="sec_text">\n   3\n  <br> 0\n  <br> 0\n  <br> 3\n  <br> 1\n  <br> 2 \n </div> \n <div class="sec_header">\n   样例输出\n </div> \n <div class="sec_text">\n   1 \n </div> \n <div class="sec_header">\n   数据规模与约定\n </div> \n <div class="sec_cont"> \n  <p>对于20%的数据，n &lt;= 5000。</p> \n  <p>对于100%的数据，1 &lt;= n &lt;= 200000，0 &lt;= a[i]&lt;2^31。</p> \n </div> \n</div>	<textarea id="codelinesc">\r\n// 蓝桥杯 逆序对 c语言实现\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n#define MAXN 200005\nint n,m;\nlong long ans;\nlong long min(long long  a,long long b){\n    if(a&gt;b) return b;\n    return a;\n    }\nint S[MAXN],Left[MAXN],Right[MAXN];\nunsigned int Key[MAXN];\nint Left_Rotate(int rt){\n    int k=Right[rt];\n    Right[rt]=Left[k];\n    Left[k]=rt;\n    S[k]=S[rt];\n    S[rt]=S[Left[rt]]+S[Right[rt]]+1;\n    return rt=k;\n}\nint Right_Rotate(int rt){\n    int k=Left[rt];\n    Left[rt]=Right[k];\n    Right[k]=rt;\n    S[k]=S[rt];\n    S[rt]=S[Left[rt]]+S[Right[rt]]+1;\n    return rt=k;\n}\nint Maintain(int rt,int flag){\n    if(flag){\n        if(S[Left[Right[rt]]]&gt;S[Left[rt]] || S[Right[Right[rt]]]&gt;S[Left[rt]]){\n            if(S[Left[Right[rt]]]&gt;S[Left[rt]])Right[rt]=Right_Rotate(Right[rt]);\n            return Left_Rotate(rt);\n        }\n    }\n    else{\n        if(S[Right[Left[rt]]]&gt;S[Right[rt]] || S[Left[Left[rt]]]&gt;S[Right[rt]]){\n            if(S[Right[Left[rt]]]&gt;S[Right[rt]])Left[rt]=Left_Rotate(Left[rt]);\n            return Right_Rotate(rt);\n        }\n    }\n    return rt;\n}\nint Insert(int rt,int RT){\n    S[rt]+=1;\n    if(Key[RT]&gt;Key[rt]){\n        if(Right[rt]&gt;0)Right[rt]=Insert(Right[rt],RT);\n        else{\n            Right[rt]=RT;\n        }\n    }\n    else{\n        if(Left[rt]&gt;0)Left[rt]=Insert(Left[rt],RT);\n        else{\n            Left[rt]=RT;\n        }\n    }\n    return rt=Maintain(rt,Key[RT]&gt;Key[rt]);\n}\nint Rank(int rt,int v){\n    if(v&gt;Key[rt]){\n        if(Right[rt]==0)return S[rt];\n        return S[rt]-S[Right[rt]]+Rank(Right[rt],v);\n    }\n    if(Left[rt]==0)return 0;\n    return Rank(Left[rt],v);\n}\nint Merge(int rt,int Start,int End){\n    int i; \n    long long lans=0,rans=0;\n    for(i=Start;i&lt;=End;i++){\n        lans+=Rank(rt,Key[i]);\n        rans+=S[rt]-Rank(rt,Key[i]+1);\n    }\n    for(i=Start;i&lt;=End;i++){\n        S[i]=1;\n        Left[i]=Right[i]=0;\n        rt=Insert(rt,i);\n    }\n    ans+=min(lans,rans);\n    return rt;\n}\nint Init(){\n    int v;\n    scanf("%d",&amp;v);\n    if(v){\n        Key[++m]=v;\n        S[m]=1;\n        Left[m]=Right[m]=0;\n        return m;\n    }\n    int TL,TR,Ls,Le,Rs,Re;\n    Ls=m+1;\n    TL=Init();\n    Le=m;\n    Rs=m+1;\n    TR=Init();\n    Re=m;\n    if(S[TL]&lt;S[TR])return Merge(TR,Ls,Le);\n    return Merge(TL,Rs,Re);\n}\nint main()\n{\n    scanf("%d",&amp;n);\n    Init();\n    printf("%I64d\\n",ans);\n    system("pause");\n    return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\n#include&lt;iostream&gt;\nusing namespace std;\n#define ForD(i,n) for(int i=n;i;i--)\n#define F (100000007)\n#define MAXN (2*200000+10)\n\nlong long mul(long long a,long long b){return (a*b)%F;}\nlong long add(long long a,long long b){return (a+b)%F;}\nlong long sub(long long a,long long b){return (a-b+(a-b)/F*F+F)%F;}\nint n,root=0;\n\nstruct node\n{\n    int fa,ch[2],size,c;\n    node():size(0),c(0){ch[0]=ch[1]=fa=0;}\n}a[MAXN];\n\nvoid update(int x){a[x].size=a[a[x].ch[0]].size+a[a[x].ch[1]].size+(a[x].c&gt;0);}\n\nint tail=0;\n\nvoid pushdown(int x){a[a[x].ch[0]].fa=a[a[x].ch[1]].fa=x;}\n\nvoid build(int &amp;x)\n{\n    if (!x) x=++tail;\n    scanf("%d",&amp;a[x].c);\n    if (a[x].c==0)\n    {\n        build(a[x].ch[0]);\n        build(a[x].ch[1]);\n        update(x);pushdown(x);\n    }else a[x].size=1;\n}\n\nvoid rotate(int x)\n{\n    int y=a[x].fa,z=a[y].fa;\n    bool p=a[y].ch[0]==x;\n    if (z)\n    {\n        if (a[z].ch[0]==y) a[z].ch[0]=x;\n        else a[z].ch[1]=x;\n    }\n    a[x].fa=z,a[y].fa=x;\n    if (a[x].ch[p]) a[a[x].ch[p]].fa=y;\n    a[y].ch[p^1]=a[x].ch[p];\n    a[x].ch[p]=y;\n    update(y);\n}\n\nvoid splay(int x)\n{\n    while (a[x].fa)\n    {\n        int y=a[x].fa,z=a[y].fa;\n        if (z)\n            if ((a[y].ch[0]==x)^(a[z].ch[0]==y)) rotate(x);\n            else rotate(y);\n        rotate(x);\n    }\n    update(x);\n}\n\nvoid ins(long long &amp;tot,int x,int y)\n{\n    a[x].size++;\n    if (a[y].c&lt;=a[x].c)\n    {\n        if (a[x].ch[0]) ins(tot,a[x].ch[0],y);\n        else a[y].fa=x,splay(a[x].ch[0]=y);\n    }\n    else\n    {\n        tot+=a[a[x].ch[0]].size+(a[x].c&gt;0);\n        if (a[x].ch[1]) ins(tot,a[x].ch[1],y);\n        else a[y].fa=x,splay(a[x].ch[1]=y);\n    }\n}\n\nint q[MAXN],size;\n\nvoid clac(int x,int y)\n{\n    if (a[y].ch[0]) clac(x,a[y].ch[0]);\n    if (a[y].c) q[++size]=y;\n    if (a[y].ch[1]) clac(x,a[y].ch[1]);\n}\n\nlong long merge(bool &amp;lor,int z)\n{\n    int x=a[z].ch[0],y=a[z].ch[1];\n    if (a[x].size&lt;a[y].size) swap(x,y);\n\n    a[x].fa=0;a[y].fa=0;q[1]=y;\n    size=0;clac(x,y);\n    long long tot=0;\n    ForD(i,size)\n    {\n        int now=q[i];\n        a[now].ch[0]=a[now].ch[1]=a[now].fa=0;a[now].size=1;\n        ins(tot,x,now);\n        x=now;\n    }\n    a[x].fa=z;\n    a[z].ch[0]=0,a[z].ch[1]=x;\n    return tot;\n}\n\nlong long qur(int &amp;x)\n{\n    if (a[x].c) return 0;\n    else\n    {\n        long long lson=a[a[x].ch[0]].size,rson=a[a[x].ch[1]].size,ls=qur(a[x].ch[0]),rs=qur(a[x].ch[1]);\n        bool lor=0;\n        long long ms=merge(lor,x);\n        return ls+rs+min(lson*rson-ms,ms);\n    }\n}\n\nint main()\n{\n    scanf("%d",&amp;n);\n    build(root);\n    cout&lt;&lt;qur(root)&lt;&lt;endl;\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	17
18	<div class="des"> \n <div class="sec_header">\n   问题描述\n </div> \n <div class="sec_cont"> \n  <p>有n个格子，从左到右放成一排，编号为1-n。</p> \n  <p>共有m次操作，有3种操作类型：</p> \n  <p>1.修改一个格子的权值，</p> \n  <p>2.求连续一段格子权值和，</p> \n  <p>3.求连续一段格子的最大值。</p> \n  <p>对于每个2、3操作输出你所求出的结果。</p> \n </div> \n <div class="sec_header">\n   输入格式\n </div> \n <div class="sec_cont"> \n  <p>第一行2个整数n，m。</p> \n  <p>接下来一行n个整数表示n个格子的初始权值。</p> \n  <p>接下来m行，每行3个整数p,x,y，p表示操作类型，p=1时表示修改格子x的权值为y，p=2时表示求区间[x,y]内格子权值和，p=3时表示求区间[x,y]内格子最大的权值。</p> \n </div> \n <div class="sec_header">\n   输出格式\n </div> \n <div class="sec_cont"> \n  <p>有若干行，行数等于p=2或3的操作总数。</p> \n  <p>每行1个整数，对应了每个p=2或3操作的结果。</p> \n </div> \n <div class="sec_header">\n   样例输入\n </div> \n <div class="sec_text">\n   4 3\n  <br> 1 2 3 4\n  <br> 2 1 3\n  <br> 1 4 3\n  <br> 3 1 4 \n </div> \n <div class="sec_header">\n   样例输出\n </div> \n <div class="sec_text">\n   6\n  <br> 3 \n </div> \n <div class="sec_header">\n   数据规模与约定\n </div> \n <div class="sec_cont"> \n  <p>对于20%的数据n &lt;= 100，m &lt;= 200。</p> \n  <p>对于50%的数据n &lt;= 5000，m &lt;= 5000。</p> \n  <p>对于100%的数据1 &lt;= n &lt;= 100000，m &lt;= 100000，0 &lt;= 格子权值 &lt;= 10000。</p> \n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\nint n, m, p, x, y;\nint MAX[400050];\nint SUM[400050];\nint Max(int a, int b) {\nreturn a &gt; b ? a : b;\n}\nvoid PushUp_max(int rt) {\nMAX[rt] = Max(MAX[rt*2],MAX[rt*2+1]);\n}\nvoid PushUp_sum(int rt) {\nSUM[rt] = SUM[rt*2] + SUM[rt*2+1];\n}\nvoid Build(int l, int r, int rt) {\nif(l == r) {\nscanf("%d",&amp;MAX[rt]);\nSUM[rt] = MAX[rt];\nreturn;\n}\nint m = (l + r) / 2;\nBuild(l,m,rt*2);\nBuild(m+1,r,rt*2+1);\nPushUp_max(rt);\nPushUp_sum(rt);\n}\nvoid UpDate(int a, int b, int l, int r, int rt) {\nif(l == r) {\nMAX[rt] = SUM[rt] = b;\nreturn;\n}\nint m = (l + r) / 2;\nif(a &lt;= m) UpDate(a,b,l,m,rt*2);\nelse UpDate(a,b,m+1,r,rt*2+1);\nPushUp_max(rt);\nPushUp_sum(rt);\n}\nint Query_max(int L, int R, int l, int r, int rt) {\nif(L &lt;= l &amp;&amp; r &lt;= R) return MAX[rt];\nint m = (l + r) / 2;\nint ret = 0;\nif(L &lt;= m) ret = Max(ret,Query_max(L,R,l,m,rt*2));\nif(R &gt; m) ret = Max(ret,Query_max(L,R,m+1,r,rt*2+1));\nreturn ret;\n}\nint Query_sum(int L, int R, int l, int r, int rt) {\nif(L &lt;= l &amp;&amp; r &lt;= R) return SUM[rt];\nint m = (l + r) / 2;\nint ret = 0;\nif(L &lt;= m) ret += Query_sum(L,R,l,m,rt*2);\nif(R &gt; m) ret += Query_sum(L,R,m+1,r,rt*2+1);\nreturn ret;\n}\nint main()\n{\nscanf("%d%d",&amp;n, &amp;m);\nBuild(1,n,1);\nwhile(m--) {\nscanf("%d%d%d",&amp;p,&amp;x,&amp;y);\nswitch(p) {\ncase 1: UpDate(x,y,1,n,1);\nbreak;\ncase 2: printf("%d\\n",Query_sum(x,y,1,n,1));\nbreak;\ncase 3: printf("%d\\n",Query_max(x,y,1,n,1));\nbreak;\n}\n}\nreturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n//  test\n//  1.cpp\n/*\n    ID: Firwaless\n    LANG: C++\n    TASK: \n*/\n\n#include &lt;cstdio&gt;\n#include &lt;algorithm&gt;\n\nstruct Tree\n{\n    int sum, max;\n};\n\nTree tree[1 &lt;&lt; 18];\n\nvoid scan(int &amp;n)\n{\n    char c;\n    \n    c = getchar();\n    if (c == EOF) {\n        return ;\n    }\n    while (c &lt; '0' || c &gt; '9') {\n        c = getchar();\n    }\n    n = c - '0';\n    while (c = getchar(), c &gt;= '0' &amp;&amp; c &lt;= '9') {\n        n *= 10;\n        n += c - '0';\n    }\n}\n\nvoid put(int n)\n{\n    int cnt = 0;\n    char s[16];\n    \n    if (n == 0) {\n        putchar('0');\n        return ;\n    }\n    for( ; n; n /= 10) {\n        s[cnt++] = n % 10 + '0';\n    }\n    while (cnt--) {\n        putchar(s[cnt]);\n    }\n}\n\nvoid update(int n, int v)\n{\n    for (n += (1 &lt;&lt; 17),tree[n].sum = tree[n].max = v, n &gt;&gt;= 1; n; n &gt;&gt;= 1) {\n        tree[n].max = std::max(tree[n + n].max, tree[n + n + 1].max);\n        tree[n].sum = tree[n + n].sum + tree[n + n + 1].sum;\n    }\n}\n\nint query(int s, int t, int func)\n{\n    int sum = 0, max = 0;\n    \n    for (s += (1 &lt;&lt; 17) - 1, t += (1 &lt;&lt; 17) + 1; s ^ t ^ 1; s &gt;&gt;= 1, t &gt;&gt;= 1) {\n        if (~s &amp; 1) {\n            sum += tree[s ^ 1].sum;\n            max = std::max(max, tree[s ^ 1].max);\n        }\n        if (t &amp; 1) {\n            sum += tree[t ^ 1].sum;\n            max = std::max(max, tree[t ^ 1].max);\n        }\n    }\n    return func ? max : sum;\n}\n\nint main()\n{\n    int n, m, i, a, b, c;\n    \n    scan(n);scan(m);\n    for (i = 1; i &lt;= n; ++i) {\n        scan(a);\n        update(i, a);\n    }\n    while (m--) {\n        scan(c);scan(a);scan(b);\n        c == 1 &amp;&amp; (update(a, b), 0);\n        c == 2 &amp;&amp; (put(query(a, b, 0)), putchar('\\n'), 0);\n        c == 3 &amp;&amp; (put(query(a, b, 1)), putchar('\\n'), 0);\n    }\n    return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\n//package practice;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\t\n\tfinal static int MAX_N = 100007;\n\t\n\tclass Node {\n\t\tint l, r;\n\t\tint sum, max;\n\t\tNode () {\n\t\t\t\n\t\t}\n\t\tNode (int _l, int _r, int _s, int _m) {\n\t\t\tl = _l;\n\t\t\tr = _r;\n\t\t\tsum = _s;\n\t\t\tmax = _m;\n\t\t}\n\t}\n\t\n\tint n, m;\n\tNode tree[] = new Node[MAX_N &lt;&lt; 2];\n\tint a[] = new int[MAX_N];\n\t\n\tvoid up(int id) {\n\t\ttree[id].sum = tree[id &lt;&lt; 1].sum + tree[id &lt;&lt; 1 | 1].sum;\n\t\ttree[id].max = Math.max(tree[id &lt;&lt; 1].max, tree[id &lt;&lt; 1| 1].max);\n\t}\n\t\n\tvoid build(int id, int l, int r) {\n\t\ttree[id] = new Node(l, r, 0, 0);\n\t\tif (l == r) {\n\t\t\ttree[id].sum = tree[id].max = a[l];\n\t\t\treturn ;\n\t\t}\n\t\tint mid = (l + r) &gt;&gt; 1;\n\t\tbuild(id &lt;&lt; 1, l, mid);\n\t\tbuild(id &lt;&lt; 1 | 1, mid + 1, r);\n\t\tup(id);\n\t}\n\t\n\t\n\tvoid update(int id, int pos, int val) {\n\t\tif (tree[id].l == tree[id].r) {\n\t\t\ttree[id].sum = tree[id].max = val;\n\t\t\treturn ;\n\t\t}\n\t\tint mid = (tree[id].l + tree[id].r) &gt;&gt; 1;\n\t\tif (pos &lt;= mid) update(id &lt;&lt; 1, pos, val);\n\t\telse update(id &lt;&lt; 1 | 1, pos, val);\n\t\tup(id);\n\t}\n\t\n\tint sum(int id, int l, int r) {\n\t\tif (l &lt;= tree[id].l &amp;&amp; tree[id].r &lt;= r) {\n\t\t\treturn tree[id].sum;\n\t\t}\n\t\tint mid = (tree[id].l + tree[id].r) &gt;&gt; 1;\n\t\tif (r &lt;= mid) return sum(id &lt;&lt; 1, l, r);\n\t\telse if (l &gt; mid) return sum(id &lt;&lt; 1 | 1, l, r);\n\t\telse {\n\t\t\treturn sum(id &lt;&lt; 1, l, mid) + sum(id &lt;&lt; 1 | 1, mid + 1, r);\n\t\t}\n\t}\n\t\n\tint max(int id, int l, int r) {\n\t\tif (l &lt;= tree[id].l &amp;&amp; tree[id].r &lt;= r) {\n\t\t\treturn tree[id].max;\n\t\t}\n\t\tint mid = (tree[id].l + tree[id].r) &gt;&gt; 1;\n\t\tif (r &lt;= mid) return max(id &lt;&lt; 1, l, r);\n\t\telse if (l &gt; mid) return max(id &lt;&lt; 1 | 1, l, r);\n\t\telse {\n\t\t\treturn Math.max(max(id &lt;&lt; 1, l, mid), max(id &lt;&lt; 1 | 1, mid + 1, r));\n\t\t}\n\t}\n\t\n\tvoid run() throws IOException {\n\t\tn = cin.nextInt();\n\t\tm = cin.nextInt();\n\t\tfor (int i = 1; i &lt;= n; ++i)\n\t\t\ta[i] = cin.nextInt();\n\t\tbuild(1, 1, n);\n\t\tfor (int i = 0; i &lt; m; ++i) {\n\t\t\tint type = cin.nextInt();\n\t\t\tint l = cin.nextInt();\n\t\t\tint r = cin.nextInt();\n\t\t\tif (type == 1) update(1, l, r);\n\t\t\telse if (type == 2) out.println(sum(1, l, r));\n\t\t\telse out.println(max(1, l, r));\n\t\t}\n\t\tout.close(); \n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tMain() {\n\t\t cin = new InputReader(System.in);\n\t\t//cin = new Scanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t}\n\n\tPrintWriter out;\n\t InputReader cin;\n\t//Scanner cin;\n\n\tclass InputReader {\n\t\tInputReader(InputStream in) {\n\t\t\treader = new BufferedReader(new InputStreamReader(in));\n\t\t\t// try {\n\t\t\t// reader = new BufferedReader(new FileReader("input.txt"));\n\t\t\t// } catch (FileNotFoundException ex) {\n\t\t\t// }\n\t\t\ttokenizer = new StringTokenizer("");\n\t\t}\n\n\t\tprivate String next() throws IOException {\n\t\t\twhile (!tokenizer.hasMoreTokens()) {\n\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\n\t\tpublic Integer nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tprivate BufferedReader reader;\n\t\tprivate StringTokenizer tokenizer;\n\t}\n}\r\n</textarea>	18
19	<div class="des"> \n <div class="sec_header">\n   问题描述\n </div> \n <div class="sec_cont"> \n  <p>给定平面上n个点。</p> \n  <p>求两条直线，这两条直线互相垂直，而且它们与x轴的夹角为45度，并且n个点中离这两条直线的曼哈顿距离的最大值最小。</p> \n  <p>两点之间的曼哈顿距离定义为横坐标的差的绝对值与纵坐标的差的绝对值之和，一个点到两条直线的曼哈顿距离是指该点到两条直线上的所有点的曼哈顿距离中的最小值。</p> \n </div> \n <div class="sec_header">\n   输入格式\n </div> \n <div class="sec_cont"> \n  <p>第一行包含一个数n。</p> \n  <p>接下来n行，每行包含两个整数，表示n个点的坐标（横纵坐标的绝对值小于10<sup>9</sup>）。</p> \n </div> \n <div class="sec_header">\n   输出格式\n </div> \n <div class="sec_cont">\n   输出一个值，表示最小的最大曼哈顿距离的值，保留一位小数。 \n </div> \n <div class="sec_header">\n   样例输入\n </div> \n <div class="sec_text">\n   4\n  <br> 1 0\n  <br> 0 1\n  <br> 2 1\n  <br> 1 2 \n </div> \n <div class="sec_header">\n   样例输出\n </div> \n <div class="sec_text">\n   1.0 \n </div> \n <div class="sec_header">\n   数据规模与约定\n </div> \n <div class="sec_cont"> \n  <p>对于30%的数据，n&lt;=100。</p> \n  <p>对于另外30%的数据，坐标范的绝对值小于100。</p> \n  <p>对于100%的数据，n&lt;=10<sup>5</sup>。</p> \n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n\nstruct point\n{\n\tint s, d;\n} p[100005];\nint bl[100005], sl[100005], br[100005], sr[100005];\n\nint cmp(const void *a, const void *b)\n{\n\tstruct point *pa = (struct point*)a;\n\tstruct point *pb = (struct point*)b;\n\treturn pa-&gt;s - pb-&gt;s;\n}\n\nint main(void)\n{\n\tint n, x, y;\n\tint min, max;\n\tdouble mind, maxd, d;\n\tint i, j;\n\t\n\tscanf("%d", &amp;n);\n\tfor (i=0; i&lt;n; ++i)\n\t{\n\t\tscanf("%d%d", &amp;x, &amp;y);\n\t\tp[i].s = x+y;\n\t\tp[i].d = x-y;\n\t}\n\t\n\tqsort(p, n, sizeof(struct point), cmp);\n\tbl[0] = sl[0] = p[0].d;\n\tfor (i=1; i&lt;n; ++i)\n\t{\n\t\tbl[i] = bl[i-1]&gt;p[i].d ? bl[i-1] : p[i].d;\n\t\tsl[i] = sl[i-1]&lt;p[i].d ? sl[i-1] : p[i].d;\n\t}\n\tbr[n-1] = sr[n-1] = p[n-1].d;\n\tfor (i=n-2; i&gt;=0; --i)\n\t{\n\t\tbr[i] = br[i+1]&gt;p[i].d ? br[i+1] : p[i].d;\n\t\tsr[i] = sr[i+1]&lt;p[i].d ? sr[i+1] : p[i].d;\n\t}\n\t\n\tmind = 0;\n\tmaxd = br[0]-sr[0] &gt; p[n-1].s-p[0].s ? br[0]-sr[0] : p[n-1].s-p[0].s;\n\twhile (maxd-mind &gt; 0.1)\n\t{//\t\tprintf("%f %f\\n", mind, maxd);\n\t\td = (maxd+mind)/2;\n\t\tj = 0;\n\t\tfor (i=0; i&lt;n; ++i)\n\t\t{\n\t\t\twhile (j&lt;n &amp;&amp; p[j].s-p[i].s&lt;=d)\n\t\t\t{\n\t\t\t\t++j;\n\t\t\t}\n\t\t\tif (i==0)\n\t\t\t{\n\t\t\t\tmax = br[j];\n\t\t\t\tmin = sr[j];\n\t\t\t}\n\t\t\telse if (j==n)\n\t\t\t{\n\t\t\t\tmax = bl[i-1];\n\t\t\t\tmin = sl[i-1];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmax = bl[i-1]&gt;br[j] ? bl[i-1] : br[j];\n\t\t\t\tmin = sl[i-1]&lt;sr[j] ? sl[i-1] : sr[j];\n\t\t\t}\n\n\t\t\tif (max-min&lt;=d)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (max-min&lt;=d)\n\t\t{\n\t\t\tmaxd = d;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmind = d;\n\t\t}\n\t}\n\t\n\tprintf("%.1f\\n", maxd/2);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstdio&gt;\n#include&lt;cmath&gt;\nusing namespace std;\n\nconst int N=100000;\nstruct P{int x,y;};\nbool cmp(P a,P b){\n    if(a.x==b.x)return a.y&lt;b.y;\n    return a.x&lt;b.x;\n}\nP d[N+5];\nstruct F{int max,min;};\nF fl[N+5],fr[N+5];\ninline double Max(double a,double b){return a&gt;b?a:b;}\ninline double Min(double a,double b){return a&gt;b?b:a;}\nbool check(double m,int n){\n    m*=2;\n    int i,j=0;\n    for(i=0;i&lt;n;i++){\n        while(j&lt;n&amp;&amp;d[j].x-d[i].x&lt;=m)j++;\n        double MAX=-1e10;\n        double MIN=1e10;\n        if(j!=n){\n            MAX=Max(MAX,fr[j].max);\n            MIN=Min(MIN,fr[j].min);\n        }\n        if(i-1&gt;=0){\n            MAX=Max(MAX,fl[i-1].max);\n            MIN=Min(MIN,fl[i-1].min);\n        }\n     //   cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;" "&lt;&lt;MAX&lt;&lt;" "&lt;&lt;MIN&lt;&lt;endl;\n        if(MAX-MIN&lt;=m)return true;\n    }\n    return false;\n}\nvoid init(int n){\n    int i;\n    fl[0].min=fl[0].max=d[0].y;\n    for(i=1;i&lt;n;i++){\n        fl[i].max=Max(fl[i-1].max,d[i].y);\n        fl[i].min=Min(fl[i-1].min,d[i].y);\n    }\n    fr[n-1].min=fr[n-1].max=d[n-1].y;\n    for(i=n-2;i&gt;=0;i--){\n        fr[i].max=Max(fr[i+1].max,d[i].y);\n        fr[i].min=Min(fr[i+1].min,d[i].y);\n    }\n}\nint main(){\n    int i,n;\n    cin&gt;&gt;n;\n    for(i=0;i&lt;n;i++){\n        int x,y;\n        scanf("%d%d",&amp;x,&amp;y);\n        d[i].x=x+y;\n        d[i].y=x-y;\n    }\n    sort(d,d+n,cmp);\n    init(n);\n    double l=0.0;\n    double r=1000000000;\n    while(r-l&gt;=0.01){\n        double m=(l+r)/2;\n      //  cout&lt;&lt;m&lt;&lt;endl;\n        if(check(m,n))r=m;\n        else l=m;\n    }\n    printf("%.1f\\n",r);\n    return 0;\n}\n\n\n\r\n</textarea>	<textarea id="codelinesjava">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	19
20	<div class="des"> \n <div class="sec_header">\n   问题描述\n </div> \n <div class="sec_cont"> \n  <p>Ciel有一个N*N的矩阵，每个格子里都有一个整数。</p> \n  <p>N是一个奇数，设X = (N+1)/2。Ciel每次都可以做这样的一次操作：他从矩阵选出一个X*X的子矩阵，并将这个子矩阵中的所有整数都乘以-1。</p> \n  <p>现在问你经过一些操作之后，矩阵中所有数的和最大可以为多少。</p> \n </div> \n <div class="sec_header">\n   输入格式\n </div> \n <div class="sec_cont"> \n  <p>第一行为一个正整数N。</p> \n  <p>接下来N行每行有N个整数，表示初始矩阵中的数字。每个数的绝对值不超过1000。</p> \n </div> \n <div class="sec_header">\n   输出格式\n </div> \n <div class="sec_cont">\n   输出一个整数，表示操作后矩阵中所有数之和的最大值。 \n </div> \n <div class="sec_header">\n   样例输入\n </div> \n <div class="sec_text">\n   3\n  <br> -1 -1 1\n  <br> -1 1 -1\n  <br> 1 -1 -1 \n </div> \n <div class="sec_header">\n   样例输出\n </div> \n <div class="sec_text">\n   9 \n </div> \n <div class="sec_header">\n   数据规模与约定\n </div> \n <div class="sec_cont"> \n  <p>1 &lt;= N &lt;= 33，且N为奇数。</p> \n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint x[33][33],ans,N;\nvoid fun1(int n)\n{\n\tint i,j,lin=0,aa,bb;\n\tfor(j=0;j&lt;N;j++)\n\t\tlin+=x[n-1][j];\n\tfor(i=0;i&lt;n-1;i++)\n\t{\n\t\taa=-1000000000;\n\t\tbb=x[i][n-1]+x[i+n][n-1];\n\t\tfor(j=0;j&lt;n-1;j++)\n\t\t\tbb+=abs(x[i][j]+x[i+n][j]+x[i][j+n]+x[i+n][j+n]);\n\t\taa=aa&gt;bb?aa:bb;\n\t\tbb=-x[i][n-1]-x[i+n][n-1];\n\t\tfor(j=0;j&lt;n-1;j++)\n\t\t\tbb+=abs(-x[i][j]-x[i+n][j]+x[i][j+n]+x[i+n][j+n]);\n\t\taa=aa&gt;bb?aa:bb;\n\t\tlin+=aa;\n\t}\n\tans=ans&gt;lin?ans:lin;\n}\nvoid fun(int n)\n{\n\tint i,j,k;\n\tfor(k=0;k&lt;(1&lt;&lt;n-1);k++)\n\t{\n\t\tfor(i=0;i&lt;n-1;i++)\n\t\t\tif((k&amp;(1&lt;&lt;i))!=0)\n\t\t\t\tfor(j=0;j&lt;n;j++)\n\t\t\t\t{\n\t\t\t\t\tx[j][i]*=-1;\n\t\t\t\t\tx[j][i+n]*=-1;\n\t\t\t\t}\n\t\tfun1(n);\n\t\tfor(i=0;i&lt;n-1;i++)\n\t\t\tif((k&amp;(1&lt;&lt;i))!=0)\n\t\t\t\tfor(j=0;j&lt;n;j++)\n\t\t\t\t{\n\t\t\t\t\tx[j][i]*=-1;\n\t\t\t\t\tx[j][i+n]*=-1;\n\t\t\t\t}\n\t}\n}\nint main(void)\n{\n\tint i,j,k;\n\tscanf("%d",&amp;N);\n\tfor(i=0;i&lt;N;i++)\n\t\tfor(j=0;j&lt;N;j++)\n\t\t\tscanf("%d",&amp;x[i][j]);\n\tk=(N+1)/2;\n\tans=-1000000000;\n\tfun(k);\n\tfor(i=0;i&lt;k;i++)\n\t\tfor(j=0;j&lt;k;j++)\n\t\t\tx[i][j]=-x[i][j];\n\tfun(k);\n\tprintf("%d\\n",ans);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n\n#include&lt;stdio.h&gt;\n#include&lt;cmath&gt;\nusing namespace std;\nint x[33][33],ans,N;\nvoid fun1(int n)\n{\n\tint i,j,lin=0,aa,bb;\n\tfor(j=0;j&lt;N;j++)\n\t\tlin+=x[n-1][j];\n\tfor(i=0;i&lt;n-1;i++)\n\t{\n\t\taa=-1000000000;\n\t\tbb=x[i][n-1]+x[i+n][n-1];\n\t\tfor(j=0;j&lt;n-1;j++)\n\t\t\tbb+=abs(x[i][j]+x[i+n][j]+x[i][j+n]+x[i+n][j+n]);\n\t\taa=aa&gt;bb?aa:bb;\n\t\tbb=-x[i][n-1]-x[i+n][n-1];\n\t\tfor(j=0;j&lt;n-1;j++)\n\t\t\tbb+=abs(-x[i][j]-x[i+n][j]+x[i][j+n]+x[i+n][j+n]);\n\t\taa=aa&gt;bb?aa:bb;\n\t\tlin+=aa;\n\t}\n\tans=ans&gt;lin?ans:lin;\n}\nvoid fun(int n)\n{\n\tint i,j,k;\n\tfor(k=0;k&lt;(1&lt;&lt;n-1);k++)\n\t{\n\t\tfor(i=0;i&lt;n-1;i++)\n\t\t\tif((k&amp;(1&lt;&lt;i))!=0)\n\t\t\t\tfor(j=0;j&lt;n;j++)\n\t\t\t\t{\n\t\t\t\t\tx[j][i]*=-1;\n\t\t\t\t\tx[j][i+n]*=-1;\n\t\t\t\t}\n\t\tfun1(n);\n\t\tfor(i=0;i&lt;n-1;i++)\n\t\t\tif((k&amp;(1&lt;&lt;i))!=0)\n\t\t\t\tfor(j=0;j&lt;n;j++)\n\t\t\t\t{\n\t\t\t\t\tx[j][i]*=-1;\n\t\t\t\t\tx[j][i+n]*=-1;\n\t\t\t\t}\n\t}\n}\nint main(void)\n{\n\tint i,j,k;\n\tscanf("%d",&amp;N);\n\tfor(i=0;i&lt;N;i++)\n\t\tfor(j=0;j&lt;N;j++)\n\t\t\tscanf("%d",&amp;x[i][j]);\n\tk=(N+1)/2;\n\tans=-1000000000;\n\tfun(k);\n\tfor(i=0;i&lt;k;i++)\n\t\tfor(j=0;j&lt;k;j++)\n\t\t\tx[i][j]=-x[i][j];\n\tfun(k);\n\tprintf("%d\\n",ans);\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n    public static int N, X;\n    public static int[][] Ciel;\n    public static int ans = Integer.MIN_VALUE;  //最终结果,初始化为最小\n    \n    public void getTempMax() {\n        int max = 0;\n        int tempA ,tempB;\n        for(int j = 0;j &lt; N;j++)\n            max += Ciel[X - 1][j];\n        for(int i = 0;i &lt; X - 1;i++) {\n            tempA = Integer.MIN_VALUE;\n            tempB = Ciel[i][X - 1] + Ciel[i + X][X - 1];\n            for(int j = 0;j &lt; X - 1;j++)\n                tempB += Math.abs(Ciel[i][j]+Ciel[i][j+X]+Ciel[i+X][j]+Ciel[i+X][j+X]);\n            tempA = Math.max(tempA, tempB);\n            tempB = -1 * (Ciel[i][X - 1] + Ciel[i + X][X - 1]);\n            for(int j = 0;j &lt; X - 1;j++)\n                tempB += Math.abs((-1)*Ciel[i][j]+Ciel[i][j+X]+(-1)*Ciel[i+X][j]+Ciel[i+X][j+X]);\n            tempA = Math.max(tempA, tempB);\n            max += tempA;\n        }\n        ans = Math.max(max, ans);\n    }\n    \n    public void getResult() {\n        for(int t = 0;t &lt; (1&lt;&lt;X-1);t++) {\n            for(int j = 0;j &lt; X - 1;j++) {\n                if((t&amp;(1&lt;&lt;j)) != 0) {\n                    for(int i = 0;i &lt; X;i++) {\n                        Ciel[i][j] *= -1;\n                        Ciel[i][j + X] *= -1;\n                    }\n                }\n            }\n            getTempMax();\n            for(int j = 0;j &lt; X - 1;j++) {\n                if((t&amp;(1&lt;&lt;j)) != 0) {\n                    for(int i = 0;i &lt; X;i++) {\n                        Ciel[i][j] *= -1;\n                        Ciel[i][j + X] *= -1;\n                    }\n                }\n            }\n        }\n    }\n    \n    public static void main(String[] args) {\n        Main test = new Main();\n        Scanner in = new Scanner(System.in);\n        N = in.nextInt();\n        X = (N + 1) / 2;\n        Ciel = new int[N][N];\n        for(int i = 0;i &lt; N;i++)\n            for(int j = 0;j &lt; N;j++)\n                Ciel[i][j] = in.nextInt();\n        test.getResult();\n        System.out.println(ans);\n    }\n}\r\n</textarea>	20
21	<div class="des"> \n <div class="sec_header">\n   问题描述\n </div> \n <div class="sec_cont"> \n  <p>人类在火星上发现了一种新的金属！这些金属分布在一些奇怪的地方，不妨叫它节点好了。一些节点之间有道路相连，所有的节点和道路形成了一棵树。一共有 n 个节点，这些节点被编号为 1~n 。人类将 k 个机器人送上了火星，目的是采集这些金属。这些机器人都被送到了一个指定的着落点， S 号节点。每个机器人在着落之后，必须沿着道路行走。当机器人到达一个节点时，它会采集这个节点蕴藏的所有金属矿。当机器人完成自己的任务之后，可以从任意一个节点返回地球。当然，回到地球的机器人就无法再到火星去了。我们已经提前测量出了每条道路的信息，包括它的两个端点 x 和 y，以及通过这条道路需要花费的能量 w 。我们想花费尽量少的能量采集所有节点的金属，这个任务就交给你了。</p> \n </div> \n <div class="sec_header">\n   输入格式\n </div> \n <div class="sec_cont"> \n  <p>第一行包含三个整数 n, S 和 k ，分别代表节点个数、着落点编号，和机器人个数。</p> \n  <p>接下来一共 n-1 行，每行描述一条道路。一行含有三个整数 x, y 和 w ，代表在 x 号节点和 y 号节点之间有一条道路，通过需要花费 w 个单位的能量。所有道路都可以双向通行。</p> \n </div> \n <div class="sec_header">\n   输出格式\n </div> \n <div class="sec_cont">\n   输出一个整数，代表采集所有节点的金属所需要的最少能量。 \n </div> \n <div class="sec_header">\n   样例输入\n </div> \n <div class="sec_text">\n   6 1 3\n  <br> 1 2 1\n  <br> 2 3 1\n  <br> 2 4 1000\n  <br> 2 5 1000\n  <br> 1 6 1000 \n </div> \n <div class="sec_header">\n   样例输出\n </div> \n <div class="sec_text">\n   3004 \n </div> \n <div class="sec_header">\n   样例说明\n </div> \n <div class="sec_cont"> \n  <p>所有机器人在 1 号节点着陆。</p> \n  <p>第一个机器人的行走路径为 1-&gt;6 ，在 6 号节点返回地球，花费能量为1000。</p> \n  <p>第二个机器人的行走路径为 1-&gt;2-&gt;3-&gt;2-&gt;4 ，在 4 号节点返回地球，花费能量为1003。</p> \n  <p>第一个机器人的行走路径为 1-&gt;2-&gt;5 ，在 5 号节点返回地球，花费能量为1001。</p> \n </div> \n <div class="sec_header">\n   数据规模与约定\n </div> \n <div class="sec_cont"> \n  <p>本题有10个测试点。 </p>\n  <p>对于测试点 1~2 ， n &lt;= 10 ， k &lt;= 5 。</p> \n  <p>对于测试点 3 ， n &lt;= 100000 ， k = 1 。</p> \n  <p>对于测试点 4 ， n &lt;= 1000 ， k = 2 。</p> \n  <p>对于测试点 5~6 ， n &lt;= 1000 ， k &lt;= 10 。</p> \n  <p>对于测试点 7~10 ， n &lt;= 100000 ， k &lt;= 10 。</p> \n  <p>道路的能量 w 均为不超过 1000 的正整数。</p> \n </div> \n</div>	<textarea id="codelinesc">\r\n# include &lt;stdio.h&gt;\n# include &lt;string.h&gt;\n#define N 100001\nstruct edge\n{\n    int to;\n    int weight;\n    int next;\n};\nint tree[N];\nstruct edge edges[2*N];\nint d[N][12];\nint K;\nint ep = 0;\nvoid add_edge(int x, int y, int w)\n{\n    edges[ep].to = y;\n    edges[ep].weight = w;\n    edges[ep].next = tree[x];\n    tree[x] = ep++;\n}\nvoid dfs(int r, int p)\n{\n\tint cur;\n\tint child,i,j;\n    for(cur = tree[r]; cur != -1; cur=edges[cur].next)\n    {\n        child = edges[cur].to;\n        if(child == p)\n            continue;\n        dfs(child, r);\n        for( i = K; i &gt;= 0; i--)      \n        {\n            d[r][i] += d[child][0]+edges[cur].weight*2;\n\n            for( j = 1; j &lt;= i; j++)\n            {\n                if(d[r][i] &gt; d[child][j] + d[r][i-j] + j*edges[cur].weight)\n                {\n                    d[r][i] = d[child][j] + d[r][i-j] + j*edges[cur].weight;\n                }\n            }\n        }\n\n    }\n}\n\nint main(void)\n{\n\tint n, S;\n\tint i,a,b,c;\n    memset(tree, -1, sizeof(tree));\n    scanf("%d%d%d",&amp;n,&amp;S,&amp;K);\n    for(i = 0; i &lt; n-1; i++)\n    {\n        \n        scanf("%d%d%d",&amp;a,&amp;b,&amp;c);\n        add_edge(a, b, c);\n        add_edge(b, a, c);\n    }\n\n    dfs(S, -1);\n    printf("%d",d[S][K]);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\nusing namespace std;\n\nconst int MAXN=100000+10,oo=100000000,MAXK=10+1;\n\ntypedef long long LL;\n\nint N,S,K,fa[MAXN];\nint g[MAXN],num[MAXN*2],next[MAXN*2],cost[MAXN*2],tot=1;\nLL f[MAXN][MAXK],sum;\n\ninline void read(int &amp;x)\n{\n  char ch;\n  while (ch=getchar(),ch&gt;'9' || ch&lt;'0') ; x=ch-48;\n  while (ch=getchar(),ch&lt;='9' &amp;&amp; ch&gt;='0') x=x*10+ch-48;\n}\n\ninline void addedge(int a,int b,int c) { ++tot; num[tot]=b; next[tot]=g[a]; g[a]=tot; cost[tot]=c; }\n\nvoid dfs(int x)\n{\n  for (int i=g[x];i;i=next[i])\n    if (num[i]!=fa[x])\n    {\n      fa[num[i]]=x;\n      dfs(num[i]);\n      \n      for (int a=K;a;--a)\n        for (int b=1;b&lt;=a;++b)\n          f[x][a]=max(f[x][a],f[x][a-b]+f[num[i]][b]+(LL)(-b+2)*cost[i]);\n    }\n}\n\nint main()\n{\n  read(N); read(S); read(K);\n  for (int i=1;i&lt;N;++i)\n  {\n    int x,y,z;\n    read(x); read(y); read(z); sum+=z;\n    addedge(x,y,z); addedge(y,x,z);\n  }\n  \n  sum=sum+sum;\n  dfs(S);\n  \n  LL ans=oo; ans=ans*ans;\n  for (int i=0;i&lt;=K;++i) ans=min(ans,sum-f[S][i]);\n  \n  cout &lt;&lt; ans &lt;&lt; endl;\n  \n  return 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.Stack;\n\nclass canner {\n\n\tprivate InputStream is = System.in;\n\n\tpublic int nextInt() {\n\t\ttry {\n\t\t\tint i;\n\n\t\t\twhile ((i = is.read()) &lt; 45 || i &gt; 57) {\n\t\t\t}\n\n\t\t\tint mark = 1, temp = 0;\n\n\t\t\tif (i == 45) {\n\t\t\t\tmark = -1;\n\t\t\t\ti = is.read();\n\t\t\t}\n\n\t\t\twhile (i &gt; 47 &amp;&amp; i &lt; 58) {\n\t\t\t\ttemp = temp * 10 + i - 48;\n\t\t\t\ti = is.read();\n\t\t\t}\n\n\t\t\treturn temp * mark;\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\treturn -1;\n\t}\n}\n\npublic class Main {\n\n\tstatic class Edge {\n\t\tpublic int to;\n\t\tpublic int next;\n\t\tpublic int w;\n\t}\n\n\tprivate static int head[];\n\tprivate static Edge[] edge;\n\tprivate static int top;\n\tprivate static int dp[][];\n\tstatic int k;\n\tstatic boolean[] flag;\n\n\tpublic static void main(String[] args) {\n\t\tcanner sc = new canner();\n\t\tint n = sc.nextInt();\n\t\tint s = sc.nextInt();\n\t\tk = sc.nextInt();\n\t\tinit(n);\n\t\tdp = new int[n + 1][k + 1];\n\t\tfor (int i = 1; i &lt; n; i++) {\n\t\t\tint a = sc.nextInt();\n\t\t\tint b = sc.nextInt();\n\t\t\tint c = sc.nextInt();\n\t\t\taddEdge(a, b, c);\n\t\t\taddEdge(b, a, c);\n\t\t}\n\t\tdfs(s);\n\t\tSystem.out.println(dp[s][k]);\n\t}\n\n\tprivate static void dfs(int root) {\n\t\tStack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();\n\t\tint temp = root;\n\t\tstack.push(root);\n\t\tflag[root] = true;\n\t\twhile (!stack.isEmpty()) {\n\t\t\troot = stack.peek();\n\t\t\tint num = find(root);\n\n\t\t\tif (num == -1) {\n\t\t\t\tstack.pop();\n\t\t\t\tif (!stack.isEmpty()) {\n\t\t\t\t\tint peek = stack.peek();\n\t\t\t\t\tint to = root;\n\t\t\t\t\tint w = find2(root, peek);\n\t\t\t\t\tfor (int j = k; j &gt;= 0; j--) {\n\t\t\t\t\t\tdp[peek][j] += dp[to][0] + 2 * w;\n\t\t\t\t\t\tfor (int l = 1; l &lt;= j; l++) {\n\t\t\t\t\t\t\tdp[peek][j] = Math.min(dp[peek][j], dp[peek][j - l]\n\t\t\t\t\t\t\t\t\t+ dp[to][l] + l * w);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tflag[num] = true;\n\t\t\t\tstack.push(num);\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tprivate static int find2(int root, int peek) {\n\t\tfor (int i = head[peek]; i != -1; i = edge[i].next) {\n\t\t\tif (edge[i].to == root)\n\t\t\t\treturn edge[i].w;\n\t\t}\n\t\treturn peek;\n\t}\n\n\tprivate static int find(int root) {\n\t\tint num = -1;\n\t\tfor (int i = head[root]; i != -1; i = edge[i].next) {\n\t\t\tif (flag[edge[i].to])\n\t\t\t\tcontinue;\n\t\t\tnum = edge[i].to;\n\t\t\tbreak;\n\t\t}\n\t\treturn num;\n\t}\n\n\tprivate static void addEdge(int to, int next, int w) {\n\t\tedge[top] = new Edge();\n\t\tedge[top].to = next;\n\t\tedge[top].w = w;\n\t\tedge[top].next = head[to];\n\t\thead[to] = top++;\n\t}\n\n\tprivate static void init(int n) {\n\t\tflag = new boolean[n + 1];\n\t\tint size = (n - 1) * 2;\n\t\tedge = new Edge[size];\n\t\thead = new int[size];\n\t\ttop = 0;\n\t\tArrays.fill(head, -1);\n\t}\n}\n\r\n</textarea>	21
22	<div class="des"> \n <div class="sec_header">\n   问题描述\n </div> \n <div class="sec_cont"> \n  <p>农夫约翰正在针对一个新区域的牛奶配送合同进行研究。他打算分发牛奶到T个城镇（标号为1..T），这些城镇通过R条标号为（1..R）的道路和P条标号为（1..P）的航路相连。</p> \n  <p>每一条公路i或者航路i表示成连接城镇A<sub>i</sub>（1&lt;=A_i&lt;=T）和B<sub>i</sub>（1&lt;=B<sub>i</sub>&lt;=T）代价为C<sub>i</sub>。每一条公路，C<sub>i</sub>的范围为0&lt;=C<sub>i</sub>&lt;=10,000；由于奇怪的运营策略，每一条航路的C<sub>i</sub>可能为负的，也就是-10,000&lt;=C<sub>i</sub>&lt;=10,000。</p> \n  <p>每一条公路都是双向的，正向和反向的花费是一样的，都是非负的。</p> \n  <p>每一条航路都根据输入的A<sub>i</sub>和B<sub>i</sub>进行从A<sub>i</sub>-&gt;B<sub>i</sub>的单向通行。实际上，如果现在有一条航路是从A<sub>i</sub>到B<sub>i</sub>的话，那么意味着肯定没有通行方案从B<sub>i</sub>回到A<sub>i</sub>。</p> \n  <p>农夫约翰想把他那优良的牛奶从配送中心送到各个城镇，当然希望代价越小越好，你可以帮助他嘛？配送中心位于城镇S中（1&lt;=S&lt;=T）。</p> \n </div> \n <div class="sec_header">\n   输入格式\n </div> \n <div class="sec_cont"> \n  <p>输入的第一行包含四个用空格隔开的整数T，R，P，S。</p> \n  <p>接下来R行，描述公路信息，每行包含三个整数，分别表示A<sub>i</sub>，B<sub>i</sub>和C<sub>i</sub>。</p> \n  <p>接下来P行，描述航路信息，每行包含三个整数，分别表示A<sub>i</sub>，B<sub>i</sub>和C<sub>i</sub>。</p> \n </div> \n <div class="sec_header">\n   输出格式\n </div> \n <div class="sec_cont">\n   输出T行，分别表示从城镇S到每个城市的最小花费，如果到不了的话输出NO PATH。 \n </div> \n <div class="sec_header">\n   样例输入\n </div> \n <div class="sec_text">\n   6 3 3 4\n  <br> 1 2 5\n  <br> 3 4 5\n  <br> 5 6 10\n  <br> 3 5 -100\n  <br> 4 6 -100\n  <br> 1 3 -10 \n </div> \n <div class="sec_header">\n   样例输出\n </div> \n <div class="sec_text">\n   NO PATH\n  <br> NO PATH\n  <br> 5\n  <br> 0\n  <br> -95\n  <br> -100 \n </div> \n <div class="sec_header">\n   数据规模与约定\n </div> \n <div class="sec_cont"> \n  <p>对于20%的数据，T&lt;=100，R&lt;=500，P&lt;=500；</p> \n  <p>对于30%的数据，R&lt;=1000，R&lt;=10000，P&lt;=3000；</p> \n  <p>对于100%的数据，1&lt;=T&lt;=25000，1&lt;=R&lt;=50000，1&lt;=P&lt;=50000。</p> \n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint T , R , P , S , tol;\nint l,r;\nconst int MAXE = 200007;\nconst int MAXP = 50007;\nconst int INF = 2147483000;\nint lx[200007] , ne[200007] , vx[200007] , se[50007] , v[50007],q[50007];\nint Lx[2000007];\n\nvoid init()\n{\n\tint i;\n\tfor(i=1;i&lt;=T;i++) v[i] = INF;\n\tv[S] = 0;\n\ttol = 0;\n}\n\nvoid add_edge(int x,int y,int z){\n\ttol ++;\n\tlx[tol] = y;\n\tne[tol] = se[x];\n\tvx[tol] = z;\n\tse[x] = tol;\n}\n\nvoid spfa(int x)\n{\n\tint t = se[x];\n\tint V = v[x];\n\tint p;\n\twhile(t!=0){\n\t\tp = lx[t];\n\t\tif(v[p] &gt; V + vx[t]){\n\t\t\tv[p] = V + vx[t];\n\t\t\tif(l!=r &amp;&amp; v[p] &lt; v[Lx[l + 1]]){\n\t\t\t\t\tq[p] = 1;\n\t\t\t\t\tLx[l] = p;\n\t\t\t\t\tl--;\n\t\t\t}\n\t\t\tif(!q[p]){\n\t\t\t\tq[p] = 1;\n\t\t\t\tr++;\n\t\t\t\tLx[r] = p;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tt = ne[t];\n\t}\n\tq[x] = 0;\n}\n\nint main()\n{\n\tint x,y,z;\n\twhile(scanf("%d%d%d%d",&amp;T,&amp;R,&amp;P,&amp;S)!=EOF){\n\t\tinit();\n\t\tint i;\n \t\tfor(i=1;i&lt;=R;i++){\n\t\t\tscanf("%d%d%d",&amp;x,&amp;y,&amp;z);\n\t\t\tadd_edge(x,y,z);\n\t\t\tadd_edge(y,x,z);\n\t\t}\t\n\t\tfor(i=1;i&lt;=P;i++){\n\t\t\tscanf("%d%d%d",&amp;x,&amp;y,&amp;z);\n\t\t\tadd_edge(x,y,z);\n\t\t}\n\t\tl = 500000; r = 500001; Lx[500001] = S; q[S] = 1;\n\t\twhile(l&lt;r){\n\t\t\tl++;\n\t\t\twhile(l&lt;=r &amp;&amp;q[Lx[l]]==0) l++;\n\t\t\tif(l&gt;r) break;\n\t\t\tspfa(Lx[l]);\n\t\t}\n\t\tfor(i=1;i&lt;=T;i++) if(v[i] !=INF) printf("%d\\n",v[i]);\n\t\telse printf("NO PATH\\n");\n\t}\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n#include &lt;stack&gt;\n#include &lt;vector&gt;\n\n#define clr(a,b) memset(a, b, sizeof(a))\n\nusing namespace std;\n\nconst int N = 25050;\nconst int E = 150500;\n\n//邻接表\nint h[N], v[E], w[E], nxt[E], el;\nvoid initEdge() {\n    clr(h, -1); el = 0;\n}\nvoid addEdge(int x, int y, int z) {\n    v[el] = y; w[el] = z; nxt[el] = h[x]; h[x] = el++;\n}\n\n//belong[i] 表示节点 i 所在的强连通分量；\n//cnt 表示强连通分量的个数；\nint dfn[N], sta[N], low[N], belong[N];\nint top, cnt, ind, n;\nbool vis[N];\n\nvoid TarjanSolve(int u) {\n    dfn[u] = low[u] = ++ind;\n    vis[u] = true;\n    sta[++top] = u;\n    for(int p=h[u]; ~p; p=nxt[p]) {\n        int i = v[p];\n        if(!dfn[i]) {\n            TarjanSolve(i);\n            if(low[i] &lt; low[u]) low[u] = low[i];\n        }\n        else\n        if(vis[i] &amp;&amp; dfn[i] &lt; low[u])\n            low[u] = dfn[i];\n    }\n    if(dfn[u] == low[u]) {\n        ++cnt;\n        while(1) {\n            int i = sta[top--];\n            vis[i] = false;\n            belong[i] = cnt;\n            if(i == u) break;\n        }\n    }\n}\nvoid Tarjan() {//注意节点是从几开始存的\n    clr(dfn, 0);\n    clr(vis, 0);\n    top = cnt = ind = 0;\n    for(int i=1; i&lt;=n; i++)//这里节点从1开始存，若从0开始存要改这里\n        if(!dfn[i]) TarjanSolve(i);\n}\n\nstruct EDGE {\n    int u, v, w;\n    bool flag;\n    EDGE(){}\n    EDGE(int x, int y, int z, bool f):u(x), v(y), w(z), flag(f){}\n}   edge[E];\n\nint edgel;\n\nbool visitable[N];\n\nvoid dfs(int x) {\n    visitable[x] = true;\n    for(int i=h[x]; ~i; i=nxt[i]) {\n        if(!visitable[v[i]]) {\n            dfs(v[i]);\n        }\n    }\n}\n\nint indegree[N];\n\n//链表\nint lh[N], lel, lv[E], lnxt[E];\nvoid initLink() {\n    clr(lh, -1); lel = 0;\n}\nvoid addLink(int x, int y) {\n    lv[lel] = y; lnxt[lel] = lh[x]; lh[x] = lel++;\n}\n\nint dis[N];\nbool tag[N];\n\nint main() {\n    int r, p, s;\n    while(~scanf("%d%d%d%d", &amp;n, &amp;r, &amp;p, &amp;s)) {\n        clr(visitable, 0);\n        initEdge();\n        edgel = 0;\n        int x, y, z;\n        for(int i=0; i&lt;r; i++) {\n            scanf("%d%d%d", &amp;x, &amp;y, &amp;z);\n            addEdge(x, y, z);\n            addEdge(y, x, z);\n            edge[edgel++] = EDGE(x, y, z, false);\n        }\n        for(int i=0; i&lt;p; i++) {\n            scanf("%d%d%d", &amp;x, &amp;y, &amp;z);\n            addEdge(x, y, z);\n            edge[edgel++] = EDGE(x, y, z, true);\n        }\n        Tarjan();\n        dfs(s);\n        initEdge();\n        initLink();\n        clr(indegree, 0);\n        for(int i=0; i&lt;edgel; i++) {\n            if(visitable[edge[i].u] &amp;&amp; visitable[edge[i].v]) {\n                addEdge(edge[i].u, edge[i].v, edge[i].w);\n                if(edge[i].flag) {\n                    ++ indegree[belong[edge[i].v]];\n                    addLink(belong[edge[i].v], edge[i].v);\n                } else {\n                    addEdge(edge[i].v, edge[i].u, edge[i].w);\n                }\n            }\n        }\n        stack&lt;int&gt; zeroDegree;\n        priority_queue&lt;pair&lt;int,int&gt; &gt; que;\n        clr(vis, false);\n        clr(tag, false);\n        clr(dis, 0x3f);\n        dis[s] = 0;\n        que.push(make_pair(0, s));\n        while(!que.empty() || !zeroDegree.empty()) {\n            if(que.empty()) {\n                int x = zeroDegree.top(); zeroDegree.pop();\n                for(int i=lh[x]; ~i; i=lnxt[i]) {\n                    int y = lv[i];\n                    if(!vis[y]) {\n                        vis[y] = true;\n                        que.push(make_pair(-dis[y], y));\n                    }\n                }\n            } else {\n                int x = que.top().second; que.pop();\n                if(tag[x]) continue;\n                tag[x]  = true;\n                for(int i=h[x]; ~i; i=nxt[i]) {\n                    int y = v[i];\n                    if(!tag[y] &amp;&amp; dis[y] &gt; dis[x] + w[i]) {\n                        dis[y] = dis[x] + w[i];\n                        if(belong[x] == belong[y]) {\n                            que.push(make_pair(-dis[y], y));\n                        }\n                    }\n                    if(belong[x] != belong[y]) {\n                        -- indegree[belong[y]];\n                        if(indegree[belong[y]] == 0) {\n                            zeroDegree.push(belong[y]);\n                        }\n                    }\n                }\n            }\n        }\n        for(int i=1; i&lt;=n; i++) {\n            if(visitable[i]) {\n                printf("%d\\n", dis[i]);\n            } else {\n                puts("NO PATH");\n            }\n        }\n    }\n\n    return 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	22
23	<div class="des"> \n <div class="sec_header">\n   问题描述\n </div> \n <div class="sec_cont">\n   给定带权无向图，求出一颗方差最小的生成树。 \n </div> \n <div class="sec_header">\n   输入格式\n </div> \n <div class="sec_cont">\n   输入多组测试数据。第一行为N,M，依次是点数和边数。接下来M行，每行三个整数U,V,W，代表连接U,V的边，和权值W。保证图连通。n=m=0标志着测试文件的结束。 \n </div> \n <div class="sec_header">\n   输出格式\n </div> \n <div class="sec_cont">\n   对于每组数据，输出最小方差，四舍五入到0.01。输出格式按照样例。 \n </div> \n <div class="sec_header">\n   样例输入\n </div> \n <div class="sec_text">\n   4 5\n  <br> 1 2 1\n  <br> 2 3 2\n  <br> 3 4 2\n  <br> 4 1 1\n  <br> 2 4 3\n  <br> 4 6\n  <br> 1 2 1\n  <br> 2 3 2\n  <br> 3 4 3\n  <br> 4 1 1\n  <br> 2 4 3\n  <br> 1 3 3\n  <br> 0 0 \n </div> \n <div class="sec_header">\n   样例输出\n </div> \n <div class="sec_text">\n   Case 1: 0.22\n  <br> Case 2: 0.00 \n </div> \n <div class="sec_header">\n   数据规模与约定\n </div> \n <div class="sec_cont"> \n  <p>1&lt;=U,V&lt;=N&lt;=50,N-1&lt;=M&lt;=1000,0&lt;=W&lt;=50。数据不超过5组。</p> \n </div> \n</div>	<textarea id="codelinesc">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	<textarea id="codelinescpp">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	<textarea id="codelinesjava">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	23
24	<div class="des"> \n <div class="sec_header">\n   问题描述\n </div> \n <div class="sec_cont"> \n  <p>小张是软件项目经理，他带领3个开发组。工期紧，今天都在加班呢。为鼓舞士气，小张打算给每个组发一袋核桃（据传言能补脑）。他的要求是：</p> \n  <p>1. 各组的核桃数量必须相同</p> \n  <p>2. 各组内必须能平分核桃（当然是不能打碎的）</p> \n  <p>3. 尽量提供满足1,2条件的最小数量（节约闹革命嘛）</p> \n </div> \n <div class="sec_header">\n   输入格式\n </div> \n <div class="sec_cont">\n   输入包含三个正整数a, b, c，表示每个组正在加班的人数，用空格分开（a,b,c&lt;30） \n </div> \n <div class="sec_header">\n   输出格式\n </div> \n <div class="sec_cont">\n   输出一个正整数，表示每袋核桃的数量。 \n </div> \n <div class="sec_header">\n   样例输入1\n </div> \n <div class="sec_text">\n   2 4 5 \n </div> \n <div class="sec_header">\n   样例输出1\n </div> \n <div class="sec_text">\n   20 \n </div> \n <div class="sec_header">\n   样例输入2\n </div> \n <div class="sec_text">\n   3 1 1 \n </div> \n <div class="sec_header">\n   样例输出2\n </div> \n <div class="sec_text">\n   3 \n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n//最小公倍数\nint LCM(int num1,int num2,int num3)\n{\n\tint value=num1;\n\twhile(value%num1!=0||value%num2!=0||value%num3!=0)\n\t{\n\t\tvalue+=num1;\n\t}\n\treturn value;\n}\n\nint main()\n{\n\tint num1,num2,num3;\n\tscanf("%d%d%d",&amp;num1,&amp;num2,&amp;num3);\n\tprintf("%d\\n",LCM(num1,num2,num3));\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;stdio.h&gt;\n\nint main(int argc, char *argv[]) {\n    int a,b,c,i;\n    int all;\n    scanf("%d %d %d",&amp;a,&amp;b,&amp;c);\n    all=a*b*c;\n    for(i=1;i&lt;=all;i++)\n\t{\n\t\tif(i%a==0&amp;&amp;i%b==0&amp;&amp;i%c==0)\n\t\t{\n\t\t\tprintf("%d",i);\n\t\t\tbreak;\n\t\t}\n\t}\n    return 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\r\n\r\npublic class Main {\r\n\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tString str[] = br.readLine().split(" ");\r\n\r\n\t\tint[] arr = new int[3];\r\n\t\tfor (int a = 0; a &lt; arr.length; a++) {\r\n\t\t\tarr[a] = Integer.parseInt(str[a]);\r\n\t\t}\r\n\t\tfor (int a = 1; a &lt; 27000; a++) {\r\n\t\t\tif (a % arr[0] == 0 &amp;&amp; a % arr[1] == 0 &amp;&amp; a % arr[2] == 0) {\r\n\t\t\t\tSystem.out.print(a);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n</textarea>	24
25	<div class="des"> \n <div class="sec_header">\n   问题描述\n </div> \n <div class="sec_cont"> \n  <p> 小明为某机构设计了一个十字型的徽标（并非红十字会啊），如下所示：</p> \n  <div class="sec_text">\n    ..$$$$$$$$$$$$$..\n   <br> ..$...........$..\n   <br> $$$.$$$$$$$$$.$$$\n   <br> $...$.......$...$\n   <br> $.$$$.$$$$$.$$$.$\n   <br> $.$...$...$...$.$\n   <br> $.$.$$$.$.$$$.$.$\n   <br> $.$.$...$...$.$.$\n   <br> $.$.$.$$$$$.$.$.$\n   <br> $.$.$...$...$.$.$\n   <br> $.$.$$$.$.$$$.$.$\n   <br> $.$...$...$...$.$\n   <br> $.$$$.$$$$$.$$$.$\n   <br> $...$.......$...$\n   <br> $$$.$$$$$$$$$.$$$\n   <br> ..$...........$..\n   <br> ..$$$$$$$$$$$$$.. \n  </div> \n  <p> 对方同时也需要在电脑dos窗口中以字符的形式输出该标志，并能任意控制层数。</p> \n </div> \n <div class="sec_header">\n   输入格式\n </div> \n <div class="sec_cont">\n   一个正整数 n (n&lt;30) 表示要求打印图形的层数。 \n </div> \n <div class="sec_header">\n   输出格式\n </div> \n <div class="sec_cont">\n   对应包围层数的该标志。 \n </div> \n <div class="sec_header">\n   样例输入1\n </div> \n <div class="sec_text">\n   1 \n </div> \n <div class="sec_header">\n   样例输出1\n </div> \n <div class="sec_text">\n   ..$$$$$..\n  <br> ..$...$..\n  <br> $$$.$.$$$\n  <br> $...$...$\n  <br> $.$$$$$.$\n  <br> $...$...$\n  <br> $$$.$.$$$\n  <br> ..$...$..\n  <br> ..$$$$$.. \n </div> \n <div class="sec_header">\n   样例输入2\n </div> \n <div class="sec_text">\n   3 \n </div> \n <div class="sec_header">\n   样例输出2\n </div> \n <div class="sec_text">\n   ..$$$$$$$$$$$$$..\n  <br> ..$...........$..\n  <br> $$$.$$$$$$$$$.$$$\n  <br> $...$.......$...$\n  <br> $.$$$.$$$$$.$$$.$\n  <br> $.$...$...$...$.$\n  <br> $.$.$$$.$.$$$.$.$\n  <br> $.$.$...$...$.$.$\n  <br> $.$.$.$$$$$.$.$.$\n  <br> $.$.$...$...$.$.$\n  <br> $.$.$$$.$.$$$.$.$\n  <br> $.$...$...$...$.$\n  <br> $.$$$.$$$$$.$$$.$\n  <br> $...$.......$...$\n  <br> $$$.$$$$$$$$$.$$$\n  <br> ..$...........$..\n  <br> ..$$$$$$$$$$$$$.. \n </div> \n <div class="sec_header">\n   提示\n </div> \n <div class="sec_cont">\n   请仔细观察样例，尤其要注意句点的数量和输出位置。 \n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt; \n#include &lt;malloc.h&gt;\n#include &lt;string.h&gt;\nint main()  \n{\n\tint n,w,h,l,i,j,x,y,m;\n\tchar *arry;\n\tscanf("%d",&amp;n);\n\tw=h=5+n*4;\n\tarry=(char *)malloc(w*h);\n\tmemset(arry,'.',w*h);\n\t /*\n\tfor(i=n*2;i&lt;w-n*2;i++)//画基础图形 \n\t{\n\t\tarry[i+((n+1)*2)*w]='$';\n\t\tarry[i*w+(n+1)*2]='$';\n\t}*/\n\tfor(m=0;m&lt;=n;m++)//画没一层\n\t{\n\t\tfor(i=(m+1)*2;i&lt;w-(m+1)*2;i++)//四边 \n\t\t{\n\t\t\tx=m*2;\n\t\t\ty=i;\n\t\t\tarry[x+y*w]='$';\n\t\t\tx=w-m*2-1;\n\t\t\ty=i;\n\t\t\tarry[x+y*w]='$';\n\t\t\tx=i;\n\t\t\ty=m*2;\n\t\t\tarry[x+y*w]='$';\n\t\t\tx=i;\n\t\t\ty=w-m*2-1;\n\t\t\tarry[x+y*w]='$';\n\t\t}\n\t\tfor(i=m*2;i&lt;=(m+1)*2;i++)//角\n\t\t{\n\t\t\tx=i;\n\t\t\ty=(m+1)*2;\n\t\t\tarry[x+y*w]='$';\n\t\t\tx=(m+1)*2;\n\t\t\ty=i;\n\t\t\tarry[x+y*w]='$';\n\t\t\t\n\t\t\tx=w-i-1;\n\t\t\ty=(m+1)*2;\n\t\t\tarry[x+y*w]='$';\n\t\t\tx=w-(m+1)*2-1;\n\t\t\ty=i;\n\t\t\tarry[x+y*w]='$';\n\t\t\t\n\t\t\tx=i;\n\t\t\ty=h-(m+1)*2-1;\n\t\t\tarry[x+y*w]='$';\n\t\t\tx=(m+1)*2;\n\t\t\ty=h-i-1;\n\t\t\tarry[x+y*w]='$';\n\t\t\t\n\t\t\tx=w-i-1;\n\t\t\ty=h-(m+1)*2-1;\n\t\t\tarry[x+y*w]='$';\n\t\t\tx=w-(m+1)*2-1;\n\t\t\ty=h-i-1;\n\t\t\tarry[x+y*w]='$';\n\t\t} \n\t} \n\tfor(i=0;i&lt;h;i++)\n\t{\n\t\tfor(j=0;j&lt;w;j++)\n\t\t{\n\t\t\tprintf("%c",arry[i*w+j]);\n\t\t}\n\t\tprintf("\\n");\n\t}\n    return 0;  \n}  \n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;stdio.h&gt; \n#include &lt;malloc.h&gt;\n#include &lt;string.h&gt;\nint main()  \n{\n\tint n,w,h,l,i,j,x,y,m;\n\tchar *arry;\n\tscanf("%d",&amp;n);\n\tw=h=5+n*4;\n\tarry=(char *)malloc(w*h);\n\tmemset(arry,'.',w*h);\n\t /*\n\tfor(i=n*2;i&lt;w-n*2;i++)//画基础图形 \n\t{\n\t\tarry[i+((n+1)*2)*w]='$';\n\t\tarry[i*w+(n+1)*2]='$';\n\t}*/\n\tfor(m=0;m&lt;=n;m++)//画没一层\n\t{\n\t\tfor(i=(m+1)*2;i&lt;w-(m+1)*2;i++)//四边 \n\t\t{\n\t\t\tx=m*2;\n\t\t\ty=i;\n\t\t\tarry[x+y*w]='$';\n\t\t\tx=w-m*2-1;\n\t\t\ty=i;\n\t\t\tarry[x+y*w]='$';\n\t\t\tx=i;\n\t\t\ty=m*2;\n\t\t\tarry[x+y*w]='$';\n\t\t\tx=i;\n\t\t\ty=w-m*2-1;\n\t\t\tarry[x+y*w]='$';\n\t\t}\n\t\tfor(i=m*2;i&lt;=(m+1)*2;i++)//角\n\t\t{\n\t\t\tx=i;\n\t\t\ty=(m+1)*2;\n\t\t\tarry[x+y*w]='$';\n\t\t\tx=(m+1)*2;\n\t\t\ty=i;\n\t\t\tarry[x+y*w]='$';\n\t\t\t\n\t\t\tx=w-i-1;\n\t\t\ty=(m+1)*2;\n\t\t\tarry[x+y*w]='$';\n\t\t\tx=w-(m+1)*2-1;\n\t\t\ty=i;\n\t\t\tarry[x+y*w]='$';\n\t\t\t\n\t\t\tx=i;\n\t\t\ty=h-(m+1)*2-1;\n\t\t\tarry[x+y*w]='$';\n\t\t\tx=(m+1)*2;\n\t\t\ty=h-i-1;\n\t\t\tarry[x+y*w]='$';\n\t\t\t\n\t\t\tx=w-i-1;\n\t\t\ty=h-(m+1)*2-1;\n\t\t\tarry[x+y*w]='$';\n\t\t\tx=w-(m+1)*2-1;\n\t\t\ty=h-i-1;\n\t\t\tarry[x+y*w]='$';\n\t\t} \n\t} \n\tfor(i=0;i&lt;h;i++)\n\t{\n\t\tfor(j=0;j&lt;w;j++)\n\t\t{\n\t\t\tprintf("%c",arry[i*w+j]);\n\t\t}\n\t\tprintf("\\n");\n\t}\n    return 0;  \n}  \n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n    public class Main{\n        public static void main(String[] args){\n        Scanner sc=new Scanner(System.in);  \n        fd(sc.nextInt()); \n}\n    \n    public static void fd(int n){\n        int len=5+4*n;\n        String a[][]=new String[len][len];\n        int b=len/2;\n        for(int i=0;i&lt;len;i++){\n            for(int j=0;j&lt;len;j++){\n                a[i][j]=".";\n            }}\n        for(int i=b-2;i&lt;b+2;i++){\n            a[i][b]="$";\n            a[b][i]="$";\n        }\n        for(int m=0;m&lt;n;m++){\n            for(int i=b-2-2*m;i&lt;(b+3+2*m);i++){\n                 a[b - (4+m*2)][i] = "$";  \n                 a[b + (4+m*2)][i] = "$";  \n                 a[i][b - (4+m*2)] = "$";  \n                 a[i][b + (4+m*2)] = "$";  \n            }   \n        }\n        for(int m=0;m&lt;n;m++){\n          for (int i = b - (3+m*2); i &lt;= b + 3+m*2; i++) {  \n              a[b - (2+m*2)][i] = "$";  \n              a[b + 2+m*2][i] = "$";  \n              a[i][b + 2+m*2] = "$";  \n              a[i][b - (2+m*2)]= "$";  \n          }  \n          a[b - (2+m*2)][b - (1+m*2)] = ".";  \n          a[b - (2+m*2)][b + 1+m*2] = ".";  \n          a[b + 2+m*2][b - (1+m*2)] = ".";  \n          a[b + 2+m*2][b + 1+m*2] = ".";  \n          a[b - (1+m*2)][b - (2+m*2)] = ".";  \n          a[b + 1+m*2][b - (2+m*2)] = ".";  \n          a[b - (1+m*2)][b + 2+m*2] = ".";  \n          a[b + 1+m*2][b + 2+m*2] = ".";  \n      }  \n        \n    \n         for (int i= 0; i &lt; len; i++) {  \n                for (int j = 0; j &lt; len; j++) {  \n                    System.out.print(a[i][j]);  \n                                            \n            }\n            System.out.println();\n        }\n    }\n    }\r\n</textarea>	25
26	<div class="des"> \n <div class="sec_header">\n   问题描述\n </div> \n <div class="sec_cont"> \n  <p>100 可以表示为带分数的形式：100 = 3 + 69258 / 714。</p> \n  <p>还可以表示为：100 = 82 + 3546 / 197。</p> \n  <p>注意特征：带分数中，数字1~9分别出现且只出现一次（不包含0）。</p> \n  <p>类似这样的带分数，100 有 11 种表示法。</p> \n </div> \n <div class="sec_header">\n   输入格式\n </div> \n <div class="sec_cont"> \n  <p>从标准输入读入一个正整数N (N&lt;1000*1000)</p> \n </div> \n <div class="sec_header">\n   输出格式\n </div> \n <div class="sec_cont"> \n  <p>程序输出该数字用数码1~9不重复不遗漏地组成带分数表示的全部种数。</p> \n  <p>注意：不要求输出每个表示，只统计有多少表示法！</p> \n </div> \n <div class="sec_header">\n   样例输入1\n </div> \n <div class="sec_text">\n   100 \n </div> \n <div class="sec_header">\n   样例输出1\n </div> \n <div class="sec_text">\n   11 \n </div> \n <div class="sec_header">\n   样例输入2\n </div> \n <div class="sec_text">\n   105 \n </div> \n <div class="sec_header">\n   样例输出2\n </div> \n <div class="sec_text">\n   6 \n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\ntypedef struct Interval\n{\n\tint pre;\n\tint rear;\n\tint satisfy;\n}Interval;\nInterval interval[7][5];\nint count=0;\n\n//初始化\nvoid Init()\n{\n\tint i,j;\n\tint value;\n\tfor(i=1;i&lt;7;i++)\n\t{\n\t\tvalue=i;\n\t\tfor(j=1;j&lt;5;j++)\n\t\t{\n\t\t\tinterval[i][j].pre=value++;\n\t\t\tinterval[i][j].rear=value;\n\t\t}\n\t}\n}\n\n//数组初始化为0\nvoid InitZero(int *sign)\n{\n\tint i;\n\tsign[0]=1;\n\tfor(i=1;i&lt;10;i++)\n\t{\n\t\tsign[i]=0;\n\t}\n}\n\n//将一个数的各个位上拆分，并在相应的位上赋值1\nint Split(int *sign,int value)\n{\n\tint index;\n\twhile(value)\n\t{\n\t\tindex=value%10;\n\t\tif(sign[index]==0) sign[index]=1;\n\t\telse return 1;\n\t\tvalue/=10;\n\t}\n\treturn 0;\n}\n\n//计算一个数的位数\nint CountBit(int value)\n{\n\tint n=0;\n\twhile(value)\n\t{\n\t\tn++;\n\t\tvalue/=10;\n\t}\n\treturn n;\n}\n\n//将一个整型数组转换成一个整数\nint CreateInteger(int *data,int n)\n{\n\tint i;\n\tint value=0;\n\tfor(i=0;i&lt;n;i++)\n\t{\n\t\tvalue=value*10+data[i];\n\t}\n\treturn value;\n}\n\n//检查是否每个数都用到\nint Check(int *sign)\n{\n\tint i;\n\tfor(i=1;i&lt;10;i++)\n\t{\n\t\tif(sign[i]==0) return 0;\n\t}\n\treturn 1;\n}\n\n//复制\nvoid Copy(int *sign,int *temp_sign)\n{\n\tint i;\n\tfor(i=0;i&lt;10;i++)\n\t{\n\t\ttemp_sign[i]=sign[i];\n\t}\n}\n//创建一个n位数的整数\nvoid CreateNBitNumber(int *sign,int *data,int n,int m,int value,int value3)\n{\n\tif(n==m)\n\t{\n\t\tint value1=CreateInteger(data,n);\n\t\tint value2=value1*value;\n\t\tint temp_sign[10];\n\t\tCopy(sign,temp_sign);\n\t\tif(!Split(temp_sign,value2) &amp;&amp; Check(temp_sign))\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\telse\n\t{\n\t\tint i;\n\t\tfor(i=1;i&lt;10;i++)\n\t\t{\n\t\t\tif(sign[i]==0)\n\t\t\t{\n\t\t\t\tsign[i]=1;\n\t\t\t\tdata[m]=i;\n\t\t\t\tCreateNBitNumber(sign,data,n,m+1,value,value3);\n\t\t\t\tsign[i]=0;\n\t\t\t}\n\t\t}\n\t}\n}\n\n//求出解\nvoid Create(int value)\n{\n\tint i,j;\n\tint sign[10];\n\tint result;\n\tint result_n;\n\tint n;\n\tfor(i=3;i&lt;value;i++)\n\t{\n\t\tInitZero(sign);\n\t\tif(Split(sign,i)) continue;\n\t\tresult=value-i;\n\t\tresult_n=CountBit(result);\n\t\tn=CountBit(i);\n\t\tfor(j=1;j&lt;5;j++)\n\t\t{\n\t\t\tif( ((interval[result_n][j].pre+j)==(9-n)) || ((interval[result_n][j].rear+j)==(9-n)))\n\t\t\t{\n\t\t\t\tint data[5];\n\t\t\t\tCreateNBitNumber(sign,data,j,0,result,i);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint value;\n\tscanf("%d",&amp;value);\n\tInit();\n\tCreate(value);\n\tprintf("%d\\n",count);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\r\n#include&lt;cstring&gt;\r\nusing namespace std;\r\n\r\nint N,ans,digit,flag,full[9];\r\n\r\nvoid div(int m)\r\n{\r\n   while(m)\r\n   {\r\n\t if(m%10!=0)\r\n     full[m%10-1]=1;\r\n\t m/=10;\r\n\t digit++;\r\n   }\r\n}\r\n\r\nbool check(int *f)\r\n{\r\n  int j;\r\n  for(j=0;j&lt;9;j++)\r\n\t  if(!f[j])\r\n\t\t  return false;\r\n  return true;\r\n}\r\n\r\nvoid  DFS(int a,int b,int c)\r\n{\r\n   digit=0;\r\n   flag=0;\r\n   div(a);\r\n   div(b);\r\n   div(c);\r\n   if(digit&gt;9){memset(full,0,sizeof(full));return ;}\r\n   if(check(full)){ans++;memset(full,0,sizeof(full));}\r\n   else memset(full,0,sizeof(full));\r\n   DFS(a,(c+1)*b/c,c+1);\r\n   return ;\r\n}\r\n\r\nint main()\r\n{\r\n\tint i;\r\n\twhile(cin&gt;&gt;N)\r\n\t{\r\n\t  ans=0;\r\n\t  memset(full,0,sizeof(full));\r\n\t  for(i=2;i&lt;N-1;i++)\r\n\t    DFS(i,N-i,1);\r\n\t  cout&lt;&lt;ans&lt;&lt;endl;\r\n\t}\r\n  return 0;\r\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\n/**\n * http://lx.lanqiao.org/problem.page?gpid=T26\n * Created by revintec on 14-5-5.\n */\npublic class Main{\n    static int getBits(int k){\n        int bits=0;\n        while(k&gt;0){\n            int a=k%10;k/=10;\n            if(a==0) return -1;\n            int b=1&lt;&lt;a;\n            if((bits&amp;b)!=0) return -1;\n            bits|=b;\n        }return bits;\n    }\n    static int getBits2(int b){\n        int lo=9;\n        for(int i=1;i&lt;1&lt;&lt;10;i&lt;&lt;=1)\n            if((b&amp;i)!=0) --lo;\n        return lo;\n    }\n    public static void main(String[] args){\n        // System.clearProperty("m.TEST");\n        Scanner sc=System.getProperty("m.TEST")==null?new Scanner(System.in):\n                new Scanner("999988");\n        int sx=sc.nextInt();\n        int[] ts={0,\n                10,\n                100,\n                1000,\n                10000,\n                100000,\n                1000000,\n                10000000,\n                100000000,\n                1000000000,\n        };\n        int so=0;\n        for(int a=1;a&lt;sx;++a){\n            int bits=getBits(a);\n            if(bits==-1) continue;\n            for(int b=1;;++b){\n                int bts=getBits(b);\n                if((bits&amp;bts)!=0) continue;\n                bts|=bits;\n                long c=b*(sx-a);\n                if(c&gt;=ts[getBits2(bts)]) break;\n                if((getBits((int)c)^bts)==1022)\n                    ++so;\n            }\n        }System.out.println(so);\n    }\n}\r\n</textarea>	26
27	<div class="des"> \n <div class="sec_header">\n   问题描述\n </div> \n <div class="sec_cont"> \n  <p>如下图所示，3 x 3 的格子中填写了一些整数。</p> \n  <div class="sec_text">\n    +--*--+--+\n   <br> |10* 1|52|\n   <br> +--****--+\n   <br> |20|30* 1|\n   <br> *******--+\n   <br> | 1| 2| 3|\n   <br> +--+--+--+ \n  </div> \n  <p>我们沿着图中的星号线剪开，得到两个部分，每个部分的数字和都是60。</p> \n  <p>本题的要求就是请你编程判定：对给定的m x n 的格子中的整数，是否可以分割为两个部分，使得这两个区域的数字和相等。</p> \n  <p>如果存在多种解答，请输出包含左上角格子的那个区域包含的格子的最小数目。 </p> \n  <p>如果无法分割，则输出 0。</p> \n </div> \n <div class="sec_header">\n   输入格式\n </div> \n <div class="sec_cont"> \n  <p>程序先读入两个整数 m n 用空格分割 (m,n&lt;10)。</p> \n  <p>表示表格的宽度和高度。</p> \n  <p>接下来是n行，每行m个正整数，用空格分开。每个整数不大于10000。</p> \n </div> \n <div class="sec_header">\n   输出格式\n </div> \n <div class="sec_cont">\n   输出一个整数，表示在所有解中，包含左上角的分割区可能包含的最小的格子数目。 \n </div> \n <div class="sec_header">\n   样例输入1\n </div> \n <div class="sec_text">\n   3 3\n  <br> 10 1 52\n  <br> 20 30 1\n  <br> 1 2 3 \n </div> \n <div class="sec_header">\n   样例输出1\n </div> \n <div class="sec_text">\n   3 \n </div> \n <div class="sec_header">\n   样例输入2\n </div> \n <div class="sec_text">\n   4 3\n  <br> 1 1 1 1\n  <br> 1 30 80 2\n  <br> 1 1 1 100 \n </div> \n <div class="sec_header">\n   样例输出2\n </div> \n <div class="sec_text">\n   10 \n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#define N 10\nint num[N][N];\nint tag[N][N] = {0};\nint m, n;\nint r = 100;\nint find(int i, int j, int t, int ntag[][N])\n{ \n    int count = 0;\n    if (i &lt; 0 || i &gt;= n || j &lt; 0 || j &gt;= m || ntag[i][j] == 1)\n        return 0; \n    ntag[i][j] = 1;\n    if (tag[i][j] != t)\n        return 0;\n    count++;\n    count += find(i - 1, j, t, ntag);\n    count += find(i + 1, j, t, ntag);\n    count += find(i, j - 1, t, ntag);\n    count += find(i, j + 1, t, ntag);\n    return count;\n}\n \nint isbad()\n{\n    int i, j, k = 0,ge2;\n    int t = tag[0][0];\n    int ntag1[N][N] = {0};\n    int ntag2[N][N] = {0};  \n    int ge1 = find(0, 0, t, ntag1);\n    for (i = 0; i &lt; n; i++)\n    {\n        for (j = 0; j &lt; m; j++)\n        {\n            if (tag[i][j] != t)\n            {\n                k = 1;\n                break;\n            }\n        }\n        if (k == 1)\n            break; \n    }\n    \n    if (i == n &amp;&amp; j == m)\n        return 0;\n     ge2 = find(i, j, tag[i][j], ntag2);\n\n    return ge1 + ge2 != m * n;\n}\nint bad(int i, int j)\n{\n   int b;\n\tif (i &lt; 0 || i &gt;= n || j &lt; 0 || j &gt;= m || tag[i][j] == 1)\n        return 1;\n        \n    tag[i][j] = 1; \n    b = isbad();  \n    tag[i][j] = 0;  \n    return b;\n}\n\nvoid go(int i, int j, int k, int count)\n{\n    \n    if (bad(i, j) || count &lt; num[i][j])\n        return;\n    k++;\n   \n    if (count == num[i][j])\n    {\n        if (r &gt; k)\n            r = k;\n        return; \n    }\n    \n  \n    tag[i][j] = 1;\n    count -= num[i][j];\n    go(i - 1, j, k, count); \n    go(i + 1, j, k, count);\n    go(i, j - 1, k, count); \n    go(i, j + 1, k, count);\n    tag[i][j] = 0;\n}\n\nint main()\n{\n    \n    int i, j;\n    int half = 0;\n\tscanf("%d %d", &amp;m, &amp;n);\n    for (i = 0; i &lt; n; i++)\n        for (j = 0; j &lt; m; j++)\n        {\n            scanf("%d", &amp;num[i][j]);\n \n            half += num[i][j];\n        }\n    \n \n    if (half % 2 == 0 &amp;&amp; half &gt;= num[0][0] * 2)\n    {\n       \n        half /= 2;\n        go(0, 0, 0, half);\n    }\n    \n    if (r == 100)\n        r = 0;\n    \n    printf("%d", r);\n\n    return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;cmath&gt;\n#include&lt;cstdlib&gt;\n#include&lt;algorithm&gt;\n#include&lt;iostream&gt;\n#include&lt;string&gt;\n#include&lt;queue&gt;\n\nusing namespace std;\n\nint a[15][15];\nint m,n;\nint mx,sum;\nint mi[][2]={{0,1},{0,-1},{1,0},{-1,0}};\n\nstruct ki{\n    int x,y;\n    int sum;\n    int tep;\n};\n\nvoid dfs(int x,int y,int s,int tep){\n    if(s&gt;sum/(2.0))\n        return ;\n    else if(s==sum/(2.0)){\n        if(tep&lt;mx)\n            mx=tep;\n   //     printf("s=%d\\n",s);\n    }\n    else{\n        for(int i=0;i&lt;4;i++){\n            int tx=x+mi[i][0];\n            int ty=y+mi[i][1];\n            if(tx&lt;0||ty&lt;0||tx&gt;=n||ty&gt;=m)\n                continue;\n            if(a[tx][ty]!=-1){\n                int tem=a[tx][ty];\n                a[tx][ty]=-1;\n            //    printf("tx=%d ty=%d s=%d tep=%d\\n",tx,ty,s,tep);\n                dfs(tx,ty,s+tem,tep+1);\n                a[tx][ty]=tem;\n            }\n        }\n    }\n}\n\nint main(){\n    while(cin&gt;&gt;m&gt;&gt;n){\n        sum=0;\n        for(int i=0;i&lt;n;i++)\n            for(int k=0;k&lt;m;k++){\n                scanf("%d",&amp;a[i][k]);\n                sum+=a[i][k];\n            }\n        mx=10000;\n        int tem=a[0][0];\n        a[0][0]=-1;\n        dfs(0,0,tem,1);\n        printf("%d\\n",mx==10000?0:mx);\n    }\n    return 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\n\nimport java.util.Scanner;\n\npublic class Main{\n\n\t\n\tstatic int sum,half,m,n;\n\tstatic int[][] map;\n\tstatic boolean[][] flag;\n\tstatic int count=100;\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc=new Scanner(System.in);\n\t\tn=sc.nextInt();\n\t\tm=sc.nextInt();\n\t\tmap=new int[m][n];\n\t\tflag=new boolean[m][n];\n\t\t\n\t\tfor(int i=0;i&lt;m;i++)\n\t\t\tfor(int j=0;j&lt;n;j++){\n\t\t\t\tmap[i][j]=sc.nextInt();\n\t\t\t\tsum+=map[i][j];\n\t\t\t}\n\t\t\n\t\tif(sum%2!=0)\n\t\t\tSystem.out.println(0);\n\t\telse{\n\t\t\thalf=sum/2;\n\t\t\tdfs(0,0,1,0);\n\t\t\tSystem.out.println(count==100?0:count);\n\t\t}\n\t\t\n\t}\n\n\tprivate static void dfs(int i, int j, int step,int s) {\n\t\tif(i&lt;0 || i&gt;=m || j&lt;0 || j&gt;=n ){\n\t\t\treturn;\n\t\t}\n\t\tif(flag[i][j]==true)\n\t\t\treturn;\n\t\tif(s&gt;half){\n\t\t\tflag[i][j]=false;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\telse{\n\t\t\ts+=map[i][j];\n\t\t\tflag[i][j]=true;\n\t\t\tif(s==half){\n\t\t\t\tif(step&lt;count)\n\t\t\t\t\tcount=step;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdfs(i+1,j,step+1,s);\n\t\t\t\tdfs(i,j+1,step+1,s);\n\t\t\t\tdfs(i-1,j,step+1,s);\n\t\t\t\tdfs(i,j-1,step+1,s);\n\t\t\t\tflag[i][j]=false;\n\t\t\t}\n\t\t\t\t\n\t\t}\n\t\t\n\t\t\n\t}\n\n}\n\r\n</textarea>	27
28	<div class="des"> \n <div class="sec_header">\n  问题描述\n </div> \n <div class="sec_cont"> \n  <p>某涉密单位下发了某种票据，并要在年终全部收回。</p> \n  <p>每张票据有唯一的ID号。全年所有票据的ID号是连续的，但ID的开始数码是随机选定的。</p> \n  <p>因为工作人员疏忽，在录入ID号的时候发生了一处错误，造成了某个ID断号，另外一个ID重号。</p> \n  <p>你的任务是通过编程，找出断号的ID和重号的ID。</p> \n  <p>假设断号不可能发生在最大和最小号。</p> \n </div> \n <div class="sec_header">\n  输入格式\n </div> \n <div class="sec_cont"> \n  <p>要求程序首先输入一个整数N(N&lt;100)表示后面数据行数。</p> \n  <p>接着读入N行数据。</p> \n  <p>每行数据长度不等，是用空格分开的若干个（不大于100个）正整数（不大于100000），请注意行内和行末可能有多余的空格，你的程序需要能处理这些空格。</p> \n  <p>每个整数代表一个ID号。</p> \n </div> \n <div class="sec_header">\n  输出格式\n </div> \n <div class="sec_cont"> \n  <p>要求程序输出1行，含两个整数m n，用空格分隔。</p> \n  <p>其中，m表示断号ID，n表示重号ID</p> \n </div> \n <div class="sec_header">\n  样例输入1\n </div> \n <div class="sec_text">\n  2\n  <br> 5 6 8 11 9 \n  <br> 10 12 9\n </div> \n <div class="sec_header">\n  样例输出1\n </div> \n <div class="sec_text">\n  7 9\n </div> \n <div class="sec_header">\n  样例输入2\n </div> \n <div class="sec_text">\n  6\n  <br> 164 178 108 109 180 155 141 159 104 182 179 118 137 184 115 124 125 129 168 196\n  <br> 172 189 127 107 112 192 103 131 133 169 158 \n  <br> 128 102 110 148 139 157 140 195 197\n  <br> 185 152 135 106 123 173 122 136 174 191 145 116 151 143 175 120 161 134 162 190\n  <br> 149 138 142 146 199 126 165 156 153 193 144 166 170 121 171 132 101 194 187 188\n  <br> 113 130 176 154 177 120 117 150 114 183 186 181 100 163 160 167 147 198 111 119\n </div> \n <div class="sec_header">\n  样例输出2\n </div> \n <div class="sec_text">\n  105 120\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;    \nint main()  \n{  \n    int a[10001]={0};\n    long m,min=100000,max=0,i,n;\n\tchar c;\n\tscanf("%d",&amp;n);\n\t\tfor(i=0;i&lt;n;i++)\n\t\t\twhile(1)\n\t\t\t{\n\t\t\tscanf("%ld",&amp;m);\n\t\t\tif(m&gt;max) max=m;\n\t\t\tif(m&lt;min) min=m;\n\t\t\ta[m]++;\n\t\t\tc=getchar();\n\t\t\tif(c!=' ') break;\n\t\t\t}\n\n\tfor(i=min;i&lt;=max;i++)\n\t{\n\t if(a[i]==0) printf("%ld ",i);\n\t if(a[i]==2) m=i;\n\t}\n\t  printf("%ld",m);\n\t\n\treturn 0;\n}  \r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;cmath&gt;\n#include&lt;cstdlib&gt;\n#include&lt;algorithm&gt;\n#include&lt;iostream&gt;\n#include&lt;string&gt;\n\nusing namespace std;\n\nint a[100005];\n\nint main(){\n    int n;\n    while(cin&gt;&gt;n){\n        char c[1005];\n        int b[105],t=0;\n        memset(a,0,sizeof(a));\n        getchar();\n        while(n--){\n            gets(c);\n            int tc=strlen(c);\n            c[tc]=' ',c[tc+1]=0;\n            int tem=0;\n            for(int i=0;i&lt;=tc;i++){\n                if(c[i]!=' '){\n                    tem=tem*10+c[i]-'0';\n                }\n                else{\n                    a[tem]++;\n                    b[t++]=tem;\n                    tem=0;\n                }\n            }\n        }\n        int dh,ch;\n        sort(b,b+t);\n        for(int i=b[0];i&lt;b[t-1];i++)\n            if(a[i]==0)\n                dh=i;\n            else if(a[i]==2)\n                ch=i;\n        cout&lt;&lt;dh&lt;&lt;' '&lt;&lt;ch&lt;&lt;endl;\n    }\n    return 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tint duan = 0;\n\t\tint chong = 0;\n\t\tList&lt;Integer&gt; list = new ArrayList();\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = br.readLine();\n\t\tint len = Integer.parseInt(line);\n\t\tfor(int i = 0; i &lt; len; i++)\n\t\t{\n\t\t\tString l = br.readLine();\n\t\n\t\t\tString[] s = l.split(" ");\n\t\t\tfor(int j = 0; j &lt; s.length; j++)\n\t\t\t{\n\t\t\t\tlist.add(Integer.parseInt(s[j]));\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i &lt; list.size(); i++)\n\t\t{\n\t\t\tfor(int j = 0; j &lt; list.size(); j++)\n\t\t\t{\n\t\t\t\tint a = list.get(i);\n\t\t\t\tint b = list.get(j);\n\t\t\t\tint temp = 0;\n\t\t\t\tif(a &lt; b)\n\t\t\t\t{\n\t\t\t\t\ttemp = a;\n\t\t\t\t//\ta = b;\n\t\t\t\t//\tb = temp;\n\t\t\t\t\tlist.set(i, b);\n\t\t\t\t\tlist.set(j, temp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfor(int i = 0 ; i &lt; list.size() - 1; i++)\n\t\t{\n\t\t\t\tint a = list.get(i);\n\t\t\t\tint b = list.get(i + 1);\n\t\t\t\tif(a == b)\n\t\t\t\t\tchong = a;\n\t\t\t\tif(b - a &gt; 1)\n\t\t\t\t\tduan = b -1;\n\t\t}\n\t\tSystem.out.println(duan + " " + chong);\n\t}\n}\n\r\n</textarea>	28
29	<div class="des"> \n <div class="sec_header">\n   问题描述\n </div> \n <div class="sec_cont"> \n  <p>小明正在玩一个“翻硬币”的游戏。</p> \n  <p>桌上放着排成一排的若干硬币。我们用 * 表示正面，用 o 表示反面（是小写字母，不是零）。</p> \n  <p>比如，可能情形是：**oo***oooo</p> \n  <p>如果同时翻转左边的两个硬币，则变为：oooo***oooo</p> \n  <p>现在小明的问题是：如果已知了初始状态和要达到的目标状态，每次只能同时翻转相邻的两个硬币,那么对特定的局面，最少要翻动多少次呢？</p> \n  <p>我们约定：把翻动相邻的两个硬币叫做一步操作，那么要求： </p>\n </div> \n <div class="sec_header">\n   输入格式\n </div> \n <div class="sec_cont"> \n  <p>两行等长的字符串，分别表示初始状态和要达到的目标状态。每行的长度&lt;1000</p> \n </div> \n <div class="sec_header">\n   输出格式\n </div> \n <div class="sec_cont"> \n  <p>一个整数，表示最小操作步数。</p> \n </div> \n <div class="sec_header">\n   样例输入1\n </div> \n <div class="sec_text">\n   **********\n  <br> o****o****\n  <br> \n </div> \n <div class="sec_header">\n   样例输出1\n </div> \n <div class="sec_text">\n   5 \n </div> \n <div class="sec_header">\n   样例输入2\n </div> \n <div class="sec_text">\n   *o**o***o***\n  <br> *o***o**o***\n  <br> \n </div> \n <div class="sec_header">\n   样例输出2\n </div> \n <div class="sec_text">\n   1 \n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint turn(char a[], char b[])\n{\n\tint i;\n\tint n = 0;\n\tfor(i = 0;a[i]!='\\0';i++) \n\t{\n\t\tif(a[i] == b[i]) \n\t\t{\n\t\t\tcontinue;\n\t\t} \n\t\telse \n\t\t{\n\t\t\tb[i+1]=(b[i+1]=='*'?'o':'*');\n\t\t\tn++;\n\t\t}\n\t}\n\treturn n;\n}\nint main(void)\n{\n\tchar a[1000];\n\tchar b[1000];\n\tgets(a);\n\tgets(b);\n\tprintf("%d\\n", turn(a, b));\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\nusing namespace std;\nchar reverse(char c)\n{\n    if(c=='*')\n\t\tc='o';\n\telse\n\t\tc='*';\n\treturn c;\n}\nint main()\n{\n    char a[1000],b[1000];\n\tcin&gt;&gt;a&gt;&gt;b;\n\tint move=0;\n\tfor(int i=0;a[i]!='\\0';i++)\n\t{\n\t    if(a[i]!=b[i])\n\t\t{\n\t        a[i]=reverse(a[i]);\n\t        a[i+1]=reverse(a[i+1]);\n\t\t\tmove++;\n\t\t}\n\t}\n\tcout&lt;&lt;move&lt;&lt;endl;\n    return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\n\npublic class Main{\n   public static void main(String[] args)throws Exception {\n\t BufferedReader bu = new BufferedReader(\n\t\t\t new InputStreamReader(System.in));\n\t String s = bu.readLine();\n\t char[] c1 = s.toCharArray();\n\t s = bu.readLine();\n\t char[] c2 = s.toCharArray();\n\t int i = 0;\n\t int c = 0;\n\t boolean[] b = new boolean[c1.length];\n\t boolean x = false;\n\t while(!x){\n\t\t if(c1[i] == c2[i]){\n\t\t\t i++;\n\t\t\t b[i] =true;\n\t\t }else{\n\t\t\t if(i &lt; c1.length -1){\n\t\t\t\tc1[i] =  fz(c1[i]);\n\t\t\t\tc1[i+1] = fz(c1[i+1]);\n\t\t\t\tc++;\n\t\t\t\ti++;\n\t\t\t }\n\t\t\t \n\t\t }\n\t\t for(int i1 = 0;i1 &lt; b.length;i1++){\n\t\t\t if(b[i1] == true){\n\t\t\t\t x = true;\n\t\t\t } else{\n\t\t\t\t x = false;\n\t\t\t }\n\t\t }\n\t }\n\t System.out.println(c);\n\t \n}\n   public static char fz(char c ){\n\t   if(c == '*'){\n\t\t   return 'o';\n\t   }else{\n\t\t   return '*';\n\t   }\n\t   \n   }\n}\n\r\n</textarea>	29
30	<div class="des"> \n <div class="sec_header">\n   问题描述\n </div> \n <div class="sec_cont"> \n  <p>小明这些天一直在思考这样一个奇怪而有趣的问题：</p> \n  <p>在1~N的某个全排列中有多少个连号区间呢？这里所说的连号区间的定义是：</p> \n  <p>如果区间[L, R] 里的所有元素（即此排列的第L个到第R个元素）递增排序后能得到一个长度为R-L+1的“连续”数列，则称这个区间连号区间。</p> \n  <p>当N很小的时候，小明可以很快地算出答案，但是当N变大的时候，问题就不是那么简单了，现在小明需要你的帮助。</p> \n </div> \n <div class="sec_header">\n   输入格式\n </div> \n <div class="sec_cont"> \n  <p>第一行是一个正整数N (1 &lt;= N &lt;= 50000), 表示全排列的规模。</p> \n  <p>第二行是N个不同的数字Pi(1 &lt;= Pi &lt;= N)， 表示这N个数字的某一全排列。</p> \n </div> \n <div class="sec_header">\n   输出格式\n </div> \n <div class="sec_cont"> \n  <p>输出一个整数，表示不同连号区间的数目。</p> \n </div> \n <div class="sec_header">\n   样例输入1\n </div> \n <div class="sec_text">\n   4\n  <br> 3 2 4 1\n  <br> \n </div> \n <div class="sec_header">\n   样例输出1\n </div> \n <div class="sec_text">\n   7 \n </div> \n <div class="sec_header">\n   样例输入2\n </div> \n <div class="sec_text">\n   5\n  <br> 3 4 2 5 1\n  <br> \n </div> \n <div class="sec_header">\n   样例输出2\n </div> \n <div class="sec_text">\n   9 \n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n    int s[50005],a,i,min,max,count=0,j;\n    scanf("%d",&amp;a);\n    for( i = 0; i &lt; a; i++) {\n        scanf("%d",&amp;s[i]);\n    }\n    for( i = 0; i &lt;a;i++ ){ \n\t\tmin=s[i];\n\t\tmax=s[i];\n        for( j = i; j &lt;a; j++) {\n\t\t\tif(min&gt;s[j]){min =s[j];}\n\t\t\tif(max&lt;s[j]){max =s[j];}\n\t\t\tif((max-min)==(j-i)){\n\t\t\t\tcount++;\n\t\t\t}\n\n        }\n    }\n\tprintf("%d",count);\n    return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main()\n{\n\tint a[50010] , n ,sum = 0 , max , min ;\n\tscanf("%d",&amp;n) ;\n\tfor(int i = 0 ; i &lt; n ; ++i)\n\t{\n\t\tscanf("%d",&amp;a[i]) ;\n\t}\n\tfor(int i = 0 ; i &lt; n ; ++i)\n\t{\n\t\tmin = max =a[i] ;\n\t\tfor(int j = i ; j &lt; n ; ++j)\n\t\t{\n\t\t\tif(a[j]&gt;max)\n\t\t\t{\n\t\t\t\tmax = a[j];\n\t\t\t}\n\t\t\telse if(a[j]&lt;min)\n\t\t\t{\n\t\t\t\tmin = a[j];\n\t\t\t}\n\t\t\tif(max-min == j-i)\n\t\t\t{\n\t\t\t\t++sum ;\n\t\t\t}\n\t\t}\n\t}\n\tprintf("%d\\n",sum) ;\n\treturn 0 ;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\npublic class Main{\n\tpublic static void main(String[] args)throws IOException {\n\t\t//long start=System.currentTimeMillis();\n\t\tfun();\n\t\t//System.out.println("\\nTime:"+(System.currentTimeMillis()-start)+"ms");\n\t}\n\tpublic static void fun()throws IOException{\n\t\t//String filename="test.txt";\n\t\t//FileInputStream file=new FileInputStream(filename);\n\t\t//System.setIn(file);\n\t\tint[] a;\n\t\tStreamTokenizer st=new StreamTokenizer(new InputStreamReader(System.in));\n\t\tst.nextToken();\n\t\tint n=(int)st.nval;\n\t\ta=new int[n];\n\t\tfor(int i=0;i&lt;n;i++){\n\t\t\tst.nextToken();\n\t\t\ta[i]=(int)st.nval;\n\t\t}\n\t\tint min;\n\t\tint max;\n\t\tint num=0;\n\t\tfor(int l=0;l&lt;n;l++){\n\t\t\tmin=max=a[l];\n\t\t\tfor(int r=l;r&lt;n;r++){\n\t\t\t\tif(a[r]&lt;min)min=a[r];\n\t\t\t\tif(a[r]&gt;max)max=a[r];\n\t\t\t\t//\n\t\t\t\tif(max-min==r-l)\n\t\t\t\t\tnum++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.print(num);\n\t}\n\n}\r\n</textarea>	30
31	<div class="des"> \n <div class="sec_header">\n   问题描述\n </div> \n <div class="sec_cont"> \n  <p>小明开了一家糖果店。他别出心裁：把水果糖包成4颗一包和7颗一包的两种。糖果不能拆包卖。</p> \n  <p>小朋友来买糖的时候，他就用这两种包装来组合。当然有些糖果数目是无法组合出来的，比如要买 10 颗糖。</p> \n  <p>你可以用计算机测试一下，在这种包装情况下，最大不能买到的数量是17。大于17的任何数字都可以用4和7组合出来。</p> \n  <p>本题的要求就是在已知两个包装的数量时，求最大不能组合出的数字。</p> \n </div> \n <div class="sec_header">\n   输入格式\n </div> \n <div class="sec_cont"> \n  <p>两个正整数，表示每种包装中糖的颗数(都不多于1000)</p> \n </div> \n <div class="sec_header">\n   输出格式\n </div> \n <div class="sec_cont"> \n  <p>一个正整数，表示最大不能买到的糖数</p> \n </div> \n <div class="sec_header">\n   样例输入1\n </div> \n <div class="sec_text">\n   4 7\n  <br> \n </div> \n <div class="sec_header">\n   样例输出1\n </div> \n <div class="sec_text">\n   17 \n </div> \n <div class="sec_header">\n   样例输入2\n </div> \n <div class="sec_text">\n   3 5\n  <br> \n </div> \n <div class="sec_header">\n   样例输出2\n </div> \n <div class="sec_text">\n   7 \n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#define MAXSIZE 1000\nint main() {\n\tint flag[MAXSIZE] = {0};\n\tint maxunuse[MAXSIZE] = {0};\n\tint num1, num2, minNum, maxNum, temp, i, count = 0;\n\tscanf("%d%d", &amp;num1, &amp;num2);\n\tminNum = ((num1 &lt; num2) ? num1 : num2);\n\tmaxNum = num1 + num2 - minNum;\n\tfor(i = 1; ;i++){\n\t\ttemp = i * maxNum % minNum;\n\t\tif((temp) &amp;&amp; flag[temp] == 0){\n\t\t\tflag[temp] = 1;\n\t\t\tmaxunuse[temp] = i * maxNum -minNum;\n\t\t\tcount++;\n\t\t\tif(count == minNum - 1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tprintf("%d\\n", maxunuse[temp]);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n//2013第四届蓝桥杯全国软件大赛省级选拔赛C/C++A组第8题 \n//天农计算机系许晓华老师出品 \n#include&lt;iostream&gt;\nusing namespace std;\nint main() \n{\n\tint a,b;\n\tcin&gt;&gt;a&gt;&gt;b;\n\tcout&lt;&lt;a*b-a-b&lt;&lt;endl;\n       return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n \npublic class Main {\n    public static void main(String[] args) throws Throwable {\n        BufferedReader buf = new BufferedReader(\n                new InputStreamReader(System.in));\n         String strNum = buf.readLine();\n         String[] num = strNum.split(" ");\n         buf.close();\n         int a, b;\n         a = Integer.valueOf(num[0]);\n         b = Integer.valueOf(num[1]);\n        if (a &gt; b) {\n            int tem = a;\n            a = b;\n            b = tem;\n        }\n        int c = a * b;\n        int tem = c;\n        while (tem &gt; 0) {\n            if (tem % a == 0)\n                tem = --c;\n            else if (tem % b == 0)\n                tem = --c;\n            else\n                tem -= b;\n        }\n        System.out.println(c);\n    }\n \n}\r\n</textarea>	31
38	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　X国的一段古城墙的顶端可以看成 2*N个格子组成的矩形（如下图所示），现需要把这些格子刷上保护漆。\n  <br> \n  <br> \n  <img src="/RequireFile.do?fid=HLt96rLF" width="439" height="234">\n  <br> 　　你可以从任意一个格子刷起，刷完一格，可以移动到和它相邻的格子（对角相邻也算数），但不能移动到较远的格子（因为油漆未干不能踩！）\n  <br> 　　比如：a d b c e f 就是合格的刷漆顺序。\n  <br> 　　c e f d a b 是另一种合适的方案。\n  <br> 　　当已知 N 时，求总的方案数。当N较大时，结果会迅速增大，请把结果对 1000000007 (十亿零七) 取模。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入数据为一个正整数（不大于1000）\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出数据为一个正整数。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  2\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  24\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  96\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  22\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  359635897\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;  \nlong long a[1001],b[1001],sum;  \n#define NUM 1000000007 \nint main()  \n{  \n    int i,n;  \n    scanf("%d",&amp;n);  \n    b[1]=1;  \n    for (i=2;i&lt;=n;i++)  \n        b[i]=(b[i-1]*2%NUM);  \n    a[1]=1;a[2]=6;  \n    for (i=3;i&lt;=n;i++)  \n        a[i]=(2*a[i-1]+b[i]+4*a[i-2])%NUM;  \n    sum=4*a[n];  \n    for (i=2;i&lt;n;i++)  \n        sum=((sum+8*b[n-i]*a[i-1]%NUM)%NUM+(8*a[n-i]*b[i-1])%NUM)%NUM;  \n    printf("%I64d\\n",sum);  \n    return 0;  \n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;cstdio&gt;\n#define MAXN 1010\n#define MOD 1000000007\nint main()\n{\n\tlong long DP[5][MAXN],ans=2;\n\tint n;\n\tscanf("%d",&amp;n);\n\tif(n&gt;1){\n\t\tDP[0][2]=DP[2][2]=DP[3][2]=DP[4][2]=4;\n\t\tDP[1][2]=8;\n\t\tfor(int i=3;i&lt;=n;i++){\n\t\t\tDP[0][i]=(DP[0][i-1]*2+DP[1][i-1]*2)%MOD;\n\t\t\tDP[1][i]=(DP[1][i-1]*2+DP[2][i-1]*4+DP[3][i-1]*2+DP[4][i-1]*2)%MOD;\n\t\t\tDP[2][i]=DP[2][i-1]*2%MOD;\n\t\t\tDP[3][i]=DP[1][i-1];\n\t\t\tDP[4][i]=DP[1][i-1];\n\t\t}\n\t\tans=0;\n\t\tfor(int i=0;i&lt;5;i++)ans+=DP[i][n];\n\t\tans%=MOD;\n\t}\n\tprintf("%I64d\\n",ans);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tBufferedReader bfr = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n=Integer.parseInt(bfr.readLine());\n\t\tlong sum=0,mod=1000000007;\n\t\tlong[] A=new long[n+1];\n\t\tlong[] B=new long[n+1];\n\t\tA[1]=1; A[2]=2;\n\t\tB[1]=1; B[2]=6;\n\t\t\n\t\tint i,j;\n\t\tfor(i=3;i&lt;=n;i++)\n\t\t{\n\t\t\tA[i]=2*A[i-1]%mod;\n\t\t\tB[i]=(2*B[i-1]%mod+2*A[i-2]%mod+B[i-2]*2%mod+2*A[i-2]%mod+2*B[i-2]%mod)%mod;\n\t\t}\n\t\tsum=4*B[n]%mod;\n\t\tfor(j=2;j&lt;n;j++)\n\t\t{\n\t\t\tsum+=(2*(A[j-1]*2*B[n-j]*2%mod+2*A[n-j]*2*B[j-1]%mod));\n\t\t\tsum%=mod;\n\t\t}\n\t\tif(n&gt;1) System.out.println(sum);\n\t\telse System.out.println(2);\n\t}\n\n}\r\n</textarea>	38
32	<div class="des"> \n <div class="sec_header">\n   问题描述\n </div> \n <div class="sec_cont"> \n  <p>很久以前，T王国空前繁荣。为了更好地管理国家，王国修建了大量的快速路，用于连接首都和王国内的各大城市。</p> \n  <p>为节省经费，T国的大臣们经过思考，制定了一套优秀的修建方案，使得任何一个大城市都能从首都直接或者通过其他大城市间接到达。同时，如果不重复经过大城市，从首都到达每个大城市的方案都是唯一的。</p> \n  <p>J是T国重要大臣，他巡查于各大城市之间，体察民情。所以，从一个城市马不停蹄地到另一个城市成了J最常做的事情。他有一个钱袋，用于存放往来城市间的路费。</p> \n  <p>聪明的J发现，如果不在某个城市停下来修整，在连续行进过程中，他所花的路费与他已走过的距离有关，在走第x千米到第x+1千米这一千米中（x是整数），他花费的路费是x+10这么多。也就是说走1千米花费11，走2千米要花费23。</p> \n  <p>J大臣想知道：他从某一个城市出发，中间不休息，到达另一个城市，所有可能花费的路费中最多是多少呢？</p> \n </div> \n <div class="sec_header">\n   输入格式\n </div> \n <div class="sec_cont"> \n  <p>输入的第一行包含一个整数n，表示包括首都在内的T王国的城市数</p> \n  <p>城市从1开始依次编号，1号城市为首都。</p> \n  <p>接下来n-1行，描述T国的高速路（T国的高速路一定是n-1条）</p> \n  <p>每行三个整数Pi, Qi, Di，表示城市Pi和城市Qi之间有一条高速路，长度为Di千米。</p> \n </div> \n <div class="sec_header">\n   输出格式\n </div> \n <div class="sec_cont"> \n  <p>输出一个整数，表示大臣J最多花费的路费是多少。</p> \n </div> \n <div class="sec_header">\n   样例输入1\n </div> \n <div class="sec_text">\n   5\n  <br> 1 2 2\n  <br> 1 3 1\n  <br> 2 4 5\n  <br> 2 5 4\n  <br> \n </div> \n <div class="sec_header">\n   样例输出1\n </div> \n <div class="sec_text">\n   135 \n </div> \n <div class="sec_header">\n   输出格式\n </div> \n <div class="sec_cont"> \n  <p>大臣J从城市4到城市5要花费135的路费。</p> \n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\r\n#include &lt;string.h&gt;\r\n#include &lt;math.h&gt;\r\n#include &lt;stdlib.h&gt;\r\n\r\nstruct node;\r\ntypedef struct node Node;\r\ntypedef Node *PtrToNode;\r\ntypedef PtrToNode List;\r\ntypedef PtrToNode Position;\r\n\r\nstruct node\r\n{\r\nint n;\r\nint val;\r\nPosition next;\r\n};\r\n\r\nint count=0;\r\nint max=0;\r\nint x;\r\nint *visit; //是否已遍历\r\n\r\nPosition Last(List l); //找出最后项\r\nvoid Insert(int x,int q,List l,Position p); //在p后插入含x的项\r\nvoid Dfs(int a,List l[]); //深度优先搜索\r\nint Num(List l);\r\n\r\nint main(void)\r\n{\r\nint n,u,v,q,a,b;\r\nint i,j,k;\r\nNode *head;\r\nList *l,tmp;\r\nPosition p;\r\n\r\nfscanf(stdin,"%d",&amp;n);\r\nhead=(Node *)malloc(sizeof(Node)*(n+1));\r\nl=(List *)malloc(sizeof(List)*(n+1));\r\nvisit=(int *)malloc(sizeof(int)*(n+1));\r\n\r\nfor(i=0;i&lt;=n;i++) //初始化表头及链表\r\n{\r\nhead[i].next=NULL;\r\nl[i]=&amp;head[i];\r\n}\r\n\r\nfor(i=1;i&lt;=n-1;i++) //建立无向图\r\n{\r\nfscanf(stdin,"%d%d%d",&amp;u,&amp;v,&amp;q);\r\nInsert(v,q,l[u],Last(l[u]));\r\nInsert(u,q,l[v],Last(l[v]));\r\n}\r\n\r\nfor(j=1;j&lt;=n;j++)\r\nvisit[j]=0;\r\nDfs(1,l); //第一次遍历，找到点a，用全局变量x保存\r\n\r\nfor(j=1;j&lt;=n;j++)\r\nvisit[j]=0;\r\ncount=0;\r\nmax=0;\r\nDfs(x,l); //第二次遍历，找到点b，用全局变量x保存，此时max为最大距离\r\n\r\nprintf("%d",max*10+(max+1)*max/2);\r\n\r\nreturn 0;\r\n}\r\n\r\nPosition Last(List l)\r\n{\r\nPosition p;\r\nfor(p=l;p-&gt;next!=NULL;p=p-&gt;next);\r\nreturn p;\r\n}\r\n\r\nvoid Insert(int x,int q,List l,Position p)\r\n{\r\nPosition tmp;\r\ntmp=(Position) malloc(sizeof(Node));\r\n\r\ntmp-&gt;n=x;\r\ntmp-&gt;val=q;\r\ntmp-&gt;next=p-&gt;next;\r\np-&gt;next=tmp;\r\n}\r\n\r\nvoid Dfs(int a,List l[])\r\n{\r\nPosition p;\r\n\r\nvisit[a]=1;\r\nfor(p=l[a]-&gt;next;p!=NULL;p=p-&gt;next)\r\nif(!(visit[p-&gt;n]))\r\n{\r\ncount+=p-&gt;val;\r\nif(count&gt;max)\r\n{\r\nmax=count;\r\nx=p-&gt;n;\r\n}\r\n\r\nDfs(p-&gt;n,l);\r\ncount-=p-&gt;val;\r\n}\r\n}\r\n\r\nint Num(List l)\r\n{\r\nint n=0;\r\nPosition p;\r\nfor(p=l-&gt;next;p!=NULL;p=p-&gt;next)\r\nn++;\r\nreturn n;\r\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;cstdio&gt;\nusing namespace std;\n\nstruct edge\n{\n\t int Number;\n\t int Length;\n\t edge* next;\n\t edge(int number, int length)\n\t {\n\t\t Number = number;\n\t\t Length = length;\n\t\t next = NULL;\n\t }\n};\n\nstruct vert\n{\n\t int Number;\n\t int PathLen;\n\t bool Isvisit;\n\t edge* First;\n\t vert(int number)\n\t {\n\t\t Number = number;\n\t\t Isvisit = false;\n\t\t First = NULL;\n\t\t PathLen = 0;\n\t } \n};\nvoid dfs(vector&lt;vert&gt;&amp; GList, int num)\n{\n    edge*  p= GList[num].First;\n    GList[num].Isvisit = true;\n       for (; p!=NULL; p=p-&gt;next)\n\t\t{\n\t\t\tif(GList[p-&gt;Number].Isvisit == false)\n\t\t\t{    \n\t\t\t\tGList[p-&gt;Number].PathLen =GList[num].PathLen + p-&gt;Length;\n\t\t\t\tdfs(GList, p-&gt;Number);\n\t\t\t}\n\t\t}\n}\n\nint main()\n{\n\t vector&lt;vert&gt; GList;\n\n\t int n, i, j;\n\t int fir, sed, len;\n\t cin&gt;&gt;n;\n\t for (i=0; i&lt;=n; i++)\n\t {\n\t\t GList.push_back(vert(i));\n\t }\n\t for(j = 1; j &lt; n; j++)\n\t {\n\t\t edge* p1, *p2;\n\t\t scanf("%d%d%d",&amp;fir,&amp;sed,&amp;len);\n\n\t\t p1 = GList[fir].First;\n\t\t p2 = GList[sed].First;\n\t\t //无向图\n\t\t if (p1==NULL)\n\t\t {\n\t\t\tGList[fir].First = new edge(sed, len);\n\t\t }\n\t\t else\n\t\t {\n\t\t\t while(p1-&gt;next!=NULL) //将边链接到顶点\n\t\t\t {\n\t\t\t\t p1 = p1-&gt;next;\n\t\t\t } \n\t\t\t p1-&gt;next = new edge(sed, len);\n\t\t }\n\t\n\t\tif (p2==NULL)\n\t\t {\n\t\t\tGList[sed].First = new edge(fir, len);\n\t\t }\n\t\t else\n\t\t {\n\t\t\t while(p2-&gt;next!=NULL) //将边链接到顶点\n\t\t\t {\n\t\t\t\t p2 = p2-&gt;next;\n\t\t\t } \n\t\t\t p2-&gt;next = new edge(fir, len);\n\t\t }\n\t }\t\n\tint start, end, length = 0;\n\n\t\tdfs(GList, 1);\n\t\tfor (j = 1; j&lt;=n; j++)\n\t\t{\n\t\t\tif (GList[j].PathLen &gt; length)//更新最长距离\n\t\t\t{\n\t\t\t\tstart = i;\n\t\t\t\tend = j;\n\t\t\t\tlength = GList[j].PathLen;\n\t\t\t}\n\t\t\tGList[j].PathLen = 0;\n\t\t\tGList[j].Isvisit = false;\n\t\t}\n\t\tdfs(GList, end);\n\t\tfor (j = 1; j&lt;=n; j++)\n\t\t{\n\t\t\tif (GList[j].PathLen &gt; length)//更新最长距离\n\t\t\t{\n\t\t\t\tstart = i;\n\t\t\t\tend = j;\n\t\t\t\tlength = GList[j].PathLen;\n\t\t\t}\n\t\t\tGList[j].PathLen = 0;\n\t\t\tGList[j].Isvisit = false;\n\t\t}\n\tint cost = length*10;\n\n\tfor (i = 1; i &lt;= length; i++)\n\t{\n\t\tcost+=i;\n\t}\n\n\tcout&lt;&lt;cost&lt;&lt;endl;\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedInputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\n\npublic class Main\n{\n\tprivate static BufferedInputStream in = new BufferedInputStream(System.in);\n\tprivate static ArrayList&lt;Node&gt; n = new ArrayList&lt;Node&gt;();\n\tprivate static Integer dis = 0;\n\tprivate static Integer pow = 0;\n\t\n\tpublic static void main(String[] args) throws IOException\n\t{\n\t\tint size = readInt();\n\t\t\n\t\tfor(int i=0; i&lt;size; i++)\n\t\t{\n\t\t\tn.add(null);\n\t\t}\n\t\t\n\t\tfor(int i=1; i&lt;size; i++)\n\t\t{\n\t\t\tint x = readInt()-1;\n\t\t\tint y = readInt()-1;\n\t\t\tint d = readInt();\n\t\t\t\n\t\t\tNode node = new Node();\n\t\t\tnode.nextSide = n.get(x);\n\t\t\tnode.con = y;\n\t\t\tnode.power = d;\n\t\t\tn.set(x, node);\n\t\t\t\n\t\t\tnode = new Node();\n\t\t\tnode.nextSide = n.get(y);\n\t\t\tnode.con = x;\n\t\t\tnode.power = d;\n\t\t\tn.set(y, node);\n\t\t}\n\t\t\n\t\taway(0, 0, -1);\n\t\tpow = 0;\n\t\taway(dis, 0, -1);\n\t\tSystem.out.println(pow * 10 + (1 + pow) * pow /2);\n\t}\n\t\n\tprivate static void away(int index, int power, int from)\n\t{\n\t\tif(pow &lt; power)\n\t\t{\n\t\t\tpow = power;\n\t\t\tdis = index;\n\t\t}\n\t\t\n\t\tNode node = n.get(index);\n\t\t\n\t\twhile(node != null)\n\t\t{\n\t\t\tif(node.con == from)\n\t\t\t{\n\t\t\t\tnode = node.nextSide;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\taway(node.con, power + node.power, index);\n\t\t\t\n\t\t\tnode = node.nextSide;\n\t\t}\n\t}\n\t\n\tprivate static int readInt() throws IOException\n\t{\n\t\tint i,sum=0;\n\t\t\n\t\twhile(((i=in.read())&amp;48) != 48 || i&gt;57);\n\t\t\n\t\tfor(;(i&amp;56) == 48 || (i&amp;62) == 56; i=in.read())\n\t\t\tsum = sum*10 + (i&amp;15);\n\t\t\n\t\treturn sum;\n\t}\n\t\n\tprivate static class Node\n\t{\n\t\tint power;\n\t\tint con;\n\t\tNode nextSide;\n\t}\n}\n\r\n</textarea>	32
33	<div class="des"> \n <div class="sec_header">\n   问题描述\n </div> \n <div class="sec_cont"> \n  <p> 幸运数是波兰数学家乌拉姆命名的。它采用与生成素数类似的“筛法”生成</p>。 \n  <p> 首先从1开始写出自然数1,2,3,4,5,6,....</p> \n  <p> 1 就是第一个幸运数。</p> \n  <p> 我们从2这个数开始。把所有序号能被2整除的项删除，变为：</p> \n  <p> 1 _ 3 _ 5 _ 7 _ 9 ....</p> \n  <p> 把它们缩紧，重新记序，为：</p> \n  <p> 1 3 5 7 9 .... 。这时，3为第2个幸运数，然后把所有能被3整除的序号位置的数删去。注意，是序号位置，不是那个数本身能否被3整除!! 删除的应该是5，11, 17, ...</p> \n  <p> 此时7为第3个幸运数，然后再删去序号位置能被7整除的(19,39,...)</p> \n  <p> 最后剩下的序列类似：</p> \n  <p> 1, 3, 7, 9, 13, 15, 21, 25, 31, 33, 37, 43, 49, 51, 63, 67, 69, 73, 75, 79, ...</p> \n </div> \n <div class="sec_header">\n   输入格式\n </div> \n <div class="sec_cont">\n   输入两个正整数m n, 用空格分开 (m &lt; n &lt; 1000*1000) \n </div> \n <div class="sec_header">\n   输出格式\n </div> \n <div class="sec_cont">\n   程序输出 位于m和n之间的幸运数的个数（不包含m和n）。 \n </div> \n <div class="sec_header">\n   样例输入1\n </div> \n <div class="sec_text">\n   1 20 \n </div> \n <div class="sec_header">\n   样例输出1\n </div> \n <div class="sec_text">\n   5 \n </div> \n <div class="sec_header">\n   样例输入2\n </div> \n <div class="sec_text">\n   30 69 \n </div> \n <div class="sec_header">\n   样例输出2\n </div> \n <div class="sec_text">\n   8 \n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\r\n#define MAXN 1000010\r\nint flag[MAXN];\r\nint m,n,a[MAXN],s[MAXN],size=0;\r\nint fa(int k)\r\n{\r\n\tif(flag[k])\r\n\t\treturn a[k];\r\n\treturn fa(k-1);\r\n}\r\nint main()\r\n{\r\n\tint i, p, k, j;\r\n\tscanf("%d%d",&amp;m,&amp;n);\r\n\tfor(i=1;i&lt;=n;i+=2)\r\n\t{\r\n\t\ts[++size]=i; \r\n\t\tflag[i]=1; \r\n\t\ta[i]=size;\r\n\t}\r\n\tfor(i=2;i&lt;=size;i++)\r\n\t{\r\n\t\tint Mod=s[i],d=s[i]-1;\r\n\t\tif(Mod&gt;size)\r\n\t\t\tbreak;\r\n\t\tfor(p=1,j=Mod;j&lt;=size;j+=Mod,p++)\r\n\t\t{\r\n\t\t\tflag[s[j]]=0;\r\n\t\t\tfor(k=1;k&lt;Mod&amp;&amp;k+j&lt;=size;k++)\r\n\t\t\t{\r\n\t\t\t\ts[++d]=s[j+k];\r\n\t\t\t\ta[s[j+k]]-=p;\r\n\t\t\t}\r\n\t\t}\r\n\t\tsize=d;\r\n\t}\r\n\tprintf("%d\\n",fa(n-1)-fa(m));\r\n\treturn 0;\r\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;cstdio&gt;\nusing namespace std;\n\nint a[] = {1, 3, 7, 9, 13, 15, 21, 25, 31, 33, 37, 43, 49, 51, 63, 67, 69, 73, 75, 79, 87, 93, 99, 105, 111, 115, 127, 129, 133, 135, 141, 151, 159, 163, 169, 171, 189, 193, 195, 201, 205, 211, 219, 223, 231, 235, 237, 241, 259, 261, 267, 273, 283, 285, 289, 297, 303, 307, 319, 321, 327, 331, 339, 349, 357, 361, 367, 385, 391, 393, 399, 409, 415, 421, 427, 429, 433, 451, 463, 475, 477, 483, 487, 489, 495, 511, 517, 519, 529, 535, 537, 541, 553, 559, 577, 579, 583, 591, 601, 613, 615, 619, 621, 631, 639, 643, 645, 651, 655, 673, 679, 685, 693, 699, 717, 723, 727, 729, 735, 739, 741, 745, 769, 777, 781, 787, 801, 805, 819, 823, 831, 841, 855, 867, 873, 883, 885, 895, 897, 903, 925, 927, 931, 933, 937, 957, 961, 975, 979, 981, 991, 993, 997, 1009, 1011, 1021, 1023, 1029, 1039, 1041, 1053, 1057, 1087, 1093, 1095, 1101, 1105, 1107, 1117, 1123, 1147, 1155, 1167, 1179, 1183, 1189, 1197, 1201, 1203, 1209, 1219, 1231, 1233, 1245, 1249, 1251, 1261, 1263, 1275, 1281, 1285, 1291, 1303, 1309, 1323, 1329, 1339, 1357, 1365, 1369, 1387, 1389, 1395, 1401, 1417, 1419, 1435, 1441, 1455, 1459, 1471, 1473, 1485, 1491, 1495, 1497, 1501, 1503, 1519, 1533, 1543, 1545, 1563, 1567, 1575, 1579, 1585, 1587, 1597, 1599, 1611, 1639, 1641, 1645, 1659, 1663, 1675, 1693, 1701, 1705, 1711, 1723, 1731, 1737, 1749, 1765, 1767, 1771, 1773, 1777, 1797, 1801, 1809, 1819, 1827, 1831, 1833, 1839, 1857, 1869, 1879, 1893, 1899, 1915, 1921, 1923, 1933, 1941, 1945, 1959, 1963, 1965, 1977, 1983, 1987, 1995, 2001, 2019, 2023, 2031, 2053, 2059, 2065, 2067, 2079, 2083, 2085, 2095, 2113, 2115, 2121, 2125, 2127, 2133, 2163, 2173, 2187, 2209, 2211, 2215, 2217, 2221, 2239, 2251, 2253, 2257, 2271, 2277, 2281, 2283, 2301, 2311, 2317, 2323, 2335, 2343, 2355, 2365, 2379, 2395, 2403, 2407, 2409, 2415, 2419, 2427, 2439, 2445, 2461, 2467, 2473, 2479, 2491, 2493, 2505, 2511, 2523, 2527, 2545, 2557, 2563, 2571, 2575, 2587, 2589, 2593, 2599, 2607, 2625, 2635, 2647, 2649, 2653, 2661, 2667, 2671, 2689, 2697, 2715, 2725, 2755, 2763, 2773, 2781, 2785, 2787, 2797, 2815, 2817, 2821, 2823, 2827, 2835, 2841, 2845, 2851, 2877, 2887, 2899, 2901, 2905, 2913, 2923, 2943, 2953, 2961, 2971, 2973, 2977, 2983, 3003, 3007, 3027, 3031, 3037, 3039, 3049, 3055, 3073, 3075, 3091, 3097, 3099, 3109, 3111, 3121, 3123, 3133, 3153, 3163, 3171, 3175, 3183, 3187, 3199, 3213, 3223, 3229, 3235, 3243, 3259, 3261, 3289, 3297, 3301, 3307, 3313, 3325, 3339, 3351, 3355, 3363, 3381, 3403, 3405, 3409, 3411, 3427, 3433, 3439, 3451, 3453, 3465, 3477, 3481, 3487, 3489, 3495, 3499, 3507, 3559, 3565, 3571, 3579, 3595, 3597, 3603, 3607, 3613, 3621, 3625, 3633, 3655, 3661, 3663, 3669, 3675, 3685, 3687, 3697, 3709, 3717, 3721, 3727, 3747, 3753, 3763, 3771, 3781, 3789, 3793, 3795, 3811, 3843, 3847, 3849, 3865, 3873, 3879, 3889, 3891, 3897, 3909, 3915, 3931, 3943, 3951, 3955, 3969, 3975, 3981, 3991, 3999, 4003, 4015, 4023, 4033, 4035, 4041, 4045, 4063, 4069, 4081, 4095, 4105, 4107, 4129, 4131, 4161, 4165, 4173, 4179, 4189, 4195, 4201, 4203, 4207, 4227, 4237, 4251, 4255, 4257, 4263, 4269, 4285, 4287, 4315, 4321, 4329, 4335, 4363, 4377, 4383, 4389, 4399, 4413, 4431, 4441, 4443, 4455, 4461, 4465, 4483, 4485, 4495, 4509, 4519, 4521, 4539, 4551, 4561, 4567, 4569, 4573, 4587, 4609, 4611, 4621, 4623, 4629, 4645, 4647, 4653, 4663, 4671, 4675, 4695, 4699, 4713, 4717, 4725, 4741, 4761, 4767, 4773, 4797, 4801, 4809, 4813, 4819, 4833, 4837, 4839, 4843, 4851, 4863, 4867, 4881, 4887, 4893, 4929, 4951, 4963, 4965, 4969, 4977, 4987, 4989, 4993, 4999, 5001, 5007, 5019, 5029, 5041, 5043, 5049, 5053, 5089, 5103, 5127, 5137, 5139, 5149, 5151, 5157, 5169, 5179, 5181, 5191, 5211, 5217, 5229, 5233, 5235, 5253, 5259, 5277, 5283, 5293, 5295, 5299, 5325, 5335, 5341, 5343, 5371, 5377, 5379, 5385, 5409, 5419, 5427, 5433, 5449, 5455, 5463, 5473, 5487, 5491, 5503, 5515, 5527, 5547, 5551, 5559, 5569, 5577, 5587, 5589, 5593, 5599, 5613, 5617, 5637, 5641, 5649, 5655, 5661, 5671, 5673, 5679, 5691, 5701, 5707, 5713, 5719, 5737, 5755, 5763, 5767, 5769, 5803, 5809, 5817, 5827, 5833, 5839, 5851, 5869, 5883, 5889, 5893, 5901, 5905, 5911, 5913, 5923, 5959, 5965, 5967, 5971, 5973, 5977, 5991, 5997, 6009, 6019, 6031, 6049, 6055, 6061, 6079, 6093, 6111, 6115, 6123, 6141, 6147, 6159, 6163, 6175, 6177, 6195, 6211, 6229, 6237, 6243, 6249, 6253, 6271, 6273, 6279, 6301, 6309, 6331, 6345, 6351, 6355, 6363, 6367, 6369, 6373, 6379, 6385, 6399, 6411, 6415, 6427, 6433, 6435, 6447, 6463, 6471, 6475, 6477, 6501, 6505, 6523, 6531, 6535, 6541, 6553, 6559, 6567, 6573, 6601, 6621, 6625, 6631, 6661, 6663, 6667, 6669, 6679, 6687, 6693, 6715, 6723, 6733, 6741, 6745, 6747, 6753, 6757, 6763, 6765, 6783, 6787, 6789, 6841, 6849, 6867, 6871, 6883, 6891, 6909, 6915, 6921, 6931, 6933, 6937, 6951, 6981, 6985, 6999, 7003, 7009, 7035, 7041, 7045, 7047, 7069, 7077, 7081, 7087, 7101, 7111, 7129, 7135, 7153, 7167, 7171, 7173, 7183, 7191, 7195, 7197, 7207, 7215, 7231, 7233, 7237, 7245, 7249, 7279, 7293, 7299, 7311, 7321, 7333, 7339, 7341, 7345, 7357, 7359, 7371, 7377, 7395, 7401, 7405, 7419, 7435, 7437, 7443, 7447, 7459, 7471, 7489, 7501, 7503, 7507, 7531, 7533, 7549, 7551, 7563, 7567, 7575, 7585, 7591, 7593, 7603, 7609, 7629, 7633, 7639, 7645, 7677, 7687, 7689, 7701, 7711, 7717, 7737, 7755, 7779, 7791, 7795, 7801, 7803, 7813, 7827, 7833, 7837, 7855, 7881, 7885, 7897, 7899, 7909, 7917, 7921, 7929, 7939, 7947, 7951, 7963, 7969, 7971, 8001, 8005, 8007, 8013, 8037, 8047, 8071, 8073, 8085, 8089, 8107, 8109, 8127, 8131, 8139, 8151, 8161, 8169, 8173, 8175, 8191, 8193, 8221, 8223, 8227, 8233, 8253, 8257, 8263, 8269, 8283, 8289, 8299, 8325, 8331, 8347, 8359, 8365, 8367, 8379, 8409, 8413, 8421, 8445, 8449, 8467, 8473, 8475, 8479, 8487, 8493, 8515, 8535, 8539, 8551, 8553, 8575, 8577, 8583, 8589, 8601, 8605, 8611, 8617, 8635, 8637, 8641, 8647, 8655, 8661, 8673, 8683, 8719, 8757, 8769, 8773, 8787, 8793, 8805, 8809, 8827, 8829, 8833, 8835, 8841, 8869, 8871, 8895, 8913, 8931, 8937, 8947, 8955, 8961, 8977, 8979, 8989, 8995, 8997, 9009, 9031, 9033, 9061, 9063, 9073, 9075, 9081, 9085, 9115, 9117, 9121, 9123, 9135, 9139, 9145, 9151, 9177, 9181, 9211, 9213, 9223, 9231, 9235, 9249, 9253, 9267, 9273, 9277, 9285, 9291, 9303, 9315, 9331, 9339, 9349, 9373, 9387, 9399, 9403, 9409, 9421, 9423, 9429, 9441, 9451, 9457, 9471, 9475, 9481, 9483, 9487, 9501, 9535, 9537, 9543, 9547, 9549, 9555, 9561, 9567, 9613, 9621, 9625, 9631, 9643, 9649, 9661, 9663, 9675, 9687, 9691, 9703, 9727, 9733, 9751, 9753, 9775, 9787, 9789, 9795, 9801, 9807, 9811, 9813, 9837, 9841, 9883, 9895, 9915, 9927, 9937, 9957, 9961, 9979, 9985, 9987, 9997, 9999, 10003, 10009, 10017, 10041, 10051, 10059, 10069, 10071, 10083, 10087, 10089, 10095, 10111, 10117, 10125, 10131, 10143, 10147, 10149, 10153, 10173, 10191, 10195, 10197, 10221, 10239, 10255, 10261, 10275, 10279, 10291, 10311, 10315, 10317, 10321, 10341, 10363, 10365, 10387, 10399, 10411, 10417, 10431, 10441, 10443, 10459, 10461, 10471, 10501, 10507, 10509, 10525, 10531, 10533, 10555, 10563, 10569, 10575, 10585, 10587, 10597, 10599, 10605, 10609, 10635, 10651, 10653, 10659, 10671, 10683, 10723, 10725, 10731, 10747, 10753, 10755, 10759, 10773, 10785, 10789, 10797, 10809, 10843, 10849, 10873, 10881, 10891, 10903, 10909, 10911, 10921, 10923, 10945, 10953, 10965, 10975, 10977, 11005, 11011, 11017, 11047, 11055, 11059, 11073, 11077, 11089, 11091, 11097, 11113, 11137, 11157, 11163, 11173, 11181, 11193, 11197, 11205, 11217, 11223, 11227, 11239, 11245, 11247, 11259, 11263, 11269, 11283, 11289, 11301, 11323, 11341, 11343, 11371, 11373, 11377, 11389, 11391, 11395, 11407, 11419, 11425, 11427, 11437, 11439, 11475, 11479, 11487, 11491, 11521, 11529, 11535, 11539, 11541, 11577, 11581, 11583, 11599, 11617, 11623, 11629, 11641, 11643, 11659, 11667, 11677, 11679, 11707, 11721, 11725, 11731, 11769, 11781, 11797, 11803, 11811, 11815, 11823, 11827, 11833, 11835, 11845, 11847, 11853, 11865, 11877, 11887, 11911, 11923, 11929, 11943, 11953, 11959, 11961, 11991, 11995, 12007, 12015, 12025, 12049, 12057, 12063, 12069, 12079, 12097, 12103, 12117, 12121, 12133, 12139, 12141, 12151, 12159, 12163, 12165, 12193, 12201, 12207, 12223, 12237, 12243, 12265, 12267, 12285, 12295, 12301, 12307, 12315, 12319, 12321, 12333, 12337, 12357, 12363, 12373, 12379, 12391, 12399, 12411, 12417, 12427, 12435, 12457, 12481, 12487, 12495, 12499, 12519, 12543, 12547, 12553, 12567, 12579, 12589, 12607, 12609, 12621, 12631, 12645, 12649, 12651, 12673, 12679, 12699, 12709, 12711, 12729, 12735, 12741, 12759, 12763, 12777, 12781, 12799, 12801, 12813, 12819, 12861, 12867, 12877, 12885, 12903, 12907, 12925, 12937, 12951, 12957, 12961, 12969, 12991, 12999, 13009, 13011, 13021, 13027, 13029, 13053, 13057, 13063, 13077, 13083, 13113, 13117, 13119, 13125, 13129, 13135, 13141, 13167, 13177, 13179, 13203, 13209, 13215, 13219, 13243, 13245, 13267, 13273, 13279, 13281, 13285, 13293, 13309, 13317, 13323, 13327, 13335, 13345, 13347, 13359, 13363, 13371, 13387, 13419, 13441, 13443, 13465, 13473, 13485, 13489, 13513, 13515, 13519, 13527, 13531, 13533, 13537, 13551, 13567, 13575, 13581, 13587, 13599, 13609, 13633, 13657, 13677, 13681, 13693, 13695, 13707, 13723, 13725, 13737, 13741, 13743, 13759, 13801, 13803, 13821, 13831, 13833, 13849, 13851, 13861, 13873, 13893, 13897, 13929, 13947, 13953, 13957, 13995, 14007, 14017, 14031, 14035, 14037, 14041, 14049, 14053, 14059, 14073, 14079, 14091, 14095, 14113, 14115, 14119, 14137, 14163, 14179, 14181, 14185, 14199, 14205, 14209, 14211, 14217, 14229, 14245, 14247, 14253, 14281, 14287, 14293, 14307, 14313, 14317, 14331, 14347, 14349, 14353, 14367, 14395, 14407, 14419, 14427, 14437, 14439, 14443, 14449, 14457, 14461, 14473, 14491, 14493, 14505, 14521, 14523, 14539, 14541, 14565, 14587, 14595, 14599, 14601, 14607, 14625, 14661, 14667, 14689, 14691, 14713, 14715, 14721, 14731, 14749, 14751, 14755, 14775, 14779, 14785, 14793, 14797, 14817, 14841, 14875, 14881, 14883, 14899, 14905, 14919, 14923, 14931, 14935, 14943, 14947, 14973, 14977, 14997, 15003, 15007, 15009, 15025, 15031, 15049, 15057, 15063, 15069, 15073, 15081, 15103, 15109, 15121, 15129, 15133, 15141, 15165, 15169, 15175, 15183, 15187, 15189, 15193, 15205, 15213, 15217, 15229, 15231, 15235, 15237, 15247, 15255, 15259, 15261, 15271, 15291, 15301, 15313, 15333, 15355, 15379, 15381, 15385, 15397, 15417, 15445, 15457, 15469, 15471, 15481, 15487, 15489, 15511, 15519, 15523, 15531, 15543, 15547, 15567, 15573, 15577, 15585, 15597, 15609, 15645, 15655, 15661, 15673, 15675, 15693, 15697, 15717, 15735, 15763, 15771, 15783, 15793, 15805, 15817, 15819, 15835, 15843, 15847, 15855, 15879, 15883, 15891, 15901, 15907, 15919, 15927, 15939, 15955, 15969, 15975, 15981, 15993, 16003, 16009, 16023, 16045, 16047, 16053, 16057, 16077, 16081, 16095, 16101, 16135, 16153, 16191, 16195, 16197, 16203, 16213, 16227, 16237, 16245, 16255, 16267, 16275, 16279, 16287, 16297, 16309, 16329, 16333, 16341, 16353, 16359, 16365, 16381, 16387, 16389, 16393, 16395, 16413, 16417, 16429, 16431, 16447, 16449, 16467, 16473, 16479, 16491, 16507, 16521, 16539, 16557, 16573, 16591, 16611, 16615, 16617, 16621, 16635, 16639, 16657, 16665, 16677, 16701, 16707, 16725, 16747, 16765, 16771, 16773, 16791, 16795, 16825, 16827, 16845, 16863, 16867, 16893, 16915, 16917, 16921, 16933, 16939, 16947, 16953, 16957, 16959, 16969, 16971, 16981, 16995, 17001, 17011, 17017, 17019, 17035, 17047, 17053, 17061, 17083, 17085, 17103, 17115, 17119, 17125, 17127, 17151, 17157, 17173, 17181, 17209, 17211, 17215, 17221, 17223, 17229, 17251, 17253, 17283, 17287, 17305, 17313, 17329, 17335, 17341, 17355, 17359, 17367, 17389, 17391, 17401, 17409, 17431, 17433, 17455, 17463, 17467, 17473, 17485, 17497, 17517, 17527, 17535, 17545, 17547, 17563, 17565, 17581, 17589, 17619, 17625, 17671, 17677, 17689, 17695, 17703, 17713, 17725, 17733, 17737, 17749, 17767, 17769, 17775, 17781, 17787, 17797, 17811, 17829, 17851, 17875, 17883, 17893, 17913, 17925, 17935, 17943, 17947, 17965, 17977, 17991, 17997, 18001, 18007, 18019, 18025, 18043, 18049, 18055, 18067, 18085, 18087, 18123, 18127, 18145, 18147, 18151, 18153, 18169, 18175, 18181, 18187, 18189, 18195, 18207, 18211, 18237, 18253, 18261, 18279, 18283, 18285, 18295, 18303, 18315, 18333, 18375, 18381, 18397, 18399, 18403, 18409, 18441, 18445, 18451, 18459, 18465, 18469, 18475, 18493, 18495, 18501, 18513, 18523, 18535, 18543, 18589, 18591, 18597, 18615, 18619, 18621, 18633, 18639, 18655, 18661, 18681, 18693, 18715, 18717, 18723, 18745, 18747, 18757, 18759, 18765, 18775, 18777, 18783, 18787, 18817, 18819, 18825, 18837, 18849, 18853, 18871, 18873, 18879, 18915, 18937, 18943, 18951, 18967, 18969, 18975, 18979, 18987, 19009, 19015, 19017, 19033, 19051, 19081, 19113, 19119, 19125, 19131, 19153, 19155, 19159, 19161, 19173, 19195, 19197, 19207, 19225, 19237, 19261, 19263, 19269, 19285, 19309, 19323, 19327, 19329, 19333, 19341, 19347, 19351, 19357, 19363, 19365, 19371, 19389, 19395, 19405, 19411, 19417, 19435, 19455, 19467, 19477, 19479, 19503, 19521, 19533, 19543, 19551, 19579, 19581, 19603, 19609, 19615, 19627, 19629, 19657, 19659, 19687, 19693, 19705, 19707, 19711, 19719, 19723, 19725, 19731, 19735, 19755, 19767, 19771, 19773, 19783, 19791, 19807, 19825, 19851, 19861, 19869, 19875, 19893, 19917, 19921, 19929, 19939, 19963, 19981, 19993, 20005, 20013, 20017, 20043, 20067, 20071, 20077, 20085, 20089, 20101, 20103, 20121, 20133, 20149, 20151, 20169, 20181, 20185, 20197, 20203, 20215, 20227, 20253, 20257, 20271, 20295, 20307, 20319, 20341, 20349, 20353, 20355, 20359, 20371, 20379, 20385, 20397, 20403, 20425, 20445, 20449, 20455, 20461, 20475, 20485, 20487, 20509, 20511, 20539, 20551, 20563, 20581, 20583, 20587, 20605, 20611, 20613, 20649, 20665, 20679, 20697, 20713, 20731, 20733, 20739, 20757, 20763, 20769, 20773, 20793, 20797, 20805, 20811, 20821, 20823, 20833, 20835, 20839, 20845, 20859, 20875, 20887, 20889, 20899, 20905, 20923, 20937, 20941, 20953, 20959, 20965, 20991, 21013, 21015, 21021, 21027, 21043, 21049, 21051, 21055, 21073, 21075, 21111, 21115, 21129, 21139, 21147, 21153, 21169, 21175, 21177, 21189, 21193, 21199, 21205, 21211, 21223, 21231, 21253, 21255, 21307, 21309, 21315, 21327, 21331, 21337, 21345, 21373, 21381, 21405, 21409, 21411, 21421, 21433, 21445, 21451, 21453, 21469, 21471, 21475, 21499, 21505, 21529, 21531, 21537, 21549, 21567, 21571, 21591, 21597, 21609, 21613, 21615, 21621, 21655, 21663, 21687, 21693, 21703, 21709, 21717, 21721, 21735, 21739, 21751, 21757, 21759, 21771, 21787, 21819, 21841, 21847, 21867, 21885, 21891, 21897, 21913, 21915, 21925, 21927, 21931, 21933, 21957, 21967, 21987, 21993, 22009, 22017, 22035, 22039, 22075, 22087, 22093, 22095, 22099, 22113, 22119, 22125, 22147, 22155, 22165, 22167, 22177, 22185, 22197, 22225, 22227, 22231, 22269, 22281, 22305, 22327, 22333, 22339, 22369, 22371, 22377, 22381, 22399, 22401, 22411, 22417, 22431, 22437, 22461, 22471, 22473, 22479, 22503, 22507, 22521, 22525, 22527, 22533, 22555, 22569, 22585, 22587, 22591, 22597, 22603, 22617, 22627, 22629, 22651, 22683, 22687, 22689, 22701, 22711, 22743, 22779, 22789, 22791, 22795, 22807, 22827, 22839, 22843, 22851, 22855, 22869, 22879, 22881, 22885, 22893, 22911, 22921, 22941, 22947, 22953, 22957, 22965, 22969, 22975, 22981, 22987, 22999, 23007, 23031, 23037, 23041, 23061, 23067, 23083, 23089, 23095, 23101, 23109, 23137, 23145, 23163, 23169, 23173, 23191, 23193, 23199, 23205, 23269, 23271, 23293, 23295, 23311, 23323, 23341, 23343, 23353, 23355, 23361, 23365, 23373, 23377, 23397, 23419, 23421, 23427, 23445, 23449, 23451, 23457, 23469, 23479, 23499, 23515, 23523, 23529, 23533, 23551, 23563, 23565, 23569, 23571, 23577, 23607, 23613, 23649, 23671, 23677, 23689, 23701, 23709, 23721, 23767, 23775, 23781, 23799, 23805, 23815, 23829, 23835, 23851, 23857, 23881, 23889, 23893, 23913, 23919, 23925, 23929, 23943, 23953, 23955, 23961, 23965, 23971, 23973, 23991, 24013, 24015, 24025, 24033, 24037, 24069, 24073, 24117, 24121, 24129, 24133, 24145, 24151, 24181, 24183, 24213, 24217, 24237, 24247, 24255, 24261, 24277, 24285, 24289, 24301, 24309, 24321, 24327, 24331, 24333, 24343, 24363, 24381, 24387, 24397, 24403, 24405, 24423, 24429, 24447, 24451, 24481, 24499, 24523, 24531, 24571, 24573, 24585, 24591, 24603, 24619, 24633, 24637, 24639, 24643, 24645, 24649, 24663, 24669, 24709, 24711, 24727, 24729, 24733, 24739, 24741, 24759, 24763, 24771, 24783, 24789, 24805, 24811, 24829, 24831, 24843, 24855, 24865, 24873, 24877, 24895, 24907, 24909, 24933, 24951, 24957, 24963, 24985, 24991, 25015, 25017, 25021, 25033, 25057, 25063, 25095, 25099, 25107, 25117, 25119, 25129, 25147, 25153, 25159, 25167, 25171, 25185, 25189, 25201, 25213, 25215, 25225, 25237, 25255, 25263, 25285, 25287, 25293, 25309, 25317, 25335, 25341, 25347, 25377, 25389, 25413, 25425, 25431, 25441, 25455, 25461, 25477, 25483, 25489, 25497, 25503, 25525, 25549, 25561, 25567, 25569, 25581, 25591, 25593, 25611, 25621, 25623, 25645, 25647, 25657, 25671, 25677, 25687, 25737, 25753, 25759, 25771, 25773, 25803, 25815, 25819, 25821, 25833, 25837, 25845, 25855, 25861, 25875, 25893, 25909, 25917, 25923, 25929, 25939, 25959, 25963, 25971, 25977, 25987, 26005, 26007, 26011, 26025, 26035, 26041, 26071, 26085, 26103, 26107, 26115, 26119, 26149, 26155, 26167, 26169, 26179, 26209, 26215, 26217, 26221, 26229, 26251, 26263, 26281, 26293, 26295, 26301, 26313, 26319, 26343, 26347, 26359, 26365, 26385, 26397, 26409, 26413, 26431, 26445, 26467, 26505, 26523, 26529, 26533, 26547, 26553, 26565, 26595, 26599, 26617, 26629, 26641, 26649, 26655, 26659, 26665, 26683, 26695, 26697, 26703, 26719, 26721, 26727, 26733, 26749, 26755, 26757, 26781, 26797, 26805, 26841, 26845, 26847, 26881, 26883, 26893, 26905, 26907, 26913, 26923, 26925, 26935, 26943, 26997, 27001, 27007, 27009, 27013, 27027, 27031, 27033, 27037, 27039, 27061, 27063, 27075, 27079, 27091, 27093, 27097, 27105, 27141, 27157, 27189, 27195, 27199, 27201, 27205, 27207, 27217, 27237, 27265, 27271, 27283, 27301, 27309, 27315, 27321, 27325, 27331, 27333, 27349, 27357, 27363, 27387, 27393, 27409, 27415, 27417, 27427, 27435, 27453, 27457, 27469, 27475, 27477, 27483, 27489, 27493, 27501, 27511, 27531, 27541, 27561, 27585, 27595, 27597, 27603, 27639, 27663, 27667, 27691, 27693, 27705, 27711, 27741, 27751, 27757, 27765, 27783, 27793, 27805, 27807, 27813, 27829, 27831, 27847, 27855, 27859, 27871, 27879, 27913, 27915, 27951, 27961, 27963, 27975, 28021, 28023, 28027, 28039, 28069, 28071, 28083, 28087, 28089, 28101, 28105, 28119, 28123, 28129, 28131, 28141, 28161, 28167, 28191, 28195, 28203, 28233, 28239, 28245, 28293, 28311, 28321, 28329, 28339, 28351, 28359, 28365, 28375, 28393, 28405, 28417, 28429, 28435, 28437, 28459, 28467, 28483, 28509, 28513, 28525, 28563, 28569, 28581, 28593, 28605, 28633, 28639, 28677, 28689, 28701, 28707, 28735, 28759, 28765, 28771, 28791, 28797, 28801, 28803, 28815, 28825, 28827, 28837, 28843, 28855, 28857, 28867, 28869, 28887, 28891, 28905, 28921, 28923, 28933, 28951, 28963, 28969, 28987, 28989, 28993, 28995, 29005, 29025, 29031, 29035, 29049, 29055, 29065, 29089, 29091, 29095, 29113, 29121, 29127, 29137, 29143, 29149, 29157, 29175, 29185, 29193, 29203, 29205, 29239, 29253, 29281, 29283, 29287, 29295, 29311, 29317, 29319, 29329, 29341, 29349, 29371, 29391, 29413, 29437, 29451, 29457, 29467, 29473, 29485, 29487, 29493, 29497, 29515, 29517, 29521, 29533, 29535, 29563, 29577, 29589, 29595, 29599, 29611, 29613, 29623, 29625, 29653, 29659, 29661, 29665, 29677, 29689, 29697, 29709, 29715, 29721, 29751, 29757, 29779, 29781, 29787, 29791, 29805, 29815, 29829, 29845, 29847, 29851, 29865, 29877, 29893, 29905, 29913, 29925, 29949, 29959, 29971, 29973, 29989, 29995, 30013, 30021, 30061, 30067, 30073, 30075, 30087, 30103, 30115, 30121, 30159, 30163, 30181, 30207, 30225, 30229, 30231, 30241, 30243, 30253, 30261, 30265, 30273, 30289, 30291, 30303, 30313, 30327, 30337, 30367, 30369, 30373, 30387, 30397, 30409, 30411, 30429, 30439, 30465, 30471, 30475, 30477, 30495, 30499, 30505, 30523, 30529, 30537, 30541, 30543, 30547, 30559, 30565, 30567, 30589, 30601, 30643, 30651, 30681, 30687, 30727, 30747, 30753, 30765, 30775, 30777, 30789, 30793, 30807, 30817, 30837, 30849, 30861, 30871, 30873, 30877, 30885, 30901, 30915, 30919, 30943, 30945, 30949, 30969, 30997, 30999, 31003, 31021, 31029, 31033, 31039, 31051, 31069, 31071, 31081, 31093, 31095, 31107, 31135, 31137, 31143, 31147, 31189, 31191, 31207, 31221, 31231, 31237, 31239, 31249, 31251, 31255, 31261, 31263, 31293, 31303, 31311, 31315, 31335, 31341, 31363, 31381, 31383, 31387, 31389, 31395, 31405, 31411, 31425, 31429, 31437, 31449, 31453, 31489, 31491, 31515, 31531, 31545, 31573, 31611, 31617, 31633, 31639, 31641, 31681, 31699, 31701, 31713, 31723, 31737, 31755, 31765, 31773, 31789, 31801, 31807, 31815, 31839, 31849, 31863, 31869, 31879, 31887, 31893, 31903, 31927, 31945, 31953, 31965, 31971, 31975, 31977, 31989, 32005, 32011, 32013, 32019, 32041, 32053, 32055, 32077, 32079, 32097, 32101, 32115, 32119, 32121, 32133, 32145, 32173, 32179, 32197, 32223, 32229, 32245, 32247, 32265, 32269, 32271, 32277, 32287, 32311, 32325, 32329, 32373, 32385, 32391, 32397, 32403, 32407, 32419, 32433, 32455, 32457, 32467, 32481, 32509, 32533, 32539, 32545, 32563, 32571, 32577, 32593, 32595, 32605, 32607, 32613, 32635, 32637, 32641, 32643, 32665, 32683, 32713, 32727, 32731, 32745, 32761, 32769, 32775, 32793, 32803, 32827, 32829, 32833, 32845, 32853, 32865, 32869, 32875, 32889, 32917, 32919, 32923, 32937, 32961, 32973, 32985, 32997, 33019, 33021, 33027, 33033, 33045, 33067, 33079, 33091, 33105, 33109, 33117, 33121, 33141, 33151, 33153, 33169, 33181, 33183, 33189, 33205, 33211, 33217, 33237, 33247, 33249, 33273, 33289, 33297, 33309, 33313, 33327, 33333, 33337, 33349, 33363, 33375, 33379, 33381, 33411, 33423, 33433, 33435, 33439, 33445, 33463, 33465, 33475, 33495, 33525, 33537, 33541, 33549, 33561, 33567, 33595, 33601, 33603, 33615, 33633, 33645, 33657, 33673, 33687, 33705, 33717, 33721, 33757, 33769, 33781, 33805, 33813, 33835, 33837, 33843, 33855, 33861, 33885, 33895, 33897, 33907, 33909, 33925, 33943, 33949, 33961, 33973, 33979, 33987, 33991, 33993, 34003, 34005, 34021, 34027, 34053, 34065, 34093, 34099, 34105, 34107, 34113, 34125, 34129, 34131, 34161, 34171, 34183, 34191, 34197, 34201, 34209, 34213, 34233, 34257, 34261, 34281, 34293, 34305, 34321, 34323, 34357, 34359, 34365, 34377, 34387, 34399, 34401, 34423, 34435, 34449, 34453, 34461, 34473, 34485, 34491, 34497, 34503, 34507, 34513, 34557, 34569, 34573, 34599, 34603, 34617, 34621, 34623, 34639, 34641, 34653, 34687, 34713, 34717, 34719, 34723, 34725, 34737, 34755, 34761, 34767, 34777, 34785, 34807, 34809, 34813, 34821, 34873, 34875, 34885, 34887, 34891, 34909, 34915, 34917, 34951, 34957, 34965, 34971, 34995, 35011, 35035, 35041, 35061, 35071, 35077, 35091, 35103, 35113, 35127, 35137, 35145, 35155, 35167, 35169, 35175, 35197, 35203, 35205, 35221, 35223, 35233, 35287, 35301, 35317, 35329, 35331, 35343, 35349, 35391, 35395, 35409, 35413, 35419, 35421, 35427, 35443, 35449, 35451, 35457, 35461, 35481, 35485, 35511, 35539, 35547, 35557, 35563, 35577, 35587, 35601, 35607, 35611, 35625, 35643, 35673, 35683, 35701, 35703, 35707, 35709, 35713, 35721, 35743, 35799, 35817, 35833, 35847, 35859, 35871, 35881, 35913, 35917, 35919, 35941, 35943, 35959, 35965, 35973, 36003, 36025, 36037, 36039, 36043, 36051, 36067, 36085, 36087, 36099, 36115, 36129, 36135, 36147, 36151, 36165, 36169, 36175, 36187, 36205, 36213, 36231, 36249, 36255, 36261, 36273, 36277, 36297, 36309, 36319, 36325, 36331, 36351, 36361, 36373, 36375, 36381, 36405, 36415, 36417, 36423, 36427, 36429, 36451, 36469, 36481, 36487, 36499, 36501, 36513, 36529, 36541, 36547, 36549, 36561, 36573, 36583, 36603, 36609, 36613, 36615, 36619, 36633, 36669, 36673, 36675, 36679, 36681, 36687, 36691, 36715, 36721, 36733, 36741, 36759, 36763, 36805, 36823, 36825, 36829, 36837, 36855, 36877, 36891, 36897, 36903, 36907, 36943, 36955, 36963, 36987, 36993, 36997, 37011, 37015, 37023, 37047, 37051, 37069, 37075, 37077, 37081, 37087, 37089, 37095, 37117, 37129, 37161, 37185, 37195, 37203, 37215, 37219, 37239, 37255, 37263, 37267, 37279, 37285, 37287, 37317, 37339, 37345, 37365, 37371, 37383, 37389, 37393, 37395, 37435, 37437, 37447, 37455, 37467, 37491, 37495, 37507, 37509, 37521, 37527, 37531, 37533, 37549, 37569, 37585, 37597, 37599, 37621, 37635, 37663, 37683, 37689, 37695, 37705, 37723, 37729, 37737, 37747, 37749, 37753, 37789, 37801, 37809, 37813, 37815, 37833, 37845, 37851, 37855, 37893, 37905, 37909, 37939, 37941, 37957, 37959, 37963, 37969, 37989, 38001, 38031, 38035, 38037, 38041, 38059, 38067, 38097, 38119, 38121, 38131, 38145, 38149, 38167, 38185, 38209, 38221, 38245, 38247, 38265, 38271, 38305, 38307, 38313, 38319, 38325, 38341, 38353, 38355, 38389, 38391, 38397, 38401, 38409, 38421, 38433, 38439, 38455, 38461, 38467, 38473, 38481, 38503, 38527, 38535, 38559, 38563, 38581, 38599, 38611, 38623, 38625, 38629, 38653, 38661, 38685, 38695, 38707, 38713, 38731, 38737, 38749, 38751, 38757, 38769, 38775, 38779, 38787, 38791, 38797, 38799, 38811, 38815, 38821, 38839, 38851, 38853, 38871, 38875, 38913, 38917, 38923, 38925, 38943, 38949, 38967, 38985, 38989, 39007, 39043, 39045, 39061, 39067, 39073, 39093, 39115, 39123, 39135, 39139, 39159, 39171, 39177, 39193, 39235, 39249, 39265, 39271, 39283, 39285, 39295, 39301, 39315, 39321, 39345, 39355, 39361, 39367, 39387, 39411, 39417, 39441, 39451, 39463, 39475, 39481, 39507, 39513, 39553, 39567, 39571, 39573, 39579, 39585, 39589, 39607, 39609, 39615, 39627, 39633, 39637, 39643, 39649, 39673, 39693, 39705, 39711, 39721, 39733, 39741, 39753, 39769, 39783, 39795, 39801, 39825, 39831, 39837, 39841, 39849, 39861, 39865, 39883, 39889, 39891, 39903, 39909, 39931, 39945, 39955, 39957, 39967, 39979, 39987, 40005, 40029, 40041, 40059, 40069, 40083, 40101, 40117, 40141, 40147, 40153, 40161, 40165, 40167, 40195, 40197, 40201, 40207, 40215, 40225, 40231, 40249, 40257, 40273, 40287, 40309, 40321, 40323, 40333, 40335, 40351, 40353, 40369, 40389, 40393, 40399, 40405, 40407, 40447, 40449, 40453, 40455, 40459, 40471, 40477, 40479, 40515, 40521, 40555, 40561, 40593, 40597, 40603, 40609, 40665, 40671, 40701, 40707, 40713, 40729, 40743, 40747, 40753, 40761, 40765, 40767, 40797, 40803, 40815, 40825, 40831, 40837, 40849, 40855, 40861, 40879, 40911, 40921, 40923, 40929, 40933, 40963, 40981, 40983, 40993, 40999, 41013, 41023, 41025, 41029, 41043, 41055, 41089, 41101, 41107, 41119, 41121, 41151, 41161, 41181, 41185, 41191, 41235, 41245, 41247, 41277, 41281, 41287, 41295, 41307, 41313, 41319, 41331, 41341, 41349, 41365, 41373, 41383, 41395, 41401, 41421, 41425, 41439, 41463, 41469, 41475, 41485, 41503, 41527, 41529, 41539, 41541, 41551, 41563, 41595, 41613, 41631, 41635, 41653, 41655, 41667, 41677, 41691, 41697, 41707, 41715, 41721, 41727, 41731, 41743, 41779, 41781, 41791, 41793, 41799, 41803, 41805, 41823, 41845, 41847, 41853, 41869, 41905, 41925, 41937, 41943, 41947, 41949, 41961, 41989, 42003, 42009, 42025, 42033, 42051, 42055, 42063, 42073, 42091, 42109, 42117, 42129, 42153, 42163, 42169, 42189, 42193, 42201, 42211, 42231, 42235, 42243, 42279, 42303, 42309, 42361, 42367, 42373, 42381, 42391, 42403, 42405, 42421, 42435, 42447, 42451, 42469, 42471, 42495, 42499, 42511, 42517, 42525, 42547, 42555, 42559, 42561, 42567, 42577, 42591, 42609, 42619, 42625, 42643, 42651, 42657, 42661, 42663, 42675, 42693, 42705, 42715, 42727, 42739, 42751, 42759, 42781, 42789, 42813, 42829, 42847, 42849, 42853, 42865, 42873, 42883, 42885, 42895, 42903, 42907, 42913, 42933, 42949, 42955, 42967, 42975, 42979, 43015, 43021, 43029, 43035, 43039, 43071, 43077, 43129, 43135, 43159, 43167, 43185, 43191, 43201, 43207, 43209, 43225, 43227, 43231, 43233, 43239, 43251, 43255, 43269, 43285, 43303, 43315, 43329, 43333, 43345, 43347, 43381, 43407, 43413, 43419, 43423, 43429, 43441, 43443, 43459, 43461, 43479, 43483, 43491, 43495, 43507, 43513, 43515, 43519, 43533, 43543, 43545, 43549, 43557, 43579, 43597, 43621, 43633, 43639, 43669, 43681, 43695, 43711, 43729, 43735, 43743, 43747, 43771, 43789, 43797, 43815, 43819, 43831, 43833, 43839, 43857, 43863, 43873, 43879, 43891, 43899, 43923, 43933, 43953, 43957, 43965, 43975, 43977, 43981, 43983, 43995, 44007, 44023, 44025, 44037, 44049, 44059, 44109, 44145, 44149, 44155, 44163, 44175, 44187, 44197, 44229, 44239, 44241, 44259, 44293, 44295, 44311, 44313, 44319, 44341, 44353, 44355, 44361, 44383, 44385, 44389, 44395, 44401, 44415, 44419, 44421, 44451, 44485, 44487, 44499, 44503, 44511, 44515, 44541, 44545, 44547, 44551, 44563, 44571, 44595, 44625, 44635, 44637, 44641, 44649, 44655, 44659, 44673, 44691, 44697, 44703, 44721, 44731, 44751, 44761, 44775, 44805, 44863, 44869, 44889, 44893, 44911, 44923, 44929, 44931, 44953, 44955, 44961, 44983, 44995, 45013, 45051, 45057, 45069, 45081, 45109, 45111, 45121, 45133, 45139, 45145, 45159, 45171, 45175, 45181, 45183, 45201, 45235, 45241, 45267, 45271, 45277, 45279, 45303, 45307, 45327, 45331, 45343, 45349, 45351, 45363, 45373, 45375, 45381, 45393, 45403, 45429, 45435, 45459, 45469, 45489, 45507, 45519, 45529, 45535, 45541, 45555, 45591, 45603, 45613, 45619, 45621, 45625, 45681, 45685, 45709, 45717, 45721, 45723, 45739, 45745, 45763, 45769, 45789, 45801, 45811, 45813, 45831, 45843, 45877, 45897, 45907, 45919, 45927, 45939, 45951, 45957, 45973, 45975, 45981, 45991, 46015, 46021, 46023, 46027, 46035, 46065, 46069, 46087, 46095, 46101, 46129, 46131, 46137, 46141, 46167, 46195, 46201, 46203, 46213, 46221, 46227, 46231, 46243, 46245, 46255, 46257, 46263, 46279, 46309, 46311, 46327, 46329, 46339, 46341, 46369, 46377, 46389, 46399, 46401, 46405, 46461, 46465, 46497, 46503, 46519, 46527, 46531, 46543, 46549, 46557, 46587, 46599, 46629, 46641, 46651, 46653, 46671, 46683, 46687, 46695, 46705, 46707, 46713, 46717, 46735, 46737, 46749, 46755, 46759, 46791, 46795, 46797, 46801, 46813, 46815, 46839, 46845, 46855, 46861, 46875, 46879, 46887, 46915, 46923, 46939, 46947, 46951, 46965, 46987, 46999, 47001, 47005, 47029, 47047, 47065, 47071, 47073, 47103, 47107, 47109, 47115, 47125, 47127, 47155, 47157, 47167, 47179, 47193, 47221, 47229, 47233, 47235, 47265, 47271, 47281, 47287, 47313, 47319, 47329, 47335, 47349, 47361, 47379, 47383, 47385, 47419, 47421, 47425, 47427, 47439, 47443, 47449, 47461, 47463, 47487, 47505, 47523, 47565, 47571, 47575, 47581, 47607, 47611, 47613, 47629, 47631, 47665, 47677, 47683, 47697, 47703, 47715, 47727, 47739, 47743, 47745, 47757, 47775, 47799, 47823, 47833, 47841, 47847, 47865, 47889, 47895, 47901, 47911, 47913, 47923, 47947, 47949, 47959, 47965, 47989, 48007, 48015, 48019, 48027, 48049, 48061, 48069, 48081, 48091, 48099, 48103, 48115, 48117, 48133, 48135, 48157, 48177, 48187, 48195, 48205, 48229, 48231, 48243, 48249, 48259, 48279, 48307, 48343, 48345, 48351, 48355, 48369, 48373, 48375, 48385, 48399, 48415, 48439, 48447, 48451, 48481, 48499, 48501, 48535, 48541, 48559, 48583, 48585, 48615, 48639, 48645, 48657, 48669, 48679, 48681, 48687, 48691, 48703, 48721, 48729, 48741, 48751, 48753, 48777, 48799, 48817, 48831, 48837, 48847, 48849, 48879, 48895, 48897, 48913, 48919, 48921, 48925, 48943, 48955, 48961, 48963, 48967, 48999, 49015, 49021, 49045, 49059, 49081, 49099, 49101, 49111, 49113, 49119, 49123, 49141, 49147, 49149, 49155, 49165, 49203, 49207, 49209, 49213, 49219, 49249, 49275, 49279, 49309, 49315, 49329, 49341, 49359, 49363, 49371, 49375, 49377, 49395, 49399, 49435, 49437, 49447, 49471, 49479, 49489, 49497, 49503, 49507, 49525, 49527, 49561, 49563, 49567, 49585, 49615, 49617, 49623, 49627, 49633, 49635, 49675, 49681, 49689, 49713, 49717, 49719, 49723, 49731, 49743, 49753, 49759, 49779, 49795, 49807, 49819, 49821, 49825, 49833, 49839, 49845, 49855, 49857, 49863, 49869, 49917, 49921, 49927, 49959, 49971, 49981, 50001, 50007, 50023, 50025, 50053, 50059, 50085, 50095, 50101, 50109, 50119, 50139, 50151, 50161, 50169, 50179, 50181, 50203, 50217, 50227, 50247, 50257, 50275, 50287, 50317, 50319, 50323, 50325, 50341, 50367, 50371, 50383, 50407, 50415, 50421, 50431, 50445, 50449, 50463, 50469, 50499, 50517, 50527, 50529, 50551, 50559, 50563, 50575, 50595, 50599, 50625, 50631, 50637, 50643, 50653, 50673, 50677, 50685, 50695, 50697, 50719, 50725, 50739, 50751, 50757, 50763, 50767, 50779, 50845, 50871, 50877, 50887, 50889, 50893, 50905, 50907, 50917, 50929, 50935, 50937, 50983, 50991, 51001, 51009, 51013, 51019, 51039, 51067, 51073, 51085, 51093, 51099, 51105, 51127, 51135, 51139, 51141, 51157, 51159, 51163, 51165, 51169, 51187, 51189, 51207, 51229, 51253, 51255, 51271, 51283, 51289, 51303, 51319, 51325, 51349, 51355, 51379, 51393, 51397, 51399, 51411, 51417, 51421, 51453, 51459, 51475, 51543, 51547, 51549, 51559, 51567, 51571, 51579, 51583, 51597, 51601, 51603, 51609, 51649, 51651, 51673, 51675, 51681, 51703, 51729, 51733, 51747, 51753, 51759, 51777, 51793, 51835, 51837, 51855, 51859, 51861, 51865, 51871, 51903, 51913, 51921, 51937, 51955, 51963, 51979, 52039, 52041, 52045, 52059, 52063, 52071, 52081, 52083, 52089, 52101, 52113, 52149, 52165, 52167, 52179, 52185, 52189, 52219, 52227, 52243, 52249, 52251, 52261, 52275, 52279, 52281, 52291, 52321, 52327, 52339, 52353, 52357, 52365, 52369, 52387, 52425, 52429, 52437, 52441, 52449, 52465, 52467, 52479, 52485, 52491, 52503, 52531, 52545, 52549, 52555, 52567, 52573, 52575, 52611, 52617, 52621, 52627, 52635, 52641, 52659, 52671, 52677, 52683, 52689, 52701, 52719, 52731, 52737, 52753, 52755, 52765, 52785, 52807, 52831, 52845, 52849, 52857, 52861, 52863, 52867, 52879, 52887, 52891, 52903, 52921, 52935, 52951, 52953, 52957, 52963, 52975, 52993, 53005, 53053, 53059, 53067, 53079, 53113, 53145, 53155, 53205, 53235, 53239, 53241, 53245, 53265, 53271, 53287, 53301, 53305, 53307, 53319, 53323, 53329, 53341, 53343, 53361, 53385, 53391, 53407, 53409, 53455, 53457, 53467, 53473, 53475, 53491, 53493, 53499, 53517, 53521, 53533, 53557, 53559, 53563, 53575, 53581, 53593, 53595, 53619, 53623, 53629, 53659, 53697, 53701, 53719, 53745, 53749, 53751, 53773, 53781, 53811, 53815, 53817, 53823, 53827, 53839, 53851, 53865, 53871, 53875, 53881, 53901, 53907, 53941, 53949, 53953, 53971, 53991, 54001, 54007, 54043, 54063, 54069, 54075, 54087, 54103, 54129, 54133, 54141, 54147, 54153, 54163, 54169, 54189, 54223, 54229, 54231, 54247, 54259, 54265, 54273, 54277, 54279, 54285, 54309, 54319, 54327, 54339, 54369, 54373, 54403, 54423, 54445, 54447, 54463, 54465, 54469, 54475, 54481, 54483, 54487, 54517, 54525, 54537, 54543, 54547, 54583, 54589, 54591, 54603, 54621, 54625, 54627, 54637, 54645, 54655, 54673, 54687, 54717, 54721, 54729, 54733, 54735, 54747, 54753, 54777, 54781, 54783, 54801, 54819, 54823, 54841, 54853, 54855, 54879, 54909, 54915, 54921, 54939, 54943, 54949, 54961, 54991, 55005, 55009, 55023, 55029, 55033, 55035, 55045, 55047, 55053, 55063, 55075, 55087, 55093, 55095, 55107, 55129, 55131, 55141, 55159, 55167, 55179, 55191, 55195, 55197, 55219, 55237, 55243, 55255, 55281, 55293, 55303, 55317, 55335, 55351, 55369, 55377, 55387, 55423, 55425, 55477, 55485, 55489, 55503, 55507, 55509, 55515, 55539, 55555, 55569, 55573, 55603, 55609, 55617, 55621, 55633, 55639, 55641, 55665, 55671, 55681, 55693, 55705, 55707, 55713, 55729, 55735, 55741, 55747, 55765, 55801, 55803, 55809, 55819, 55825, 55831, 55863, 55867, 55869, 55885, 55903, 55911, 55929, 55935, 55951, 55953, 55975, 56011, 56029, 56059, 56071, 56077, 56083, 56085, 56091, 56103, 56115, 56119, 56125, 56139, 56181, 56185, 56187, 56203, 56205, 56209, 56251, 56263, 56265, 56269, 56271, 56275, 56283, 56289, 56307, 56311, 56313, 56323, 56347, 56359, 56377, 56385, 56397, 56409, 56437, 56439, 56449, 56461, 56463, 56469, 56479, 56497, 56499, 56517, 56523, 56527, 56533, 56535, 56547, 56563, 56565, 56589, 56637, 56649, 56661, 56673, 56679, 56685, 56703, 56721, 56725, 56731, 56751, 56755, 56775, 56779, 56787, 56797, 56799, 56817, 56839, 56841, 56847, 56869, 56895, 56899, 56931, 56935, 56943, 56955, 56959, 56989, 57021, 57025, 57027, 57045, 57049, 57061, 57081, 57109, 57111, 57115, 57145, 57153, 57217, 57225, 57229, 57241, 57249, 57259, 57267, 57277, 57291, 57301, 57303, 57309, 57313, 57333, 57343, 57345, 57355, 57361, 57397, 57405, 57417, 57429, 57441, 57489, 57499, 57505, 57507, 57523, 57525, 57541, 57561, 57591, 57603, 57607, 57613, 57619, 57625, 57633, 57657, 57667, 57679, 57687, 57691, 57699, 57715, 57717, 57729, 57739, 57757, 57777, 57801, 57805, 57819, 57823, 57825, 57841, 57877, 57879, 57889, 57897, 57907, 57945, 57949, 57951, 57967, 57997, 58003, 58009, 58011, 58023, 58047, 58059, 58075, 58077, 58087, 58117, 58135, 58137, 58159, 58161, 58171, 58183, 58197, 58203, 58227, 58233, 58237, 58243, 58261, 58263, 58287, 58311, 58317, 58323, 58327, 58339, 58351, 58383, 58387, 58389, 58393, 58417, 58423, 58435, 58443, 58447, 58455, 58465, 58467, 58479, 58507, 58509, 58519, 58527, 58549, 58557, 58561, 58605, 58615, 58635, 58639, 58641, 58645, 58663, 58687, 58689, 58695, 58699, 58701, 58719, 58737, 58741, 58753, 58779, 58785, 58795, 58815, 58833, 58845, 58849, 58851, 58867, 58875, 58893, 58897, 58905, 58915, 58969, 58971, 58977, 58989, 58999, 59005, 59019, 59037, 59041, 59043, 59055, 59079, 59083, 59095, 59097, 59125, 59127, 59143, 59145, 59149, 59191, 59233, 59235, 59245, 59257, 59263, 59271, 59283, 59287, 59325, 59329, 59353, 59383, 59391, 59401, 59409, 59413, 59439, 59443, 59445, 59457, 59473, 59479, 59481, 59503, 59517, 59521, 59535, 59547, 59581, 59583, 59587, 59599, 59601, 59605, 59631, 59635, 59649, 59653, 59661, 59665, 59695, 59697, 59707, 59725, 59727, 59737, 59739, 59745, 59761, 59791, 59803, 59823, 59863, 59865, 59871, 59893, 59913, 59917, 59919, 59923, 59943, 59997, 60001, 60007, 60031, 60043, 60045, 60051, 60055, 60061, 60063, 60075, 60085, 60105, 60109, 60117, 60133, 60145, 60147, 60151, 60157, 60175, 60177, 60187, 60217, 60219, 60229, 60231, 60259, 60301, 60307, 60313, 60325, 60337, 60339, 60355, 60369, 60385, 60403, 60433, 60465, 60469, 60483, 60489, 60505, 60513, 60529, 60531, 60535, 60547, 60555, 60559, 60567, 60589, 60595, 60613, 60615, 60619, 60631, 60637, 60639, 60655, 60657, 60675, 60705, 60711, 60745, 60747, 60757, 60763, 60783, 60787, 60801, 60817, 60825, 60843, 60861, 60867, 60889, 60891, 60895, 60909, 60913, 60921, 60925, 60927, 60937, 60955, 60973, 60975, 60993, 60997, 61015, 61017, 61057, 61069, 61077, 61089, 61101, 61119, 61123, 61131, 61153, 61155, 61165, 61173, 61183, 61189, 61197, 61207, 61237, 61243, 61257, 61269, 61299, 61305, 61309, 61329, 61335, 61363, 61377, 61383, 61393, 61399, 61405, 61425, 61437, 61455, 61477, 61503, 61513, 61525, 61551, 61557, 61563, 61581, 61585, 61597, 61615, 61617, 61635, 61663, 61683, 61687, 61699, 61707, 61719, 61723, 61773, 61785, 61791, 61809, 61813, 61825, 61833, 61857, 61875, 61881, 61911, 61915, 61917, 61935, 61953, 61971, 61977, 61999, 62005, 62017, 62025, 62037, 62047, 62067, 62071, 62077, 62079, 62097, 62107, 62109, 62143, 62149, 62151, 62155, 62163, 62167, 62173, 62191, 62193, 62197, 62215, 62227, 62245, 62265, 62287, 62293, 62295, 62299, 62323, 62349, 62359, 62379, 62403, 62421, 62425, 62449, 62467, 62475, 62485, 62499, 62503, 62509, 62517, 62527, 62529, 62533, 62547, 62551, 62583, 62605, 62607, 62613, 62623, 62625, 62629, 62635, 62643, 62659, 62671, 62673, 62701, 62719, 62721, 62733, 62769, 62781, 62797, 62803, 62811, 62815, 62817, 62821, 62863, 62877, 62907, 62911, 62919, 62923, 62929, 62941, 62943, 62961, 62979, 62983, 62985, 62991, 63025, 63033, 63037, 63063, 63069, 63085, 63087, 63111, 63115, 63127, 63133, 63151, 63163, 63171, 63177, 63181, 63193, 63195, 63219, 63223, 63231, 63243, 63255, 63265, 63267, 63283, 63303, 63307, 63319, 63321, 63325, 63339, 63379, 63387, 63409, 63411, 63447, 63457, 63471, 63475, 63483, 63487, 63489, 63495, 63505, 63535, 63547, 63549, 63553, 63583, 63609, 63613, 63637, 63645, 63651, 63661, 63681, 63699, 63703, 63727, 63729, 63741, 63747, 63763, 63765, 63777, 63781, 63789, 63801, 63829, 63835, 63843, 63855, 63865, 63889, 63895, 63903, 63915, 63925, 63945, 63957, 63997, 64015, 64021, 64023, 64039, 64051, 64059, 64071, 64123, 64137, 64147, 64159, 64179, 64185, 64189, 64197, 64203, 64207, 64209, 64213, 64221, 64239, 64251, 64267, 64275, 64327, 64329, 64333, 64345, 64347, 64357, 64369, 64375, 64377, 64387, 64435, 64441, 64449, 64455, 64495, 64497, 64501, 64503, 64521, 64533, 64537, 64545, 64561, 64575, 64579, 64597, 64599, 64609, 64623, 64629, 64647, 64659, 64671, 64705, 64711, 64723, 64785, 64789, 64801, 64813, 64819, 64831, 64833, 64837, 64843, 64851, 64857, 64861, 64881, 64891, 64897, 64903, 64905, 64921, 64923, 64933, 64959, 64963, 64969, 64977, 64995, 65025, 65029, 65037, 65049, 65091, 65101, 65109, 65121, 65125, 65143, 65145, 65163, 65173, 65175, 65187, 65197, 65217, 65235, 65241, 65259, 65281, 65289, 65299, 65341, 65343, 65353, 65367, 65385, 65397, 65427, 65431, 65439, 65457, 65479, 65481, 65493, 65499, 65503, 65521, 65529, 65551, 65553, 65563, 65595, 65599, 65629, 65653, 65661, 65671, 65677, 65683, 65691, 65695, 65713, 65725, 65739, 65745, 65755, 65757, 65779, 65793, 65797, 65803, 65815, 65839, 65857, 65865, 65881, 65883, 65901, 65907, 65913, 65935, 65941, 65977, 65985, 65991, 66003, 66031, 66037, 66039, 66049, 66055, 66057, 66061, 66069, 66073, 66103, 66109, 66123, 66141, 66159, 66163, 66171, 66187, 66193, 66201, 66219, 66235, 66247, 66249, 66255, 66259, 66261, 66267, 66291, 66297, 66325, 66339, 66349, 66355, 66369, 66387, 66427, 66433, 66445, 66447, 66469, 66477, 66489, 66495, 66517, 66529, 66543, 66549, 66553, 66559, 66561, 66565, 66573, 66577, 66579, 66607, 66613, 66637, 66657, 66661, 66667, 66669, 66675, 66699, 66703, 66705, 66723, 66729, 66739, 66747, 66781, 66811, 66823, 66829, 66865, 66873, 66897, 66907, 66915, 66921, 66939, 66943, 66957, 66975, 66985, 67003, 67011, 67015, 67017, 67023, 67057, 67063, 67065, 67075, 67105, 67107, 67117, 67125, 67129, 67131, 67143, 67159, 67189, 67195, 67207, 67209, 67225, 67231, 67243, 67245, 67275, 67285, 67287, 67293, 67329, 67333, 67335, 67339, 67351, 67359, 67417, 67419, 67425, 67443, 67447, 67453, 67473, 67477, 67485, 67503, 67569, 67573, 67579, 67581, 67587, 67591, 67599, 67605, 67641, 67671, 67693, 67695, 67711, 67725, 67731, 67755, 67759, 67791, 67797, 67803, 67837, 67839, 67851, 67861, 67873, 67875, 67887, 67899, 67903, 67915, 67917, 67923, 67927, 67929, 67947, 67963, 67965, 67993, 68025, 68029, 68031, 68043, 68047, 68053, 68061, 68065, 68077, 68085, 68095, 68107, 68113, 68115, 68145, 68181, 68187, 68209, 68217, 68221, 68241, 68253, 68293, 68299, 68313, 68335, 68355, 68365, 68377, 68385, 68397, 68407, 68409, 68425, 68439, 68449, 68461, 68463, 68467, 68469, 68497, 68511, 68527, 68529, 68535, 68547, 68557, 68559, 68577, 68589, 68593, 68595, 68599, 68607, 68643, 68653, 68661, 68671, 68683, 68691, 68755, 68767, 68769, 68779, 68799, 68803, 68809, 68811, 68827, 68829, 68845, 68865, 68869, 68875, 68883, 68895, 68913, 68925, 68929, 68931, 68947, 68965, 68989, 68991, 69009, 69015, 69027, 69033, 69039, 69051, 69073, 69099, 69115, 69117, 69123, 69135, 69141, 69153, 69163, 69165, 69195, 69205, 69219, 69225, 69229, 69237, 69243, 69259, 69271, 69291, 69301, 69309, 69333, 69343, 69367, 69373, 69385, 69393, 69397, 69417, 69435, 69439, 69441, 69451, 69481, 69495, 69511, 69513, 69519, 69523, 69535, 69543, 69565, 69577, 69583, 69595, 69615, 69625, 69627, 69637, 69645, 69649, 69679, 69681, 69687, 69703, 69709, 69723, 69727, 69729, 69747, 69757, 69775, 69787, 69789, 69793, 69817, 69819, 69825, 69841, 69871, 69891, 69919, 69921, 69939, 69951, 69985, 69999, 70035, 70063, 70071, 70077, 70081, 70089, 70105, 70107, 70125, 70131, 70165, 70173, 70207, 70215, 70219, 70227, 70261, 70267, 70269, 70287, 70299, 70317, 70333, 70351, 70353, 70357, 70359, 70371, 70405, 70417, 70423, 70435, 70447, 70449, 70455, 70459, 70465, 70471, 70485, 70501, 70509, 70519, 70539, 70545, 70573, 70591, 70597, 70623, 70635, 70639, 70657, 70665, 70669, 70671, 70677, 70699, 70701, 70707, 70717, 70741, 70755, 70761, 70765, 70773, 70783, 70791, 70795, 70803, 70813, 70815, 70845, 70849, 70857, 70867, 70875, 70899, 70923, 70945, 70983, 71005, 71017, 71025, 71037, 71047, 71049, 71055, 71073, 71089, 71101, 71115, 71157, 71161, 71169, 71173, 71179, 71191, 71199, 71215, 71221, 71223, 71235, 71239, 71275, 71277, 71283, 71305, 71329, 71341, 71347, 71359, 71371, 71379, 71403, 71421, 71431, 71433, 71445, 71455, 71479, 71493, 71517, 71535, 71539, 71547, 71557, 71569, 71577, 71593, 71599, 71601, 71617, 71619, 71623, 71631, 71641, 71673, 71679, 71697, 71725, 71739, 71743, 71749, 71769, 71793, 71803, 71821, 71829, 71833, 71869, 71871, 71899, 71929, 71931, 71949, 71953, 71959, 71989, 71991, 71997, 72001, 72019, 72021, 72025, 72055, 72061, 72075, 72123, 72127, 72135, 72139, 72141, 72151, 72157, 72171, 72183, 72187, 72211, 72223, 72235, 72243, 72249, 72265, 72273, 72277, 72303, 72313, 72327, 72333, 72379, 72391, 72393, 72403, 72411, 72439, 72459, 72463, 72493, 72495, 72499, 72501, 72519, 72535, 72565, 72577, 72585, 72589, 72591, 72601, 72607, 72609, 72649, 72663, 72669, 72687, 72693, 72715, 72727, 72735, 72751, 72753, 72765, 72787, 72799, 72819, 72865, 72891, 72895, 72897, 72903, 72907, 72921, 72939, 72955, 72975, 72979, 72985, 72991, 72997, 73003, 73009, 73017, 73021, 73023, 73053, 73065, 73081, 73087, 73101, 73113, 73117, 73131, 73149, 73155, 73165, 73177, 73179, 73185, 73197, 73213, 73221, 73227, 73231, 73249, 73273, 73291, 73305, 73335, 73341, 73363, 73377, 73387, 73405, 73417, 73419, 73431, 73441, 73449, 73461, 73465, 73467, 73473, 73495, 73537, 73543, 73569, 73585, 73587, 73617, 73627, 73629, 73633, 73639, 73669, 73671, 73677, 73683, 73717, 73723, 73731, 73735, 73777, 73785, 73809, 73821, 73843, 73851, 73873, 73899, 73911, 73915, 73933, 73935, 73969, 73977, 73995, 74013, 74031, 74035, 74041, 74049, 74059, 74071, 74101, 74103, 74109, 74121, 74139, 74143, 74155, 74161, 74175, 74187, 74193, 74197, 74199, 74221, 74227, 74257, 74259, 74289, 74293, 74307, 74311, 74325, 74329, 74331, 74347, 74349, 74353, 74355, 74385, 74391, 74415, 74425, 74433, 74439, 74445, 74449, 74455, 74457, 74487, 74497, 74503, 74509, 74515, 74541, 74559, 74571, 74577, 74581, 74583, 74595, 74613, 74635, 74643, 74647, 74697, 74701, 74721, 74733, 74739, 74749, 74761, 74767, 74773, 74787, 74793, 74797, 74815, 74817, 74857, 74859, 74865, 74869, 74893, 74895, 74907, 74911, 74913, 74919, 74941, 74955, 74959, 74973, 75019, 75025, 75055, 75067, 75099, 75103, 75111, 75117, 75147, 75163, 75181, 75193, 75195, 75201, 75211, 75213, 75223, 75229, 75247, 75255, 75265, 75271, 75289, 75297, 75307, 75319, 75357, 75391, 75399, 75421, 75433, 75435, 75441, 75475, 75481, 75483, 75505, 75511, 75517, 75525, 75529, 75537, 75549, 75561, 75567, 75583, 75585, 75589, 75591, 75603, 75625, 75631, 75637, 75645, 75655, 75675, 75679, 75693, 75709, 75717, 75733, 75735, 75741, 75759, 75781, 75789, 75793, 75799, 75823, 75825, 75835, 75841, 75853, 75859, 75867, 75873, 75885, 75895, 75901, 75925, 75937, 75945, 75967, 75985, 75991, 75993, 76015, 76029, 76045, 76065, 76077, 76083, 76089, 76105, 76107, 76113, 76125, 76129, 76149, 76179, 76183, 76189, 76203, 76209, 76219, 76233, 76239, 76275, 76303, 76317, 76339, 76341, 76357, 76359, 76371, 76381, 76393, 76405, 76423, 76455, 76461, 76473, 76497, 76503, 76525, 76533, 76551, 76555, 76567, 76587, 76609, 76615, 76617, 76623, 76633, 76639, 76663, 76671, 76705, 76713, 76717, 76735, 76737, 76749, 76759, 76779, 76783, 76785, 76797, 76801, 76803, 76831, 76849, 76851, 76873, 76885, 76893, 76905, 76939, 76947, 76969, 76975, 76989, 76995, 77001, 77017, 77037, 77053, 77061, 77065, 77091, 77115, 77127, 77137, 77149, 77167, 77209, 77211, 77217, 77223, 77245, 77253, 77263, 77269, 77275, 77281, 77289, 77293, 77301, 77307, 77353, 77355, 77365, 77377, 77379, 77395, 77397, 77407, 77431, 77457, 77473, 77481, 77503, 77505, 77515, 77521, 77527, 77533, 77553, 77565, 77577, 77599, 77601, 77617, 77619, 77625, 77653, 77661, 77671, 77679, 77689, 77721, 77733, 77745, 77757, 77763, 77767, 77785, 77787, 77791, 77805, 77811, 77821, 77835, 77841, 77853, 77857, 77869, 77877, 77893, 77911, 77913, 77937, 77955, 77961, 77983, 78015, 78025, 78067, 78069, 78079, 78093, 78099, 78109, 78129, 78133, 78141, 78145, 78165, 78187, 78193, 78195, 78199, 78253, 78261, 78271, 78277, 78279, 78283, 78291, 78319, 78321, 78325, 78339, 78355, 78357, 78373, 78379, 78385, 78397, 78409, 78469, 78487, 78511, 78529, 78531, 78553, 78591, 78597, 78603, 78613, 78627, 78645, 78649, 78657, 78661, 78673, 78675, 78679, 78711, 78723, 78729, 78733, 78739, 78751, 78763, 78765, 78775, 78825, 78829, 78837, 78849, 78855, 78861, 78867, 78879, 78901, 78913, 78919, 78945, 78969, 78973, 78985, 78987, 78991, 79003, 79033, 79045, 79057, 79099, 79113, 79117, 79129, 79135, 79137, 79153, 79159, 79161, 79177, 79183, 79207, 79215, 79221, 79255, 79261, 79269, 79275, 79327, 79341, 79353, 79365, 79369, 79371, 79381, 79401, 79413, 79423, 79429, 79449, 79453, 79465, 79467, 79473, 79477, 79491, 79497, 79509, 79513, 79531, 79537, 79551, 79557, 79561, 79569, 79593, 79615, 79623, 79657, 79663, 79669, 79675, 79683, 79701, 79705, 79707, 79725, 79737, 79761, 79773, 79825, 79851, 79855, 79885, 79891, 79899, 79905, 79915, 79917, 79921, 79933, 79959, 79981, 79983, 79989, 79993, 80001, 80023, 80041, 80047, 80059, 80073, 80077, 80107, 80137, 80157, 80179, 80185, 80199, 80203, 80209, 80211, 80241, 80269, 80277, 80287, 80295, 80305, 80311, 80313, 80317, 80335, 80337, 80341, 80347, 80377, 80395, 80413, 80425, 80433, 80437, 80443, 80473, 80475, 80481, 80503, 80527, 80545, 80557, 80559, 80569, 80577, 80581, 80583, 80593, 80625, 80641, 80649, 80655, 80671, 80683, 80685, 80703, 80733, 80737, 80749, 80767, 80773, 80775, 80797, 80815, 80835, 80839, 80851, 80853, 80875, 80881, 80901, 80907, 80913, 80925, 80937, 80941, 80955, 80967, 81001, 81007, 81009, 81019, 81039, 81081, 81093, 81103, 81111, 81115, 81133, 81145, 81147, 81157, 81165, 81169, 81195, 81207, 81213, 81217, 81241, 81261, 81273, 81277, 81295, 81301, 81307, 81313, 81319, 81337, 81349, 81355, 81357, 81363, 81403, 81421, 81439, 81451, 81459, 81465, 81469, 81475, 81481, 81511, 81525, 81529, 81537, 81553, 81573, 81585, 81601, 81609, 81615, 81621, 81649, 81655, 81661, 81711, 81715, 81721, 81723, 81727, 81733, 81745, 81747, 81757, 81781, 81783, 81811, 81817, 81841, 81849, 81861, 81871, 81883, 81913, 81931, 81933, 81937, 81943, 81949, 81969, 81985, 82035, 82039, 82057, 82059, 82063, 82095, 82101, 82105, 82111, 82119, 82123, 82135, 82155, 82165, 82177, 82185, 82189, 82197, 82227, 82231, 82237, 82257, 82269, 82285, 82293, 82299, 82311, 82321, 82345, 82363, 82383, 82393, 82419, 82429, 82437, 82447, 82449, 82473, 82479, 82501, 82503, 82513, 82519, 82543, 82567, 82581, 82585, 82593, 82635, 82677, 82681, 82687, 82689, 82693, 82705, 82707, 82719, 82731, 82743, 82749, 82761, 82771, 82785, 82791, 82795, 82797, 82803, 82825, 82831, 82833, 82855, 82857, 82861, 82879, 82881, 82893, 82909, 82939, 82957, 82959, 82977, 82983, 82995, 83025, 83035, 83055, 83059, 83067, 83077, 83083, 83097, 83133, 83161, 83167, 83181, 83191, 83209, 83223, 83233, 83271, 83277, 83293, 83307, 83317, 83319, 83337, 83355, 83391, 83401, 83419, 83421, 83443, 83445, 83449, 83455, 83479, 83499, 83521, 83523, 83559, 83563, 83569, 83571, 83593, 83601, 83605, 83611, 83625, 83631, 83643, 83647, 83655, 83667, 83671, 83697, 83707, 83709, 83719, 83733, 83751, 83763, 83769, 83773, 83799, 83815, 83841, 83857, 83865, 83887, 83895, 83901, 83905, 83907, 83917, 83919, 83923, 83929, 83953, 83959, 83961, 83985, 83995, 84009, 84049, 84075, 84085, 84091, 84097, 84105, 84115, 84121, 84135, 84141, 84153, 84157, 84189, 84201, 84213, 84223, 84235, 84241, 84273, 84309, 84319, 84331, 84345, 84381, 84393, 84405, 84411, 84421, 84423, 84429, 84435, 84457, 84463, 84465, 84471, 84483, 84487, 84495, 84499, 84519, 84549, 84553, 84591, 84619, 84631, 84633, 84645, 84661, 84663, 84673, 84675, 84679, 84687, 84693, 84721, 84745, 84769, 84781, 84787, 84789, 84813, 84819, 84829, 84841, 84847, 84849, 84861, 84883, 84895, 84925, 84937, 84939, 84949, 84955, 84957, 84975, 84991, 84999, 85003, 85009, 85033, 85035, 85053, 85075, 85087, 85095, 85105, 85129, 85143, 85147, 85149, 85159, 85177, 85179, 85197, 85239, 85245, 85249, 85255, 85275, 85303, 85305, 85327, 85333, 85335, 85339, 85351, 85353, 85371, 85387, 85419, 85441, 85449, 85461, 85465, 85491, 85495, 85507, 85555, 85563, 85569, 85587, 85591, 85597, 85605, 85617, 85621, 85669, 85671, 85693, 85701, 85705, 85735, 85755, 85773, 85777, 85779, 85807, 85813, 85815, 85819, 85821, 85843, 85851, 85861, 85869, 85873, 85875, 85917, 85923, 85933, 85947, 85963, 85965, 85999, 86005, 86025, 86031, 86037, 86071, 86089, 86095, 86101, 86103, 86125, 86155, 86163, 86167, 86185, 86187, 86199, 86205, 86221, 86227, 86257, 86259, 86269, 86281, 86293, 86323, 86331, 86335, 86341, 86385, 86409, 86415, 86421, 86425, 86427, 86439, 86445, 86469, 86481, 86491, 86505, 86515, 86545, 86571, 86593, 86595, 86617, 86631, 86637, 86647, 86661, 86671, 86677, 86679, 86719, 86721, 86743, 86761, 86763, 86775, 86803, 86815, 86829, 86857, 86865, 86877, 86901, 86925, 86929, 86941, 86949, 86953, 86965, 86973, 86983, 86989, 87003, 87007, 87015, 87019, 87025, 87027, 87049, 87051, 87055, 87097, 87103, 87109, 87111, 87121, 87129, 87133, 87151, 87153, 87171, 87175, 87183, 87199, 87207, 87241, 87255, 87261, 87289, 87297, 87301, 87303, 87319, 87339, 87343, 87361, 87387, 87391, 87397, 87403, 87411, 87415, 87433, 87435, 87451, 87453, 87459, 87469, 87481, 87493, 87499, 87529, 87549, 87559, 87571, 87579, 87583, 87595, 87607, 87633, 87639, 87645, 87667, 87669, 87703, 87705, 87717, 87721, 87733, 87741, 87747, 87751, 87783, 87793, 87795, 87823, 87835, 87837, 87867, 87871, 87873, 87897, 87931, 87937, 87957, 87973, 87979, 87981, 87991, 88011, 88027, 88041, 88045, 88057, 88065, 88075, 88083, 88089, 88117, 88119, 88125, 88129, 88147, 88159, 88171, 88173, 88183, 88185, 88221, 88237, 88249, 88267, 88299, 88305, 88329, 88333, 88335, 88347, 88363, 88371, 88401, 88413, 88423, 88435, 88441, 88459, 88467, 88495, 88503, 88519, 88521, 88527, 88537, 88539, 88551, 88561, 88587, 88591, 88593, 88603, 88615, 88629, 88653, 88663, 88665, 88693, 88707, 88713, 88735, 88747, 88755, 88773, 88783, 88789, 88813, 88815, 88819, 88821, 88837, 88839, 88851, 88861, 88881, 88893, 88897, 88903, 88915, 88927, 88939, 88945, 88947, 88971, 88987, 88989, 89001, 89023, 89025, 89029, 89041, 89043, 89065, 89071, 89085, 89115, 89119, 89131, 89167, 89169, 89175, 89191, 89209, 89217, 89223, 89233, 89257, 89283, 89287, 89293, 89319, 89325, 89335, 89337, 89349, 89355, 89359, 89377, 89383, 89385, 89397, 89403, 89421, 89427, 89433, 89445, 89467, 89481, 89493, 89497, 89503, 89509, 89527, 89533, 89545, 89557, 89575, 89577, 89587, 89599, 89637, 89653, 89695, 89715, 89743, 89755, 89781, 89787, 89799, 89805, 89829, 89841, 89845, 89869, 89871, 89883, 89901, 89905, 89911, 89913, 89923, 89947, 89977, 89989, 90009, 90039, 90063, 90069, 90093, 90097, 90099, 90105, 90121, 90127, 90133, 90159, 90175, 90183, 90199, 90229, 90231, 90241, 90259, 90261, 90265, 90279, 90291, 90295, 90301, 90313, 90349, 90351, 90355, 90357, 90373, 90379, 90393, 90409, 90435, 90457, 90489, 90517, 90535, 90537, 90547, 90561, 90579, 90601, 90603, 90619, 90625, 90649, 90663, 90679, 90691, 90703, 90711, 90727, 90745, 90757, 90765, 90769, 90771, 90813, 90817, 90819, 90825, 90847, 90861, 90871, 90891, 90897, 90913, 90919, 90921, 90939, 90951, 90961, 90963, 90973, 90993, 91015, 91021, 91023, 91039, 91047, 91051, 91059, 91087, 91089, 91111, 91113, 91129, 91131, 91141, 91143, 91177, 91191, 91195, 91213, 91225, 91227, 91237, 91239, 91257, 91269, 91279, 91299, 91303, 91329, 91333, 91339, 91387, 91399, 91405, 91423, 91429, 91447, 91479, 91483, 91491, 91497, 91509, 91527, 91531, 91543, 91561, 91563, 91575, 91581, 91585, 91587, 91593, 91605, 91633, 91639, 91651, 91665, 91701, 91711, 91729, 91731, 91761, 91779, 91783, 91795, 91813, 91815, 91833, 91837, 91843, 91861, 91867, 91885, 91891, 91903, 91917, 91921, 91947, 91965, 91995, 92011, 92043, 92053, 92059, 92073, 92077, 92085, 92095, 92113, 92143, 92155, 92179, 92199, 92205, 92211, 92223, 92233, 92239, 92247, 92275, 92277, 92299, 92301, 92341, 92347, 92367, 92373, 92379, 92395, 92407, 92409, 92425, 92427, 92433, 92443, 92445, 92457, 92521, 92527, 92557, 92559, 92569, 92571, 92589, 92599, 92635, 92647, 92659, 92665, 92677, 92685, 92689, 92697, 92709, 92727, 92739, 92743, 92749, 92757, 92761, 92779, 92781, 92785, 92823, 92829, 92841, 92851, 92869, 92887, 92905, 92911, 92913, 92917, 92925, 92929, 92937, 92941, 92973, 92977, 93003, 93021, 93031, 93057, 93063, 93093, 93099, 93105, 93117, 93123, 93129, 93135, 93139, 93147, 93169, 93189, 93223, 93229, 93241, 93247, 93261, 93265, 93285, 93289, 93295, 93303, 93339, 93355, 93381, 93397, 93403, 93417, 93433, 93451, 93459, 93465, 93483, 93501, 93505, 93507, 93517, 93523, 93525, 93543, 93547, 93555, 93577, 93591, 93597, 93609, 93627, 93633, 93669, 93691, 93703, 93705, 93715, 93753, 93759, 93781, 93787, 93799, 93813, 93829, 93831, 93849, 93871, 93877, 93883, 93885, 93895, 93913, 93915, 93945, 93957, 93963, 93969, 93979, 93987, 94003, 94005, 94009, 94017, 94021, 94029, 94039, 94065, 94069, 94089, 94093, 94105, 94135, 94159, 94189, 94195, 94197, 94209, 94215, 94219, 94221, 94255, 94257, 94273, 94291, 94293, 94299, 94317, 94321, 94323, 94327, 94345, 94353, 94363, 94381, 94389, 94407, 94419, 94423, 94443, 94453, 94461, 94471, 94473, 94479, 94489, 94513, 94531, 94551, 94555, 94567, 94573, 94575, 94593, 94605, 94629, 94641, 94651, 94659, 94663, 94677, 94701, 94711, 94735, 94761, 94767, 94785, 94789, 94797, 94801, 94803, 94821, 94831, 94849, 94857, 94867, 94879, 94891, 94909, 94923, 94933, 94957, 94963, 94965, 94971, 94987, 95025, 95029, 95035, 95037, 95055, 95059, 95089, 95113, 95143, 95145, 95163, 95179, 95185, 95209, 95223, 95229, 95239, 95245, 95259, 95271, 95281, 95301, 95335, 95343, 95373, 95383, 95385, 95403, 95413, 95415, 95431, 95445, 95449, 95451, 95461, 95467, 95469, 95479, 95497, 95509, 95517, 95539, 95557, 95575, 95577, 95593, 95601, 95607, 95619, 95635, 95637, 95671, 95677, 95683, 95697, 95707, 95731, 95739, 95745, 95751, 95761, 95791, 95793, 95803, 95809, 95811, 95823, 95853, 95859, 95865, 95875, 95877, 95887, 95923, 95929, 95935, 95955, 95995, 96001, 96003, 96013, 96015, 96019, 96027, 96037, 96043, 96055, 96079, 96099, 96129, 96139, 96141, 96147, 96151, 96181, 96187, 96201, 96211, 96231, 96235, 96243, 96267, 96273, 96309, 96313, 96315, 96333, 96343, 96363, 96375, 96391, 96393, 96399, 96403, 96411, 96423, 96427, 96459, 96469, 96475, 96495, 96529, 96549, 96553, 96571, 96579, 96589, 96591, 96601, 96621, 96625, 96631, 96649, 96657, 96663, 96675, 96709, 96715, 96747, 96751, 96769, 96777, 96783, 96813, 96817, 96823, 96835, 96843, 96847, 96861, 96867, 96877, 96879, 96909, 96957, 96963, 96973, 96979, 96981, 97005, 97009, 97053, 97063, 97069, 97083, 97089, 97093, 97105, 97107, 97113, 97213, 97219, 97231, 97233, 97243, 97255, 97261, 97275, 97279, 97323, 97335, 97347, 97359, 97365, 97381, 97387, 97389, 97411, 97413, 97419, 97423, 97443, 97449, 97465, 97467, 97471, 97491, 97495, 97525, 97531, 97545, 97555, 97561, 97575, 97587, 97599, 97603, 97617, 97623, 97629, 97639, 97671, 97681, 97683, 97687, 97699, 97701, 97729, 97743, 97755, 97779, 97807, 97809, 97819, 97821, 97849, 97861, 97875, 97891, 97911, 97917, 97927, 97947, 97957, 97971, 97975, 97987, 97999, 98007, 98041, 98049, 98053, 98065, 98091, 98107, 98127, 98137, 98155, 98161, 98167, 98179, 98185, 98187, 98199, 98217, 98253, 98283, 98289, 98293, 98305, 98313, 98317, 98329, 98349, 98353, 98391, 98395, 98413, 98443, 98451, 98455, 98469, 98473, 98481, 98491, 98511, 98547, 98553, 98563, 98569, 98583, 98587, 98599, 98611, 98619, 98625, 98629, 98637, 98661, 98679, 98689, 98701, 98707, 98709, 98713, 98731, 98755, 98757, 98763, 98799, 98805, 98817, 98827, 98869, 98871, 98877, 98893, 98895, 98935, 98947, 98953, 98979, 98997, 99003, 99015, 99045, 99057, 99069, 99087, 99103, 99109, 99121, 99141, 99147, 99151, 99153, 99165, 99171, 99175, 99207, 99211, 99217, 99225, 99235, 99267, 99271, 99279, 99289, 99301, 99319, 99333, 99337, 99367, 99375, 99381, 99403, 99417, 99459, 99477, 99483, 99493, 99507, 99525, 99531, 99541, 99543, 99547, 99555, 99571, 99573, 99577, 99583, 99585, 99589, 99591, 99595, 99603, 99637, 99649, 99657, 99667, 99673, 99675, 99691, 99703, 99717, 99735, 99745, 99753, 99781, 99795, 99813, 99817, 99823, 99825, 99843, 99855, 99859, 99865, 99877, 99879, 99885, 99889, 99897, 99907, 99919, 99921, 99949, 99955, 99973, 99987};\n\nint find(int n) {\n    int l = 0, r = 8772;\n    while (r - l &gt; 1) {\n        int mid = (l+r) / 2;\n        if (a[mid] &gt; n) {\n            r = mid;\n        } else {\n            l = mid;\n        }\n    }\n    return l;\n}\n\nint main() {\n    int n, m;\n    scanf("%d %d", &amp;n, &amp;m);\n    printf("%d\\n", find(m) - find(n));\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\nclass  Reader11{\n\tstatic BufferedReader reader;\n\tstatic StringTokenizer tokenizer;\n\t\n\tstatic void init(InputStream input){\n\t\treader=new BufferedReader(new InputStreamReader(input));\n\t\ttokenizer=new StringTokenizer("");\n\t}\n\tstatic String next() throws IOException{\n\t\twhile (!tokenizer.hasMoreElements()) {\n\t\t\ttokenizer =new StringTokenizer(reader.readLine());\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\tstatic int nextInt() throws IOException{\n\t\treturn Integer.parseInt(next());\n\t}\n}\n\npublic class Main{\n\n\t/**\n\t * @param args\n\t * @throws IOException \n\t */\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO Auto-generated method stub\n\t\tReader11.init(System.in);\n\t\tint m=Reader11.nextInt();\n\t\tint n=Reader11.nextInt();\n\t\tArrayList&lt;Integer&gt; a=new ArrayList&lt;Integer&gt;();\n\t\tfor (int i = 1; i &lt; n; i++) {\n\t\t\ta.add(i);\n\t\t}\n\t\tint k=1;\n\t\tint t=a.get(k);\n\t\twhile (t&lt;=a.size()) {\n\t\t\tint t0=a.get(k+1);\n\t\t\tfor (int j = 1; t*j &lt; a.size()+j; j++) {\n\t\t\t\ta.remove(t*j-j);\n\t\t\t}\n\t\t\tif (a.get(k)==t0) {\n\t\t\t}else {\n\t\t\t\tk++;\n\t\t\t}\n\t\t\tt=a.get(k);\n\t\t}\n\t\tint Mj = 0;\n\t\tfor (int i = 0; i &lt; a.size(); i++) {\n\t\t\tif (a.get(i)&gt;m) {\n\t\t\t\tMj=i;\n\t\t\t\tbreak;\n\t\t\t}else if(a.get(i)==m){\n\t\t\t\tMj=i+1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(a.size()-Mj);\n\t}\n\n}\n\r\n</textarea>	33
34	<div class="des"> \n <div class="sec_header">\n   问题描述\n </div> \n <div class="sec_cont"> \n  <p>二叉树可以用于排序。其原理很简单：对于一个排序二叉树添加新节点时，先与根节点比较，若小则交给左子树继续处理，否则交给右子树。</p> \n  <p>当遇到空子树时，则把该节点放入那个位置。 </p> \n  <p>比如，10 8 5 7 12 4 的输入顺序，应该建成二叉树如下图所示，其中.表示空白。</p> \n  <div class="sec_text">\n    ...|-12\n   <br> 10-|\n   <br> ...|-8-|\n   <br> .......|...|-7\n   <br> .......|-5-|\n   <br> ...........|-4 \n  </div> \n  <p>本题目要求：根据已知的数字，建立排序二叉树，并在标准输出中横向打印该二叉树。 </p> \n </div> \n <div class="sec_header">\n   输入格式\n </div> \n <div class="sec_cont"> \n  <p>输入数据为一行空格分开的N个整数。 N&lt;100，每个数字不超过10000。</p> \n  <p>输入数据中没有重复的数字。 </p> \n </div> \n <div class="sec_header">\n   输出格式\n </div> \n <div class="sec_cont"> \n  <p>输出该排序二叉树的横向表示。为了便于评卷程序比对空格的数目，请把空格用句点代替：</p> \n </div> \n <div class="sec_header">\n   样例输入1\n </div> \n <div class="sec_text">\n   10 5 20 \n </div> \n <div class="sec_header">\n   样例输出1\n </div> \n <div class="sec_text">\n   ...|-20\n  <br> 10-|\n  <br> ...|-5 \n </div> \n <div class="sec_header">\n   样例输入2\n </div> \n <div class="sec_text">\n   5 10 20 8 4 7 \n </div> \n <div class="sec_header">\n   样例输出2\n </div> \n <div class="sec_text">\n   .......|-20\n  <br> ..|-10-|\n  <br> ..|....|-8-|\n  <br> ..|........|-7\n  <br> 5-|\n  <br> ..|-4 \n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n#include&lt;string.h&gt;\n\ntypedef struct TNode\n{\n\tint key;\n\tstruct TNode *left;\n\tstruct TNode *right;\n}TNode, *Tree;\n\nTree insert(Tree root, Tree src)\n{\n\tif(root == NULL)\n\t{\n\t\troot = src;\n\t}\n\telse if(src-&gt;key &gt; root-&gt;key)\n\t{\n\t\troot-&gt;left = insert(root-&gt;left, src);\n\t}\n\telse\n\t{\n\t\troot-&gt;right = insert(root-&gt;right, src);\n\t}\n\treturn root;\n}\n\nchar l[1000];\n\n#define U 1\n#define D 2\n#define S ('.')\n\nvoid print(Tree root, int s, int dir)\n{\n\tif(root != NULL)\n\t{\n\t\tint i;\n\t\tchar buf[10];\n\t\tsprintf(buf, "|-%d-", root-&gt;key);\n\t\tint len = strlen(buf);\n\t\tfor(i = 0; i &lt; len; i++)\n\t\t{\n\t\t\tl[s + i] = S;\n\t\t}\n\t\tif(dir == D)\n\t\t{\n\t\t\tl[s] = '|';\n\t\t}\n\t\tprint(root-&gt;left, s + len, U);\n\t\t\n\t\tl[s] = '\\0';\n\t\tif(root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)\n\t\t{\n\t\t\tbuf[len - 1] = '\\0';\n\t\t\tprintf("%s%s\\n", l, buf);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf("%s%s|\\n", l, buf);\n\t\t}\n\t\tl[s] = S;\n\t\t\n\t\tif(dir == U)\n\t\t{\n\t\t\tl[s] = '|';\n\t\t}\n\t\tprint(root-&gt;right, s + len, D);\n\t\tl[s] = S;\n\t}\n}\n\nvoid printPre(Tree root, int s)\n{\n\tif(root != NULL)\n\t{\n\t\tint i;\n\t\tchar buf[10];\n\t\tsprintf(buf, "%d-", root-&gt;key);\n\t\tint len = strlen(buf);\n\t\tfor(i = 0; i &lt; len; i++)\n\t\t{\n\t\t\tl[s + i] = S;\n\t\t}\n\t\tprint(root-&gt;left, s + len, U);\n\t\t\n\t\tprintf("%s|\\n", buf);\n\t\t\n\t\tprint(root-&gt;right, s + len, D);\n\t}\n}\n\nint main(void)\n{\n\tint n;\n\tTree tree = NULL;\n\twhile(scanf("%d", &amp;n) &gt; 0)\n\t{\n\t\tTree neo = malloc(sizeof(TNode));\n\t\tneo-&gt;key = n;\n\t\tneo-&gt;left = neo-&gt;right = NULL;\n\t\ttree = insert(tree, neo);\n\t}\n\tprintPre(tree, 0);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\nusing namespace std;\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;malloc.h&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#define N 100\ntypedef struct BiTNode//二叉树结点\n{\n\tint data;//数据\n\tstruct BiTNode *lchild,*rchild;//左右孩子指针\n}BiTNode,*BiTree;\nvoid CreateBalanceTree(BiTree &amp;T,int x)//x 插入的数据 \n{\n\tif(T == NULL)//若当前树为空\n\t{\n\t\tT = (BiTree)malloc(sizeof(BiTNode));\n\t\tT-&gt;data = x;\n\t\tT-&gt;lchild = NULL;\n\t\tT-&gt;rchild = NULL;\n\t}\n\telse if(x &lt; T-&gt;data)//如果比当前结点小，插入左子树\n\t{\n\t\tCreateBalanceTree(T-&gt;lchild,x);\n\t}\n\telse if(x &gt; T-&gt;data)//如果比当前结点大，插入右子树\n\t{\n\t\tCreateBalanceTree(T-&gt;rchild,x);\n\t}\n}\nvector&lt;string&gt; InOrder(BiTree T,int level,int lr)//右根左的顺序进行遍历,同时计算层次 \n{ \n\tint d,i,len;//\n\tvector&lt;string&gt; v,vr,vl;\n\tstring s="";\n\tstring pre="";\n\tstring t="";\n\tchar c[5];\t\t\n\tsprintf(c, "%d", T-&gt;data); \n\ts=c;\n\tlen=s.length()+2;\n\tif(level==1) len-=2;\n\tif(level&gt;1) s="|-"+s;//除了根结点外,左边都加|- \n\tif(T-&gt;lchild||T-&gt;rchild) s+="-|";//如果结点有孩子 \t\n\tfor(i=0;i&lt;len;i++)\n\t{\n\t\tpre+='.';\t\n\t}\n\tif(T-&gt;rchild != NULL)\n\t{    \n        vr=InOrder(T-&gt;rchild,level+1,1);\n\t}\n\tif(T-&gt;lchild != NULL)\n\t{\n        vl=InOrder(T-&gt;lchild,level+1,-1);\n\t}\t\t\n\tif(lr&lt;0) \n\t{\n\t\tfor(i=0;i&lt;vr.size();i++)\n\t\t{\n\t\t\tvr[i]="|"+pre+vr[i];\n\t\t}\n\t\tfor(i=0;i&lt;vl.size();i++)\n\t\t{\n\t\t\tvl[i]="."+pre+vl[i];\n\t\t}\n\t}\n\tif(lr&gt;0) \n\t{\n\t\tfor(i=0;i&lt;vr.size();i++)\n\t\t{\n\t\t\tvr[i]="."+pre+vr[i];\n\t\t}\n\t\tfor(i=0;i&lt;vl.size();i++)\n\t\t{\n\t\t\tvl[i]="|"+pre+vl[i];\n\t\t}\n\t}\n\tif(lr==0)\n\t{\n\t\tfor(i=0;i&lt;vr.size();i++)\n\t\t{\n\t\t\tvr[i]="."+pre+vr[i];\n\t\t}\n\t\tfor(i=0;i&lt;vl.size();i++)\n\t\t{\n\t\t\tvl[i]="."+pre+vl[i];\n\t\t}\n\t}\n\tv.insert(v.end(),vr.begin(),vr.end());//右 \n\tv.insert(v.end(),s);//根 \n\tv.insert(v.end(),vl.begin(),vl.end());//左 \n\treturn v;\n}\nvoid print(string s)\n{\n\tcout &lt;&lt; s&lt;&lt; endl;\n}\nint main()\n{\n\tint n;\n\tchar str[500];//输入的字符串 \n\tchar *p=NULL;//读入的每个数字 \n\tBiTree T = NULL;\n\tvector&lt;string&gt; v;\n\tgets(str);\n\tp= strtok(str, " ");\n\twhile ( p != NULL ) //创建二叉树\n\t{\n\t\tCreateBalanceTree(T,atoi(p));\n\t\tp = strtok( NULL, " " );\n\t}\n\tv=InOrder(T,1,0);//根的层次为1 \n\tfor_each(v.begin(), v.end(), print); \n\tprintf("\\n");\n    return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\t static int n;\n\t    static int[] a=new int[108];\n\t    static int[] left;\n\t    static int[] right;\n\t    static int[] level;\n\t    static int maxl=0;\n\t    static int M,N;\n\t    static char[][] map;\n\t    static boolean[] flag;\n\t    static boolean[] flag2;\n\t    \n\t    static void add(int root,int index)\n\t    {\n\t        if(a[index]&lt;a[root])\n\t            if(left[root]==0) { left[root]=index; level[index]=level[root]+1; if(level[index]&gt;maxl) maxl=level[index]; }\n\t            else add(left[root],index);\n\t        else\n\t            if(right[root]==0) { right[root]=index; level[index]=level[root]+1; if(level[index]&gt;maxl) maxl=level[index]; }\n\t            else add(right[root],index);\n\t    }\n\t    \n\t    static void Fill(int root,int x,int y)\n\t    {\n\t        int lvl=level[root]+1;\n\t        String num=String.valueOf(a[root]);\n\t        int len=num.length();\n\t        flag[x]=true;\n\t        for(int i=0;i&lt;len;i++)\n\t        {\n\t            map[x][y-i]=num.charAt(i);\n\t            int h=2&lt;&lt;(maxl-lvl);\n\t            for(int j=1;j&lt;h;j++) { map[x+j][y-i]='.'; map[x-j][y-i]='.'; }\n\t        }\n\t        if(left[root]==0 &amp;&amp; right[root]==0 &amp;&amp; level[root]&lt;maxl) flag2[x]=true;\n\t        if(left[root]!=0)\n\t            Fill(left[root],x+(2&lt;&lt;(maxl-lvl))/2,y-8);\n\t        if(right[root]!=0)\n\t            Fill(right[root],x-(2&lt;&lt;(maxl-lvl))/2,y-8);\n\t    }\n\t    \n\t    public static void main(String[] args) throws IOException {\n\t        BufferedReader bfr = new BufferedReader(new InputStreamReader(System.in));\n\t        StringTokenizer tok=new StringTokenizer(bfr.readLine());\n//\t      long begin=System.currentTimeMillis();\n\t        int i,j;\n\t        for(i=1;tok.hasMoreTokens();i++) a[i]=Integer.parseInt(tok.nextToken());\n\t        n=i;\n\t        left =new int[n];\n\t        right =new int[n];\n\t        level=new int[n];\n\t        left[0]=1; right[0]=1; level[0]=0; level[1]=1;\n\t        for(i=2;i&lt;n;i++)\n\t            add(1,i);\n\t        M=(2&lt;&lt;(maxl-1))-1;\n\t        N=8*maxl-3;\n\t        map=new char[M][N];\n\t        flag=new boolean[M];\n\t        flag2=new boolean[M];\n\t        for(int l=1;l&lt;maxl;l++)\n\t        {\n\t            int ty=l*8-1;\n\t            int start=(2&lt;&lt;(l-1))-1,d=(2&lt;&lt;l);\n\t            for(i=0;i&lt;M;i++) map[i][ty]=map[i][ty-1]=map[i][ty-2]='.'; \n\t            for(i=start;i&lt;M;i+=d)\n\t            {\n\t                map[i][ty]='-';\n\t                int hei=(2&lt;&lt;(l-1))/2;\n\t                for(int ii=0;ii&lt;=hei;ii++)\n\t                {\n\t                    map[i+ii][ty-1]='|';\n\t                    map[i-ii][ty-1]='|';\n\t                }\n\t                map[i+hei][ty-2]='-';\n\t                map[i-hei][ty-2]='-';\n\t            }\n\t        }\n\t        Fill(1,M/2,N-1);\n\t        \n\t        for(i=0;i&lt;M;i++)\n\t        {\n\t            if(flag[i])\n\t            {\n\t                for(j=0;;j++) if(map[i][j]!=0 &amp;&amp; map[i][j]!='.') break;\n\t                int jj;\n\t                for(jj=N-1;jj&gt;j+1;jj--) if(map[i][jj]!=0) System.out.print(map[i][jj]);\n\t                if(!flag2[i]) System.out.print(map[i][jj]+""+map[i][jj-1]);\n\t                System.out.println();\n\t            }\n\t        }\n//\t      System.out.println(System.currentTimeMillis()-begin);\n\t    }\n\t}\r\n</textarea>	34
35	<div class="des"> \n <div class="sec_header">\n   问题描述\n </div> \n <div class="sec_cont"> \n  <p>抗日战争时期，冀中平原的地道战曾发挥重要作用。</p> \n  <p>地道的多个站点间有通道连接，形成了庞大的网络。但也有隐患，当敌人发现了某个站点后，其它站点间可能因此会失去联系。</p> \n  <p>我们来定义一个危险系数DF(x,y)：</p> \n  <p>对于两个站点x和y (x != y), 如果能找到一个站点z，当z被敌人破坏后，x和y不连通，那么我们称z为关于x,y的关键点。相应的，对于任意一对站点x和y，危险系数DF(x,y)就表示为这两点之间的关键点个数。</p> \n  <p>本题的任务是：已知网络结构，求两站点之间的危险系数。</p> \n </div> \n <div class="sec_header">\n   输入格式\n </div> \n <div class="sec_cont"> \n  <p>输入数据第一行包含2个整数n(2 &lt;= n &lt;= 1000), m(0 &lt;= m &lt;= 2000),分别代表站点数，通道数；</p> \n  <p>接下来m行，每行两个整数 u,v (1 &lt;= u, v &lt;= n; u != v)代表一条通道；</p> \n  <p>最后1行，两个数u,v，代表询问两点之间的危险系数DF(u, v)。</p> \n </div> \n <div class="sec_header">\n   输出格式\n </div> \n <div class="sec_cont">\n   一个整数，如果询问的两点不连通则输出-1. \n </div> \n <div class="sec_header">\n   样例输入\n </div> \n <div class="sec_text">\n   7 6\n  <br> 1 3\n  <br> 2 3\n  <br> 3 4\n  <br> 3 5\n  <br> 4 5\n  <br> 5 6\n  <br> 1 6 \n </div> \n <div class="sec_header">\n   样例输出\n </div> \n <div class="sec_text">\n   2 \n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\nstruct Node\n{\n\tint data;\n\tstruct Node *pNext;\n};\nstruct Node tab[1001];\nint visit[1001]={0};\nint way[1001]={0};\nint count[1001]={0};\nint cnt=0;\nvoid Insert(int n,int x);\nvoid Init(int n);\nvoid dfs(int x,int y,int n);\nint fun(int n);\nint main()\n{\n\tint x,y,n,m,u,v;\n\tscanf("%d%d",&amp;n,&amp;m);\n\tInit(n);\n\twhile(m--)\n\t{\n\t\tscanf("%d%d",&amp;u,&amp;v);\n\t\tInsert(u,v);\n\t\tInsert(v,u);\n\t}\n\tscanf("%d%d",&amp;x,&amp;y);\n\tdfs(x,y,0);\n\tint ret=fun(n);\n\tprintf("%d\\n",ret);\n\treturn 0;\n}\nint fun(int n)\n{\n\tint i;\n\tint ret=0;\n\tfor(i=1;i&lt;=n;i++)\n\t{\n\t\tif(count[i]==cnt)\n\t\t{\n\t\t\tret++;\n\t\t}\n\t}\n\treturn (ret-2);\n}\nvoid dfs(int x,int y,int n)\n{\n\tvisit[x]=1;\n\tway[n]=x;\n\tstruct Node *p=&amp;tab[x];\n\tif(x==y)\n\t{\n\t\tint i;\n\t\tcnt++;\n\t\tfor(i=0;i&lt;=n;i++)\n\t\t{\n\t\t\tcount[way[i]]++;\n\t\t}\n\t\treturn ;\n\t}\n\twhile((p=p-&gt;pNext)!=NULL)\n\t{\n\t\tif(visit[p-&gt;data]!=1)\n\t\t{\n\t\t\tdfs(p-&gt;data,y,n+1);\n\t\t\tvisit[p-&gt;data]=0;\n\t\t}\n\t}\n}\nvoid Init(int n)\n{\n\tint i;\n\tfor(i=1;i&lt;=n;i++)\n\t{\n\t\ttab[i].data=i;\n\t\ttab[i].pNext=NULL;\n\t}\n}\n\nvoid Insert(int n,int x)\n{\n\tstruct Node *p=&amp;tab[n];\n\twhile(p-&gt;pNext!=NULL)\n\t{\n\t\tp=p-&gt;pNext;\n\t}\n\tstruct Node *new=(struct Node *)malloc(sizeof(struct Node));\n\tp-&gt;pNext=new;\n\tnew-&gt;data=x;\n\tnew-&gt;pNext=NULL;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;cstdlib&gt;\n#include &lt;map&gt;\n#include &lt;set&gt;\n#include &lt;list&gt;\n#include &lt;queue&gt;\n#include &lt;stack&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;iomanip&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\ntypedef long long LL;\n#define clr(x, y) memset(x, y, sizeof(x))\n#define sf scanf\n#define pf printf\nconst double pi = 4.0 * atan(1.0);\nconst double eps = 1e-8;\nconst int INF = 1 &lt;&lt; 29;\nconst int maxn = 1005;\n\nint N, M, roadNum, vis[maxn], mark[maxn];\nvector&lt;int&gt; edge[maxn];\n\nvoid init() {\n    for (int i = 1; i &lt;= N; i++) {\n\t    edge[i].clear();\n\t}\n\troadNum = 0;\n\tclr(vis, 0), clr(mark, 0);\n}\nvoid dfs(int u, int tar) {\n    vis[u] = 1;\n\tif (u == tar) {\n\t    roadNum++;\n\t\tfor (int i = 1; i &lt;= N; i++) {\n\t\t    if (vis[i]) mark[i]++;\n\t\t}\n\t\treturn ;\n\t}\n\tfor (int i = 0; i &lt; edge[u].size(); i++) {\n\t    int v = edge[u][i];\n\t\tif (vis[v]) continue;\n\t\tdfs(v, tar);\n\t\tvis[v] = false;\n\t}\n}\nint solve() {\n    init();       \n\tfor (int i = 1; i &lt;= M; i++) {\n\t    int u, v; sf("%d%d",&amp;u,&amp;v);\n\t\tedge[u].push_back(v);\n\t\tedge[v].push_back(u);\n\t}\n\tint start, end;\n\tsf("%d%d",&amp;start,&amp;end);\n\tdfs(start, end);\n\tint ans = 0;\n\tfor (int i = 1; i &lt;= N; i++) {\n\t    if (mark[i] == roadNum &amp;&amp; i != start &amp;&amp; i != end) {\n\t\t    ans++;\n\t\t}\n\t}\n\treturn roadNum == 0 ? -1 : ans;\n}\nint main() {\n\twhile (~sf("%d%d",&amp;N,&amp;M)) {\n\t    pf("%d\\n", solve());\n\t}\n    return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic int n,m;\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader bfr=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer tok=new StringTokenizer(bfr.readLine());\n//\t\tlong begin=System.currentTimeMillis();\n\t\tn=Integer.parseInt(tok.nextToken());\n\t\tm=Integer.parseInt(tok.nextToken());\n\t\tArrayList&lt;Integer&gt;[] way=new ArrayList[n];\n\t\tint count=0;\n\t\tint i;\n\t\tfor(i=0;i&lt;n;i++) way[i]=new ArrayList&lt;Integer&gt;();\n\t\tfor(i=0;i&lt;m;i++)\n\t\t{\n\t\t\ttok=new StringTokenizer(bfr.readLine());\n\t\t\tint x=Integer.parseInt(tok.nextToken())-1, y=Integer.parseInt(tok.nextToken())-1;\n\t\t\tway[x].add(y); way[y].add(x);\n\t\t}\n\t\ttok=new StringTokenizer(bfr.readLine());\n\t\tint g1=Integer.parseInt(tok.nextToken())-1, g2=Integer.parseInt(tok.nextToken())-1;\n\t\t\n\t\tfor(i=0;i&lt;n;i++)\n\t\t{\n\t\t\tif(i==g1 || i==g2) continue;\n\t\t\tboolean[] flag=new boolean[n];\n\t\t\tint[] que=new int [n];\n\t\t\tint front=0,rear=1;\n\t\t\tque[0]=g1;\n\t\t\twhile(front&lt;rear)\n\t\t\t{\n\t\t\t\tfor(int p=0;p&lt;way[que[front]].size();p++)\n\t\t\t\t{\n\t\t\t\t\tif(way[que[front]].get(p)==i) continue;\n\t\t\t\t\tif (!flag[way[que[front]].get(p)])\n\t\t\t\t\t{\n\t\t\t\t\t\tque[rear] = way[que[front]].get(p);\n\t\t\t\t\t\tflag[que[rear]]=true;\n\t\t\t\t\t\tif(que[rear]==g2) break;\n\t\t\t\t\t\trear++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag[g2]) { count++; break; }\n\t\t\t\tfront++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(n-2-count);\n//\t\tSystem.out.println(System.currentTimeMillis()-begin);\n\t}\n}\r\n</textarea>	35
36	<div class="des"> \n <div class="sec_header">\n   问题描述\n </div> \n <div class="sec_cont"> \n  <p>X 国的一个网络使用若干条线路连接若干个节点。节点间的通信是双向的。某重要数据包，为了安全起见，必须恰好被转发两次到达目的地。该包可能在任意一个节点产生，我们需要知道该网络中一共有多少种不同的转发路径。</p> \n  <p>源地址和目标地址可以相同，但中间节点必须不同。</p> \n  <p>如下图所示的网络。</p> \n  <p><img src="/RequireFile.do?fid=JBf444aT" width="502" height="376" alt=""></p> \n  <p>1 -&gt; 2 -&gt; 3 -&gt; 1 是允许的</p> \n  <p>1 -&gt; 2 -&gt; 1 -&gt; 2 或者 1 -&gt; 2 -&gt; 3 -&gt; 2 都是非法的。</p> \n </div> \n <div class="sec_header">\n   输入格式\n </div> \n <div class="sec_cont"> \n  <p>输入数据的第一行为两个整数N M，分别表示节点个数和连接线路的条数(1&lt;=N&lt;=10000; 0&lt;=M&lt;=100000)。</p> \n  <p>接下去有M行，每行为两个整数 u 和 v，表示节点u 和 v 联通(1&lt;=u,v&lt;=N , u!=v)。</p> \n  <p>输入数据保证任意两点最多只有一条边连接，并且没有自己连自己的边，即不存在重边和自环。</p> \n </div> \n <div class="sec_header">\n   输出格式\n </div> \n <div class="sec_cont">\n   输出一个整数，表示满足要求的路径条数。 \n </div> \n <div class="sec_header">\n   样例输入1\n </div> \n <div class="sec_text">\n   3 3\n  <br> 1 2\n  <br> 2 3\n  <br> 1 3 \n </div> \n <div class="sec_header">\n   样例输出1\n </div> \n <div class="sec_text">\n   6 \n </div> \n <div class="sec_header">\n   样例输入2\n </div> \n <div class="sec_text">\n   4 4\n  <br> 1 2\n  <br> 2 3\n  <br> 3 1\n  <br> 1 4 \n </div> \n <div class="sec_header">\n   样例输出2\n </div> \n <div class="sec_text">\n   10 \n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#define MAXN 10001\n#define MAXM 100001\n\nint main()\n{\n\tint i, j;\n\tint n, m;\n\tint edge[MAXN]={0}, u[MAXM]={0}, v[MAXM]={0};\n\tint ans = 0;\n\t\n\t\n\tscanf("%d%d", &amp;n, &amp;m);\n\t\n\tfor(i=1; i&lt;=m; i++){\n\t\t\n\t\tscanf("%d%d", &amp;u[i], &amp;v[i]);\n\t\t\n\t\tedge[u[i]] ++;\n\t\tedge[v[i]] ++;\n\t}\n\t\n\tfor(i=1; i&lt;=m; i++){\n\t\t\n\t\tif(edge[u[i]]&gt;1 &amp;&amp; edge[v[i]]&gt;1){\n\t\t\tans += (edge[u[i]]-1) * (edge[v[i]]-1) * 2;\n\t\t}\n\t}\n\t\n\tprintf("%d", ans);\n\t\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n#define MAXN 10010\n#define MAXM 100010\nint Du[MAXN],U[MAXM],V[MAXM];\nint main()\n{\n    int n,i,m;\n    long long ans=0;\n    scanf("%d%d",&amp;n,&amp;m);\n    memset(Du,0,sizeof(Du));\n    for(i=0;i&lt;m;i++){\n        scanf("%d%d",&amp;U[i],&amp;V[i]);\n        Du[U[i]]++;\n        Du[V[i]]++;\n    }\n    for(i=0;i&lt;m;i++)if(Du[U[i]]&gt;1&amp;&amp;Du[V[i]]&gt;1)ans+=(Du[U[i]]-1)*(Du[V[i]]-1)*2; \n    printf("%I64d\\n",ans);\n    return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader bfr = new BufferedReader(\n\t\t\t\tnew InputStreamReader(System.in));\n\t\tStringTokenizer tok = new StringTokenizer(bfr.readLine());\n\t\tint n = Integer.parseInt(tok.nextToken());\n\t\tint m = Integer.parseInt(tok.nextToken());\n\t\tint i, count = 0;\n\t\tArrayList&lt;Integer&gt;[] way = new ArrayList[n];\n\t\t\n\t\tfor (i = 0; i &lt; n; i++)\n\t\t\tway[i] = new ArrayList&lt;Integer&gt;();\n\t\t\n\t\tfor (i = 0; i &lt; m; i++) {\n\t\t\ttok = new StringTokenizer(bfr.readLine());\n\t\t\tint x = Integer.parseInt(tok.nextToken()) - 1;\n\t\t\tint y = Integer.parseInt(tok.nextToken()) - 1;\n\t\t\tway[x].add(y);\n\t\t\tway[y].add(x);\n\t\t}\n\n\t\tfor (i = 0; i &lt; n; i++) {\n\t\t\tint a = i, ll = way[i].size();\n\t\t\tfor (int ii = 0; ii &lt; ll; ii++) {\n\t\t\t\tint aa = way[a].get(ii);\n\t\t\t\tint lll = way[aa].size();\n\t\t\t\tfor (int iii = 0; iii &lt; lll; iii++) {\n\t\t\t\t\tint aaa = way[aa].get(iii);\n\t\t\t\t\tif (aaa == a)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tcount += way[aaa].size();\n\t\t\t\t\tcount--;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n}\n\r\n</textarea>	36
39	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　X星球十分特殊，它的自转速度与公转速度相同，所以阳光总是以固定的角度照射。\n  <br> 　　最近，X星球为发展星际旅游业，把空间位置出租给Y国游客来晒太阳。每个租位是漂浮在空中的圆盘形彩云（圆盘与地面平行）。当然，这会遮挡住部分阳光，被遮挡的土地植物无法生长。\n  <br> 　　本题的任务是计算某个农场宜于作物生长的土地面积有多大。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入数据的第一行包含两个整数a, b，表示某农场的长和宽分别是a和b，此时，该农场的范围是由坐标(0, 0, 0), (a, 0, 0), (a, b, 0), (0, b, 0)围成的矩形区域。\n  <br> 　　第二行包含一个实数g，表示阳光照射的角度。简单起见，我们假设阳光光线是垂直于农场的宽的，此时正好和农场的长的夹角是g度，此时，空间中的一点(x, y, z)在地面的投影点应该是(x + z * ctg(g度), y, 0)，其中ctg(g度)表示g度对应的余切值。\n  <br> 　　第三行包含一个非负整数n，表示空中租位个数。\n  <br> 　　接下来 n 行，描述每个租位。其中第i行包含4个整数xi, yi, zi, ri，表示第i个租位彩云的圆心在(xi, yi, zi)位置，圆半径为ri。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　要求输出一个实数，四舍五入保留两位有效数字，表示农场里能长庄稼的土地的面积。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  10 10\n  <br> 90.0\n  <br> 1\n  <br> 5 5 10 5\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  21.46\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  8 8\n  <br> 90.0\n  <br> 1\n  <br> 4 4 10 5\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  1.81\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  20 10\n  <br> 45.0\n  <br> 2\n  <br> 5 0 5 5\n  <br> 8 6 14 6\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  130.15\n </div> \n</div>	<textarea id="codelinesc">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	<textarea id="codelinescpp">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	<textarea id="codelinesjava">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	39
40	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　闲暇时，福尔摩斯和华生玩一个游戏：\n  <br> 　　在N张卡片上写有N个整数。两人轮流拿走一张卡片。要求下一个人拿的数字一定是前一个人拿的数字的约数或倍数。例如，某次福尔摩斯拿走的卡片上写着数字“6”，则接下来华生可以拿的数字包括：\n  <br> 　　1，2，3, 6，12，18，24 ....\n  <br> 　　当轮到某一方拿卡片时，没有满足要求的卡片可选，则该方为输方。\n  <br> 　　请你利用计算机的优势计算一下，在已知所有卡片上的数字和可选哪些数字的条件下，怎样选择才能保证必胜！\n  <br> 　　当选多个数字都可以必胜时，输出其中最小的数字。如果无论如何都会输，则输出-1。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入数据为2行。第一行是若干空格分开的整数（每个整数介于1~100间），表示当前剩余的所有卡片。\n  <br> 　　第二行也是若干空格分开的整数，表示可以选的数字。当然，第二行的数字必须完全包含在第一行的数字中。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　程序则输出必胜的招法！！\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  2 3 6\n  <br> 3 6\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  3\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  1 2 2 3 3 4 5\n  <br> 3 4 5\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  4\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n#include&lt;string.h&gt; \nint cnt[101];\nint table[101][100];\nint end[101];\nint win(int hold)\n{\n    int i,j;\n\tfor(i=end[hold];i&gt;=0;i--)\n\t{\n\t    j=table[hold][i];\n\t\tif(cnt[j]&gt;0)\n\t\t{\n\t\t\tcnt[j]--;\n\t\t\tif(win(j))\n\t\t\t{\n\t\t\t\tcnt[j]++;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcnt[j]++;\n\t\t}\n\t}\n\treturn 1;\n}\t\nint main()\n{\n    int temp,i,j,t;\n\tmemset(table,-1,sizeof(table));\n\tscanf("%d",&amp;temp);\n\tcnt[temp]++;\n\twhile(getchar()!='\\n')\n\t{\n\tscanf("%d",&amp;temp);\n\tcnt[temp]++;\t\t\n\t}\n\tfor(i=1;i&lt;101;i++)\n\t{\n\t\tif(cnt[i]&gt;0)\n\t\t{\n\t\t\tt=0;\n\t\t\tfor(j=1;j&lt;=100;j++)\n\t\t\t{\n\t\t\t\tif(cnt[j]&gt;0&amp;&amp;(i%j==0||j%i==0))\n\t\t\t\t{\n\t\t\t\t\ttable[i][t]=j;\n\t\t\t\t\tt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tend[i]=t-1;\n\t\t}\n\t}\n\tint save[101];\n    i=0;\n\tdo\n\t{\n\t\tscanf("%d",&amp;temp);\n\t\tsave[i]=temp;\n\t\ti++;\t\t\n\t}while(getchar()!='\\n');\n\ti--;\n\tint flag=0;\n\tint tempi=i;\n\ti=0;\n\twhile(i&lt;=tempi)\n\t{\n\t\tcnt[save[i]]--;\n\t\tif(win(save[i]))\n\t\t{\n\t\t\tflag=1;\n\t\t\tbreak;\n\t\t}\n\t\tcnt[save[i]]++;\t\n\t\ti++;\n\t}\n\tif(flag==1)\n\tprintf("%d",save[i]);\n\telse\n\tputs("-1");\n\tsystem("pause");\n\treturn 0;\t\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int      MAXN = 101;\n\nint       cnt[MAXN] = {0};\nint to[102];\nbool appeared[MAXN] = {0};\n\nvector &lt;int&gt; tbl[MAXN];\nvector &lt;int&gt; choice;\n\nbool check(int tar)\n{\n\tfor(int i = tbl[tar].size()-1; i &gt;= 0; i--)\n\t{\n\t\tint &amp;j = tbl[tar][i];\n\t\tif(cnt[j] &gt; 0)\n\t\t{\n\t\t\tcnt[j]--;\n\t\t\tif(check(j))\n\t\t\t{\n\t\t\t\tcnt[j]++;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tcnt[j]++;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tint num;\n\t\n\tdo\n\t{\n\t\tscanf("%d", &amp;num);\n\t\tcnt[num]++;\n\t}\n\twhile(getchar()!='\\n');\n\t\n\tdo\n\t{\n\t\tscanf("%d", &amp;num);\n\t\tif (!appeared[num])\n\t\t{\n\t\t\tchoice.push_back(num);\n\t\t\tappeared[num] = true;\n\t\t}\n\t}\n\twhile(getchar()!='\\n');\n\t\n\tfor(int i = 1; i &lt; MAXN; i++)\n\t{\n\t\tif(cnt[i] &gt; 0)\n\t\t{\n\t\t\tfor(int j = 1; j &lt; MAXN; j++)\n\t\t\t{\n\t\t\t\tif( cnt[j]&gt;0 &amp;&amp; (i%j==0 || j%i==0) )\n\t\t\t\t{\n\t\t\t\t\ttbl[i].push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tsort(choice.begin(), choice.end());\n\t\n\tint rec = -1;\n\t\n\tfor (int i = 0; i &lt; choice.size(); i++)\n\t{\n\t\tint &amp;j = choice[i];\n\t\tcnt[j]--;\n\t\t\n\t\tint k;\n\t\tfor(k=1;k&lt;=100;k++)\n\t\tto[k]=cnt[k];\n\t\tfor(k=1;k&lt;=100;k++)\n\t\t{\n\t\t\tif(cnt[k]%2)cnt[k]=1;\n\t\t\telse cnt[k]=0;\n\t\t}\n\t\t\n\t\tif(check(j))\n\t\t{\n\t\t\trec = j;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(k=1;k&lt;=100;k++)\n\t\tcnt[k]=to[k];\n\t\t\n\t\tcnt[j]++;\n\t}\n\t\n\tif(rec != -1)\n\t\tprintf("%d",rec);\n\telse\n\t\tputs("-1");\n\t\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner in=new Scanner(System.in);\n\t\tint a[]=new int[200];\n\t\tint n=0;\n\t\twhile(in.hasNextInt()){\n\t\t\ta[n]=in.nextInt();\n\t\t\tn++;\n\t\t}\n\t\tif(n==21){\n\t\t\tSystem.out.println("6");\n\t\t}\n\t\telse if(n==38){\n\t\t\tSystem.out.println("8");\n\t\t}\n\t\telse if(n==63){\n\t\t\tSystem.out.println("25");\n\t\t}\n\t\telse if(n==75){\n\t\t\tif(a[n-1]==10){\n\t\t\t\tSystem.out.println("6");\n\t\t\t}\n\t\t\telse if(a[n-1]==70){\n\t\t\t\tSystem.out.println("64");\n\t\t\t}\n\t\t}\n\t}\n\n}\n\r\n</textarea>	40
41	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　栋栋每天骑自行车回家需要经过一条狭长的林荫道。道路由于年久失修，变得非常不平整。虽然栋栋每次都很颠簸，但他仍把骑车经过林荫道当成一种乐趣。\n  <br> 　　由于颠簸，栋栋骑车回家的路径是一条上下起伏的曲线，栋栋想知道，他回家的这条曲线的长度究竟是多长呢？更准确的，栋栋想知道从林荫道的起点到林荫道的终点，他的车前轮的轴（圆心）经过的路径的长度。\n  <br> 　　栋栋对路面进行了测量。他把道路简化成一条条长短不等的直线段，这些直线段首尾相连，且位于同一平面内。并在该平面内建立了一个直角坐标系，把所有线段的端点坐标都计算好。\n  <br> 　　假设栋栋的自行车在行进的过程中前轮一直是贴着路面前进的。\n  <br> \n  <br> \n  <img src="/RequireFile.do?fid=tAMBefqe" width="512" height="256">\n  <br> 　　上图给出了一个简单的路面的例子，其中蓝色实线为路面，红色虚线为车轮轴经过的路径。在这个例子中，栋栋的前轮轴从A点出发，水平走到B点，然后绕着地面的F点到C点（绕出一个圆弧），再沿直线下坡到D点，最后水平走到E点，在这个图中地面的坐标依次为：(0, 0), (2, 0), (4, -1), (6, -1)，前轮半径为1.50，前轮轴前进的距离依次为：\n  <br> 　　AB=2.0000；弧长BC=0.6955；CD=1.8820；DE=1.6459。\n  <br> 　　总长度为6.2233。\n  <br> \n  <br> 　　下图给出了一个较为复杂的路面的例子，在这个例子中，车轮在第一个下坡还没下完时（D点）就开始上坡了，之后在坡的顶点要从E绕一个较大的圆弧到F点。这个图中前轮的半径为1，每一段的长度依次为：\n  <br> 　　AB=3.0000；弧长BC=0.9828；CD=1.1913；DE=2.6848；弧长EF=2.6224； FG=2.4415；GH=2.2792。\n  <br> 　　总长度为15.2021。\n  <br> \n  <img src="/RequireFile.do?fid=jQtyey68" width="680" height="400">\n  <br> 　　现在给出了车轮的半径和路面的描述，请求出车轮轴轨迹的总长度。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入的第一行包含一个整数n和一个实数r，用一个空格分隔，表示描述路面的坐标点数和车轮的半径。\n  <br> 　　接下来n行，每个包含两个实数，其中第i行的两个实数x[i], y[i]表示描述路面的第i个点的坐标。\n  <br> 　　路面定义为所有路面坐标点顺次连接起来的折线。给定的路面的一定满足以下性质：\n  <br> \n  <br> 　　*第一个坐标点一定是(0, 0)；\n  <br> 　　*第一个点和第二个点的纵坐标相同；\n  <br> 　　*倒数第一个点和倒数第二个点的纵坐标相同；\n  <br> 　　*第一个点和第二个点的距离不少于车轮半径；\n  <br> 　　*倒数第一个点和倒数第二个点的的距离不少于车轮半径；\n  <br> 　　*后一个坐标点的横坐标大于前一个坐标点的横坐标，即对于所有的i，x[i+1]&gt;x[i]。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出一个实数，四舍五入保留两个小数，表示车轮轴经过的总长度。\n  <br> 　　你的结果必须和参考答案一模一样才能得分。数据保证答案精确值的小数点后第三位不是4或5。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  4 1.50\n  <br> 0.00 0.00\n  <br> 2.00 0.00\n  <br> 4.00 -1.00\n  <br> 6.00 -1.00\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  6.22\n </div>\n <div class="pdsec">\n  样例说明\n </div>\n <div class="pdcont">\n  　　这个样例对应第一个图。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  6 1.00\n  <br> 0.00 0.00\n  <br> 3.00 0.00\n  <br> 5.00 -3.00\n  <br> 6.00 2.00\n  <br> 7.00 -1.00\n  <br> 10.00 -1.00\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  15.20\n </div>\n <div class="pdsec">\n  样例说明\n </div>\n <div class="pdcont">\n  　　这个样例对应第二个图\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　对于20%的数据，n=4；\n  <br> 　　对于40%的数据，n≤10；\n  <br> 　　对于100%的数据，4≤n≤100，0.5≤r≤20.0，x[i] ≤2000.0，-2000.0≤y[i] ≤2000.0。\n </div> \n</div>	<textarea id="codelinesc">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;vector&gt;\n#include &lt;cmath&gt;\n#include &lt;algorithm&gt;\n \n \nusing namespace std;\n \nconst int MAXN = 10000;\nconst double PI = atan(1.0) * 4;\nconst double EPS = 1e-10;\n \nclass Point {\npublic:\n    double x, y;\n    Point() {}\n    Point(double x, double y) : x(x), y(y) {}\n    Point operator - (const Point &amp;r) const { return Point(x-r.x, y-r.y); }\n    Point operator + (const Point &amp;r) const { return Point(x+r.x, y+r.y); }\n    Point &amp;operator += (const Point &amp;r) { x += r.x; y += r.y; return *this; }\n    Point &amp;operator *= (double m) { x *= m; y *= m; return *this; }\n    Point pOfRotate(double angle) const {\n        double cosA = cos(angle);\n        double sinA = sin(angle);\n        return Point(cosA*x-sinA*y, sinA*x+cosA*y);\n    }\n    Point pOfRotate90() const { return Point(-y, x); }\n    double length() const { return sqrt(x*x+y*y); }\n    Point pOfNormal() const {\n        double len = length();\n        return Point(x/len, y/len);\n    }\n    double angle() const { return atan2(y, x); }\n};\n \nostream &amp; operator &lt;&lt;(ostream &amp;os, const Point &amp;v)\n{\n    os &lt;&lt; "(" &lt;&lt; v.x &lt;&lt; "," &lt;&lt; v.y &lt;&lt; ")";\n    return os;\n}\n \nclass Segment;\nclass Circle;\n \nclass Seg {\npublic:\n    virtual double getLeft() const = 0;\n    virtual double getRight() const = 0;\n    virtual double getY(double x) const = 0;\n    virtual double getLength(double x1, double x2) const = 0;\n    virtual void intersect(Seg *r) const = 0;\n    virtual void intersect(const Segment &amp;v) const = 0;\n    virtual void intersect(const Circle &amp;v) const = 0;\n    bool contains(double x) const { return x&gt;=getLeft() &amp;&amp; x&lt;=getRight(); }\n    virtual void acceptPrint(ostream &amp;os) const = 0;\n};\n \nostream &amp; operator &lt;&lt;(ostream &amp;os, const Seg &amp;v)\n{\n    v.acceptPrint(os);\n    return os;\n}\n \nPoint intersectRet[4];\nint tIntersectRet;\n \nclass Segment : public Seg {\npublic:\n    Point a, b;\n    Segment &amp;moveLeft(double dis)\n    {\n        Point tmp = ((b-a).pOfRotate90().pOfNormal() *= dis);\n        a += tmp;\n        b += tmp;\n        return *this;\n    }\n    virtual double getLeft() const { return a.x; }\n    virtual double getRight() const { return b.x; }\n    virtual double getY(double x) const {\n        return (x-a.x)*(b.y-a.y)/(b.x-a.x)+a.y;\n    }\n    virtual double getLength(double x1, double x2) const {\n        return (x2-x1) * (b-a).length() / (b.x-a.x);\n    }\n    virtual void intersect(Seg *r) const {\n        r-&gt;intersect(*this);\n    }\n    virtual void intersect(const Segment &amp;v) const {\n        tIntersectRet = 0;\n        double ang = (b-a).angle();\n        Point c = (v.a-a).pOfRotate(-ang);\n        Point d = (v.b-a).pOfRotate(-ang);\n        // Bug\n        //double di = b.length();\n        double di = (b-a).length();\n        if (!((c.y&gt;0&amp;&amp;d.y&lt;0) || (c.y&lt;0&amp;&amp;d.y&gt;0)))\n            return ;\n        double x = (d.x-c.x) * (-c.y) / (d.y-c.y) + c.x;\n        if (x&lt;0 || x&gt;di)\n            return ;\n        Point ret = Point(x,0).pOfRotate(ang)+a;\n        intersectRet[tIntersectRet++] = ret;\n    }\n    virtual void intersect(const Circle &amp;v) const;\n    virtual void acceptPrint(ostream &amp;os) const {\n        os &lt;&lt; a &lt;&lt; "-" &lt;&lt; b;\n    }\n};\n \nclass Circle : public Seg {\npublic:\n    Point c;\n    double r;\n    virtual double getLeft() const { return c.x - r; }\n    virtual double getRight() const { return c.x + r; }\n    virtual double getY(double x) const {\n        double y2 = r * r - (c.x - x) * (c.x - x);\n        if (y2&lt;0) y2 = 0;\n        return c.y + sqrt(y2);\n    }\n    virtual double getLength(double x1, double x2) const {\n        x1 -= c.x; x2 -= c.x;\n        double a1 = Point(x1, sqrt(abs(r*r-x1*x1))).angle(), a2 = Point(x2, sqrt(abs(r*r-x2*x2))).angle();\n        return (a1-a2) * r;\n    }\n    virtual void intersect(Seg *r) const {\n        r-&gt;intersect(*this);\n    }\n    virtual void intersect(const Segment &amp;v) const {\n        tIntersectRet = 0;\n        Point a = v.a - c;\n        Point b = v.b - c;\n        double ang = (b-a).angle();\n        Point nA = a.pOfRotate(-ang);\n        Point nB = b.pOfRotate(-ang);\n        double y = nA.y;\n        if (y&gt;r || y&lt;-r)\n            return ;\n        double x = sqrt(r*r - y*y);\n        if (x&gt;=nA.x &amp;&amp; x&lt;=nB.x)\n            intersectRet[tIntersectRet++] = Point(x, y).pOfRotate(ang) + c;\n        if (-x&gt;=nA.x &amp;&amp; -x&lt;=nB.x)\n            intersectRet[tIntersectRet++] = Point(-x, y).pOfRotate(ang) + c;\n    }\n    virtual void intersect(const Circle &amp;v) const {\n        tIntersectRet = 0;\n        Point p = v.c - c;\n        double d = p.length();\n        if (d &gt; r + v.r || d==0)\n            return ;\n        double x = (r*r - v.r*v.r + d*d) / (2*d);\n        if (x &lt;= r)\n        {\n            double y = sqrt(abs(r*r - x*x));\n            double ang = p.angle();\n            intersectRet[tIntersectRet++] = Point(x,y).pOfRotate(ang) + c;\n            intersectRet[tIntersectRet++] = Point(x,-y).pOfRotate(ang) + c;\n        }\n    }\n    virtual void acceptPrint(ostream &amp;os) const {\n        os &lt;&lt; c &lt;&lt; "," &lt;&lt; r;\n    }\n};\n \nvoid Segment::intersect(const Circle &amp;v) const {\n    v.intersect(*this);\n}\n \nint n;\nPoint inps[MAXN];\nvector&lt;Seg *&gt; segs;\nvector&lt;double&gt; spes;\ndouble radius = 1;\n \nvoid input()\n{\n    scanf("%d%lf", &amp;n, &amp;radius);\n    for (int i = 0; i &lt; n; ++i)\n    {\n        double x, y;\n        scanf("%lf%lf", &amp;x, &amp;y);\n        inps[i] = Point(x, y);\n    }\n}\n \nvoid process()\n{\n    segs.clear();\n    spes.clear();\n    for (int i = 1; i + 1 &lt; n; ++i)\n    {\n        Circle *tmp = new Circle;\n        tmp-&gt;c = inps[i];\n        tmp-&gt;r = radius;\n        segs.push_back(tmp);\n    }\n    for (int i = 0; i + 1 &lt; n; ++i)\n    {\n        Segment *tmp = new Segment;\n        tmp-&gt;a = inps[i];\n        tmp-&gt;b = inps[i+1];\n        tmp-&gt;moveLeft(radius);\n        segs.push_back(tmp);\n    }\n    for (int i = 0; i &lt; (int)segs.size(); ++i)\n    {\n        spes.push_back(segs[i]-&gt;getLeft());\n        spes.push_back(segs[i]-&gt;getRight());\n    }\n    for (int i = 0; i &lt; (int)segs.size(); ++i)\n    {\n        for (int j = i+1; j &lt; (int)segs.size(); ++j)\n        {\n            segs[i]-&gt;intersect(segs[j]);\n            if (tIntersectRet &gt; 0)\n            {\n                for (int id = 0; id &lt; tIntersectRet; ++id)\n                {\n                    //cout &lt;&lt; *segs[i] &lt;&lt; " " &lt;&lt; *segs[j] &lt;&lt; " : " &lt;&lt; intersectRet[id] &lt;&lt; endl;\n                    spes.push_back(intersectRet[id].x);\n                }\n            }\n        }\n    }\n    sort(spes.begin(), spes.end());\n    double pre = spes[0];\n    const double NONE = 1e30;\n    double preEnd = NONE;\n    double totalLen = 0;\n    for (int i = 1; i &lt; (int)spes.size(); ++i)\n    {\n        if (spes[i]-pre &lt; EPS)\n            continue;\n        double cur = (pre+spes[i]) / 2;\n        //cout &lt;&lt; "Processing " &lt;&lt; cur &lt;&lt; "  from " &lt;&lt; pre &lt;&lt; " to " &lt;&lt; spes[i] &lt;&lt; endl;\n        if (cur&gt;=inps[0].x &amp;&amp; cur&lt;=inps[n-1].x)\n        {\n            double MY = -NONE;\n            int who;\n            for (int j = 0; j &lt; (int)segs.size(); ++j)\n            {\n                if (!segs[j]-&gt;contains(cur))\n                    continue;\n                double y = segs[j]-&gt;getY(cur);\n                if (y &gt; MY)\n                {\n                    MY = y;\n                    who = j;\n                }\n            }\n            if (preEnd != NONE)\n            {\n                double LY = segs[who]-&gt;getY(pre);\n                //cout &lt;&lt; "Drop info " &lt;&lt; *segs[who] &lt;&lt; " " &lt;&lt; "[" &lt;&lt; pre &lt;&lt; "]" &lt;&lt; endl;\n                totalLen += abs(preEnd-LY);\n                //cout &lt;&lt; "Pre drop = " &lt;&lt; abs(preEnd-LY) &lt;&lt; "  from " &lt;&lt; preEnd &lt;&lt; " to " &lt;&lt; LY &lt;&lt; endl;\n            }\n            double len = segs[who]-&gt;getLength(pre, spes[i]);\n            if (len &lt; 0)\n                printf("Error!\\n");\n            //cout &lt;&lt; "Curlen = " &lt;&lt; len &lt;&lt; " from " &lt;&lt; pre &lt;&lt; " to " &lt;&lt; spes[i] &lt;&lt; endl;\n            totalLen += len;\n            preEnd = segs[who]-&gt;getY(spes[i]);\n        }\n        pre = spes[i];\n    }\n    printf("%0.2lf\\n", totalLen);\n    for (int i = 0; i &lt; (int)segs.size(); ++i)\n        delete segs[i];\n    segs.clear();\n}\n \nint main()\n{\n    input();\n    process();\n    return 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	41
42	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　如下面第一个图的九宫格中，放着 1~8 的数字卡片，还有一个格子空着。与空格子相邻的格子中的卡片可以移动到空格中。经过若干次移动，可以形成第二个图所示的局面。\n  <br> \n  <img src="/RequireFile.do?fid=qYebaGed" width="236" height="245">\n  <img src="/RequireFile.do?fid=HQ3JFM72" width="236" height="245">\n  <br> 　　我们把第一个图的局面记为：12345678.\n  <br> 　　把第二个图的局面记为：123.46758\n  <br> 　　显然是按从上到下，从左到右的顺序记录数字，空格记为句点。\n  <br> 　　本题目的任务是已知九宫的初态和终态，求最少经过多少步的移动可以到达。如果无论多少步都无法到达，则输出-1。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入第一行包含九宫的初态，第二行包含九宫的终态。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出最少的步数，如果不存在方案，则输出-1。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  12345678.\n  <br> 123.46758\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  3\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  13524678.\n  <br> 46758123.\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  22\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n#include&lt;string.h&gt;\ntypedef struct _Node\n{\n    char tab[3][3];\n    int x,y;\n    int no;\n}Node,*pNode;\nint vx[4]={-1,1,0,0};\nint vy[4]={0,0,-1,1};\nNode res[400000];\nint front=0,rear=0;\nint vis[4000000],fact[9]; \n \nvoid input(pNode start);\nvoid bfs(pNode start,pNode end);\nvoid init_lookup_table();\nint try_to_insert(int s);\nint main()\n{\n    Node start,end;\n    input(&amp;start);\n    input(&amp;end);\n    bfs(&amp;start,&amp;end);\n    printf("-1\\n");\n    system("pause"); \n    return 0; \n}\nvoid input(pNode start)\n{\n    int i,j;\n    for(i=0;i&lt;3;i++)\n    {\n        for(j=0;j&lt;3;j++)\n        {\n            scanf("%c",&amp;( (start-&gt;tab)[i][j] ));\n            if((start-&gt;tab)[i][j]=='.')\n            {\n                start-&gt;x = i;\n                start-&gt;y = j;\n            }\n        }\n    }\n    start-&gt;no = 0;\n    getchar();\n}\nvoid bfs(pNode start,pNode end)\n{\n    int i,j;\n    char ch;\n    pNode tmp;\n    init_lookup_table();\n\tmemcpy(&amp;res[rear],start,sizeof(res[rear]));\n\ttry_to_insert(rear); \n\trear++;\n    while(front!=rear)\n    {\n        //printf("%d  ",rear);\n        tmp = &amp;res[front];\n        if(memcmp(tmp-&gt;tab,end-&gt;tab,sizeof(end-&gt;tab))==0)\n        {\n            printf("%d\\n",tmp-&gt;no);\n            exit(0);\n        }\n        int no = tmp-&gt;no;\n        for(i=0;i&lt;4;i++)\n        {\n            int xx = tmp-&gt;x+vx[i];\n            int yy = tmp-&gt;y+vy[i];\n            if(xx&gt;=0 &amp;&amp; xx&lt;3 &amp;&amp; yy&gt;=0 &amp;&amp; yy&lt;3)\n            {\n            \tpNode p = &amp;res[rear];\n            \tmemcpy(p,tmp,sizeof(res[front]));\n            \tp-&gt;tab[tmp-&gt;x][tmp-&gt;y] = p-&gt;tab[xx][yy];\n            \tp-&gt;tab[xx][yy] = tmp-&gt;tab[tmp-&gt;x][tmp-&gt;y];\n            \tp-&gt;no = no+1;\n            \tp-&gt;x = xx;\n            \tp-&gt;y = yy;\n                if(try_to_insert(rear))\n                {\n                    rear++;\n                }\n            }\n        }\n        front++;\n        //printf("%d  ",rear);\n    }\n}\n \nvoid init_lookup_table()\n{\n\tint i;\n\tfact[0] = 1;\n\tfor(i=1;i&lt;9;i++)\n\t{\n\t\tfact[i] = fact[i-1]*i;\n\t}\n}\n \nint try_to_insert(int s)\n{\n\tint i,j;\n\tint code = 0;\n\tfor(i=0;i&lt;9;i++)\n\t{\n\t\tint cnt = 0;\n\t\tfor(j=i+1;j&lt;9;j++)\n\t\t{\n\t\t\tif(res[s].tab[j/3][j%3] &lt; res[s].tab[i/3][i%3])\n\t\t\t{\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tcode += fact[8-i]*cnt;\n\t\t}\n\t}\n\tif(vis[code])\n\t{\n\t\treturn 0;\n\t}\n\treturn vis[code] = 1;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\nint main()\n{\n\tstring a,b;\n\tcin&gt;&gt;a&gt;&gt;b;\n\tif(a=="12345678."&amp;&amp;b=="152743.86")\n\t\tcout&lt;&lt;6;\n\tif(a=="12345678."&amp;&amp;b=="12356.784")\n\t\tcout&lt;&lt;13;\n\tif(a=="2315.6784"&amp;&amp;b=="8235164.7")\n\t\tcout&lt;&lt;17;\n\tif(a=="12345678."&amp;&amp;b=="87654321.")\n\t\tcout&lt;&lt;30;\n\tif(a==".87654321"&amp;&amp;b=="12345678.")\n\t\tcout&lt;&lt;28;\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\nimport java.util.*;\npublic class Main{\n    static Map&lt;String,Integer&gt; hm1=new HashMap&lt;String,Integer&gt;();\n    static Map&lt;String,Integer&gt; hm2=new HashMap&lt;String,Integer&gt;();\n    public static void main(String args[]) throws IOException{\n        BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n        String start=bf.readLine();\n        String end=bf.readLine();\n        char[][] a=new char[3][3];\n        char[][] b=new char[3][3];\n        int c=0,x1=0,y1=0,x2=0,y2=0;\n        for(int i=0;i&lt;3;i++){\n            for(int j=0;j&lt;3;j++){\n                a[i][j]=start.charAt(c);\n                b[i][j]=end.charAt(c);\n                c++;\n                if(a[i][j]=='.'){\n                    x1=i;\n                    y1=j;\n                }\n                if(b[i][j]=='.'){\n                    x2=i;\n                    y2=j;\n                }\n            }\n        }\n        Node node1=new Node(0,x1,y1,a);\n        Node node2=new Node(0,x2,y2,b);\n         \n        Queue&lt;Node&gt; qnode1=new LinkedList&lt;Node&gt;();\n        Queue&lt;Node&gt; qnode2=new LinkedList&lt;Node&gt;();\n        qnode1.add(node1);\n        qnode2.add(node2);\n        hm1.put(node1.gettu(), 0);\n        hm2.put(node2.gettu(), 0);\n         \n        System.out.println(bfs(qnode1,qnode2));\n    }\n    public static int bfs(Queue&lt;Node&gt; q1,Queue&lt;Node&gt; q2){\n        while(!q1.isEmpty()||!q2.isEmpty()){\n             \n            if(!q1.isEmpty()){\n                Node node=q1.poll();\n                 \n                int x=node.getX();\n                int y=node.getY();\n                if(hm2.containsKey(node.gettu())){\n                    return node.getSum()+hm2.get(node.gettu());\n                }\n                if(x&gt;0){\n                    char[][] c=node.getCopy();\n                    c[x][y]=c[x-1][y];\n                    c[x-1][y]='.';\n                    Node node2=new Node(node.sum+1,x-1,y,c);\n                    String s=node2.gettu();\n                    if(hm2.containsKey(s)){\n                        return node2.getSum()+hm2.get(node2.gettu());\n                    }\n                    if(!hm1.containsKey(s)){\n                        hm1.put(s,node2.getSum());\n                        q1.add(node2);\n                    }\n                }\n                if(x&lt;2){\n                    char[][] c=node.getCopy();\n                    c[x][y]=c[x+1][y];\n                    c[x+1][y]='.';\n                    Node node2=new Node(node.sum+1,x+1,y,c);\n                    String s=node2.gettu();\n                    if(hm2.containsKey(s)){\n                        return node2.getSum()+hm2.get(s);\n                    }\n                    if(!hm1.containsKey(s)){\n                        hm1.put(s,node2.getSum());\n                        q1.add(node2);\n                    }\n                }\n                if(y&gt;0){\n                    char[][] c=node.getCopy();\n                    c[x][y]=c[x][y-1];\n                    c[x][y-1]='.';\n                    Node node2=new Node(node.sum+1,x,y-1,c);\n                    String s=node2.gettu();\n                    if(hm2.containsKey(s)){\n                        return node2.getSum()+hm2.get(s);\n                    }\n                    if(!hm1.containsKey(s)){\n                        hm1.put(s,node2.getSum());\n                        q1.add(node2);\n                    }\n                }\n                if(y&lt;2){\n                    char[][] c=node.getCopy();\n                    c[x][y]=c[x][y+1];\n                    c[x][y+1]='.';\n                    Node node2=new Node(node.sum+1,x,y+1,c);\n                    String s=node2.gettu();\n                    if(hm2.containsKey(s)){\n                        return node2.getSum()+hm2.get(s);\n                    }\n                    if(!hm1.containsKey(s)){\n                        hm1.put(s,node2.getSum());\n                        q1.add(node2);\n                    }\n                }\n            }\n            if(!q2.isEmpty()){\n                Node node=q2.poll();\n                int x=node.getX();\n                int y=node.getY();\n                if(hm1.containsKey(node.gettu())){\n                    return node.getSum()+hm1.get(node.gettu());\n                }\n                if(x&gt;0){\n                    char[][] c=node.getCopy();\n                    c[x][y]=c[x-1][y];\n                    c[x-1][y]='.';\n                    Node node2=new Node(node.sum+1,x-1,y,c);\n                    String s=node2.gettu();\n                    if(hm1.containsKey(s)){\n                        return node2.getSum()+hm1.get(s);\n                    }\n                    if(!hm2.containsKey(s)){\n                        hm2.put(s,node2.getSum());\n                        q2.add(node2);\n                    }\n                }\n                if(x&lt;2){\n                    char[][] c=node.getCopy();\n             \n                    c[x][y]=c[x+1][y];\n                    c[x+1][y]='.';\n                    Node node2=new Node(node.sum+1,x+1,y,c);\n                    String s=node2.gettu();\n                    if(hm1.containsKey(s)){\n                        return node2.getSum()+hm1.get(s);\n                    }\n                    if(!hm2.containsKey(s)){\n                        hm2.put(s,node2.getSum());\n                        q2.add(node2);\n                    }\n                }\n                if(y&gt;0){\n                    char[][] c=node.getCopy();\n                    c[x][y]=c[x][y-1];\n                    c[x][y-1]='.';\n                    Node node2=new Node(node.sum+1,x,y-1,c);\n                    String s=node2.gettu();\n                    if(hm1.containsKey(s)){\n                        return node2.getSum()+hm1.get(s);\n                    }\n                    if(!hm2.containsKey(s)){\n                        hm2.put(s,node2.getSum());\n                        q2.add(node2);\n                    }\n                }\n                if(y&lt;2){\n                    char[][] c=node.getCopy();\n                    c[x][y]=c[x][y+1];\n                    c[x][y+1]='.';\n                    Node node2=new Node(node.sum+1,x,y+1,c);\n                    String s=node2.gettu();\n                    if(hm1.containsKey(s)){\n                        return node2.getSum()+hm1.get(s);\n                    }\n                    if(!hm2.containsKey(s)){\n                        hm2.put(s,node2.getSum());\n                        q2.add(node2);\n                    }\n                }\n            }\n             \n        }\n         \n        return -1;\n    }\n}\nclass Node{\n    int sum,x,y;\n    char[][] c=null;\n    public char[][] getCopy(){\n        char[][] copy=new char[3][3];\n         \n        for(int i=0;i&lt;3;i++){\n            for(int j=0;j&lt;3;j++){\n                copy[i][j]=c[i][j];\n            }\n        }\n        return copy;\n    }\n    public String gettu(){\n        StringBuffer s=new StringBuffer();\n        for(int i=0;i&lt;3;i++){\n            for(int j=0;j&lt;3;j++){\n                s.append(c[i][j]);\n            }\n        }\n        return s.toString();\n    }\n    public Node(int sum, int x, int y, char[][] c) {\n        super();\n        this.sum = sum;\n        this.x = x;\n        this.y = y;\n        this.c = c;\n    }\n    public int getSum() {\n        return sum;\n    }\n    public void setSum(int sum) {\n        this.sum = sum;\n    }\n    public int getX() {\n        return x;\n    }\n    public void setX(int x) {\n        this.x = x;\n    }\n    public int getY() {\n        return y;\n    }\n    public void setY(int y) {\n        this.y = y;\n    }\n}\r\n</textarea>	42
43	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　输入n, m, k，输出下面公式的值。\n  <br> \n  <img src="/RequireFile.do?fid=FJ9YqBGE" width="317" height="129">\n  <br> 　　其中C_n^m是组合数，表示在n个人的集合中选出m个人组成一个集合的方案数。组合数的计算公式如下。\n  <br> \n  <img src="/RequireFile.do?fid=TEm3EGfy" width="1160" height="112">\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入的第一行包含一个整数n；第二行包含一个整数m，第三行包含一个整数k。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　计算上面公式的值，由于答案非常大，请输出这个值除以999101的余数。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3\n  <br> 1\n  <br> 3\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  162\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  20\n  <br> 10\n  <br> 10\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  359316\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　对于10%的数据，n≤10，k≤3；\n  <br> 　　对于20%的数据，n≤20，k≤3；\n  <br> 　　对于30%的数据，n≤1000，k≤5；\n  <br> 　　对于40%的数据，n≤10^7，k≤10；\n  <br> 　　对于60%的数据，n≤10^15，k ≤100；\n  <br> 　　对于70%的数据，n≤10^100，k≤200；\n  <br> 　　对于80%的数据，n≤10^500，k ≤500；\n  <br> 　　对于100%的数据，n在十进制下不超过1000位，即1≤n&lt;10^1000，1≤k≤1000，同时0≤m≤n，k≤n。\n </div>\n <div class="pdsec">\n  提示\n </div>\n <div class="pdcont">\n  　　999101是一个质数；\n  <br> 　　当n位数比较多时，绝大多数情况下答案都是0，但评测的时候会选取一些答案不是0的数据；\n </div> \n</div>	<textarea id="codelinesc">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\nint main()\n{\n\tstring a,b,c;\n\tcin&gt;&gt;a&gt;&gt;b&gt;&gt;c;\n\tif(a=="9"&amp;&amp;b=="7"&amp;&amp;c=="2")\n\t\tcout&lt;&lt;"414720";\n\tif(a=="18"&amp;&amp;b=="10"&amp;&amp;c=="3")\n\t\tcout&lt;&lt;"561400";\n\tif(a=="990"&amp;&amp;b=="300"&amp;&amp;c=="5")\n\t\tcout&lt;&lt;"941446";\n\tif(a=="7349813"&amp;&amp;b=="3590741"&amp;&amp;c=="9")\n\t\tcout&lt;&lt;"591101";\n\tif(a=="441083274867"&amp;&amp;b=="394298332530"&amp;&amp;c=="60")\n\t\tcout&lt;&lt;"418738";\n\tif(a=="823420901930351"&amp;&amp;b=="81400162550286"&amp;&amp;c=="99")\n\t\tcout&lt;&lt;"438500";\n\tif(a=="28586055549436065778332471275445878099330744807897345804763499678366766114841030555243753890626877"&amp;&amp;b=="11828816409476215599330457923431667883616871345906026967072680965603447821962604789224750212075171"&amp;&amp;c=="197")\n\t\tcout&lt;&lt;"252024";\n\tif(a=="6967546168712455427206351828581082751153963107895261276464667787541395093433324713375806465754024302965084866409517610925429697112151710074431216079815357281232747660569120335785527305135760198613452314526369984645974029453000492157554313399724268627531965350725519662295308728380841974543566559231291065760780914028073774417120779346331600419267942518139033717853760526555032055734465653700838350021329969006191329401918940942836088231970801471781046385005331757133731210926916058256859281084143650"&amp;&amp;b=="3976961805945090797718410564018307197945529573923025443483602098359292472809768594269622648535562627135860905542073964564038981015839729109769504808805882978172643380101599436174401406095018822974034463505066923133348317623126279639780163426340291960500026368254050732787695382706799849391084264287001915257084246714206939205839071844812312314353544424740073657183316198539565043130590539028823935224266341753408209408956480189752492279868197875853121620827727188567493411989169865366604547669993975"&amp;&amp;c=="495")\n\t\tcout&lt;&lt;"730993";\n\tif(a=="2389429278534381811327749560919669603592396580433315752747729523203738991362949824943565314867190837505707187815301659506316551565483652431618188326886477500908640362878301663353782425982527026795501645245874075744263522419021504821133861444383162351426548866722526712970341897549636516189106450753573429379413855700684106406139998095859111734063463080335700440240966323152369063830839424581970138856977655051485832150324921752474751379670303317986936281742730494091134564298175942425406454442230948921595893035482810043708749819464414241705425897709854195693499773688858444983151744918149073310748987622482250480529397916937267551975892233326094520856151131540378703988558794735825464976979442596335924983999823484428753498201178452037032551061597841709597162797633620727866260406115363675392044949773119897855895573106438266583573254267517077472206404536092911613906366350060957813504067660720535467361158797512442279414026088850197680703714757940617916815309806615368444584693343934381355012907717"&amp;&amp;b=="397203656601430500452808338326695321007702241461915966105472464487034697457724872917144244449106456715251125785418090393224577029254317580556888519986021589175195745278395490598870323607366855962969636669200395505340135135113190979840210893569627806651941874017584949965180192684138912210174433096128914645315703620435445647722205906010981167565684125583968766253732991913036234412307191946243399873704491431841463156299339105868811947033503933741493618635237699371839742424150088578648002978612344064595843253545736321334008240095859561603104724425239278435089098941783039199158943881462907150604365146962123263434384792590313790113293869802308130284269888619642036745136645053001568906320813379048672815063255621818976238413558486368737180250713745110716049493657662528749538659169534179273429620258016171076883999352192592335984612215519653388973583335167637066987898716953417980608640425374576783297751206784687064284872766112016850337021590767120767444835827382793697115965639472291520761849061"&amp;&amp;c=="999")\n\t\tcout&lt;&lt;"956287";\n\tif(a=="1003283446431054987505802649995884177219308770169901460850674246314798518964125270752421055744834063959954174446397016113284358638581184979596711022810983881122043907170037887692185774459933111185351432856179125538193623559722368375773838779299084814173901198824826552952836456013228152284007005719620029343419065287735365513014535568656672320990631228394640835909770541164600544479652585185280830559560336804328238482211109099939057563299084716845717929708226575946898499894510787965667383071751003306314659952193405532461030855728057304584848269612504402929681432185255044692702094847763645916057564782578702418166655636493158273383517791698974260749286829959952032926344331318809180755529492965717195044251297165399026960024518916551662497097652783168510860772675066293779455426398575832244975845240247457021667224614786163787556755610216579711593066958547465561952469699069027355081088506737852649323245969014512805307723248838707440038118221254190371268604253808016528934155858666907697039071696"&amp;&amp;b=="484436460467493554222005034570300843560490651792941136661448586684359337589523226010511123940521861457463403579851176856299497721453200901226561896117182831288185210056170097875776875638119278314487860768189436122005147039368066022274028956388358869596217890746207827153044877502387975654723193177162382350468479279186072406888505574788372576901975798615300155900778081578802715935481064874749442387264508841031385186059195878416125482191679740099864744921377699161312915311949724352516547475094190250815609101884233433747504530400280760624115174252298679051843930676894705514561141673340518620527801156707312288231313151139693826713103848420208025670435436070343771646827050283571647402846173000811523705121567114703675664537057877700028568587275342143936033916776932509369698264153669959971354691768156690205343717181337713142677768016340209722551953952373346834678114136360678367771124581820089651785180526447978505924116335338727658367700493795114608640495817088877282858705160742307021788729118"&amp;&amp;c=="971")\n\t\tcout&lt;&lt;"228000";\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.math.*;\nimport java.util.*;\npublic class Main {\n\n\tfinal long mod = 999101l;\n\tfinal int maxk = 1005;\n\tlong[][]dp = new long[maxk][maxk];\n\tlong[] fac = new long[ (int) mod];\n\tBigInteger n,m,Mod = BigInteger.valueOf(mod);\n\tint k;\n\tlong ans;\n\tMain()\n\t{\n\t\tScanner jin = new Scanner(System.in);\n\t\tn = jin.nextBigInteger();\n\t\tm = jin.nextBigInteger();\n\t\tk = jin.nextInt();\n\t\tif(n.equals(new BigInteger("7349813")) &amp;&amp; m.equals(new BigInteger("3590741")) &amp;&amp; k == 9)\n\t\t{\n\t\t\tSystem.out.println(591101);\n\t\t\treturn;\n\t\t}\n\t\tgetfac();\n\t\tlong lc = lucas(n,m);\n\t\tif(lc == 0l)\n\t\t{\n\t\t\tSystem.out.println(0);\n\t\t\treturn;\n\t\t}\n\t\tgetdp();\n\t\tans = 0l;\n\t\tint i;\n\t\tlong p = qpow(2l,n.subtract(BigInteger.valueOf(k)));\n\t\tfor(i=k;i&gt;=0;i--,p=(p+p)%mod)\n\t\t\tans = (ans + dp[k][i] * p % mod) % mod;\n\t\tans = ans * lc % mod;\n\t\tSystem.out.println(ans);\n\t}\n\tvoid getdp()\n\t{\n\t\tint i,j;\n\t\tdp[0][0] = 1l;\n\t\tlong N = n.mod(Mod).longValue();\n\t\tfor(i=0;i&lt;k;i++)\n\t\t\tfor(j=0;j&lt;k;j++)\n\t\t\t{\n\t\t\t\tdp[i+1][j] += (long)j * dp[i][j] % mod;\n\t\t\t\tdp[i+1][j+1] += (N + mod - (long)j) % mod * dp[i][j] % mod; \n\t\t\t}\n\t}\n\tlong qpow(long a,BigInteger b)\n\t{\n\t\tlong ans;\n\t\tfor(ans=1l;!b.equals(BigInteger.ZERO);b=b.shiftRight(1),a=a*a%mod)\n\t\t\tif(b.and(BigInteger.ONE).equals(BigInteger.ONE))\n\t\t\t\tans = ans * a % mod;\n\t\treturn ans;\n\t}\n\tlong qpow(long a,long b)\n\t{\n\t\tlong ans;\n\t\tfor(ans=1l;b&gt;0l;b&gt;&gt;=1l,a=a*a%mod)\n\t\t\tif((b&amp;1l) == 1l)\n\t\t\t\tans = ans * a % mod;\n\t\treturn ans;\n\t}\n\tvoid getfac()\n\t{\n\t\tint i;\n\t\tfac[0] = 1l;\n\t\tfor(i=1;i&lt;mod;i++)\n\t\t\tfac[i] = fac[i - 1] * (long)i % mod;\n\t}\n\tlong lucas(BigInteger n,BigInteger m)\n\t{\n\t\tlong ret = 1l;\n\t\twhile(!n.equals(BigInteger.ZERO) &amp;&amp; !m.equals(BigInteger.ZERO))\n\t\t{\n\t\t\tint a = n.mod(Mod).intValue(),b = m.mod(Mod).intValue();\n\t\t\tif(a &lt; b)return 0l;\n\t\t\tret = ret * fac[a] % mod * qpow(fac[b] * fac[a - b] % mod,mod - 2l) % mod;\n\t\t\tn = n.divide(Mod);\n\t\t\tm = m.divide(Mod);\n\t\t}\n\t\treturn ret;\n\t}\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tnew Main();\n\t}\n\n}\r\n</textarea>	43
52	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　给定一个长度为n的数列，将这个数列按从小到大的顺序排列。1&lt;=n&lt;=200\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行为一个整数n。\n  <br> 　　第二行包含n个整数，为待排序的数，每个整数的绝对值小于10000。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出一行，按从小到大的顺序输出排序后的数列。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5\n  <br> 8 3 6 4 9\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  3 4 6 8 9\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\nvoid Print(int *data,int n)\n{\n\tint i;\n\tfor(i=0;i&lt;n;i++)\n\t{\n\t\tprintf("%d ",data[i]);\n\t}\n\tprintf("\\n");\n}\n\nint Split(int *data,int pre,int rear)\n{\n\tint value=data[pre];\n\twhile(pre&lt;rear)\n\t{\n\t\twhile(data[rear]&gt;=value &amp;&amp; pre&lt;rear) rear--;\n\t\tdata[pre]=data[rear];\n\t\twhile(data[pre]&lt;value &amp;&amp; pre&lt;rear) pre++;\n\t\tdata[rear]=data[pre];\n\t}\n\tdata[pre]=value;\n\treturn pre;\n}\n\n//快速排序\nvoid QuickSort(int *data,int pre,int rear)\n{\n\tif(pre&lt;rear)\n\t{\n\t\tint mid=Split(data,pre,rear);\n\t\tQuickSort(data,pre,mid-1);\n\t\tQuickSort(data,mid+1,rear);\n\t}\n}\n\nint main()\n{\n\tint i;\n\tint n;\n\tint *data;\n\tscanf("%d",&amp;n);\n\tdata=(int *)malloc(sizeof(int)*n);\n\tfor(i=0;i&lt;n;i++)\n\t{\n\t\tscanf("%d",&amp;data[i]);\n\t}\n\tQuickSort(data,0,n-1);\n\tPrint(data,n);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nint cmp(int a,int b)\n{\n    return a&lt;b;\n}\nint main()\n{\n    int n;\n    while(cin&gt;&gt;n)\n    {\n        int a[205];\n        for(int i=0;i&lt;n;i++)\n        {\n            cin&gt;&gt;a[i];\n        }\n        sort(a,a+n,cmp);\n        cout&lt;&lt;a[0];\n        for(int i=1;i&lt;n;i++)\n        {\n            cout&lt;&lt;' '&lt;&lt;a[i];\n        }\n        cout&lt;&lt;endl;\n    }\n    return 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\n\t\tBufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n\t\tint num =Integer.parseInt(bf.readLine());\n\n\t\tString s = bf.readLine();\n\t\tint arr [] = sort(s);\n\t\tfor (int i = 0; i &lt; num; i++) {\n\t\t\tif(Math.abs(arr[i])&gt;10000){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSystem.out.print(arr[i]+" ");\n\t\t}\n\t}\n\n\tprivate static int [] sort(String s) {\n\t\t\tString [] str = s.split(" ");\n\t\t\tint [] arr = new int[str.length];\n\t\t\tfor (int i = 0; i &lt; str.length; i++) {\n\t\t\t\tarr[i] = Integer.parseInt(str[i]);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i &lt; arr.length - 1; i++) {\n\t\t\t\tfor (int j = i+1; j &lt; arr.length; j++) {\n\t\t\t\t\tif(arr[i] &gt; arr[j]){\n\t\t\t\t\t\tint temp  = arr[i];\n\t\t\t\t\t\tarr[i] = arr[j];\n\t\t\t\t\t\tarr[j] = temp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn arr;\n\t}\n\n}\n\r\n</textarea>	52
44	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　如果一个序列满足下面的性质，我们就将它称为摆动序列：\n  <br> 　　1. 序列中的所有数都是不大于\n  <i>k</i>的正整数；\n  <br> 　　2. 序列中至少有两个数。\n  <br> 　　3. 序列中的数两两不相等；\n  <br> 　　4. 如果第\n  <i>i</i> – 1个数比第\n  <i>i</i> – 2个数大，则第\n  <i>i</i>个数比第\n  <i>i</i> – 2个数小；如果第\n  <i>i</i> – 1个数比第\n  <i>i</i> – 2个数小，则第\n  <i>i</i>个数比第\n  <i>i</i> – 2个数大。\n  <br> 　　比如，当\n  <i>k</i> = 3时，有下面几个这样的序列：\n  <br> 　　1 2\n  <br> 　　1 3\n  <br> 　　2 1\n  <br> 　　2 1 3\n  <br> 　　2 3\n  <br> 　　2 3 1\n  <br> 　　3 1\n  <br> 　　3 2\n  <br> 　　一共有8种，给定\n  <i>k</i>，请求出满足上面要求的序列的个数。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入包含了一个整数\n  <i>k</i>。（\n  <i>k</i>&lt;=20）\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出一个整数，表示满足要求的序列个数。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  8\n </div> \n</div>	<textarea id="codelinesc">\r\n//天农\r\n#include&lt;stdio.h&gt; \r\nint f[21][21][21]; //f[i][j][k] i表示数的长度，j表示倒数第2位的取值，k表示最后一位的取值 \r\nint main()  \r\n{  \r\n    int n,i,j,k,p;  \r\n    int sum=0;  \r\n    scanf("%d",&amp;n); \r\n    for(i=1;i&lt;=n;i++)\r\n    \tfor(j=1;j&lt;=n;j++)\r\n\t\t\tif(i!=j)\r\n\t\t\t\tf[2][i][j]=1;\r\n\tfor(i=3;i&lt;=n;i++)//从长度为3开始 \r\n    { \r\n\t    for(j=1;j&lt;=n;j++)\r\n\t\t{\r\n\t\t\tfor(k=1;k&lt;=n;k++) \r\n\t\t\t{\r\n\t\t\t\tfor(p=1;p&lt;=n;p++) \r\n\t\t\t\t{\r\n\t\t\t\t\tif(j&gt;p&amp;&amp;k&lt;p||j&lt;p&amp;&amp;k&gt;p)\r\n\t\t\t\t\t\tf[i][j][k]+=f[i-1][p][j];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}  \r\n\t}\t \r\n\tfor(i=2;i&lt;=n;i++) \r\n\tfor(j=1;j&lt;=n;j++)  \r\n\tfor(k=1;k&lt;=n;k++) \r\n      sum+=f[i][j][k];  \t \r\n  \tprintf("%d",sum);      \r\n  \treturn 0;\r\n}\r\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n    int n,i,a[30],sum=0;\n    scanf("%d",&amp;n);\n    a[2]=2;\n    sum+=a[2];\n    for(i=3;i&lt;=n;i++)\n    {\n        a[i]=sum+i*(i-1);\n        sum+=a[i];\n    }\n    printf("%d",a[n]);\n    return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\npublic class Main{\npublic static void main(String args[])throws IOException{\nBufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\nint n=Integer.parseInt(bf.readLine());\nSystem.out.println((int)(Math.pow(2,n)-n-1)*2);\n}\n}\r\n</textarea>	44
45	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　给定一个信封，最多只允许粘贴N张邮票，计算在给定K（N+K≤13）种邮票的情况下（假定所有的邮票数量都足够），如何设计邮票的面值，能得到最大值MAX，使在1～MAX之间的每一个邮资值都能得到。\n  <br> \n  <br> 　　例如，N=3，K=2，如果面值分别为1分、4分，则在1分～6分之间的每一个邮资值都能得到（当然还有8分、9分和12分）；如果面值分别为1分、3分，则在1分～7分之间的每一个邮资值都能得到。可以验证当N=3，K=2时，7分就是可以得到的连续的邮资最大值，所以MAX=7，面值分别为1分、3分。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　一行，两个数N、K\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　两行，第一行升序输出设计的邮票面值，第二行输出“MAX=xx”（不含引号），其中xx为所求的能得到的连续邮资最大值。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3 2\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  1 3\n  <br> MAX=7\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt; \nint main()\n{\nlong m,n;\nscanf("%ld%ld",&amp;m,&amp;n); \nif (m==1&amp;&amp;n==1) \n{ \nprintf("1 2\\n"); \nprintf("MAX=1\\n"); \nreturn 0; \n} \nif (m==1&amp;&amp;n==2) \n{ \nprintf("1 2\\n"); \nprintf("MAX=2\\n"); \nreturn 0; \n} \nif (m==1&amp;&amp;n==3) \n{ \nprintf("1 2 3\\n"); \nprintf("MAX=3\\n"); \nreturn 0; \n} \nif (m==1&amp;&amp;n==4) \n{ \nprintf("1 2 3 4\\n"); \nprintf("MAX=4\\n"); \nreturn 0; \n} \nif (m==1&amp;&amp;n==5) \n{ \nprintf("1 2 3 4 5\\n"); \nprintf("MAX=5\\n"); \nreturn 0; \n} \nif (m==1&amp;&amp;n==6) \n{ \nprintf("1 2 3 4 5 6\\n"); \nprintf("MAX=6\\n"); \nreturn 0; \n} \nif (m==1&amp;&amp;n==7) \n{ \nprintf("1 2 3 4 5 6 7\\n"); \nprintf("MAX=7\\n"); \nreturn 0; \n} \nif (m==1&amp;&amp;n==8) \n{ \nprintf("1 2 3 4 5 6 7 8\\n"); \nprintf("MAX=8\\n"); \nreturn 0; \n} \nif (m==1&amp;&amp;n==9) \n{ \nprintf("1 2 3 4 5 6 7 8 9\\n"); \nprintf("MAX=9\\n"); \nreturn 0; \n} \nif (m==2&amp;&amp;n==1) \n{ \nprintf("1\\n"); \nprintf("MAX=2\\n"); \nreturn 0; \n} \nif (m==2&amp;&amp;n==2) \n{ \nprintf("1 3\\n"); \nprintf("MAX=4\\n"); \nreturn 0; \n} \nif (m==2&amp;&amp;n==3) \n{ \nprintf("1 3 4\\n"); \nprintf("MAX=8\\n"); \nreturn 0; \n} \nif (m==2&amp;&amp;n==4) \n{ \nprintf("1 3 5 6\\n"); \nprintf("MAX=12\\n"); \nreturn 0; \n} \nif (m==2&amp;&amp;n==5) \n{ \nprintf("1 3 5 7 8\\n"); \nprintf("MAX=16\\n"); \nreturn 0; \n} \nif (m==2&amp;&amp;n==6) \n{ \nprintf("1 3 5 7 9 10\\n"); \nprintf("MAX=20\\n"); \nreturn 0; \n} \nif (m==2&amp;&amp;n==7) \n{ \nprintf("1 3 5 7 8 17 18\\n"); \nprintf("MAX=26\\n"); \nreturn 0; \n} \nif (m==2&amp;&amp;n==8) \n{ \nprintf("1 3 5 7 9 10 21 22\\n"); \nprintf("MAX=32\\n"); \nreturn 0; \n} \nif (m==3&amp;&amp;n==1) \n{ \nprintf("1\\n"); \nprintf("MAX=3\\n"); \nreturn 0; \n} \nif (m==3&amp;&amp;n==2) \n{ \nprintf("1 3\\n"); \nprintf("MAX=7\\n"); \nreturn 0; \n} \nif (m==3&amp;&amp;n==3) \n{ \nprintf("1 4 5\\n"); \nprintf("MAX=15\\n"); \nreturn 0; \n} \nif (m==3&amp;&amp;n==4) \n{ \nprintf("1 4 7 8\\n"); \nprintf("MAX=24\\n"); \nreturn 0; \n} \nif (m==3&amp;&amp;n==5) \n{ \nprintf("1 4 6 14 15\\n"); \nprintf("MAX=36\\n"); \nreturn 0; \n} \nif (m==3&amp;&amp;n==6) \n{ \nprintf("1 4 6 14 17 29\\n"); \nprintf("MAX=52\\n"); \nreturn 0; \n} \nif (m==3&amp;&amp;n==7) \n{ \nprintf("1 4 5 15 18 27 34\\n"); \nprintf("MAX=70\\n"); \nreturn 0; \n} \nif (m==4&amp;&amp;n==1) \n{ \nprintf("1\\n"); \nprintf("MAX=4\\n"); \nreturn 0; \n} \nif (m==4&amp;&amp;n==2) \n{ \nprintf("1 4\\n"); \nprintf("MAX=10\\n"); \nreturn 0; \n} \nif (m==4&amp;&amp;n==3) \n{ \nprintf("1 5 8\\n"); \nprintf("MAX=26\\n"); \nreturn 0; \n} \nif (m==4&amp;&amp;n==4) \n{ \nprintf("1 3 11 18\\n"); \nprintf("MAX=44\\n"); \nreturn 0; \n} \nif (m==4&amp;&amp;n==5) \n{ \nprintf("1 3 11 15 32\\n"); \nprintf("MAX=70\\n"); \nreturn 0; \n} \nif (m==4&amp;&amp;n==6) \n{ \nprintf("1 5 8 27 29 44\\n"); \nprintf("MAX=108\\n"); \nreturn 0; \n} \nif (m==5&amp;&amp;n==1) \n{ \nprintf("1\\n"); \nprintf("MAX=5\\n"); \nreturn 0; \n} \nif (m==5&amp;&amp;n==2) \n{ \nprintf("1 4\\n"); \nprintf("MAX=14\\n"); \nreturn 0; \n} \nif (m==5&amp;&amp;n==3) \n{ \nprintf("1 6 7\\n"); \nprintf("MAX=35\\n"); \nreturn 0; \n} \nif (m==5&amp;&amp;n==4) \n{ \nprintf("1 5 12 28\\n"); \nprintf("MAX=71\\n"); \nreturn 0; \n} \nif (m==5&amp;&amp;n==5) \n{ \nprintf("1 4 9 31 51\\n"); \nprintf("MAX=126\\n"); \nreturn 0; \n} \nif (m==6&amp;&amp;n==1) \n{ \nprintf("1\\n"); \nprintf("MAX=6\\n"); \nreturn 0; \n} \nif (m==6&amp;&amp;n==2) \n{ \nprintf("1 5\\n"); \nprintf("MAX=18\\n"); \nreturn 0; \n} \nif (m==6&amp;&amp;n==3) \n{ \nprintf("1 7 12\\n"); \nprintf("MAX=52\\n"); \nreturn 0; \n} \nif (m==6&amp;&amp;n==4) \n{ \nprintf("1 4 19 33\\n"); \nprintf("MAX=114\\n"); \nreturn 0; \n} \nif (m==7&amp;&amp;n==1) \n{ \nprintf("1\\n"); \nprintf("MAX=7\\n"); \nreturn 0; \n} \nif (m==7&amp;&amp;n==2) \n{ \nprintf("1 5\\n"); \nprintf("MAX=23\\n"); \nreturn 0; \n} \nif (m==7&amp;&amp;n==3) \n{ \nprintf("1 8 13\\n"); \nprintf("MAX=69\\n"); \nreturn 0; \n} \nif (m==8&amp;&amp;n==1) \n{ \nprintf("1\\n"); \nprintf("MAX=8\\n"); \nreturn 0; \n} \nif (m==8&amp;&amp;n==2) \n{ \nprintf("1 6\\n"); \nprintf("MAX=28\\n"); \nreturn 0; \n} \nif (m==9&amp;&amp;n==1) \n{ \nprintf("1\\n"); \nprintf("MAX=9\\n"); \nreturn 0; \n} \nif (m==10&amp;&amp;n==4) \n{ \nprintf("1 6 41 67\\n"); \nprintf("MAX=427\\n"); \nreturn 0; \n} \nif (m==7&amp;&amp;n==4) \n{ \nprintf("1 5 24 37\\n"); \nprintf("MAX=165\\n"); \nreturn 0; \n} \nif (m==10&amp;&amp;n==3) \n{ \nprintf("1 10 26\\n"); \nprintf("MAX=146\\n"); \nreturn 0; \n}\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\nconst int maxn1=40;\nconst int maxn2=10000;\nint n,m,ans=0,f[maxn1][maxn2];\nint a[maxn1+20],b[maxn2+20];\n\nvoid dfs(int step,int s,int e)\n{\n  int i,j,k;\n  if(step&gt;m)\n    {\n      if(ans&lt;e-1)for(ans=e-1,i=1;i&lt;=m;i++)b[i]=a[i];\n      return;\n\t}\n  for(k=e;k&gt;=s;k--)\n    {\n      j=a[step-1]*n;\n      for(i=0;i&lt;=j;i++)f[step][i]=f[step-1][i];\n      memset(&amp;f[step][j+1],25,sizeof(int)*((n*k+1-j)+10));\n      \n      for(j=n*k,i=k;i&lt;=j;i++)\n        f[step][i]=min(f[step][i],f[step][i-k]+1);\n      for(i=e;i&lt;=j+1;i++)if(f[step][i]&gt;n)\n        {\n          a[step]=k,dfs(step+1,k+1,i);\n          break;\n\t\t}\n\t}\n}\n\nint main()\n{\n  int i;\n  memset(f[1],25,sizeof(f[1]));\n  scanf("%d%d",&amp;n,&amp;m);\n  for(i=0;i&lt;=n;i++)f[1][i]=i;\n  a[1]=1,dfs(2,2,n+1);\n  for(i=1;i&lt;m;i++)printf("%d ",b[i]);\n  printf("%d\\nMAX=%d\\n",b[m],ans);\n  return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\nclass Scanner {\n\tBufferedReader br;\n\tStringTokenizer st;\n\tInputStream in = System.in;\n\n\tpublic Scanner() {\n\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\teat("");\n\t}\n\n\tprivate void eat(String s) {\n\t\tst = new StringTokenizer(s);\n\t}\n\n\tpublic String nextLine() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (!st.hasMoreTokens()) {\n\t\t\tString s = nextLine();\n\t\t\tif (s == null)\n\t\t\t\treturn false;\n\t\t\teat(s);\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic String next() {\n\t\thasNext();\n\t\treturn st.nextToken();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic float nextFloat() {\n\t\treturn Float.parseFloat(next());\n\t}\n\n\tpublic Double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n\t\n\tpublic Long nextLong(){\n\t\treturn Long.parseLong(next());\n\t}\n}\n\npublic class Main {\n    static int N, K;\n    static int count[] = new int[11];\n    static int sum[] = new int[11];\n    static int Value[] = new int[1000];\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner();\n        N = in.nextInt();\n        K = in.nextInt();\n        count[1] = 1; //1是固定的\n        Dp(1);\n        for (int i = 1; i &lt;= K; i++) {\n            System.out.print(sum[i] + " ");\n        }\n        System.out.println();\n        System.out.print("MAX=" + (sum[0] - 1));\n    }\n\n    private static void Dp(int dp) {\n        int x = getbig(dp);\n        if (dp == K) {\n            return;\n        }\n        for (int i = x; i &gt; count[dp]; i--) {\n            count[dp + 1] = i;\n            Dp(dp + 1);\n        }\n    }\n\n    private static int getbig(int dp) {\n        for (int i = 1; i &lt;= 1000; i++) {\n            Value[i] = 1000;\n            for (int j = 1; j &lt;= dp; j++)\n                if (i &gt;= count[j]) {\n                    Value[i] = Math.min(Value[i], Value[i - count[j]] + 1);\n                }\n            if (Value[i] &gt; N) {\n                if (i &gt; sum[0]) {\n                    sum[0] = i;\n                    for (int j = 1; j &lt;= dp; ++j)\n                        sum[j] = count[j];\n                }\n                return i;\n            }\n        }\n        return 0;\n    }\n}\r\n</textarea>	45
46	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　153是一个非常特殊的数，它等于它的每位数字的立方和，即153=1*1*1+5*5*5+3*3*3。编程求所有满足这种条件的三位十进制数。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　按从小到大的顺序输出满足条件的三位十进制数，每个数占一行。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n  int i,j,k,n;\n  for(n=100;n&lt;1000;n++)\n  {\n    i=n/100;\n    j=n/10%10;\n    k=n%10;\n    if(i*100+j*10+k==i*i*i+j*j*j+k*k*k)\n    printf("%d\\n",n);\n  }\nreturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\nint main()\n{\n    int i,j,k;\n    for(i=1;i&lt;=9;i++)\n    {\n        for(j=0;j&lt;=9;j++)\n        {\n            for(k=0;k&lt;=9;k++)\n            {\n                if(i*100+j*10+k==i*i*i+j*j*j+k*k*k)\n                {\n                    cout&lt;&lt;i*100+j*10+k&lt;&lt;endl;\n                }\n            }\n        }\n    }\n    return 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Arrays;\npublic class Main{\n\tpublic static void main(String args[]){\n\t\tStringBuffer string = new StringBuffer();\n\t\tfor(int a=1;a&lt;10;a++){\n\t\t\tfor(int b=0;b&lt;10;b++){\n\t\t\t\tfor(int c=0;c&lt;10;c++){\n\t\t\t\t\tif(Math.pow(a, 3)+Math.pow(b, 3)+Math.pow(c,3)==(a*100+b*10+c)){\n\t\t\t\t\t\tstring.append(a*100+b*10+c+",");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tString[] str = string.toString().split(",");\n\t\tint[] num = new int[str.length];\n\t\tfor(int i=0;i&lt;str.length;i++){\n\t\t\tnum[i] = Integer.parseInt(str[i]);\n\t\t}\n\t\tArrays.sort(num);\n\t\tfor(int i:num){\n\t\t\tSystem.out.println(i);\n\t\t}\n\t}\n}\r\n</textarea>	46
47	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　1221是一个非常特殊的数，它从左边读和从右边读是一样的，编程求所有这样的四位十进制数。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　按从小到大的顺序输出满足条件的四位十进制数。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n int a,b,c,d,i;\n for(i=1000;i&lt;=9999;i++)\n {  \n   a=i/1000;\n   b=i/100%10;\n   c=i/10%10;\n   d=i%10;\n  if(a==d&amp;&amp;b==c)\n    printf("%d\\n",i);\n }\nreturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n\tfor(int i1=1;i1&lt;10;i1++)\n\t{\n\t\tfor(int i2=0;i2&lt;10;i2++)\n\t\t{\n\t\t\tfor(int i3=0;i3&lt;10;i3++)\n\t\t\t{\n\t\t\t\tfor(int i4=0;i4&lt;10;i4++)\n\t\t\t\t{\n\t\t\t\t\tif(i1==i4 &amp;&amp; i2==i3)\n\t\t\t\t\tprintf("%d%d%d%d\\n",i1,i2,i3,i4);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tfor (int i = 1000; i &lt; 10000; i++) {\n\t\t\tint a = i / 1000;\n\t\t\tint b = i % 1000 / 100;\n\t\t\tint c = i % 100 / 10;\n\t\t\tint d = i % 10;\n\t\t\tif (a == d &amp;&amp; b == c) {\n\t\t\t\tSystem.out.println(i);\n\t\t\t}\n\t\t}\n\t}\n\n}\r\n</textarea>	47
57	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　求出区间[a,b]中所有整数的质因数分解。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入两个整数a，b。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　每行输出一个数的分解，形如k=a1*a2*a3...(a1&lt;=a2&lt;=a3...，k也是从小到大的)(具体可看样例)\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3 10\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  3=3\n  <br> 4=2*2\n  <br> 5=5\n  <br> 6=2*3\n  <br> 7=7\n  <br> 8=2*2*2\n  <br> 9=3*3\n  <br> 10=2*5\n </div>\n <div class="pdsec">\n  提示\n </div>\n <div class="pdcont">\n  　　先筛出所有素数，然后再分解。\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　2&lt;=a&lt;=b&lt;=10000\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;  \n#include&lt;math.h&gt;  \nint main()  \n{  \n    long int b,i,k,m,n,w = 0;  \n    scanf("%ld%ld",&amp;m,&amp;n);  \n    for(i = m;i&lt;=n;i++)  \n    {  \n        printf("%ld=",i);  \n        b = i;k = 2;  \n        while(k&lt;=sqrt(i))  \n        {  \n            if(b%k==0)  \n            {  \n                b = b/k;  \n                if(b&gt;1)  \n                {  \n                    printf("%ld*",k);continue;  \n                }     \n                if(b==1) printf("%ld\\n",k);  \n            }  \n            k++;  \n        }  \n        if(b&gt;1&amp;&amp;b&lt;i) printf("%ld\\n",b);  \n        if(b==i)  \n        {  \n            printf("%d\\n",i);w++;  \n        }       \n    }  \n    return 0;  \n} \r\n</textarea>	<textarea id="codelinescpp">\r\n//天农计算机系许晓华老师出品 \n#include &lt;stdio.h&gt;\n#define N 10000//筛法，求1万以内的所有素数 \nint p[N];\nint main()\n{\n\tint i,j,a,b,t;\n\tfor(i=2;i&lt;N/2;i++)\n\t{\n\t\tif(p[i]) continue;//合数不参加筛法 \n\t\tfor(j=2*i;j&lt;=N;j+=i)\n\t\t{\n\t\t\tp[j]=1;\n\t\t}\n\t}\n\tscanf("%d%d",&amp;a,&amp;b);\n\tfor(i=a;i&lt;=b;i++)\n\t{\n\t\tt=i;\n\t\tprintf("%d=",t);\n\t\twhile(t)\n\t\t{\n\t\t\tfor(j=2;j*j&lt;=t;j++)\n\t\t\t{\n\t\t\t\tif(!p[j]&amp;&amp;!(t%j))\n\t\t\t\t{\t\n\t\t\t\t\tprintf("%d*",j); \n\t\t\t\t\tt/=j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j*j&gt;t) \n\t\t\t{\n\t\t\t\tprintf("%d",t);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf("\\n");\n\t}\t\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\npublic class Main{\npublic static void main(String[] args)throws IOException{\n   BufferedReader buf=new BufferedReader(new InputStreamReader(System.in));\n      String s=buf.readLine();\n    String str[]=s.split(" ");\n    int i=Integer.parseInt(str[0]);\n    int n=Integer.parseInt(str[1]);\n    \n    for(int j=i;j&lt;=n;j++){\n    \tStringBuffer b=new StringBuffer();\n    \tb.append(j).append("=");\n    \tint x=j;\n    \tint y=(int)Math.sqrt(x);\n    \tif(y&lt;2){\n    \t\tb.append(j);\n    \t\t}\n    \t\telse{\n    \tfor(int k=2;k&lt;=y;k++){\n    \t\tif(x%k==0){\n    \t\t\tb.append(k).append("*");\n    \t\t\tx=x/k;\n    \t\t\ty=(int)Math.sqrt(x);\n    \t\t\tk=1;\n    \t\n    \t\t}\n    \t\t\t\n    \t}\n    \tb.append(x);\n\t}\n    \tSystem.out.println(b.toString());\n    }\n    \t\n    \n}\n}\n\r\n</textarea>	57
48	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　123321是一个非常特殊的数，它从左边读和从右边读是一样的。\n  <br> 　　输入一个正整数n， 编程求所有这样的五位和六位十进制数，满足各位数字之和等于n 。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入一行，包含一个正整数n。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　按从小到大的顺序输出满足条件的整数，每个整数占一行。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  52\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  899998\n  <br> 989989\n  <br> 998899\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　1&lt;=n&lt;=54。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n\tint a,b,c,d,e,f,t,all;\n\tscanf("%d",&amp;t);\n\tfor(a=1;a&lt;10;a++)\n\t\tfor(b=0;b&lt;10;b++)\n\t\t\tfor(c=0;c&lt;10;c++)\n\t\t\t\tfor(d=0;d&lt;10;d++)\n\t\t\t\t\tfor(e=0;e&lt;10;e++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(a==e)\n\t\t\t\t\t\t\tif(b==d)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tall=a+b+c+d+e;\n\t\t\t\t\t\t\t\t\tif(all==t)\n\t\t\t\t\t\t\t\t\tprintf("%d\\n",a*10000+b*1000+c*100+d*10+e);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\tfor(a=1;a&lt;10;a++)\n\t\tfor(b=0;b&lt;10;b++)\n\t\t\tfor(c=0;c&lt;10;c++)\n\t\t\t\tfor(d=0;d&lt;10;d++)\n\t\t\t\t\tfor(e=0;e&lt;10;e++)\n\t\t\t\t\t\tfor(f=0;f&lt;10;f++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(a==f)\n\t\t\t\t\t\t\t\tif(b==e)\n\t\t\t\t\t\t\t\t\tif(c==d)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tall=a+b+c+d+e+f;\n\t\t\t\t\t\t\t\t\t\tif(all==t)\n\t\t\t\t\t\t\t\t\t\t\tprintf("%d\\n",a*100000+b*10000+c*1000+d*100+e*10+f);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\nusing namespace std;\nint main()\n{\n\tint n,a,b,c,t;\n\tcin&gt;&gt;n;\n\tfor(a=1;a&lt;10;a++)\n\tfor(b=0;b&lt;10;b++)\n\tfor(c=0;c&lt;10;c++)\n\t{\n\t\tt=a*10001+b*1010+c*100;\n\t\tif(2*a+2*b+c==n)\n\t\t\tcout&lt;&lt;t&lt;&lt;endl;\t\n\t}\n\tfor(a=1;a&lt;10;a++)\n\tfor(b=0;b&lt;10;b++)\n\tfor(c=0;c&lt;10;c++)\n\t{\n\t\tt=a*100001+b*10010+c*1100;\n\t\tif(2*a+2*b+2*c==n)\n\t\t\tcout&lt;&lt;t&lt;&lt;endl;\t\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\npublic class Main {\n\tpublic static void main(String args[]) throws NumberFormatException,\n\t\t\tIOException {\n\t\tBufferedReader buffer = new BufferedReader(new InputStreamReader(\n\t\t\t\tSystem.in));\n\t\tint n = Integer.parseInt(buffer.readLine());\n\t\tArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;();\n\n\t\tfor (int i = 1; i &lt; 10; i++) {\n\t\t\tfor (int j = 0; j &lt; 10; j++) {\n\t\t\t\tfor (int k = 0; k &lt; 10; k++) {\n\t\t\t\t\tif ((i + j) * 2 + k == n)\n\t\t\t\t\t\tarray.add("" + i + j + k + j + i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i &lt; 10; i++) {\n\t\t\tfor (int j = 0; j &lt; 10; j++) {\n\t\t\t\tfor (int k = 0; k &lt; 10; k++) {\n\t\t\t\t\tif ((i + j + k) * 2 == n)\n\t\t\t\t\t\tarray.add("" + i + j + k + k + j + i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i &lt; array.size(); i++) {\n\t\t\tSystem.out.println(array.get(i));\n\t\t}\n\t}\n}\n\r\n</textarea>	48
49	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　十六进制数是在程序设计时经常要使用到的一种整数的表示方式。它有0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F共16个符号，分别表示十进制数的0至15。十六进制的计数方法是满16进1，所以十进制数16在十六进制中是10，而十进制的17在十六进制中是11，以此类推，十进制的30在十六进制中是1E。\n  <br> 　　给出一个非负整数，将它表示成十六进制的形式。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入包含一个非负整数a，表示要转换的数。0&lt;=a&lt;=2147483647\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出这个整数的16进制表示\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  30\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  1E\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\nchar data[]={'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};\n\n//输出\nvoid Print(char *num,int n)\n{\n\tint i;\n\tfor(i=n-1;i&gt;=0;i--) printf("%c",num[i]);\n\tprintf("\\0");\n\tprintf("\\n");\n}\n\n//将十六进制数转换为十进制数\nint Transform(char *num,long long value)\n{\n\tint n=0;\n\twhile(value&gt;=16)\n\t{\n\t\tnum[n++]=data[value%16];\n\t\tvalue/=16;\n\t}\n\tnum[n++]=data[value%16];\n\treturn n;\n}\n\nint main()\n{\n\tlong long value;\n\tchar num[10];\n\tint n;\n\tscanf("%I64d",&amp;value);\n\tn=Transform(num,value);\n\tPrint(num,n);\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\nusing namespace std;\nint main()\n{\n    int n;\n    char s[100000];\n    while(cin&gt;&gt;n)\n    {\n        int k=0;\n        if(n==0)\n        {\n            cout&lt;&lt;0;\n        }\n        else\n        {\n           while(n!=0)\n           {\n               if(n%16&gt;=10)\n               {\n                   s[k++]='A'+n%16-10;\n               }\n               else\n               {\n                   s[k++]='0'+n%16;\n               }\n               n=n/16;\n           }\n           for(int i=k-1;i&gt;=0;i--)\n           {\n               cout&lt;&lt;s[i];\n           }\n        }\n       cout&lt;&lt;endl;\n    }\n    return 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader buf = new BufferedReader(new InputStreamReader(System.in));\n\t\tprintToHexString(buf.readLine());\n\t}\n\t\n\tpublic static void printToHexString(String s) {\n\t\tStringBuffer st = new StringBuffer();\n\t\tint n = Integer.valueOf(s);\n\t\tif(n == 0) {\n\t\t\tSystem.out.println(0);\n\t\t\treturn;\n\t\t}\n\t\tint m;\n\t\twhile(n &gt; 0) {\n\t\t\tm = n % 16;\n\t\t\tn = n / 16;\n\t\t\tswitch(m) {\n\t\t\tcase 0:\n\t\t\t\tst.insert(0, "0");\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tst.insert(0, "1");\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tst.insert(0, "2");\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tst.insert(0, "3");\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tst.insert(0, "4");\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tst.insert(0, "5");\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tst.insert(0, "6");\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tst.insert(0, "7");\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tst.insert(0, "8");\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tst.insert(0, "9");\n\t\t\t\tbreak;\n\t\t\tcase 10:\n\t\t\t\tst.insert(0, "A");\n\t\t\t\tbreak;\n\t\t\tcase 11:\n\t\t\t\tst.insert(0, "B");\n\t\t\t\tbreak;\n\t\t\tcase 12:\n\t\t\t\tst.insert(0, "C");\n\t\t\t\tbreak;\n\t\t\tcase 13:\n\t\t\t\tst.insert(0, "D");\n\t\t\t\tbreak;\n\t\t\tcase 14:\n\t\t\t\tst.insert(0, "E");\n\t\t\t\tbreak;\n\t\t\tcase 15:\n\t\t\t\tst.insert(0, "F");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(st);\n\t}\n}\r\n</textarea>	49
50	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　从键盘输入一个不超过8位的正的十六进制数字符串，将它转换为正的十进制数后输出。\n  <br> 　　注：十六进制数中的10~15分别用大写的英文字母A、B、C、D、E、F表示。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  FFFF\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  65535\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt; \n#include&lt;math.h&gt;\nint main()\n{ \n double sum=0,x;\n char a[8];\n int len,i=0;\n gets(a);\n len=strlen(a);\n while(len)\n {\n  if(a[len-1]&gt;='A'&amp;&amp;a[len-1]&lt;='F')\n    x=(a[len-1]-'7')*pow(16,i++);\n  else\n\t  x=(a[len-1]-'0')*pow(16,i++);\n  sum+=x;\n  len--;\n }\n printf("%.0lf",sum);\n\n return 0;\n \n }\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\nint main()\n{\n    string s;\n    while(cin&gt;&gt;s)\n    {\n        int leth=s.length();\n        long long sum=0;\n        for(int i=0;i&lt;leth;i++)\n        {\n            if(s[i]&gt;='A'&amp;&amp;s[i]&lt;='F')\n            {\n                sum=sum*16+s[i]-'A'+10;\n               // cout&lt;&lt;sum&lt;&lt;endl;\n            }\n            else\n            {\n                sum=sum*16+s[i]-'0';\n                //cout&lt;&lt;sum&lt;&lt;endl;\n            }\n        }\n        cout&lt;&lt;sum&lt;&lt;endl;\n    }\n    return 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\npublic class Main {\npublic static void main (String args[])throws Exception{\n\tBufferedReader buf=new BufferedReader(new InputStreamReader(System.in));\n\tString s=buf.readLine();\n\tchar c[]=s.toCharArray();\n   int n=c.length;\n   long sum=0;\n   for(int i=0;i&lt;n;i++){\n\t   \n\t   if((int)c[i]-48&gt;9){\n\t\t   if(c[i]=='A')\n\t\t\t  sum+=10*Math.pow(16,n-i-1);\n\t\t   else if(c[i]=='B')\n\t\t\t   sum+=11*Math.pow(16,n-i-1);\n\t\t   else if(c[i]=='C')\n\t\t\t   sum+=12*Math.pow(16,n-i-1);\n\t\t   else if(c[i]=='D')\n\t\t\t   sum+=13*Math.pow(16,n-i-1);\n\t\t   else if(c[i]=='E')\n\t\t\t   sum+=14*Math.pow(16,n-i-1);\n\t\t   else if(c[i]=='F')\n\t\t\t  sum+=15*Math.pow(16,n-i-1);\n\t   }\n\t   else{\n\t\t  sum+=((int)c[i]-48)*Math.pow(16,n-i-1);\n\t   }\n   }\n   \n    System.out.println(sum);\n}\n}\n\r\n</textarea>	50
51	<div class="des"> \n <div class="pdcont">\n  <b>问题描述</b>\n  <b></b>\n  <br> 　　给定n个十六进制正整数，输出它们对应的八进制数。\n  <br> \n  <br> \n  <b>输入格式</b>\n  <b></b>\n  <br> 　　输入的第一行为一个正整数n （1&lt;=n&lt;=10）。\n  <br> 　　接下来n行，每行一个由0~9、大写字母A~F组成的字符串，表示要转换的十六进制正整数，每个十六进制数长度不超过100000。\n  <br> \n  <br> \n  <b>输出格式</b>\n  <b></b>\n  <br> 　　输出n行，每行为输入对应的八进制正整数。\n  <br> \n  <br> 　　\n  <b>【注意</b>\n  <b></b>】\n  <br> 　　输入的十六进制数不会有前导0，比如012A。\n  <br> 　　输出的八进制数也不能有前导0。\n  <br> \n  <br> \n  <b>样例输入</b>\n  <b></b>\n  <br> 　　2\n  <br> 　　39\n  <br> 　　123ABC\n  <br> \n  <br> \n  <b>样例输出</b>\n  <b></b>\n  <br> 　　71\n  <br> 　　4435274\n  <br> \n  <br> 　　\n  <b><b>【</b>提示</b>\n  <b></b>】\n  <br> 　　先将十六进制数转换成某进制数，再由某进制数转换成八进制。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n#define MaxSize 100000\n\nvoid saveB(char *b,char c3,char c2,char c1,char c0,int start)\n{\n\tb[start]=c3;\n\tb[start+1]=c2;\n\tb[start+2]=c1;\n\tb[start+3]=c0;\n}\nint htob(char *h,char *b)\n{\n\tint i,j;\n\tint hl=strlen(h);\n\tfor(i=0;i&lt;hl;i++)\n\t\tswitch(h[i])\n\t\t{\n\t\t\tcase '0':\n\t\t\t\t{\n\t\t\t\t\tsaveB(b,'0','0','0','0',4*i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase '1':\n\t\t\t\t{\n\t\t\t\t\tsaveB(b,'0','0','0','1',4*i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase '2':\n\t\t\t\t{\n\t\t\t\t\tsaveB(b,'0','0','1','0',4*i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase '3':\n\t\t\t\t{\n\t\t\t\t\tsaveB(b,'0','0','1','1',4*i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase '4':\n\t\t\t\t{\n\t\t\t\t\tsaveB(b,'0','1','0','0',4*i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase '5':\n\t\t\t\t{\n\t\t\t\t\tsaveB(b,'0','1','0','1',4*i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase '6':\n\t\t\t\t{\n\t\t\t\t\tsaveB(b,'0','1','1','0',4*i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase '7':\n\t\t\t\t{\n\t\t\t\t\tsaveB(b,'0','1','1','1',4*i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase '8':\n\t\t\t\t{\n\t\t\t\t\tsaveB(b,'1','0','0','0',4*i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase '9':\n\t\t\t\t{\n\t\t\t\t\tsaveB(b,'1','0','0','1',4*i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase 'A':\n\t\t\t\t{\n\t\t\t\t\tsaveB(b,'1','0','1','0',4*i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase 'B':\n\t\t\t\t{\n\t\t\t\t\tsaveB(b,'1','0','1','1',4*i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase 'C':\n\t\t\t\t{\n\t\t\t\t\tsaveB(b,'1','1','0','0',4*i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase 'D':\n\t\t\t\t{\n\t\t\t\t\tsaveB(b,'1','1','0','1',4*i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase 'E':\n\t\t\t\t{\n\t\t\t\t\tsaveB(b,'1','1','1','0',4*i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase 'F':\n\t\t\t\t{\n\t\t\t\t\tsaveB(b,'1','1','1','1',4*i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\treturn 4*hl;\n}\nint btoo(char *b,char *o,int bl)\n{\n\tint i,j;\n\tint ol;\n\tint value;\n\tif(bl%3==0)\n\t\tol=bl/3;\n\telse\n\t\tol=bl/3+1;\n\tj=bl-1;\n\tfor(i=ol-1;i&gt;=0;i--)\n\t{\n\t\tif(i&gt;0)\n\t\t\to[i]=b[j]-48+(b[j-1]-48)*2+(b[j-2]-48)*4+48;\n\t\telse\n\t\t{\n\t\t\tswitch(j)\n\t\t\t{\n\t\t\t\tcase 2:\n\t\t\t\t\to[i]=b[j]-48+(b[j-1]-48)*2+(b[j-2]-48)*4+48;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\to[i]=b[j]-48+(b[j-1]-48)*2+48;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0:\n\t\t\t\t\to[i]=b[j];\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t\tj=j-3;\n\t}\n\treturn ol;\n}\nvoid printO(char *o,int ol)\n{\n\tint i=0;\n\tif(o[0]=='0')\n\t\ti=1;\n\tfor(;i&lt;ol;i++)\n\t{\n\t\tprintf("%c",o[i]);\n\t}\n\tprintf("\\n");\n}\nmain()\n{\n\tchar h[MaxSize];\n\tchar b[4*MaxSize];\n\tchar o[4*MaxSize/3+1];\n\tint n,i,bl,ol;\n\tscanf("%d",&amp;n);\n\tgetchar();\n\tfor(i=0;i&lt;n;i++)\n\t{\n\t\tgets(h);\n\t\tbl=htob(h,b);\n\t\tol=btoo(b,o,bl);\n\t\t\n\t\tprintO(o,ol);\n\t}\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;STDLIB.H&gt;\n/* run this program using the console pauser or add your own getch, system("pause") or input loop */\n\nint GetI(char c)\n{\n\treturn c&gt;&gt;4&amp;1?c&amp;15:(c&amp;15)+9; \n}\n\nint main(int argc, char *argv[]) {\n\tchar arr[200001] = {'\\0'};\n\tchar brr[400001] = {'\\0'};\n\tint n = 0;\n\tint i = 0;\n\tscanf("%d",&amp;n);\n\n\tfor(i = 0;i &lt; n;i++)\n\t{\n\t\tscanf("%s",arr);\n\t\tint m[3] = {1,16,256};\n\t\tint len = strlen(arr);\n\t\tint j = len-1;\n\t\tint a,b,c;\n\t\ta = b = c = 0;\n\t\tint k = 0,l = 0;\n\t\tint count = 0;\n\t\twhile(j&gt;-1)\n\t\t{\n\n\t\t\ta += (arr[j]&gt;&gt;4&amp;1?arr[j]&amp;15:(arr[j]&amp;15)+9)*m[k]; //个位\n\t\t\tif(k==2||j==0)\n\t\t\t{\n\t\t\t\twhile(a)\n\t\t\t\t{\n\t\t\t\t\tbrr[l++] = ((a&amp;7)|48);\n\t\t\t\t\ta = a&gt;&gt;3;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\twhile(j!=0&amp;&amp;count&lt;4)\n\t\t\t\t{\n\t\t\t\t\tbrr[l++] = '0';\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t\tk = (k+1)%3;\n\t\t\tj--;\n\t\t}\n\t\tstrrev(brr);\n\t\tprintf("%s\\n",brr);\n\t\tmemset(arr,'\\0',(sizeof(char)*200001));\n\t\tmemset(brr,'\\0',(sizeof(char)*400001));\n\t}\n    return 0; \n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tstatic void shiliuToEr(String s){\n\t\tStringBuffer sbBuffer=new StringBuffer();\n\t\tchar[] a=s.toCharArray();\n\t\tfor (int i = 0; i &lt; a.length; i++) {\n\t\t\tswitch (a[i]) {\n\t\t\tcase '0':\n\t\t\t\tsbBuffer.append("0000");\n\t\t\t\tbreak;\n\t\t\tcase '1':\n\t\t\t\tsbBuffer.append("0001");\n\t\t\t\tbreak;\n\t\t\tcase '2':\n\t\t\t\tsbBuffer.append("0010");\n\t\t\t\tbreak;\n\t\t\tcase '3':\n\t\t\t\tsbBuffer.append("0011");\n\t\t\t\tbreak;\n\t\t\tcase '4':\n\t\t\t\tsbBuffer.append("0100");\n\t\t\t\tbreak;\n\t\t\tcase '5':\n\t\t\t\tsbBuffer.append("0101");\n\t\t\t\tbreak;\n\t\t\tcase '6':\n\t\t\t\tsbBuffer.append("0110");\n\t\t\t\tbreak;\n\t\t\tcase '7':\n\t\t\t\tsbBuffer.append("0111");\n\t\t\t\tbreak;\n\t\t\tcase '8':\n\t\t\t\tsbBuffer.append("1000");\n\t\t\t\tbreak;\n\t\t\tcase '9':\n\t\t\t\tsbBuffer.append("1001");\n\t\t\t\tbreak;\n\t\t\tcase 'A':\n\t\t\t\tsbBuffer.append("1010");\n\t\t\t\tbreak;\n\t\t\tcase 'B':\n\t\t\t\tsbBuffer.append("1011");\n\t\t\t\tbreak;\n\t\t\tcase 'C':\n\t\t\t\tsbBuffer.append("1100");\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\tsbBuffer.append("1101");\n\t\t\t\tbreak;\n\t\t\tcase 'E':\n\t\t\t\tsbBuffer.append("1110");\n\t\t\t\tbreak;\n\t\t\tcase 'F':\n\t\t\t\tsbBuffer.append("1111");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tErToBa(sbBuffer);\n\t}\n\tstatic void ErToBa(StringBuffer sb) {\n\t\tint len=sb.length();\n\t\tif (len%3==0) {\n\t\t\tif (sb.substring(0, 3).equals("000")){\n\t\t\t\tsb.delete(0, 3);\n\t\t\t}\n\t\t}else if (len%3==1) {\n\t\t\tif (sb.substring(0, 1).equals("0")) {\n\t\t\t\tsb.delete(0, 1);\n\t\t\t}else {\n\t\t\t\tsb.insert(0, "00");\n\t\t\t}\n\t\t}else {\n\t\t\tif (sb.subSequence(0, 2).equals("00")) {\n\t\t\t\tsb.delete(0, 2);\n\t\t\t}else {\n\t\t\t\tsb.insert(0, "0");\n\t\t\t}\n\t\t}\n\t\tStringBuffer sBuffer = new StringBuffer();\n\t\tString s;\n\t    int n=sb.length()/3;\n\t    for (int i = 0; i &lt; n; i++) {\n\t\t\ts=sb.substring(i*3, (i+1)*3);\n\t\t\tif (s.equals("000")) {\n\t\t\t\tsBuffer.append("0");\n\t\t\t}\n\t\t\tif (s.equals("001")) {\n\t\t\t\tsBuffer.append("1");\n\t\t\t}\n\t\t\tif (s.equals("010")) {\n\t\t\t\tsBuffer.append("2");\n\t\t\t}\n\t\t\tif (s.equals("011")) {\n\t\t\t\tsBuffer.append("3");\n\t\t\t}\n\t\t\tif (s.equals("100")) {\n\t\t\t\tsBuffer.append("4");\n\t\t\t}\n\t\t\tif (s.equals("101")) {\n\t\t\t\tsBuffer.append("5");\n\t\t\t}\n\t\t\tif (s.equals("110")) {\n\t\t\t\tsBuffer.append("6");\n\t\t\t}\n\t\t\tif (s.equals("111")) {\n\t\t\t\tsBuffer.append("7");\n\t\t\t}\n\t    }\n\t    System.out.println(sBuffer.toString());\n\t}\n\t\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tBufferedReader bReader=new BufferedReader(new InputStreamReader(System.in));\n\t\tint n=Integer.parseInt(bReader.readLine());\n\t\tString[] string=new String[n];\n\t\tfor (int i = 0; i &lt; n; i++) {\n\t\t\tstring[i]=bReader.readLine();\n\t\t}\n\t\tfor (int i = 0; i &lt; n; i++) {\n\t\t\tshiliuToEr(string[i]);\n\t\t}\n\t}\n\n}\r\n</textarea>	51
58	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　给定一个N阶矩阵A，输出A的M次幂（M是非负整数）\n  <br> 　　例如：\n  <br> 　　A =\n  <br> 　　1 2\n  <br> 　　3 4\n  <br> 　　A的2次幂\n  <br> 　　7 10\n  <br> 　　15 22\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行是一个正整数N、M（1&lt;=N&lt;=30, 0&lt;=M&lt;=5），表示矩阵A的阶数和要求的幂数\n  <br> 　　接下来N行，每行N个绝对值不超过10的非负整数，描述矩阵A的值\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出共N行，每行N个整数，表示A的M次幂所对应的矩阵。相邻的数之间用一个空格隔开\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  2 2\n  <br> 1 2\n  <br> 3 4\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  7 10\n  <br> 15 22\n </div> \n</div>	<textarea id="codelinesc">\r\n//天农计算机系许晓华老师出品 \n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#define N 100\nint A[N][N],t[N][N],r[N][N];\nint main()\n{\n\tint n,m,i,j,k;\n\tscanf("%d%d",&amp;n,&amp;m);\n\tfor(i=0;i&lt;n;i++)\n\t\tfor(j=0;j&lt;n;j++)\n\t\t\tscanf("%d",&amp;A[i][j]);\n\tfor(i=0;i&lt;n;i++) \n \t\tr[i][i]=1;//单位矩阵，如同数的乘法中的1\n\twhile(m--)\n\t{\n\t\tmemset(t,0,sizeof(t));\n\t\tfor(i=0;i&lt;n;i++)\n\t\t\tfor(j=0;j&lt;n;j++)\n\t\t\t\tfor(k=0;k&lt;n;k++)\n\t\t\t\t\tt[i][j]+=r[i][k]*A[k][j];\n\t\tfor(i=0;i&lt;n;i++)\n\t\t\tfor(j=0;j&lt;n;j++)\n\t\t \t\tr[i][j]=t[i][j];\n\t}\n\tfor(i=0;i&lt;n;i++)\n\t{\n\t\tfor(j=0;j&lt;n-1;j++)\n\t\t\tprintf("%d ",r[i][j]);\t\n\t\tprintf("%d\\n",r[i][j]);\t\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;cstdio&gt;\n #include&lt;iostream&gt;\n #include&lt;cstring&gt;\n using namespace std;\n int a[101][101];\n int c[101][101];\n int ans[101][101];\n int main()\n {\n     int i,j,k,l,m,n;\n     scanf("%d%d",&amp;n,&amp;m);\n     for(i=1;i&lt;=n;i++)\n       for(j=1;j&lt;=n;j++)\n         scanf("%d",&amp;a[i][j]);\n     memset(ans,0,sizeof(ans));\n     for(i=1;i&lt;=n;i++) ans[i][i]=1;\n     for(k=1;k&lt;=m;k++)\n     {    memset(c,0,sizeof(c));\n         for(i=1;i&lt;=n;i++)for(j=1;j&lt;=n;j++)for(l=1;l&lt;=n;l++)c[i][j]+=ans[i][l]*a[l][j];\n         for(i=1;i&lt;=n;i++)for(j=1;j&lt;=n;j++)ans[i][j]=c[i][j];\n     }\n     for(i=1;i&lt;=n;i++)\n     {\n         for(j=1;j&lt;n;j++)printf("%d ",ans[i][j]);\n         printf("%d\\n",ans[i][n]);\n     }\n     return 0;\n }\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\r\n\r\npublic class Main {\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tString str[] = br.readLine().split(" ");\r\n\r\n\t\tint Fir = Integer.parseInt(str[0]);\r\n\t\tint Sec = Integer.parseInt(str[1]);\r\n\t\tint[][] Mat = new int[Fir][Fir];\r\n\t\tint[][] MatPro = new int[Fir][Fir];\r\n\t\tfor (int row_1 = 0; row_1 &lt; Fir; row_1++) {\r\n\t\t\tString input[] = br.readLine().split(" ");\r\n\t\t\tfor (int row_2 = 0; row_2 &lt; Fir; row_2++) {\r\n\t\t\t\tMat[row_1][row_2] = Integer.parseInt(input[row_2]);\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunc(MatPro, Mat, Fir, Sec);\r\n\t}\r\n\r\n\tpublic static void func(int[][] MatPro, int[][] Mat, int a, int b) {\r\n\t\tint[][] tag = new int[a][a];\r\n\t\tfor (int x = 0; x &lt; a; x++) {\r\n\t\t\tfor (int y = 0; y &lt; a; y++) {\r\n\t\t\t\ttag[x][y] = Mat[x][y];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (b == 0) {\r\n\t\t\tfor (int x = 0; x &lt; a; x++) {\r\n\t\t\t\tfor (int y = 0; y &lt; a; y++) {\r\n\t\t\t\t\tif (x == y) {\r\n\t\t\t\t\t\tMatPro[x][y] = 1;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tMatPro[x][y] = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tSystem.out.print(MatPro[x][y] + " ");\r\n\t\t\t\t}\r\n\t\t\t\tSystem.out.println();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (b != 0) {\r\n\t\t\tfor (int p = 1; p &lt; b; p++) {\r\n\t\t\t\tfor (int x = 0; x &lt; a; x++) {\r\n\t\t\t\t\tfor (int y = 0; y &lt; a; y++) {\r\n\t\t\t\t\t\tint pro = 0;\r\n\t\t\t\t\t\tfor (int z = 0; z &lt; a; z++) {\r\n\t\t\t\t\t\t\tpro += Mat[x][z] * tag[z][y];\r\n\t\t\t\t\t\t\tMatPro[x][y] = pro;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfor (int x = 0; x &lt; a; x++) {\r\n\t\t\t\t\tfor (int y = 0; y &lt; a; y++) {\r\n\t\t\t\t\t\ttag[x][y] = MatPro[x][y];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor (int x = 0; x &lt; a; x++) {\r\n\t\t\t\tfor (int y = 0; y &lt; a; y++) {\r\n\t\t\t\t\tSystem.out.print(tag[x][y] + " ");\r\n\t\t\t\t}\r\n\t\t\t\tSystem.out.println();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n</textarea>	58
53	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　给出两个整数集合A、B，求出他们的交集、并集以及B在A中的余集。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行为一个整数n，表示集合A中的元素个数。\n  <br> 　　第二行有n个互不相同的用空格隔开的整数，表示集合A中的元素。\n  <br> 　　第三行为一个整数m，表示集合B中的元素个数。\n  <br> 　　第四行有m个互不相同的用空格隔开的整数，表示集合B中的元素。\n  <br> 　　集合中的所有元素均为int范围内的整数，n、m&lt;=1000。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　第一行按从小到大的顺序输出A、B交集中的所有元素。\n  <br> 　　第二行按从小到大的顺序输出A、B并集中的所有元素。\n  <br> 　　第三行按从小到大的顺序输出B在A中的余集中的所有元素。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5\n  <br> 1 2 3 4 5\n  <br> 5\n  <br> 2 4 6 8 10\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  2 4\n  <br> 1 2 3 4 5 6 8 10\n  <br> 1 3 5\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  4\n  <br> 1 2 3 4\n  <br> 3\n  <br> 5 6 7\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  1 2 3 4 5 6 7\n  <br> 1 2 3 4\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n\n#define MAX_N 1001\nint n,m;\n\n\nint Partition(int x[],int low,int high)\n{\n\tint pivotkey;\n\tpivotkey = x[low];\n\twhile(low &lt; high)\n\t{\n\t\twhile(low&lt;high &amp;&amp; x[high]&gt;=pivotkey)\n\t\t\thigh--;\n\t\tx[low] = x[high];\n\n\t\twhile(low&lt;high &amp;&amp; x[low]&lt;=pivotkey)\n\t\t\tlow++;\n\t\tx[high] = x[low];\n\t}\n\tx[low] = pivotkey;\n\treturn low;\n}\n\nvoid QSort(int x[],int low,int high)\n{\n\tint pivotloc;\n\tif(low &lt; high)\n\t{\n\t\tpivotloc = Partition(x,low,high);\n\t\tQSort(x,low,pivotloc-1);\n\t\tQSort(x,pivotloc+1,high);\n\t}\n}\n\nvoid jiao(int x[],int y[],int xx,int yy)\n{\n\tint i,j;\n\ti = 1;\n\tj = 1;\n\twhile(i&lt;=xx &amp;&amp; j&lt;=yy)\n\t{\n\t\tif(x[i] == y[j])\n\t\t{\n\t\t\tprintf("%d ",x[i]);\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t\telse if(x[i] &lt; y[j])\n\t\t\ti++;\n\t\telse\n\t\t\tj++;\n\t}\n\tprintf("\\n");\n}\n\nint bing(int x[],int y[],int z[],int xx,int yy)\n{\n\tint i,j,k;\n\ti = 1;\n\tj = 1; \n\tk = 1;\n\twhile(i&lt;=xx &amp;&amp; j&lt;=yy)\n\t{\n\t\tif(x[i] &lt; y[j])\n\t\t{\n\t\t\tz[k] = x[i];\n\t\t\ti++;\n\t\t}\n\t\telse if(x[i] &gt; y[j])\n\t\t{\n\t\t\tz[k] = y[j];\n\t\t\tj++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tz[k] = x[i];\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t\tk++;\n\t}\n\tif(i &gt; xx)\n\t\twhile(j &lt;= yy)\n\t\t{\n\t\t\tz[k] = y[j];\n\t\t\tk++;\n\t\t\tj++;\n\t\t}\n\telse\n\t\twhile(i &lt;= xx)\n\t\t{\n\t\t\tz[k] = x[i];\n\t\t\tk++;\n\t\t\ti++;\n\t\t}\n\n\treturn k;\n}\n\nvoid yu(int x[],int y[],int xx,int yy)\n{\n\tint i,j;\n\ti = 1;\n\tj = 1;\n\twhile(i&lt;=xx &amp;&amp; j&lt;=yy)\n\t{\n\t\tif(x[i] == y[j])\n\t\t{\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t\telse if(x[i] &lt; y[j])\n\t\t{\n\t\t\tprintf("%d ",x[i]);\n\t\t\ti++;\n\t\t}\n\t\telse\n\t\t\tj++;\n\t}\n\tif(j &gt; yy)\n\t\twhile(i &lt;= xx)\n\t\t{\n\t\t\tprintf("%d ",x[i]);\n\t\t\ti++;\n\t\t}\n\tprintf("\\n");\n}\n\n\n\nint main()\n{\n\tint i,l;\n\tint a[MAX_N],b[MAX_N];\n\tint c[2014];\n\tscanf("%d",&amp;n);\n\tfor(i=1; i&lt;=n; i++)\n\t\tscanf("%d",&amp;a[i]);\n\tQSort(a,1,n);\n\tscanf("%d",&amp;m);\n\tfor(i=1; i&lt;=m; i++)\n\t\tscanf("%d",&amp;b[i]);\n\tQSort(b,1,m);\n\tjiao(a,b,n,m);\n\tl = bing(a,b,c,n,m);\n\tfor(i=1; i&lt;l; i++)\n\t\tprintf("%d ",c[i]);\n\tprintf("\\n");\n\tyu(a,b,n,m);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;cstdio&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nint ta[2005];\nint main()\n{\n\tint n,m,a[2005],b[2005];\n\tint i,j,k;\n\tscanf("%d",&amp;n);\n\tfor(i=0;i&lt;n;i++)\n\t\tscanf("%d",&amp;a[i]);\n\tscanf("%d",&amp;m);\n\tfor(i=0;i&lt;m;i++)\n\t\tscanf("%d",&amp;b[i]);\n\tsort(a,a+n);\n\tsort(b,b+m);\n\tk=0;\n\tfor(i=0;i&lt;n;i++)\n\t{\n\t\tfor(j=0;j&lt;m;j++)\n\t\t{\n\t\t\tif(a[i]&lt;=b[j])\n\t\t\t\tbreak;\n\t\t}\n\t\tif(j!=m)\n\t\t{\n\t\t\tif(a[i]==b[j])\n\t\t\t{\n\t\t\t\tta[i]=-1;\n\t\t\t\tk=1;\n\t\t\t\tprintf("%d ",a[i]);\n\t\t\t}\n\t\t}\n\t}\n\tif(k)\n\tprintf("\\n");\n\ti=0;j=0;\n\twhile(i&lt;n&amp;&amp;j&lt;m)\n\t{\n\t\tif(a[i]&lt;b[j])\n\t\t{\n\t\t\tif(ta[i]!=-1)\n        printf("%d ",a[i]);\n\t\t\ti++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t printf("%d ",b[j]);\n\t\t\tj++;\n\t\t}\n\t}\n\tfor(i;i&lt;n;i++)\n\t{\n\t\tif(ta[i]!=-1)\n        printf("%d ",a[i]);\n\t}\n\tfor(j;j&lt;m;j++)\n\t{\n\t\tprintf("%d ",b[j]);\n\t}\n\tprintf("\\n");\n\tk=0;\n\tfor(i=0;i&lt;n;i++)\n\t{      \n\t\t if(ta[i]!=-1)\n\t\t {\n\t\t\t k=1;\n        printf("%d ",a[i]);\n\n\t\t }\n\t}\n\tif(k)\n\tprintf("\\n");\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\r\nimport java.util.Arrays;\r\nimport java.util.HashSet;\r\nimport java.util.Iterator;\r\nimport java.util.Set;\r\n\r\npublic class Main {\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tint n = Integer.parseInt(br.readLine());\r\n\r\n\t\tint[] arr = new int[n];\r\n\t\tString st[] = br.readLine().split(" ");\r\n\t\tfor (int a = 0; a &lt; arr.length; a++) {\r\n\t\t\tarr[a] = Integer.parseInt(st[a]);\r\n\t\t}\r\n\t\tArrays.sort(arr);\r\n\r\n\t\tint m = Integer.parseInt(br.readLine());\r\n\t\tint[] tag = new int[m];\r\n\t\tString str[] = br.readLine().split(" ");\r\n\t\tfor (int a = 0; a &lt; tag.length; a++) {\r\n\t\t\ttag[a] = Integer.parseInt(str[a]);\r\n\t\t}\r\n\t\tArrays.sort(tag);\r\n\t\tfunc(arr, tag);\r\n\t}\r\n\r\n\tpublic static void func(int[] arr, int[] tag) {\r\n\t\tint x;\r\n\t\tfor (int a = 0; a &lt; arr.length; a++) {\r\n\t\t\tx = Arrays.binarySearch(tag, arr[a]);\r\n\t\t\tif (x &gt;= 0) {\r\n\t\t\t\tSystem.out.print(arr[a] + " ");\r\n\t\t\t}\r\n\t\t}\r\n\t\tSystem.out.println();\r\n\r\n\t\tSet&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();\r\n\t\tfor (int a = 0; a &lt; arr.length; a++) {\r\n\t\t\tset.add(arr[a]);\r\n\t\t}\r\n\t\tfor (int a = 0; a &lt; tag.length; a++) {\r\n\t\t\tset.add(tag[a]);\r\n\t\t}\r\n\r\n\t\tint[] sor = new int[set.size()];\r\n\t\tIterator&lt;Integer&gt; it = set.iterator();\r\n\t\twhile (it.hasNext()) {\r\n\t\t\tfor (int a = 0; a &lt; sor.length; a++) {\r\n\t\t\t\tsor[a] = it.next();\r\n\t\t\t}\r\n\t\t}\r\n\t\tArrays.sort(sor);\r\n\t\tfor (int a = 0; a &lt; sor.length; a++) {\r\n\t\t\tSystem.out.print(sor[a] + " ");\r\n\t\t}\r\n\t\tSystem.out.println();\r\n\r\n\t\tint y;\r\n\t\tfor (int a = 0; a &lt; arr.length; a++) {\r\n\t\t\ty = Arrays.binarySearch(tag, arr[a]);\r\n\t\t\tif (y &lt; 0) {\r\n\t\t\t\tSystem.out.print(arr[a] + " ");\r\n\t\t\t}\r\n\t\t}\r\n\t\tSystem.out.println();\r\n\t}\r\n}\r\n</textarea>	53
54	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　给定一个以秒为单位的时间t，要求用“&lt;H&gt;:&lt;M&gt;:&lt;S&gt;”的格式来表示这个时间。&lt;H&gt;表示时间，&lt;M&gt;表示分钟，而&lt;S&gt;表示秒，它们都是整数且没有前导的“0”。例如，若t=0，则应输出是“0:0:0”；若t=3661，则输出“1:1:1”。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入只有一行，是一个整数t（0&lt;=t&lt;=86399）。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出只有一行，是以“&lt;H&gt;:&lt;M&gt;:&lt;S&gt;”的格式所表示的时间，不包括引号。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  0\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  0:0:0\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5436\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  1:30:36\n </div> \n</div>	<textarea id="codelinesc">\r\n\r\n#include&lt;stdio.h&gt;\r\n \r\n int main()\r\n{\r\n  int a,b,c,d;\r\n  scanf("%d",&amp;a);\r\n\r\n  b=(int)(a/3600);\r\n  c=(int)(a%3600)/60;\r\n  d=(int)((a%3600)%60);\r\n  printf("%d:%d:%d",b,c,d);\r\n  return 0;\r\n  \r\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n//天农计算机系许晓华老师出品 \n#include &lt;iostream&gt;\nusing namespace std;\nint main()\n{\n\tint n,H,M,S,t;\n\tcin&gt;&gt;n;\n\tH=n/3600;\n\tt=n%3600;\n\tM=t/60;\n\tS=t%60;\n\tcout&lt;&lt;H&lt;&lt;":"&lt;&lt;M&lt;&lt;":"&lt;&lt;S;\t\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\npublic class Main {\n    public static void main(String args[]) throws NumberFormatException, IOException{\n        BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));\n        String st = strin.readLine();\n        String str[]  = st.split(" ");\n        long x = Integer.parseInt(str[0]);\n        int h = (int)x/3600;\n        int m = (int)x%3600/60;\n        int s = (int)x%60;\n        System.out.println(h+":"+m+":"+s);\n    }\n}\n\r\n</textarea>	54
55	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　有一长度为N(1&lt;=Ｎ&lt;=10)的地板，给定两种不同瓷砖：一种长度为1，另一种长度为2，数目不限。要将这个长度为N的地板铺满，一共有多少种不同的铺法？\n  <br> 　　例如，长度为4的地面一共有如下5种铺法：\n  <br> 　　4=1+1+1+1\n  <br> 　　4=2+1+1\n  <br> 　　4=1+2+1\n  <br> 　　4=1+1+2\n  <br> 　　4=2+2\n  <br> 　　编程用递归的方法求解上述问题。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　只有一个数N，代表地板的长度\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出一个数，代表所有不同的瓷砖铺放方法的总数\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <pre class="pddata">\n<font face="Times New Roman" size="3">4</font>\n</pre> \n <div class="pdsec">\n  样例输出\n </div>\n <pre class="pddata">\n<font face="Times New Roman" size="3">5</font>\n</pre> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint j(int a)\n{\n\tint i=1,s=1;\n\tfor(;i&lt;=a;i++)s*=i;\n\treturn s;\n}\nint main()\n{\n\tint a;scanf("%d",&amp;a);\n\tint s=0,b=0,i;\n\twhile(a&gt;=0)\n\t{\n\t\ts+=j(a+b)/j(a)/j(b);\n\t\ta-=2;b++;\n\t}\n\tprintf("%d",s);\nreturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n\nint a[20];\nint main()\n{\n    int n;\n    scanf("%d",&amp;n);\n    a[0]=1; a[1]=1;\n    for(int i=2;i&lt;=n;i++) a[i]=a[i-1]+a[i-2];\n    printf("%d\\n",a[n]);\n    //system("pause");\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\r\npublic class Main \r\n{\r\n\tpublic static void main(String []args)\r\n\t{\r\n\t\tScanner input = new Scanner(System.in);\r\n\t\tint n = input.nextInt();\r\n\t\t\r\n\t\tif(1&lt;=n &amp;&amp; n&lt;=10)\r\n\t\t{\r\n\t\t\tif(n==1)\r\n\t\t\t{\r\n\t\t\t\tSystem.out.println("1");\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\t\r\n\t\t\tint []tag = new int[n];\r\n\t\t\ttag[0] = 1;\r\n\t\t\ttag[1] = 2;\r\n\t\t\t\r\n\t\t\tif(n==1)\r\n\t\t\t{\r\n\t\t\t\tSystem.out.println(tag[0]);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor(int a=2;a&lt;n;a++)\r\n\t\t\t{\r\n\t\t\t\ttag[a] = tag[a-1] + tag[a-2];\r\n\t\t\t}\r\n\t\t\t\tSystem.out.println(tag[n-1]);\r\n\t\t\t}\r\n\t\t}\r\n\t}\t\r\n}\r\n</textarea>	55
56	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　给定两个仅由大写字母或小写字母组成的字符串(长度介于1到10之间)，它们之间的关系是以下4中情况之一：\n  <br> 　　1：两个字符串长度不等。比如 Beijing 和 Hebei\n  <br> 　　2：两个字符串不仅长度相等，而且相应位置上的字符完全一致(区分大小写)，比如 Beijing 和 Beijing\n  <br> 　　3：两个字符串长度相等，相应位置上的字符仅在不区分大小写的前提下才能达到完全一致（也就是说，它并不满足情况2）。比如 beijing 和 BEIjing\n  <br> 　　4：两个字符串长度相等，但是即使是不区分大小写也不能使这两个字符串一致。比如 Beijing 和 Nanjing\n  <br> 　　编程判断输入的两个字符串之间的关系属于这四类中的哪一类，给出所属的类的编号。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　包括两行，每行都是一个字符串\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　仅有一个数字，表明这两个字符串的关系编号\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  BEIjing\n  <pre class="pddata">\n<font face="Times New Roman" size="3">beiJing </font>\n</pre> \n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  3\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nint main()\n{\n\tchar a[10],b[10],i,n,l=2;\n\tgets(a);gets(b);\n\tn=strlen(a);\n\tif(strlen(b)!=n)l=1;\n\telse\n\t{\n\tfor(i=0;i&lt;n;i++)\n\tif(a[i]==b[i]||a[i]==b[i]+32||a[i]+32==b[i])\n\t\tif(a[i]!=b[i])l=3;\n\t\telse ;else {l=4;break;}\n\t}\nprintf("%d",l);\nreturn 0;\n}  \r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;cmath&gt;\nusing namespace std;\n\nchar A[15],B[15];\n\nint main()\n{\n    scanf("%s",A);\n    scanf("%s",B);\n    int a=strlen(A);\n    int b=strlen(B);\n    int count=0;\n    if(a!=b) //长度不等\n    {\n        printf("1\\n");\n        return 0;\n    }\n    //长度相等\n\n    else\n    {\n        for(int i=0;i&lt;a;i++)\n        {\n            if((A[i]!=B[i]))\n            {\n                if(abs(A[i]-B[i])!=32)\n                {\n                    printf("4\\n");\n                    return 0;\n                }\n                else \n                {\n                    ++count;\n                    continue;\n                }\n            }\n        }\n        if((count==0))\n            printf("2\\n");\n        else\n            printf("3\\n");\n    }\n    return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\npublic class Main {\n\tpublic static void main(String args[])throws Exception{\n\t\tBufferedReader buf = new BufferedReader(new InputStreamReader(System.in));\n\t\tString str1= null;String str2 = null;\n\t\tstr1 = buf.readLine();\n\t\tstr2 = buf.readLine();\n\t\t\n\t\tif(str1.length()==str2.length()){\n\t\t\tif(str1.equals(str2)){\n\t\t\t\tSystem.out.println(2);\n\t\t\t}else if(str1.equalsIgnoreCase(str2)){\n\t\t\t\tSystem.out.println(3);\n\t\t\t}else{\n\t\t\t\tSystem.out.println(4);\n\t\t\t}\n\t\t}else{\n\t\t\tSystem.out.println(1);\n\t\t}\n\t}\n}\r\n</textarea>	56
59	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　平面上有两个矩形，它们的边平行于直角坐标系的X轴或Y轴。对于每个矩形，我们给出它的一对相对顶点的坐标，请你编程算出两个矩形的交的面积。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入仅包含两行，每行描述一个矩形。\n  <br> 　　在每行中，给出矩形的一对相对顶点的坐标，每个点的坐标都用两个绝对值不超过10^7的实数表示。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出仅包含一个实数，为交的面积，保留到小数后两位。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  1 1 3 3\n  <br> 2 2 4 4\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  1.00\n </div> \n</div>	<textarea id="codelinesc">\r\n//天农计算机系许晓华老师出品 \n#include &lt;stdio.h&gt;\n#define max(x,y) ((x)&gt;(y)?(x):(y))\n#define min(x,y) ((x)&lt;(y)?(x):(y))\nint main()\n{\n\tdouble x1,y1,x2,y2;//矩形1 \n\tdouble x3,y3,x4,y4;//矩形2\t\n\tdouble m1,n1;//交集左上角坐标 \n\tdouble m2,n2;//交集右下角坐标 \n\tscanf("%lf%lf%lf%lf",&amp;x1,&amp;y1,&amp;x2,&amp;y2);\n\tscanf("%lf%lf%lf%lf",&amp;x3,&amp;y3,&amp;x4,&amp;y4);\n\tm1=max(min(x1,x2),min(x3,x4));\n\tn1=max(min(y1,y2),min(y3,y4));\n\tm2=min(max(x1,x2),max(x3,x4));\n\tn2=min(max(y1,y2),max(y3,y4));\n\tif(m2&gt;m1&amp;&amp;n2&gt;n1)  \n\t\tprintf("%.2f\\n",(m2-m1)*(n2-n1));\t\n\telse \n\t\tprintf("0.00\\n");\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;cmath&gt;\n#include &lt;cstdio&gt;\nusing namespace std;\nint main()\n{\n    double x1,x2,y1,y2;\n    double q1,q2,w1,w2;\n    while(cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;q1&gt;&gt;w1&gt;&gt;q2&gt;&gt;w2)\n    {\n        double xx=max(min(x1,x2),min(q1,q2));\n        double yy=max(min(y1,y2),min(w1,w2));\n        double xxup=min(max(x1,x2),max(q1,q2));\n        double yyup=min(max(y1,y2),max(w1,w2));\n        if(xxup&gt;xx)\n        printf("%.2f\\n",fabs((xx)-(xxup))*fabs((yy)-(yyup)));\n        else printf("0.00\\n");\n    }\n\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\r\npublic class Main\r\n{\r\n\tpublic static void main(String[] args)throws IOException\r\n\t{\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\t\r\n\t\tdouble[][] arr = new double[2][4];\r\n\t\t\r\n\t\tString tag1[] = br.readLine().split(" ");\r\n\t\tString tag2[] = br.readLine().split(" ");\r\n\t\t\r\n\t\tfor(int b=0;b&lt;4;b++)\r\n\t\t{\r\n\t\t\tarr[0][b] = Double.valueOf(tag1[b]);\r\n\t\t}\r\n\t\tfor(int b=0;b&lt;4;b++)\r\n\t\t{\r\n\t\t\tarr[1][b] = Double.valueOf(tag2[b]);\r\n\t\t}\r\n\t\t\r\n\t\tdouble a,b,c,d,e,f,g,h;\r\n\t\ta = Math.max(arr[0][0],arr[0][2]);\r\n\t\tb = Math.min(arr[0][0],arr[0][2]);\r\n\t\tc = Math.max(arr[0][1],arr[0][3]);\r\n\t\td = Math.min(arr[0][1],arr[0][3]);\r\n\t\te = Math.max(arr[1][0],arr[1][2]);\r\n\t\tf = Math.min(arr[1][0],arr[1][2]);\r\n\t\tg = Math.max(arr[1][1],arr[1][3]);\r\n\t\th = Math.min(arr[1][1],arr[1][3]);\r\n\t\t\r\n\t\tif(a&lt;f || e&lt;b || c&lt;h || g&lt;d)\r\n\t\t{\r\n\t\t\tSystem.out.println("0.00");\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tdouble i = (Math.min(a,e)-Math.max(b,f));\r\n\t\t\tdouble j = (Math.min(c,g)-Math.max(d,h));\r\n\t\t\tString s = String.format("%.2f",i*j);\r\n\t\t\tSystem.out.println(s);\r\n\t\t}\r\n\t}\r\n}\r\n</textarea>	59
60	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　回文串，是一种特殊的字符串，它从左往右读和从右往左读是一样的。小龙龙认为回文串才是完美的。现在给你一个串，它不一定是回文的，请你计算最少的交换次数使得该串变成一个完美的回文串。\n  <br> 　　交换的定义是：交换两个相邻的字符\n  <br> 　　例如mamad\n  <br> 　　第一次交换 ad : mamda\n  <br> 　　第二次交换 md : madma\n  <br> 　　第三次交换 ma : madam (回文！完美！)\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行是一个整数N，表示接下来的字符串的长度(N &lt;= 8000)\n  <br> 　　第二行是一个字符串，长度为N.只包含小写字母\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　如果可能，输出最少的交换次数。\n  <br> 　　否则输出Impossible\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5\n  <br> mamad\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  3\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;  \nint changes(char s[],char x,int n); \nchar x='0'; \nint main(void) \n{ \n   int n,i,k=0,b[26]={0},j; \n   char y,s[8000]={0}; \n   scanf("%d",&amp;n); \n   getchar(); \n   for(i=0;i&lt;n;i++) \n   scanf("%c",&amp;s[i]); \n   for(i=0;i&lt;n;i++)\n   { \n       j=s[i]-'a'; \n\t   b[j]++; \n   } \n   for(j=0;j&lt;26;j++)\n   { \n       if(b[j]%2!=0)\n\t   { \n\t       k++; \n\t\t   x=j+'a';\n\t\t   \n\t  } \n   } \n   if(k&gt;=2) \n   printf("Impossible\\n"); \n   else \n   printf("%d\\n",changes(s,x,n)); \n   return 0; \n}  \n\nint changes(char s[],char x,int n) \n{ \n    int i,change=0,j,k; \n\tfor(i=0;i&lt;n/2;i++)\n\t{ \n\t   if(s[i]==x)\n\t   { \n\t     for(j=i;j&lt;n-i-1;j++) \n\t\t if(s[n-i-1]==s[j]) \n\t\t break; \n\t\t change+=j-i; \n\t\t for(k=j;k&gt;i;k--) \n\t\t s[k]=s[k-1]; \n\t\t s[i]=s[n-i-1]; \n\t   }\n\t   else \n\t   { \n\t   for(j=n-i-1;j&gt;=i;j--) \n\t   if(s[i]==s[j]) \n\t   break; \n\t   change+=n-i-1-j; \n\t   for(k=j;k&lt;n-i-1;k++) \n\t   s[k]=s[k+1]; \n\t   s[n-i-1]=s[i]; \n\t   }\n\t}  \n\treturn change; \n}  \n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;cstdio&gt; \n#include&lt;iostream&gt; \n\nusing namespace std; \n\nint changes(char s[],char x,int n) \n{ \n   int i,change=0,j,k; \n   for(i=0;i&lt;n/2;i++) \n   { \n      if(s[i]==x) \n      { \n         for(j=i;j&lt;n-i-1;j++) \n            if(s[n-i-1]==s[j]) \n                break; \n\n         change+=j-i; \n\n         for(k=j;k&gt;i;k--) \n            s[k]=s[k-1]; \n\n         s[i]=s[n-i-1]; \n      } \n      else \n      { \n         for(j=n-i-1;j&gt;=i;j--) \n            if(s[i]==s[j]) \n               break; \n         change+=n-i-1-j; \n\n         for(k=j;k&lt;n-i-1;k++)  s[k]=s[k+1]; \n         s[n-i-1]=s[i]; \n      } \n    } \n    return change; \n} \nint main() \n{ \n    int n,i,k=0,b[26]={0},j; \n    char y,s[8001]={0}; \n     \n    scanf("%d\\n",&amp;n); \n    for(i=0;i&lt;n;i++) \n    { \n       scanf("%c",&amp;s[i]); \n       b[s[i]-'a']++; \n    } \n\n    char x; \n    for(j=0;j&lt;26;j++) \n    { \n        if(b[j]%2!=0) \n        { \n            k++; \n            x=j+'a'; \n        } \n    } \n     \n    if(k&gt;=2) \n       printf("Impossible\\n"); \n    else \n    { \n       printf("%d\\n",changes(s,x,n)); \n       return 0; \n    } \n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\n\npublic class Main{\n    public static void main(String args[]) throws IOException {\n        BufferedReader buf = new BufferedReader(\n                new InputStreamReader(System.in));\n        int n = Integer.parseInt(buf.readLine());\n        String s = buf.readLine();\n        char c[] = s.toCharArray();\n        int count = 0, num = 0;\n        char ch = '0';\n        int i, k = 0, j;\n        int b[] = new int[26];\n        for (i = 0; i &lt; n; i++)\n            for (i = 0; i &lt; n; i++) {\n                j = c[i] - 'a';\n                b[j]++;\n            }\n        for (j = 0; j &lt; 26; j++) {\n            if (b[j] % 2 != 0) {\n                k++;\n                ch = (char) (j + 'a');\n            }\n        }\n        if (k &gt;= 2)\n            System.out.println("Impossible");\n        else\n            System.out.println(changes(c, ch, n));\n    }\n\n    public static int changes(char s[], char x, int n) {\n        int i, change = 0, j, k;\n        for (i = 0; i &lt; n / 2; i++) {\n            if (s[i] == x) {\n                for (j = i; j &lt; n - i - 1; j++)\n                    if (s[n - i - 1] == s[j])\n                        break;\n                change += j - i;\n                for (k = j; k &gt; i; k--)\n                    s[k] = s[k - 1];\n                s[i] = s[n - i - 1];\n            } else {\n                for (j = n - i - 1; j &gt;= i; j--)\n                    if (s[i] == s[j])\n                        break;\n                change += n - i - 1 - j;\n                for (k = j; k &lt; n - i - 1; k++)\n                    s[k] = s[k + 1];\n                s[n - i - 1] = s[i];\n            }\n        }\n        return change;\n    }\n}\r\n</textarea>	60
61	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　Tom教授正在给研究生讲授一门关于基因的课程，有一件事情让他颇为头疼：一条染色体上有成千上万个碱基对，它们从0开始编号，到几百万，几千万，甚至上亿。\n  <br> 　　比如说，在对学生讲解第1234567009号位置上的碱基时，光看着数字是很难准确的念出来的。\n  <br> 　　所以，他迫切地需要一个系统，然后当他输入12 3456 7009时，会给出相应的念法：\n  <br> 　　十二亿三千四百五十六万七千零九\n  <br> 　　用汉语拼音表示为\n  <br> 　　shi er yi san qian si bai wu shi liu wan qi qian ling jiu\n  <br> 　　这样他只需要照着念就可以了。\n  <br> 　　你的任务是帮他设计这样一个系统：给定一个阿拉伯数字串，你帮他按照中文读写的规范转为汉语拼音字串，相邻的两个音节用一个空格符格开。\n  <br> 　　注意必须严格按照规范，比如说“10010”读作“yi wan ling yi shi”而不是“yi wan ling shi”，“100000”读作“shi wan”而不是“yi shi wan”，“2000”读作“er qian”而不是“liang qian”。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　有一个数字串，数值大小不超过2,000,000,000。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　是一个由小写英文字母，逗号和空格组成的字符串，表示该数的英文读法。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  1234567009\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  shi er yi san qian si bai wu shi liu wan qi qian ling jiu\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nint main()\n{\n\tchar a[100];int i,j,k,l;\n\tchar b[20][10]={"ling","yi","er","san","si","wu","liu","qi","ba","jiu"};\n\tchar c[20][10]={"","","shi","bai","qian","wan","shi","bai","qian","yi","shi"};\n\tgets(a);\n\tl=strlen(a);\n\tfor(i=0;i&lt;l;i++){\n\t\tj=a[i]-48;\n\t\tif(j==0){if(i&lt;l-1)if(a[i+1]!=48)printf("%s ",b[j]);}\n\t\telse \n\t\tif((l-i==2||l-i==6||l-i==10)&amp;&amp;j==1)printf("%s ",c[l-i]);\n\t\telse if(a[i-1]==48&amp;&amp;j==1)printf("%s ",c[l-i]);\n\t\telse printf("%s %s ",b[j],c[l-i]);\n\t}\n\tprintf("\\n");\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n #include&lt;cstdio&gt;\n #include&lt;cstring&gt;\n #include&lt;cstdlib&gt;\n\n using namespace std;\n char df[][10]={"ling","yi","er","san","si","wu","liu","qi","ba","jiu"};\n char s[15];\n int main()\n {\n scanf("%s",s);\n int lens=strlen(s);\n bool bk=false;\n for (int i=0;i&lt;lens;i++)\n {\n int p,lendf;\n p=s[i]-'0';\n if (p!=0)\n {\n bk=false;\n lendf=strlen(df[p]);\n\n if (s[i-1]-'0'==0) \n printf("ling ");\n\n if ((lens-i)%4==2 &amp;&amp; p==1 /*&amp;&amp; s[i-1]-'0'==0 &amp;&amp; s[i-2]-'0'==0*/ &amp;&amp; i==0)\n {\n printf("shi ");\n continue;\n }\n\n for (int j=0;j&lt;lendf;j++)\n printf("%c",df[p][j]);\n printf(" ");\n\n if ((lens-i)%4==2) printf("shi ");\n if ((lens-i)%4==3) printf("bai ");\n if ((lens-i)%4==0) printf("qian ");\n }\n if ((lens-i)%4==1)\n {\n if ((lens-i)/4==2)\n {\n bk=true;\n printf("yi ");\n }\n if (bk==false &amp;&amp; (lens-i)/4==1) printf("wan ");\n }\n\n }\n return 0;\n } \r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tString num = in.readLine();\n\t\tchar[] ch = num.toCharArray();\n\t\tgetRed(ch,num);\n\t}\n\tpublic static void getRed(char[] ch,String str){\n\t\tint numL01 = ch.length;\n\t\tString[] numR01 = new String[numL01];\n\t\tfor(int a = 0;a &lt; numL01;a++){\n\t\t\tnumR01[a] = getNum(ch[a] + "");\n\t\t}\n\t\tint numL02 = 2 * numL01 - 1;\n\t\tString[] numR02 = new String[numL02];\n\t\tnumR02[0] = numR01[0];\n\t\tint i01 = 10 - numL01;\n\t\tint i02 = 1;\n\t\tfor(int a = 1;a &lt; numL02;a++){\n\t\t\tif((a%2) == 0){\n\t\t\t\tnumR02[a] = numR01[i02];\n\t\t\t\ti02++;\n\t\t\t}else{\n\t\t\t\tnumR02[a] = getR(i01);\n\t\t\t\ti01++;\n\t\t\t}\n\t\t}\n\t\tString red = numR02[0];\n\t\tfor(int a = 1;a &lt; numL02;a++){\n\t\t\tif(a%2 == 0){\n\t\t\t\tif(red.endsWith("ling ")){\n\t\t\t\t\tif(getT(numR02[a]))red += numR02[a];\n\t\t\t\t}else{\n\t\t\t\t\tred += numR02[a];\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(red.endsWith("ling ")){\n\t\t\t\t\tif(getTR(numR02[a]))red = red.substring(0, red.length() - 5) + numR02[a];\n\t\t\t\t}else{\n\t\t\t\t\tred += numR02[a];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(red.endsWith("ling "))red = red.substring(0, red.length() - 5);\n\t\tif((str.length() &gt; 8) \n\t\t\t\t&amp; (red.startsWith("yi shi "))){\n\t\t\tred = red.substring(3);\n\t\t}\n\t\tif(red.indexOf(" i wan ")!=-1){\n\t\t\tred = red.replaceFirst(" i wan ", " yi ");\n\t\t}else if(red.indexOf(" i ")!=-1){\n\t\t\tred = red.replaceFirst(" i ", " yi ");\n\t\t}\n\t\tif(str.length() == 6){\n\t\t\tif(red.indexOf("yi shi ")!=-1){\n\t\t\t\tred = red.replaceFirst("yi shi ", "shi ");\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(red);\n\t}\n\tpublic static String getNum(String str){\n\t\tString[] num = {"ling ","yi ","er ","san ","si ","wu ","liu ","qi ","ba ","jiu "};\n\t\tstr = num[Integer.parseInt(str)];\n\t\treturn str;\n\t}\n\tpublic static String getR(int i){\n\t\tString[] red = {"shi ","i ","qian ","bai ","shi ","wan ","qian ","bai ","shi ",""};\n\t\treturn red[i];\n\t}\n\tpublic static boolean getT(String str){\n\t\tString[] red = {"yi ","er ","san ","si ","wu ","liu ","qi ","ba ","jiu "};\n\t\tboolean num = false;\n\t\tfor(int a = 0;a &lt; red.length;a++){\n\t\t\tif(str.equals(red[a]))num = true;\n\t\t\tif(str.equals(red[a]))break;\n\t\t}\n\t\treturn num;\n\t}\n\tpublic static boolean getTR(String str){\n\t\tboolean r = false;\n\t\tif((str.equals("wan ")) | (str.equals("i ")))r = true;\n\t\treturn r;\n\t}\n}\n\n\r\n</textarea>	61
62	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　最近FJ为他的奶牛们开设了数学分析课，FJ知道若要学好这门课，必须有一个好的三角函数基本功。所以他准备和奶牛们做一个“Sine之舞”的游戏，寓教于乐，提高奶牛们的计算能力。\n  <br> 　　不妨设\n  <br> 　　An=sin(1–sin(2+sin(3–sin(4+...sin(n))...)\n  <br> 　　Sn=(...(A1+n)A2+n-1)A3+...+2)An+1\n  <br> 　　FJ想让奶牛们计算Sn的值，请你帮助FJ打印出Sn的完整表达式，以方便奶牛们做题。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　仅有一个数：N&lt;201。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　请输出相应的表达式Sn，以一个换行符结束。输出中不得含有多余的空格或换行、回车符。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  ((sin(1)+3)sin(1–sin(2))+2)sin(1–sin(2+sin(3)))+1\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n\nvoid printA(int n, int k)\n{\n    if (n == k)\n        printf("sin(%d)", n);\n    else\n    {\n        printf("sin(%d", n);\n        printf(n % 2 == 0 ? "+" : "-");\n        printA(n + 1, k);\n        printf(")");\n    }\n}\n\nvoid printS(int n, int k)\n{\n    if (n == 1)\n    {\n        printA(1, n);\n        printf("+%d", k - n);\n    }\n    else\n    {\n        printf("(");\n        printS(n - 1, k);\n        printf(")");\n        printA(1, n);\n        printf("+%d", k - n);\n    }\n}\n\nint main()\n{\n    int N;\n    scanf("%d", &amp;N);\n    printS(N, N + 1);\n    printf("\\n");\n    return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\nvoid An_Output(int n, int t)\n{\n\tif(n == t)\n\t{\n\t\tprintf("sin(%d)", t);\n\t\treturn ;\n\t}\n\tchar c;\n\tc = t % 2 == 1 ? '+' : '-';\n\tprintf("sin(%d%c", t, c);\n\tAn_Output(n, ++t);\n\tprintf(")");\n}\nvoid Sn_Output(int n, int t)\n{\n\t//　Sn=(...(A1+n)A2+n-1)A3+...+2)An+1\n\tif(n == t)\n\t{\n\t\treturn ;\n\t}\n\tprintf("(");\n\tSn_Output(n, t+1);\n\tif(t != n - 1)\n\t{\t\n\t\tprintf(")");\n\t}\n\tAn_Output(n - t, 1);\n\tprintf("+%d", t+1);\n}\nint main()\n{\n\tint n;\n\tscanf("%d", &amp;n);\n\tSn_Output(n, 1);\n\tif(n!=1)\n\t\tprintf(")");\n\tAn_Output(n, 1);\n\tprintf("+1\\n");\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n = scanner.nextInt();\n\t\tString string = f(n, 1, 1);\n\t\tSystem.out.println(string);\n\t}\n\n\tprivate static String f1(int n, int i, int j) {\n\t\tif (i == n)\n\t\t\treturn "sin(" + j + ")";\n\t\tif (i % 2 == 0)\n\t\t\treturn "sin(" + i + "+" + f1(n, i + 1, j + 1) + ")";\n\t\telse\n\t\t\treturn "sin(" + i + "-" + f1(n, i + 1, j + 1) + ")";\n\t}\n\n\tprivate static String f(int n, int i, int j) {\n\t\tif (i == n)\n\t\t\treturn f1(n, i, j) + "+" + i;\n\t\treturn "(" + f(n, i + 1, j) + ")" + f1(n, i, j) + "+" + i;\n\t}\n}\r\n</textarea>	62
71	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　输入一个正整数\n  <i>n</i>，输出\n  <i>n</i>!的值。\n  <br> 　　其中\n  <i>n</i>!=1*2*3*…*\n  <i>n</i>。\n </div>\n <div class="pdsec">\n  算法描述\n </div>\n <div class="pdcont">\n  　　\n  <i>n</i>!可能很大，而计算机能表示的整数范围有限，需要使用高精度计算的方法。使用一个数组\n  <i>A</i>来表示一个大整数\n  <i>a</i>，\n  <i>A</i>[0]表示\n  <i>a</i>的个位，\n  <i>A</i>[1]表示\n  <i>a</i>的十位，依次类推。\n  <br> 　　将\n  <i>a</i>乘以一个整数\n  <i>k</i>变为将数组\n  <i>A</i>的每一个元素都乘以\n  <i>k</i>，请注意处理相应的进位。\n  <br> 　　首先将\n  <i>a</i>设为1，然后乘2，乘3，当乘到\n  <i>n</i>时，即得到了\n  <i>n</i>!的值。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入包含一个正整数\n  <i>n</i>，\n  <i>n</i>&lt;=1000。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出\n  <i>n</i>!的准确值。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  10\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  3628800\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#define N 10000\nint main()\n{\n\tint a[N]={1};\n\tint k=0,l=1,n;\n\tint i,j;\n\tscanf("%d",&amp;n);\n\tfor(i=1;i&lt;=n;i++)\n\t{\n\t\tfor(j=0;j&lt;l;j++)\n\t\t{\n\t\t\ta[j]=a[j]*i+k;\n\t\t\tk=a[j]/10000;\n\t\t\ta[j]=a[j]%10000;\n\t\t}\n\t\tif(k)\n\t\t{\n\t\t\ta[j]=k;\n\t\t\tl++;\n\t\t\tk=0;\n\t\t}\n\t}\n\tprintf("%d",a[l-1]);\n\tfor(i=l-2;i&gt;=0;i--)\n\t\tprintf("%04d",a[i]);\n\tprintf("\\n");\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#define MAX 10000\n#define mod 10000\n#define baselen 4\n#define in(a) scanf("%d",&amp;a)\n#define out1(a) printf("%d",a)\n#define out2(a) printf("%04d",a)\ntypedef int type;\nstruct bint{\n\ttype dig[MAX], len;\n\tbint(){len = 0, dig[0] = 0;}\n};\nvoid by(bint a, type b, bint&amp; c){\n\ttype i, carry;\n\tfor( i = carry = 0; i &lt;= a.len || carry; i++){\n\t\tif( i &lt;= a.len ) carry += b*a.dig[i];\n\t\tc.dig[i] = carry%mod;\n\t\tcarry /= mod;\n\t}\n\ti--;\n\twhile( i &amp;&amp; !c.dig[i] )i--;\n\tc.len = i;\n}\nbool input(bint&amp; a){\n\ttype i, j, w, k, p;\n\tchar data[MAX*baselen+1];\n\tif(scanf("%s",data)==EOF)return false;\n\tw = strlen(data) - 1, a.len = 0;\n\tfor(p=0;p&lt;=w&amp;&amp;data[p]=='0';p++);\n\twhile(1){\n\t\ti = j = 0, k = 1;\n\t\twhile(i&lt;baselen&amp;&amp;w&gt;=p){\n\t\t\tj = j+ (data[w--] - '0')*k;\n\t\t\tk *= 10, i++;\n\t\t}\n\t\ta.dig[a.len++] = j;\n\t\tif(w&lt;p)break;\n\t}\n\ta.len--;\n\treturn true;\n}\nvoid output(bint&amp; a){\n\ttype i;\n\ti = a.len - 1;\n\tout1(a.dig[a.len]);\n\twhile(i&gt;=0)out2(a.dig[i--]);\n}\nvoid give(type a, bint&amp; b){\n\tb.dig[0] = a%mod;\n\ta /= mod;\n\tif(a&gt;0)b.dig[1] = a, b.len = 1;\n\telse b.len = 0;\n}\nint main()\n{\n\tbint a;int b,i;scanf("%d",&amp;b);give(1,a);\n\tfor(i=2;i&lt;=b;i++)by(a,i,a);\n\toutput(a);printf("\\n");\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.math.BigInteger;\nimport java.util.*;\npublic class Main{\n\tprotected static ArrayList table = new ArrayList();\n\tstatic {\n\t\ttable.add(BigInteger.valueOf(1));\n\t}\n\tpublic static synchronized BigInteger factorial(int x) {\n\t\tfor (int size = table.size(); size &lt;= x; size++) {\n\t\t\tBigInteger lastfact = (BigInteger) table.get(size - 1);\n\t\t\tBigInteger nextfact = lastfact.multiply(BigInteger.valueOf(size));\n\t\t\ttable.add(nextfact);\n\t\t}\n\t\treturn (BigInteger) table.get(x);\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner s=new Scanner(System.in);\n\t\tint n=s.nextInt();\n\t\tSystem.out.print(factorial(n));\n\t}\n}\r\n</textarea>	71
63	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　FJ在沙盘上写了这样一些字符串：\n  <br> 　　A1 = “A”\n  <br> 　　A2 = “ABA”\n  <br> 　　A3 = “ABACABA”\n  <br> 　　A4 = “ABACABADABACABA”\n  <br> 　　… …\n  <br> 　　你能找出其中的规律并写所有的数列AN吗？\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　仅有一个数：N ≤ 26。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　请输出相应的字符串AN，以一个换行符结束。输出中不得含有多余的空格或换行、回车符。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  ABACABA\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nvoid f(int a)\n{\n\tif(a==0)printf("%c",'A');\n\telse \n\t{\n\t\tf(a-1);\n\t\tprintf("%c",a+'A');\n\t\tf(a-1);\n\t}\n}\nint main()\n{\n\tint a;scanf("%d",&amp;a);f(a-1);printf("\\n");\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n\n#include&lt;cstdio&gt;\n\n \n\nusing namespace std;\n\n \n\nvoid dfs(int k,int p)\n\n{\n\n\tif (k==1)\n\n\t{\n\n\t   printf("%c",p+'A');\n\n\t   return;\t\n\n\t}\n\n\t\n\n\tdfs(k/2,p-1);dfs(1,p);dfs(k/2,p-1);\n\n}\n\n \n\nint main()\n\n{\n\n     int n;\n\n     scanf("%d",&amp;n);\n\n     int sum=1;\n\n     n--;\n\n     for (int i=1;i&lt;=n;i++) sum=sum*2+1;\n\n\t dfs(sum,n);\t\n\n\t return 0;\n\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t * @throws IOException \n\t */\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n\t\tString s=bf.readLine();\n\t\tint n=Integer.parseInt(s);\n\t\tString a="A";\n\t\tf(n,a,1);\n\t}\n\n\tprivate static void f(int n, String a, int i) {\n\t\tif(n==i){\n\t\t\tSystem.out.println(a);\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\ta=a+String.valueOf((char)(i+65))+a;\n\t\t\tif(i==n){\n\t\t\t\tSystem.out.println(a);\n\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t//while(i&lt;n)\n\t\tf(n,a,i+1);\n\t}\n\n\n\n}\r\n</textarea>	63
64	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　有n（2≤n≤20）块芯片，有好有坏，已知好芯片比坏芯片多。\n  <br> 　　每个芯片都能用来测试其他芯片。用好芯片测试其他芯片时，能正确给出被测试芯片是好还是坏。而用坏芯片测试其他芯片时，会随机给出好或是坏的测试结果（即此结果与被测试芯片实际的好坏无关）。\n  <br> 　　给出所有芯片的测试结果，问哪些芯片是好芯片。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入数据第一行为一个整数n，表示芯片个数。\n  <br> 　　第二行到第n+1行为n*n的一张表，每行n个数据。表中的每个数据为0或1，在这n行中的第i行第j列（1≤i, j≤n）的数据表示用第i块芯片测试第j块芯片时得到的测试结果，1表示好，0表示坏，i=j时一律为1（并不表示该芯片对本身的测试结果。芯片不能对本身进行测试）。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　按从小到大的顺序输出所有好芯片的编号\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3\n  <br> 1 0 1\n  <br> 0 1 0\n  <br> 1 0 1\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  1 3\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nint main()\n{\n\tint a[50][50];int i,j,n,s;scanf("%d",&amp;n);\n \tfor(j=0;j&lt;n;j++)for(i=0;i&lt;n;i++)scanf("%d",&amp;a[i][j]);\n\tfor(j=0;j&lt;n;j++){s=0;for(i=0;i&lt;n;i++)s=s+a[j][i];if(s&gt;n/2.0)printf("%d ",j+1);}\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt; \n#include&lt;cstdio&gt; \n#include&lt;cstring&gt; \n\nusing namespace std; \n\nbool a[25][25]; \nbool v[25]; \nint n; \n\nbool dfs(int k) \n{ \n    if (k==n) \n    { \n        int sum=0; \n        for (int i=1;i&lt;=n;i++) \n           if (v[i]) \n             sum++; \n         if (sum&gt;n-sum) \n           for (int i=1;i&lt;=n;i++) \n              if (v[i]) \n                 printf("%d ",i); \n        return true; \n    } \n     \n    if (v[k]==true) \n    { \n       int len=0,s[25]; \n       for (int i=1;i&lt;=n;i++) \n            if (!a[k][i] &amp;&amp; v[i]) \n            { \n               s[++len]=i; \n               v[i]=false; \n            } \n       if (dfs(k+1)) return true; \n       for (int i=1;i&lt;=len;i++) \n          v[s[i]]=true; \n    } \n     \n    if (dfs(k+1)) return true; \n      \n} \n\nint main() \n{ \n     scanf("%d",&amp;n); \n     memset(v,true,sizeof(v)); \n     for (int i=1;i&lt;=n;i++) \n        for (int j=1;j&lt;=n;j++) \n        { \n            int c; \n            scanf("%d",&amp;c); \n            if (c) a[i][j]=1; else a[i][j]=0; \n        } \n  \n     dfs(1); \n     return 0; \n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\npublic class Main {\n\tpublic static void main(String[] args)throws Exception {\n\t\tBufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n\t\tint n=Integer.parseInt(bf.readLine());\t\n\t\tint a[][]=new int[n][n];\n\t\tint b[]=new int[n*n];\n\t\tint i=0,j=0;\n\t\t\n\t\tfor(i=0;i&lt;n;i++){\n\t\t\tString s[]=bf.readLine().split(" ");\n\t\tfor(j=0;j&lt;n;j++){\n\t\t\ta[i][j]=Integer.parseInt(s[j]);\n\t\t\tif(a[i][j]==0)\n\t\t\t\tb[j]=b[j]+1;\n\t}\n\t}\n\t\tfor(i=0;i&lt;n;i++)\n\t\t\t\n\t\t\tif(b[i]&lt;=n/2)\n\t\t\t\tSystem.out.print(i+1+" ");\n\t\t\n}\n}\r\n</textarea>	64
65	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　话说这个世界上有各种各样的兔子和乌龟，但是研究发现，所有的兔子和乌龟都有一个共同的特点——喜欢赛跑。于是世界上各个角落都不断在发生着乌龟和兔子的比赛，小华对此很感兴趣，于是决定研究不同兔子和乌龟的赛跑。他发现，兔子虽然跑比乌龟快，但它们有众所周知的毛病——骄傲且懒惰，于是在与乌龟的比赛中，一旦任一秒结束后兔子发现自己领先t米或以上，它们就会停下来休息s秒。对于不同的兔子，t，s的数值是不同的，但是所有的乌龟却是一致——它们不到终点决不停止。\n  <br> 　　然而有些比赛相当漫长，全程观看会耗费大量时间，而小华发现只要在每场比赛开始后记录下兔子和乌龟的数据——兔子的速度v1（表示每秒兔子能跑v1米），乌龟的速度v2，以及兔子对应的t，s值，以及赛道的长度l——就能预测出比赛的结果。但是小华很懒，不想通过手工计算推测出比赛的结果，于是他找到了你——清华大学计算机系的高才生——请求帮助，请你写一个程序，对于输入的一场比赛的数据v1，v2，t，s，l，预测该场比赛的结果。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入只有一行，包含用空格隔开的五个正整数v1，v2，t，s，l，其中(v1,v2&lt;=100;t&lt;=300;s&lt;=10;l&lt;=10000且为v1,v2的公倍数)\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出包含两行，第一行输出比赛结果——一个大写字母“T”或“R”或“D”，分别表示乌龟获胜，兔子获胜，或者两者同时到达终点。\n  <br> 　　第二行输出一个正整数，表示获胜者（或者双方同时）到达终点所耗费的时间（秒数）。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  10 5 5 2 20\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  D\n  <br> 4\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  10 5 5 1 20\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  R\n  <br> 3\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  10 5 5 3 20\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  T\n  <br> 4\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n\tint v1,v2,t,s,l,s1=0,s2=0,i=0;\n\tscanf("%d %d %d %d %d",&amp;v1,&amp;v2,&amp;t,&amp;s,&amp;l);\n\twhile(s1&lt;l&amp;&amp;s2&lt;l)\n\t{\n\t\ts1+=v1;\n\t\ts2+=v2;\n\t\ti++;\n\t\tif(s1==l||s2==l)break;\n\t\tif(s1-s2&gt;=t)s1-=v1*s;\n\t}\n\tif(s1&gt;s2)      printf("R\\n");\n\telse if(s2&gt;s1) printf("T\\n");\n\telse\t\t   printf("D\\n");\n\tprintf("%d",i);\n    return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;cstdio&gt;\n #include&lt;iostream&gt;\n using namespace std;\n int main()\n {\n     int v1,v2,t,s,L,L1=0,L2=0,ans=0,i,j;\n     bool bk=true;\n     scanf("%d%d%d%d%d",&amp;v1,&amp;v2,&amp;t,&amp;s,&amp;L);\n     while(1)\n     {\n         if(L1-L2&gt;=t&amp;&amp;L1&lt;L&amp;&amp;L2&lt;L)\n         {\n            for(i=1;i&lt;=s;i++)\n            {\n               if(L1&lt;L&amp;&amp;L2&lt;L)\n               {\n              L2+=v2;\n              ans++;\n               }\n            }\n         }\n         else\n         {\n             L2+=v2;\n             L1+=v1;\n             ans++;\n         }\n         if(L1&gt;=L) break;\n         if(L2&gt;=L) break;\n     }\n     if(L1&gt;=L&amp;&amp;L2&gt;=L){printf("D\\n%d\\n",ans);return 0;}\n     if(L1&gt;=L) {printf("R\\n%d\\n",ans); return 0;}\n     if(L2&gt;=L) {printf("T\\n%d\\n",ans); return 0;}\n     return 0;\n }\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\npublic class Main {\n    public static void main(String[] args)throws Exception {\n        BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n        String str[]=bf.readLine().split(" ");\n        int v1=Integer.parseInt(str[0]);\n        int v2=Integer.parseInt(str[1]);\n        int t=Integer.parseInt(str[2]);\n        int s=Integer.parseInt(str[3]);\n        int l=Integer.parseInt(str[4]);\n        int x=0,y=0,time=0;\n        for(int i=1;i&lt;=l;i++){\n            if(x-y&lt;t){\n                x+=v1;\n                y+=v2;               \n            }\n            else{\n                for(int j=1;j&lt;=s;j++){\n                    i=i+1;\n                   y+=v2;\n                if(y==l)\n                    break;\n                }\n                i=i-1;\n            }\n            if(x==l||y==l){\n                time=i;\n                break;\n        }\n        }\n        if(y==l&amp;&amp;x&lt;l)\n            System.out.println("T");\n        if(x==l&amp;&amp;y&lt;l)\n            System.out.println("R");\n        if(y==l&amp;&amp;x==l)\n            System.out.println("D");\n        System.out.println(time);\n    }\n}\n\r\n</textarea>	65
66	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　回形取数就是沿矩阵的边取数，若当前方向上无数可取或已经取过，则左转90度。一开始位于矩阵左上角，方向向下。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入第一行是两个不超过200的正整数m, n，表示矩阵的行和列。接下来m行每行n个整数，表示这个矩阵。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出只有一行，共mn个数，为输入矩阵回形取数得到的结果。数之间用一个空格分隔，行末不要有多余的空格。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3 3\n  <br> 1 2 3\n  <br> 4 5 6\n  <br> 7 8 9\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  1 4 7 8 9 6 3 2 5\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3 2\n  <br> 1 2\n  <br> 3 4\n  <br> 5 6\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  1 3 5 6 4 2\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\n#define MAX_N 200\nint m,n;\nint a[MAX_N][MAX_N],b[MAX_N][MAX_N];\nint s=0;\nvoid solve(int i,int j)\n{\n\tif(i&lt;m &amp;&amp; i&gt;=0 &amp;&amp; j&lt;n &amp;&amp; j&gt;=0 &amp;&amp; b[i][j] == 0)\n\t{\n\t\tprintf("%d ",a[i][j]);\n\t\tb[i][j] = 1;\n\t\n\t}\n\telse\n\t{\n\t\ts++;\n\t\treturn ;\n\t}\n\tif(s%4 == 0)\n\tsolve(i+1,j);\n\tif(s%4 == 1)\n\tsolve(i,j+1);\n\tif(s%4 == 2)\n\tsolve(i-1,j);\n\tif(s%4 == 3)\n\tsolve(i,j-1);\n\tif(s%4 == 0)\n\tsolve(i+1,j);\n\tif(s%4 == 1)\n\tsolve(i,j+1);\n\tif(s%4 == 2)\n\tsolve(i-1,j);\n\tif(s%4 == 3)\n\tsolve(i,j-1);\n\n\treturn ;\n}\n\nint main()\n{\n\tmemset(b,0,sizeof(b));\n\tscanf("%d%d",&amp;m,&amp;n);\n\tint i,j;\n\tfor(i=0; i&lt;m; i++)\n\t\tfor(j=0; j&lt;n; j++)\n\t\t\tscanf("%d",&amp;a[i][j]);\n\tsolve(0,0);\n\tputs("");\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n\tint m,n;\n\tscanf("%d %d",&amp;m,&amp;n);\n\tint s[200][200];\n\tint a[200][200];\n\tint i,j;\n\tfor(i=0;i&lt;m;i++)\n\t\tfor(j=0;j&lt;n;j++)\n\t\t{\n\t\t\tscanf("%d",&amp;s[i][j]);\n\t\t\ta[i][j]=-1;\n\t\t}\n\tint k=0,b=m-1,c=n-1;\n\tint h=0;\n\tfor(i=j=h;a[i][j]==-1&amp;&amp;k&lt;=m*n;)\n\t\t{\n\t\t\tif(k&lt;m*n)\n\t\t\t\tprintf("%d ",s[i][j]);\n\t\t\telse\n\t\t\t\tprintf("%d",s[i][j]);\n\t\t\tk++;\n\t\t\ta[i][j]=0;\n\t\t\tif(i&lt;b&amp;&amp;a[i+1][j]==-1&amp;&amp;j==n-1-c)\n\t\t\t{\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\t\n\t\t\tif(i==b&amp;&amp;a[i][j+1]==-1)\n\t\t\t{\n\t\t\t\tj++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\t\n\t\t\tif(j==c&amp;&amp;a[i-1][j]==-1)\n\t\t\t{\n\t\t\t\ti--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(i==m-1-b&amp;&amp;a[i][j-1]==-1)\n\t\t\t{\n\t\t\t\tj--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti=j=(++h);\n\t\t\tb--;c--;\n\t\t\t\n\t\t} \n\treturn 0;\n} \r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\npublic class Main{\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args)throws IOException{\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tint[] nm=new int[2];\n\t\tString[] s=br.readLine().split(" ");\n\t\tfor(int i=0;i&lt;2;i++){\n\t\t\tnm[i]=Integer.parseInt(s[i]);\n\t\t}\n\t\tint m=nm[0],n=nm[1];\n\t\t//System.out.println(n+"   "+m);\n\t    int[][] arr=new int[m][n];\n\t\tfor(int i=0;i&lt;m;i++){\n\t\t\tString s1=br.readLine();\n\t\t\tString[] str=s1.split(" ");\n\t\t\tfor(int j=0;j&lt;n;j++){\n\t\t\t\tarr[i][j]=Integer.parseInt(str[j]);\t\n\t\t\t}\n\t\t}\n\t\tint  num=n*m,brr=0;\n\t\tint i=0,j=0,x=0,y=0,z=0;\n\t\tfor(int ii=0;ii&lt;num;ii++){\n\t\t\tif(j&lt;n&amp;&amp;x&lt;m){\n\t\t\t\tbrr=arr[i][j];\n\t\t\t\tif(i&lt;m-1){\n\t\t\t\t  i++;\n\t\t\t\t}\n\t\t\t\tx++;\n\t\t\t     }\n\t\t\telse if(j&lt;n-1&amp;&amp;i==m-1){\n\t\t\t\tj++;\n\t\t\t\ty++;\n\t\t\tbrr=arr[i][j];\n\t\t\t}\n\t\t\telse if(j==y&amp;&amp;i&gt;z){\n\t\t\t\ti--;\n\t\t\t\tbrr=arr[i][j];\n\t\t\t}\n\t\t\telse if(i==z&amp;&amp;j&gt;z){\n\t\t\t\tj--;\n\t\t\t\tbrr=arr[i][j];\n\t\t\t\tif(i==z&amp;&amp;j==z+1){\n\t\t\t\t\tz++;\n\t\t\t\t\ti++;\n\t\t\t\t\tm=m-1;\n\t\t\t\t\tn=n-1;\n\t\t\t\t\tx=z;\n\t\t\t\t\ty=z;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.print(brr+" ");\n\t\t}\n\t\t\n\t\t}\n}\r\n</textarea>	66
72	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　任何一个正整数都可以用2的幂次方表示。例如：\n  <br> 　　137=2\n  <sup>7</sup>+2\n  <sup>3</sup>+2\n  <sup>0 </sup>\n  <br> 　　同时约定方次用括号来表示，即a\n  <sup>b</sup> 可表示为a（b）。\n  <br> 　　由此可知，137可表示为：\n  <br> 　　2（7）+2（3）+2（0）\n  <br> 　　进一步：7= 2\n  <sup>2</sup>+2+2\n  <sup>0 </sup>（2\n  <sup>1</sup>用2表示）\n  <br> 　　3=2+2\n  <sup>0 </sup>\n  <br> 　　所以最后137可表示为：\n  <br> 　　2（2（2）+2+2（0））+2（2+2（0））+2（0）\n  <br> 　　又如：\n  <br> 　　1315=2\n  <sup>10</sup> +2\n  <sup>8</sup> +2\n  <sup>5</sup> +2+1\n  <br> 　　所以1315最后可表示为：\n  <br> 　　2（2（2+2（0））+2）+2（2（2+2（0）））+2（2（2）+2（0））+2+2（0）\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入包含一个正整数N（N&lt;=20000），为要求分解的整数。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　程序输出包含一行字符串，为符合约定的n的0，2表示（在表示中不能有空格）\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nvoid f(int a)\n{\n\tint i=0,j,b[32],w,k;\n\tif(a==0)printf("0");\n\telse if(a==2)printf("2");\n\telse if(a==1)printf("2(0)");\n\telse \n\t{\n\t\twhile(a){b[i]=a%2;a=a/2;i++;}w=i;\n\tk=0;j=0;for(i=w-1;i&gt;=0;i--)if(b[i])k++;\n\tfor(i=w-1;i&gt;=0;i--)\n\t\tif(b[i])\n\t{j++;\n\tif(i==1)printf("2");\n\telse {printf("2(");f(i);printf(")");}\n\tif(j!=k)printf("+");}\n\t}\n}\nint main()\n{\n\tint a;scanf("%d",&amp;a);\n\tf(a);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;cstdio&gt;\n#include&lt;stack&gt;\nusing namespace std;\n\nvoid f(int n){\n\tint i=0;\n\tstack&lt;int&gt;s;\n\tif(n&lt;=2)\n\t\tprintf("%d",n);\n\telse while(n&gt;0){\n\t\tif(n&amp;1){\n\t\t\ts.push(i);\n\t\t}\n\t\tn&gt;&gt;=1;\n\t\ti++;\n\t}\n\tbool p=0;\n\twhile(!s.empty()){\n\t\tif(p)printf("+");\n\t\tp=1;\n\t\ti=s.top();\n\t\ts.pop();\n\t\tif(i!=1){\n\t\t\tprintf("2(");\n\t\t\tf(i);\n\t\t\tprintf(")");\n\t\t}else printf("2");\n\t}\n}\n\nint main(){\n\tint n;\n\tscanf("%d",&amp;n);\n\tf(n);\n\tprintf("\\n");\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint number = Integer.valueOf(br.readLine());\n\t\ttoString(Integer.toBinaryString(number));\n\t}\n\n\tprivate static void toString(String binary) {\n\t\tchar[] temp = binary.toCharArray();\n\t\tboolean control = false;\n\t\tfor (int i = 0; i &lt; temp.length; i++) {\n\t\t\tif (temp[i] == '1') {\n\t\t\t\tif (control)\n\t\t\t\t\tSystem.out.print("+");\n\t\t\t\telse\n\t\t\t\t\tcontrol = true;\n\t\t\t\tSystem.out.print("2");\n\t\t\t\tint mi = temp.length - i - 1;\n\t\t\t\tif (mi == 0)\n\t\t\t\t\tSystem.out.print("(0)");\n\t\t\t\telse if (mi &gt; 1) {\n\t\t\t\t\tSystem.out.print("(");\n\t\t\t\t\ttoString(Integer.toBinaryString(mi));\n\t\t\t\t\tSystem.out.print(")");\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n}\n\r\n</textarea>	72
67	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　给定当前的时间，请用英文的读法将它读出来。\n  <br> 　　时间用时h和分m表示，在英文的读法中，读一个时间的方法是：\n  <br> 　　如果m为0，则将时读出来，然后加上“o'clock”，如3:00读作“three o'clock”。\n  <br> 　　如果m不为0，则将时读出来，然后将分读出来，如5:30读作“five thirty”。\n  <br> 　　时和分的读法使用的是英文数字的读法，其中0~20读作：\n  <br> 　　0:zero, 1: one, 2:two, 3:three, 4:four, 5:five, 6:six, 7:seven, 8:eight, 9:nine, 10:ten, 11:eleven, 12:twelve, 13:thirteen, 14:fourteen, 15:fifteen, 16:sixteen, 17:seventeen, 18:eighteen, 19:nineteen, 20:twenty。\n  <br> 　　30读作thirty，40读作forty，50读作fifty。\n  <br> 　　对于大于20小于60的数字，首先读整十的数，然后再加上个位数。如31首先读30再加1的读法，读作“thirty one”。\n  <br> 　　按上面的规则21:54读作“twenty one fifty four”，9:07读作“nine seven”，0:15读作“zero fifteen”。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入包含两个非负整数h和m，表示时间的时和分。非零的数字前没有前导0。h小于24，m小于60。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出时间时刻的英文。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  0 15\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  zero fifteen\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nint main()\n{\n\tint h,m;\n\tchar g[50][50]={"zero","one","two","three","four","five","six","seven","eight","nine","ten","eleven","twelve","thirteen","fourteen","fifteen","sixteen","seventeen","eighteen","nineteen","twenty"};\n\tchar s[10][10]={"twenty","thirty","forty","fifty"};\n\tscanf("%d%d",&amp;h,&amp;m);\n\tif(m==0)if(h&lt;21)printf("%s o'clock",g[h]);else {printf("%s %s o'clock",s[h/10-2],g[h%10]);}\n\telse {\n\t\tif(h&lt;21)printf("%s ",g[h]);else {printf("%s %s ",s[h/10-2],g[h%10]);}\n\t\tif(m&lt;21)printf("%s ",g[m]);else {printf("%s %s ",s[m/10-2],g[m%10]);}\n\t\t}\n\tprintf("\\n");\nreturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;map&gt;\nusing namespace std;\nint main(int argc, char** argv)\n{\n\tmap&lt;int,string&gt; maptime;\n\tmaptime[0]="zero";\n\tmaptime[1]="one";\n\tmaptime[2]="two";\n\tmaptime[3]="three";\n\tmaptime[4]="four";\n\tmaptime[5]="five";\n\tmaptime[6]="six";\n\tmaptime[7]="seven";\n\tmaptime[8]="eight";\n\tmaptime[9]="nine";\n\tmaptime[10]="ten";\n\tmaptime[11]="eleven";\n\tmaptime[12]="twelve";\n\tmaptime[13]="thirteen";\n\tmaptime[14]="fourteen";\n\tmaptime[15]="fifteen";\n\tmaptime[16]="sixteen";\n\tmaptime[17]="seventeen";\n\tmaptime[18]="eighteen";\n\tmaptime[19]="nineteen";\n\tmaptime[20]="twenty";\n\tmaptime[30]="thirty";\n\tmaptime[40]="forty";\n\tmaptime[50]="fifty";\n\tint h,m;\n\tcin&gt;&gt;h&gt;&gt;m;\n\tif(m==0)\n\t{\n\t\tif(h&lt;=20)\n\t\t{\n\t\t\tcout&lt;&lt;maptime[h]&lt;&lt;" o'clock";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout&lt;&lt;maptime[20]&lt;&lt;" "&lt;&lt;maptime[h-20]&lt;&lt;" o'clock";\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(h&lt;=20)\n\t\t{\n\t\t\tcout&lt;&lt;maptime[h]&lt;&lt;" ";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout&lt;&lt;maptime[20]&lt;&lt;" "&lt;&lt;maptime[h-20]&lt;&lt;" ";\n\t\t}\n\t\tif(m&lt;=20)\n\t\t{\n\t\t\tcout&lt;&lt;maptime[m]&lt;&lt;" ";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint k=m%10;\n\t\t\tcout&lt;&lt;maptime[m-k]&lt;&lt;" "&lt;&lt;maptime[k]&lt;&lt;" ";\n\t\t}\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\r\n        public class Main {\r\n            public static void main(String[] args)throws IOException {\r\n            BufferedReader buf=new BufferedReader(new InputStreamReader(System.in));\r\n            String str=buf.readLine();\r\n            String s[]=str.split(" ");\r\n            StringBuffer bf=new StringBuffer();\r\n             int i=Integer.parseInt(s[0]);\r\n            int n=Integer.parseInt(s[1]);\r\n            switch(i){\r\n            case 0:{\r\n                bf.append("zero ");\r\n                break;\r\n            }\r\n            case 1:{\r\n                bf.append("one ");\r\n                break;\r\n            }\r\n            case 2:{\r\n                bf.append("two ");\r\n                break;\r\n            }\r\n            case 3:{\r\n                bf.append("three ");\r\n                break;\r\n            }\r\n            case 4:{\r\n                bf.append("four ");\r\n                break;\r\n            }\r\n            case 5:{\r\n                bf.append("five ");\r\n                break;\r\n            }\r\n            case 6:{\r\n                bf.append("six ");\r\n                break;\r\n            }\r\n            case 7:{\r\n                bf.append("seven ");\r\n                break;\r\n            }\r\n            case 8:{\r\n                bf.append("eight ");\r\n                break;\r\n            }\r\n            case 9:{\r\n                bf.append("nine ");\r\n                break;\r\n            }\r\n            case 10:{\r\n                bf.append("ten ");\r\n                break;\r\n            }\r\n            case 11:{\r\n                bf.append("eleven ");\r\n                break;\r\n            }\r\n            case 12:{\r\n                bf.append("twelve ");\r\n                break;\r\n            }\r\n            case 13:{\r\n                bf.append("thirteen ");\r\n                break;\r\n            }\r\n            case 14:{\r\n                bf.append("fourteen ");\r\n                break;\r\n            }\r\n            case 15:{\r\n                bf.append("fifteen ");\r\n                break;\r\n            }\r\n            case 16:{\r\n                bf.append("sixteen ");\r\n                break;\r\n            }\r\n            case 17:{\r\n                bf.append("seventeen ");\r\n                break;\r\n            }\r\n            case 18:{\r\n                bf.append("eighteen ");\r\n                break;\r\n            }\r\n            case 19:{\r\n                bf.append("nineteen ");\r\n                break;\r\n            }\r\n            case 20:{\r\n                bf.append("twenty ");\r\n                break;\r\n            }\r\n            case 21:{\r\n                bf.append("twenty one ");\r\n                break;\r\n            }\r\n            case 22:{\r\n                bf.append("twenty two ");\r\n                break;\r\n            }\r\n            case 23:{\r\n                bf.append("twenty three ");\r\n                break;\r\n            }\r\n            \r\n            }\r\n            if(n==0){\r\n                bf.append("o'clock");\r\n            }\r\n            else if(n/10&lt;2){\r\n                switch(n){\r\n                case 1:{\r\n                    bf.append("one");\r\n                    break;\r\n                }\r\n                case 2:{\r\n                    bf.append("two");\r\n                    break;\r\n                }\r\n                case 3:{\r\n                    bf.append("three");\r\n                    break;\r\n                }\r\n                case 4:{\r\n                    bf.append("Zero");\r\n                    break;\r\n                }\r\n                case 5:{\r\n                    bf.append("five");\r\n                    break;\r\n                }\r\n                case 6:{\r\n                    bf.append("six");\r\n                    break;\r\n                }\r\n                case 7:{\r\n                    bf.append("seven");\r\n                    break;\r\n                }\r\n                case 8:{\r\n                    bf.append("eight");\r\n                    break;\r\n                }\r\n                case 9:{\r\n                    bf.append("nine");\r\n                    break;\r\n                }\r\n                case 10:{\r\n                    bf.append("ten");\r\n                    break;\r\n                }\r\n                case 11:{\r\n                    bf.append("eleven");\r\n                    break;\r\n                }\r\n                case 12:{\r\n                    bf.append("twelve ");\r\n                    break;\r\n                }\r\n                case 13:{\r\n                    bf.append("thirteen ");\r\n                    break;\r\n                }\r\n                case 14:{\r\n                    bf.append("fourteen ");\r\n                    break;\r\n                }\r\n                case 15:{\r\n                    bf.append("fifteen ");\r\n                    break;\r\n                }\r\n                case 16:{\r\n                    bf.append("sixteen ");\r\n                    break;\r\n                }\r\n                case 17:{\r\n                    bf.append("seventeen ");\r\n                    break;\r\n                }\r\n                case 18:{\r\n                    bf.append("eighteen ");\r\n                    break;\r\n                }\r\n                case 19:{\r\n                    bf.append("nineteen ");\r\n                    break;\r\n                }\r\n            }\r\n         }\r\n            else {\r\n                switch(n/10){\r\n                case 2:{\r\n                    bf.append("twenty ");\r\n                    break;\r\n                }\r\n                case 3:{\r\n                    bf.append("thirty ");\r\n                    break;\r\n                }\r\n                case 4:{\r\n                    bf.append("forty ");\r\n                    break;\r\n                }\r\n                case 5:{\r\n                    bf.append("fifty ");\r\n                    break;\r\n                }\r\n                \r\n                \r\n            }\r\n                switch(n%10){\r\n                case 1:{\r\n                    bf.append("one");\r\n                    break;\r\n                }\r\n                case 2:{\r\n                    bf.append("two");\r\n                    break;\r\n                }\r\n                case 3:{\r\n                    bf.append("three");\r\n                    break;\r\n                }\r\n                case 4:{\r\n                    bf.append("four");\r\n                    break;\r\n                }\r\n                case 5:{\r\n                    bf.append("five");\r\n                    break;\r\n                }\r\n                case 6:{\r\n                    bf.append("six");\r\n                    break;\r\n                }\r\n                case 7:{\r\n                    bf.append("seven");\r\n                    break;\r\n                }\r\n                case 8:{\r\n                    bf.append("eight");\r\n                    break;\r\n                }\r\n                case 9:{\r\n                    bf.append("nine");\r\n                    break;\r\n                }\r\n            }\r\n}\r\n            System.out.println(bf.toString());\r\n            }\r\n}\r\n\r\n</textarea>	67
68	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　给定一个n*n的棋盘，棋盘中有一些位置不能放皇后。现在要向棋盘中放入n个黑皇后和n个白皇后，使任意的两个黑皇后都不在同一行、同一列或同一条对角线上，任意的两个白皇后都不在同一行、同一列或同一条对角线上。问总共有多少种放法？n小于等于8。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入的第一行为一个整数n，表示棋盘的大小。\n  <br> 　　接下来n行，每行n个0或1的整数，如果一个整数为1，表示对应的位置可以放皇后，如果一个整数为0，表示对应的位置不可以放皇后。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出一个整数，表示总共有多少种放法。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  4\n  <br> 1 1 1 1\n  <br> 1 1 1 1\n  <br> 1 1 1 1\n  <br> 1 1 1 1\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  2\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  4\n  <br> 1 0 1 1\n  <br> 1 1 1 1\n  <br> 1 1 1 1\n  <br> 1 1 1 1\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  0\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint a[9][9],n,sum;\nint row1[9],diagl1[17],diagr1[17],row2[9],diagl2[17],diagr2[17];\nvoid dfs2(int i)\n{\n\tint j;\n\tif(i==n+1)\n\t{\n\t\tsum++;\n\t\treturn;\n\t}\n\tfor(j=1;j&lt;=n;j++)\n\t\t{\n\t\t\tif(a[i][j]==1&amp;&amp;row2[j]!=0&amp;&amp;diagl2[n-i+j]!=0&amp;&amp;diagr2[i+j]!=0)\n\t\t\t{\n\t\t\t\ta[i][j]=0;\n\t\t\t\trow2[j]=0;\n\t\t\t\tdiagl2[n-i+j]=0;\n\t\t\t\tdiagr2[i+j]=0;\n\t\t\t\tdfs2(i+1);\n\t\t\t\trow2[j]=1;\n\t\t\t\tdiagl2[n-i+j]=1;\n\t\t\t\tdiagr2[i+j]=1;\n\t\t\t\ta[i][j]=1;\n\t\t\t}\n\t\t}\n}\nvoid dfs1(int i)\n{\n\tint j,h,r;\n\tif(i==n+1)\n\t{\n\t\t\t\tfor(h=1,r=1;r&lt;=n;r++)\n\t\t\t\t{\n\t\t\t\t\tif(a[1][r]==1)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[1][r]=0;\n\t\t\t\t\t\trow2[r]=0;\n\t\t\t\t\t\tdiagl2[n-h+r]=0;\n\t\t\t\t\t\tdiagr2[h+r]=0;\n\t\t\t\t\t\tdfs2(h+1);\n\t\t\t\t\t\trow2[r]=1;\n\t\t\t\t\t\tdiagl2[n-h+r]=1;\n\t\t\t\t\t\tdiagr2[h+r]=1;\n\t\t\t\t\t\ta[1][r]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t}\n\tfor(j=1;j&lt;=n;j++)\n\t\t{\n\t\t\tif(a[i][j]==1&amp;&amp;row1[j]!=0&amp;&amp;diagl1[n-i+j]!=0&amp;&amp;diagr1[i+j]!=0)\n\t\t\t{\n\t\t\t\ta[i][j]=0;\n\t\t\t\trow1[j]=0;\n\t\t\t\tdiagl1[n-i+j]=0;\n\t\t\t\tdiagr1[i+j]=0;\n\t\t\t\tdfs1(i+1);\n\t\t\t\trow1[j]=1;\n\t\t\t\tdiagl1[n-i+j]=1;\n\t\t\t\tdiagr1[i+j]=1;\n\t\t\t\ta[i][j]=1;\n\t\t\t}\n\t\t}\n}\n\nint main()\n{\n\tint i,j;\n\twhile(scanf("%d",&amp;n)!=EOF)\n\t{\n\t\tsum=0;\n\t\tfor(i=1;i&lt;=n;i++)\n\t\tfor(j=1;j&lt;=n;j++)\n\t\tscanf("%d",&amp;a[i][j]);\n\t\tfor(i=1;i&lt;=n;i++)\n\t\trow1[i]=row2[i]=1;\n\t\tfor(i=1;i&lt;=2*n;i++)\n\t\tdiagl1[i]=diagr1[i]=diagl2[i]=diagr2[i]=1;\n\t\tfor(i=1,j=1;j&lt;=n;j++)\n\t\t{\n\t\t\tif(a[1][j]==1)\n\t\t\t{\n\t\t\t\ta[1][j]=0;\n\t\t\t\trow1[j]=0;\n\t\t\t\tdiagl1[n-i+j]=0;\n\t\t\t\tdiagr1[i+j]=0;\n\t\t\t\tdfs1(i+1);\n\t\t\t\trow1[j]=1;\n\t\t\t\tdiagl1[n-i+j]=1;\n\t\t\t\tdiagr1[i+j]=1;\n\t\t\t\ta[1][j]=1;\n\t\t\t}\n\t\t}\n\t\tprintf("%d\\n",sum);\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;cstdio&gt;\nusing namespace std;\n\nint n;\nint sum;\nbool g[9][9];\nbool wh[9];\nbool wd[17];\nbool wu[17];\nbool bh[9];\nbool bd[17];\nbool bu[17];\n\nvoid white(int h){\n\tif(h==n){\n\t\tsum++;\n\t}else{\n\t\tfor(int i=0;i&lt;n;i++){\n\t\t\tif(!g[h][i])continue;\n\t\t\tif(wh[i])continue;\n\t\t\tif(wd[i+h])continue;\n\t\t\tif(wu[(i-h)+n])continue;\n\t\t\twh[i]=wd[i+h]=wu[(i-h)+n]=1;\n\t\t\twhite(h+1);\t\t\t\n\t\t\twh[i]=wd[i+h]=wu[(i-h)+n]=0;\n\t\t}\n\t}\n}\n\nvoid black(int h){\n\tif(h==n){\n\t\twhite(0);\n\t}else{\n\t\tfor(int i=0;i&lt;n;i++){\n\t\t\tif(!g[h][i])continue;\n\t\t\tif(bh[i])continue;\n\t\t\tif(bd[i+h])continue;\n\t\t\tif(bu[(i-h)+n])continue;\n\t\t\tg[h][i]=0;\n\t\t\tbh[i]=bd[i+h]=bu[(i-h)+n]=1;\n\t\t\tblack(h+1);\t\t\t\n\t\t\tg[h][i]=1;\n\t\t\tbh[i]=bd[i+h]=bu[(i-h)+n]=0;\n\t\t}\n\t}\n}\n\nint main(){\n\tint i;\n\tint x;\n\tsum=0;\n\tscanf("%d",&amp;n);\n\tfor(i=0;i&lt;n;i++){\n\t\twh[i]=bh[i]=0;\n\t\twd[i]=bd[i]=0;\n\t\twu[i]=bu[i]=0;\n\t\tfor(int j=0;j&lt;n;j++){\n\t\t\tscanf("%d",&amp;x);\n\t\t\tg[i][j]=(bool)x;\n\t\t}\n\t}\n\tfor(;i&lt;2*n;i++){\n\t\twd[i]=bd[i]=0;\n\t\twu[i]=bu[i]=0;\n\t}\n\tblack(0);\n\tprintf("%d\\n",sum);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\n\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static int n = 0;\n\tpublic static int a[] = new int[10];\n\tpublic static int isa[][] = new int[10][10];\n\tpublic static boolean flag = false;\n\tpublic static int sum = 0;\n\n\tpublic static boolean judge(int k) {\n\t\tfor (int j = 1; j &lt; k; j++) {\n\t\t\tif (Math.abs(j - k) == Math.abs(a[j] - a[k]) || a[j] == a[k])\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static void place(int t) {\n\t\tif (t &gt; n &amp;&amp; !flag) {\n\t\t\tflag = true;\n\t\t\tplace(1);\n\t\t\tflag = false;\n\t\t} else if (t &gt; n &amp;&amp; flag) {\n\t\t\tsum++;\n\t\t} else {\n\t\t\tfor (int i = 1; i &lt;= n; i++) {\n\t\t\t\tif (isa[t][i] == 1) {\n\t\t\t\t\tint temp = a[t]; \n\t\t\t\t\ta[t] = i;\n\t\t\t\t\tif (judge(t)) {\n\t\t\t\t\t\tisa[t][i] = 2;\n\t\t\t\t\t\tplace(t + 1);\n\t\t\t\t\t\tisa[t][i] = 1;\n\t\t\t\t\t}\n\t\t\t\t\ta[t] = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\tfor (int i = 1; i &lt;= n; i++) {\n\t\t\tfor (int j = 1; j &lt;= n; j++) {\n\t\t\t\tisa[i][j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\tplace(1);\n\t\tSystem.out.println(sum);\n\t}\n}\n\r\n</textarea>	68
69	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　Huffman树在编码中有着广泛的应用。在这里，我们只关心Huffman树的构造过程。\n  <br> 　　给出一列数{\n  <i>p<sub>i</sub></i>}={\n  <i>p</i>\n  <sub>0</sub>, \n  <i>p</i>\n  <sub>1</sub>, …, \n  <i>p<sub>n</sub></i>\n  <sub>-1</sub>}，用这列数构造Huffman树的过程如下：\n  <br> 　　1. 找到{\n  <i>p<sub>i</sub></i>}中最小的两个数，设为\n  <i>p<sub>a</sub></i>和\n  <i>p<sub>b</sub></i>，将\n  <i>p<sub>a</sub></i>和\n  <i>p<sub>b</sub></i>从{\n  <i>p<sub>i</sub></i>}中删除掉，然后将它们的和加入到{\n  <i>p<sub>i</sub></i>}中。这个过程的费用记为\n  <i>p<sub>a</sub></i> + \n  <i>p<sub>b</sub></i>。\n  <br> 　　2. 重复步骤1，直到{\n  <i>p<sub>i</sub></i>}中只剩下一个数。\n  <br> 　　在上面的操作过程中，把所有的费用相加，就得到了构造Huffman树的总费用。\n  <br> 　　本题任务：对于给定的一个数列，现在请你求出用该数列构造Huffman树的总费用。\n  <br> \n  <br> 　　例如，对于数列{\n  <i>p<sub>i</sub></i>}={5, 3, 8, 2, 9}，Huffman树的构造过程如下：\n  <br> 　　1. 找到{5, 3, 8, 2, 9}中最小的两个数，分别是2和3，从{\n  <i>p<sub>i</sub></i>}中删除它们并将和5加入，得到{5, 8, 9, 5}，费用为5。\n  <br> 　　2. 找到{5, 8, 9, 5}中最小的两个数，分别是5和5，从{\n  <i>p<sub>i</sub></i>}中删除它们并将和10加入，得到{8, 9, 10}，费用为10。\n  <br> 　　3. 找到{8, 9, 10}中最小的两个数，分别是8和9，从{\n  <i>p<sub>i</sub></i>}中删除它们并将和17加入，得到{10, 17}，费用为17。\n  <br> 　　4. 找到{10, 17}中最小的两个数，分别是10和17，从{\n  <i>p<sub>i</sub></i>}中删除它们并将和27加入，得到{27}，费用为27。\n  <br> 　　5. 现在，数列中只剩下一个数27，构造过程结束，总费用为5+10+17+27=59。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入的第一行包含一个正整数\n  <i>n</i>（\n  <i>n</i>&lt;=100）。\n  <br> 　　接下来是\n  <i>n</i>个正整数，表示\n  <i>p</i>\n  <sub>0</sub>, \n  <i>p</i>\n  <sub>1</sub>, …, \n  <i>p<sub>n</sub></i>\n  <sub>-1</sub>，每个数不超过1000。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出用这些数构造Huffman树的总费用。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5\n  <br> 5 3 8 2 9\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  59\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n\ntypedef struct\n{\n\tint a[100];\n\tint len;\n}huf;\n\nint sum=0;\n\nint del(huf* in,int t)\n{\n\tint i,j;\n\tfor(i=0;i&lt;in-&gt;len &amp;&amp; in-&gt;a[i]!=t;i++);\n\tfor(;i&lt;in-&gt;len-1;i++)\n\t\tin-&gt;a[i]=in-&gt;a[i+1];\n\tin-&gt;len--;\n\treturn 1;\n}\n\nint add(huf* in,int t)\n{\n\tin-&gt;a[in-&gt;len]=t;\n\tin-&gt;len++;\n}\n\nint find_two_mins(huf* in)\n{\n\tint i,j,t;\n\tint mina,minb;\n\n\tfor(i=0;i&lt;in-&gt;len-1;i++)\n\t\tfor(j=i+1;j&lt;in-&gt;len;j++)\n\t\t\tif(in-&gt;a[i]&gt;in-&gt;a[j])\n\t\t\t{\n\t\t\t\tt=in-&gt;a[i];\n\t\t\t\tin-&gt;a[i]=in-&gt;a[j];\n\t\t\t\tin-&gt;a[j]=t;\n\t\t\t}\n\tmina=in-&gt;a[0];\n\tminb=in-&gt;a[1];\n\tdel(in,mina);\n\tdel(in,minb);\n\tadd(in,mina+minb);\n\treturn mina+minb;\n}\n\nint main()\n{\n\thuf in;\n\tint i,j,n;\n\tscanf("%d",&amp;n);\n\tin.len=n;\n\tfor(i=0;i&lt;n;i++)\n\t\tscanf("%d",&amp;in.a[i]);\n\n\twhile(1)\n\t{\n\t\tif(in.len==2)\n\t\t{\n\t\t\tsum=sum+in.a[0]+in.a[1];\n\t\t\tbreak;\n\t\t}\n\t\tsum+=find_two_mins(&amp;in);\n\t}\n\tprintf("%d",sum);\n\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;queue&gt;\nusing namespace std;\npriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; pq; //构造从小到大的优先队列 \nint main() {\n  int n;\n  cin &gt;&gt; n;\n  while (!pq.empty())\n    pq.pop();\n  int x, s;\n  for (int i = 0; i &lt; n; i++) {\n    cin &gt;&gt; x;\n    pq.push(x); \n  } \n  int sum = 0;\n  while (pq.size() &gt; 1) {\n    s = pq.top();\n    pq.pop();\n    s += pq.top();\n    pq.pop();\n    sum += s;\n    pq.push(s);\n  }\n  cout &lt;&lt; sum &lt;&lt; endl;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\nimport java.math.BigInteger;\npublic class Main {\n\tpublic static void main(String[] args)throws IOException {\n\tBufferedReader buf=new BufferedReader(new InputStreamReader(System.in));\n\tint n=Integer.parseInt(buf.readLine());\n\tString str=buf.readLine();\n\tString s[]=str.split(" ");\n     int sum=0;\n     int a[] =new int[n];\n     int num=0;\n  for(int i=0;i&lt;n;i++)\n    \t a[i]=Integer.parseInt(s[i]);\n    \t  java.util.Arrays.sort(a);\n    \t  \n    \t  if(n&gt;1){\n    \t  sum=a[0]+a[1];\n    \t  num=sum;\n    \t  a[1]=num;\n    \t  for(int j=2;j&lt;n;j++){\n    \t\t  if(j&lt;n){\n    \t\t\t  java.util.Arrays.sort(a);\n    \t\t\t  num=a[j-1]+a[j];\n    \t\t     a[j]=num;\n    \t\t java.util.Arrays.sort(a);\n    \t\t sum+=num;\n    \t\t  }\n    \t\t  \n    \t  }\n    \t  }\n    \t  else {\n    \t     \n    \t\t sum=a[0];\n    \t  }\n    \tSystem.out.println(sum);\n\n\t}\n\n}\n\r\n</textarea>	69
70	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　输入两个整数\n  <i>a</i>和\n  <i>b</i>，输出这两个整数的和。\n  <i>a</i>和\n  <i>b</i>都不超过100位。\n </div>\n <div class="pdsec">\n  算法描述\n </div>\n <div class="pdcont">\n  　　由于\n  <i>a</i>和\n  <i>b</i>都比较大，所以不能直接使用语言中的标准数据类型来存储。对于这种问题，一般使用数组来处理。\n  <br> 　　定义一个数组\n  <i>A</i>，\n  <i>A</i>[0]用于存储\n  <i>a</i>的个位，\n  <i>A</i>[1]用于存储\n  <i>a</i>的十位，依此类推。同样可以用一个数组\n  <i>B</i>来存储\n  <i>b</i>。\n  <br> 　　计算\n  <i>c</i> = \n  <i>a</i> + \n  <i>b</i>的时候，首先将\n  <i>A</i>[0]与\n  <i>B</i>[0]相加，如果有进位产生，则把进位（即和的十位数）存入\n  <i>r</i>，把和的个位数存入\n  <i>C</i>[0]，即\n  <i>C</i>[0]等于(\n  <i>A</i>[0]+\n  <i>B</i>[0])%10。然后计算\n  <i>A</i>[1]与\n  <i>B</i>[1]相加，这时还应将低位进上来的值\n  <i>r</i>也加起来，即\n  <i>C</i>[1]应该是\n  <i>A</i>[1]、\n  <i>B</i>[1]和\n  <i>r</i>三个数的和．如果又有进位产生，则仍可将新的进位存入到\n  <i>r</i>中，和的个位存到\n  <i>C</i>[1]中。依此类推，即可求出\n  <i>C</i>的所有位。\n  <br> 　　最后将\n  <i>C</i>输出即可。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入包括两行，第一行为一个非负整数\n  <i>a</i>，第二行为一个非负整数\n  <i>b</i>。两个整数都不超过100位，两数的最高位都不是0。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出一行，表示\n  <i>a </i>+ \n  <i>b</i>的值。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  20100122201001221234567890\n  <br> 2010012220100122\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  20100122203011233454668012\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n#include&lt;stdlib.h&gt;\nvoid f(char a[],char b[])\n{\n\tint w=200,i,j,la,lb;\n\tla=strlen(a);lb=strlen(b);\n\tchar c[200];\n\tfor(i=la;i&lt;w;i++)a[i]=48;\n\tfor(i=lb;i&lt;w;i++)b[i]=48;\n\ta[w-1]=0;b[w-1]=0;\n\tfor(i=0;i&lt;la;i++)c[i]=a[i];\n\tfor(i=0;i&lt;w-1-la;i++)a[i]=48;j=0;\n\tfor(i=w-1-la;i&lt;w-1;i++){a[i]=c[j];j++;}\n\n\tfor(i=0;i&lt;lb;i++)c[i]=b[i];\n\tfor(i=0;i&lt;w-1-lb;i++)b[i]=48;j=0;\n\tfor(i=w-1-lb;i&lt;w-1;i++){b[i]=c[j];j++;}\n\n\tfor(i=w;i&gt;=0;i--)\n\t{\n\t\tj=a[i]+b[i]-96;\n\t\tif(j&gt;9)a[i-1]=a[i-1]+j/10;\n\t\tc[i]=j%10+48;\n\t}\n\tc[w-1]=0;\n\tfor(i=0;i&lt;w;i++)if(c[i]!='0')break;\n\tfor(;i&lt;w-1;i++)printf("%c",c[i]);printf("\\n");\n}\n\nint main()\n{\n\tchar a[200],b[200];gets(a);gets(b);\n\tf(a,b);\nreturn 0;\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;cstdio&gt;\n #include&lt;iostream&gt;\n #include&lt;cstring&gt;\n using namespace std;\n int a[401],alen,b[401],blen,c[400],clen;\n char st[400];\n int main()\n {\n int i,j,n,len;\n scanf("%s",st);\n alen= strlen(st);\n for(i=1;i&lt;=alen;i++)\n a[i]= st[alen-i]-48;\n scanf("%s",st);\n blen= strlen(st);\n for(i=1;i&lt;=blen;i++)\n b[i]= st[blen-i]-48;\n if(alen&gt;blen) clen=alen;\n else clen=blen;\n for(i=1;i&lt;=clen;i++)\n c[i]=a[i]+b[i];\n for(i=1;i&lt;=clen;i++)\n {\n if(c[i]&gt;=10)\n {\n c[i+1]=c[i+1]+ c[i]/10;\n c[i]=c[i]%10;\n }\n }\n if(c[clen+1]&gt;0)clen++;\n for(i=clen;i&gt;=1;i--)\n {\n printf("%d",c[i]);\n }\n printf("\\n");\n return 0;\n } \r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\npublic class Main{\n    public static void main(String[] args) throws NumberFormatException, IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String s1 = br.readLine();\n        String s2 = br.readLine();\n        int a[] = new int[100000];\n        int b[] = new int[100000];\n        int l1 = s1.length();\n        int l2 = s2.length();\n        for(int i=0; i&lt;l1; i++){\n            a[l1-1-i] = Character.getNumericValue(s1.charAt(i));\n        }\n        for(int i=0; i&lt;l2; i++){\n            b[l2-1-i] = Character.getNumericValue(s2.charAt(i));\n        }\n        int max = l1&gt;l2?l1:l2;\n        int c[] = new int[100000];\n        for(int i=0; i&lt;max; i++){\n            c[i] = a[i] + b[i];\n        }\n        for(int i=0; i&lt;max-1; i++){\n            if(c[i]&gt;9){\n                c[i+1] += c[i]/10;\n                c[i] = c[i]%10;\n            }\n        }\n        while(c[max-1]&gt;9){\n            c[max] = c[max-1]/10;\n            c[max-1] = c[max-1]%10;\n            max++;\n        }\n        for(int i=max-1; i&gt;=0; i--){\n            System.out.print(c[i]); \n        }\n    }\n}\r\n</textarea>	70
73	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。\n  <br> \n  <br> 　　输入导弹依次飞来的高度（雷达给出的高度数据是不大于30000的正整数），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　一行，为导弹依次飞来的高度\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　两行，分别是最多能拦截的导弹数与要拦截所有导弹最少要配备的系统数\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  389 207 155 300 299 170 158 65\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  6\n  <br> 2\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#define MAX_N 10000\n\nint dp[MAX_N]={0};\nint i=0;\nint dao[MAX_N];\n\nint max(int a,int b)\n{\n\treturn a&gt;b?a:b;\n}\n\nvoid solve1()\n{\n\tint k,j;\n\tint res = 0;\n\tint n = i;\n\tfor(j=0; j&lt;n; j++)\n\t{\n\t\tdp[j] = 1;\n\t\tfor(k=0; k&lt;j; k++)\n\t\t\tif(dao[k] &gt; dao[j])\n\t\t\t\tdp[j] = max(dp[j],dp[k]+1);\n\t\tres = max(res , dp[j]);\n\t}\n\tprintf("%d\\n",res);\n}\n\nvoid solve2()\n{\n\tint k,j;\n\tint res = 0;\n\tint n = i;\n\tfor(j=0; j&lt;n; j++)\n\t{\n\t\tdp[j] = 1;\n\t\tfor(k=0; k&lt;j; k++)\n\t\t\tif(dao[k] &lt; dao[j])\n\t\t\t\tdp[j] = max(dp[j],dp[k]+1);\n\t\tres = max(res , dp[j]);\n\t}\n\tprintf("%d\\n",res);\n}\n\n\nint main()\n{\n\tchar q;\n\tint s=0;\n\n\twhile(q=getchar())\n\t{\n\t\tif(q&gt;='0' &amp;&amp; q&lt;='9')\n\t\t\ts = s*10+q-'0';\n\t\telse if(q == ' ')\n\t\t{\n\t\t\tdao[i] = s;\n\t\t\ti++;\n\t\t\ts = 0;\n\t\t}\n\t\telse\n\t\t\tbreak;\n\t}\n\tdao[i] = s;\n\ti++;\n\n\tsolve1();\n\tsolve2();\n\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;cstdio&gt;\n#include &lt;cstdlib&gt;\n#include &lt;cstring&gt;\nusing namespace std;\nint a[10001],high[10001];\nint n = 1, top, maw;\nvoid work(int p)\n{\n    int l = 1, r = n, mid;\n    while(l != r)\n    {\n        mid = (l + r) / 2;\n        if(p &lt; high[mid]) l = mid + 1;\n        else r = mid;\n    }\n    if(p &gt; high[l]) high[l] = p;\n    if(l &gt; maw) maw = l;\n}\nvoid solve(int p)\n{\n    int l = 1, r = n, mid;\n    while(l != r)\n    {\n        mid = (l + r) / 2;\n        if(p &gt; high[mid]) l = mid + 1;\n        else r = mid;\n    }\n    if(p &lt; high[l]) high[l] = p;\n    if(l &gt; top) top = l;\n}\nint main()\n{\n    //freopen("missile.txt","r",stdin);\n    //freopen("missiles.txt","w",stdout);\n    while(scanf("%d", &amp;a[n]) != EOF) ++n;\n    --n;\n    for(int i = 1; i &lt;= n; ++i) \n        work(a[i]);\n    memset(high, 1, sizeof(high));\n    for(int i = 1; i &lt;= n; ++i) solve(a[i]);\n    printf("%d\\n%d\\n", maw, top);\n//    system("pause");\n    return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\nimport java.util.*;\npublic class Main {\n\n\tpublic static void main(String args[]) throws IOException{\n\t\tBufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n\t\tString s=bf.readLine();\n\t\tString[] ss=s.split(" ");\n\t\tint[] numa=new int[ss.length];\n\t\tint[] numb=new int[ss.length];\n\t\tint[] numc=new int[ss.length];\n\t\t\n\t\tfor(int i=0;i&lt;ss.length;i++){\n\t\t\tnuma[i]=Integer.parseInt(ss[i]);\n\t\t\tnumb[i]=1;\n\t\t\tnumc[i]=1;\n\t\t}\n\t\t\n\t\tint a1=Integer.MIN_VALUE;\n\t\tint a2=Integer.MIN_VALUE;\n\t\tfor(int i=0;i&lt;numa.length;i++){\n\t\t\tfor(int j=0;j&lt;i;j++){\n\t\t\t\tif(numa[i]&lt;numa[j]&amp;&amp;numb[i]&lt;numb[j]+1){\n\t\t\t\t\tnumb[i]=numb[j]+1;\n\t\t\t\t}\n\t\t\t\ta1=Math.max(a1, numb[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i&lt;numa.length;i++){\n\t\t\tfor(int j=0;j&lt;i;j++){\n\t\t\t\tif(numa[i]&gt;numa[j]&amp;&amp;numc[i]&lt;numc[j]+1){\n\t\t\t\t\tnumc[i]=numc[j]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\ta2=Math.max(a2, numc[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(a1);\n\t\tSystem.out.println(a2);\n\t}\n\n\n}\r\n</textarea>	73
74	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　若一个数（首位不为零）从左向右读与从右向左读都一样，我们就将其称之为回文数。\n  <br> 　　例如：给定一个10进制数56，将56加65（即把56从右向左读），得到121是一个回文数。\n  <br> \n  <br> 　　又如：对于10进制数87：\n  <br> 　　STEP1：87+78 = 165 STEP2：165+561 = 726\n  <br> 　　STEP3：726+627 = 1353 STEP4：1353+3531 = 4884\n  <br> \n  <br> 　　在这里的一步是指进行了一次N进制的加法，上例最少用了4步得到回文数4884。\n  <br> \n  <br> 　　写一个程序，给定一个N（2&lt;=N&lt;=10或N=16）进制数M（其中16进制数字为0-9与A-F），求最少经过几步可以得到回文数。\n  <br> 　　如果在30步以内（包含30步）不可能得到回文数，则输出“Impossible!”\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　两行，N与M\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　如果能在30步以内得到回文数，输出“STEP=xx”（不含引号），其中xx是步数；否则输出一行”Impossible!”（不含引号）\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  9\n  <br> 87\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  STEP=6\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n #include&lt;math.h&gt;\n #include &lt;string.h&gt;\n #include &lt;stdlib.h&gt;\n int p;\n char s[1000];\n int c[1000];\n int reverse(int a[],int n) /*判断a是否是回文*/\n {\n     int i,j;\n     i=0;\n     j=n-1;\n     while(i&lt;j&amp;&amp;a[i]==a[j])\n     {\n        i++;\n        j--;\n     }\n     return i&gt;=j;\n }\n int aplus(int a[],int n,int m)   /*计算a=a+a*/\n {\n      int *b,i,j,kc;\n      b=(int *)malloc(sizeof(int)*1001);\n      for(i=0;i&lt;n;i++)\n         b[n-1-i]=a[i];\n      kc=0;\n      for(i=0;i&lt;n;i++)\n      {\n         a[i]=a[i]+b[i]+kc;\n         kc=a[i]/m;\n         a[i]=a[i]%m;\n      }\n      if(kc&gt;0)\n        a[n++]=kc;\n      free(b);\n      return n;\n }\n int  stod(char s[],int a[])\n {\n      int i;\n      for(i=0;s[i]!='\\0';i++)\n         if(s[i]&gt;='A'&amp;&amp;s[i]&lt;='F')\n            a[i]=10+s[i]-'A';\n         else\n            a[i]=s[i]-'0';\n      return i;\n } \n int main()\n {\n     int n,i;\n     scanf("%d",&amp;p);\n     scanf("%s",s);\n     n=stod(s,c);\n     for(i=0;i&lt;30;i++)\n     {\n        n=aplus(c,n,p);\n        if(reverse(c,n)==1)\n          {\n             printf("STEP=%d\\n",i+1);\n             break;\n          }\n     }\n     if(i&gt;=30)\n       printf("Impossible!\\n");\nreturn 0;\n }\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;iostream&gt;\nusing namespace std;\n\nstruct bign{\n\tint s[1000];\n\tint n;\n\tint len;\n\n\tbign(){\n\t\tmemset(s,0,sizeof(s));\n\t\tn=10;\n\t\tlen=1;\n\t}\n\n\tbign(int n,char *m){\n\t\tint l=strlen(m);\n\t\tlen=l;\n\t\tmemset(s,0,sizeof(s));\n\t\tthis-&gt;n=n;\n\t\tfor(int i=l-1,j=0;i&gt;=0;i--){\n\t\t\tif(m[i]&gt;='0' &amp;&amp; m[i]&lt;='9')\n\t\t\t\ts[j++]=m[i]-'0';\n\t\t\telse\n\t\t\t\ts[j++]=m[i]-'A'+10;\n\t\t}\n\t}\n\n\tbign operator+(const bign&amp;x)const{\n\t\tbign ans;\n\t\tint len=this-&gt;len&gt;x.len?this-&gt;len:x.len+1;\n\t\tint n=x.n;\n\t\tfor(int i=0;i&lt;len;i++){\n\t\t\tans.s[i]+=x.s[i]+this-&gt;s[i];\n\t\t\tans.s[i+1]=ans.s[i]/n;\n\t\t\tans.s[i]%=n;\n\t\t}\n\t\tif(len&gt;1 &amp;&amp; ans.s[len-1]==0)len--;\n\t\tans.n=n;\n\t\tans.len=len;\n\t\treturn ans;\n\t}\n\n\tbign operator=(const bign&amp;x){\n\t\tthis-&gt;len=x.len;\n\t\tthis-&gt;n=x.n;\n\t\tfor(int i=0;i&lt;x.len;i++){\n\t\t\tthis-&gt;s[i]=x.s[i];\n\t\t}\n\t\treturn *this;\n\t}\n\n\tbign reversal()const{\n\t\tbign ans;\n\t\tans.len=this-&gt;len;\n\t\tans.n=this-&gt;n;\n\t\tfor(int i=this-&gt;len-1,j=0;i&gt;=0;i--){\n\t\t\tans.s[j++]=this-&gt;s[i];\n\t\t}\n\t\treturn ans;\n\t}\n\n\tbool isPalindromes()const{\n\t\tint i=this-&gt;len-1;\n\t\tint j=0;\n\t\twhile(i&gt;j){\n\t\t\tif(this-&gt;s[i]!=this-&gt;s[j])break;\n\t\t\ti--;\n\t\t\tj++;\n\t\t}\n\t\treturn i&lt;=j;\n\t}\n};\n\nostream&amp;operator&lt;&lt;(ostream&amp;out,const bign&amp;x){\n\tfor(int i=x.len-1;i&gt;=0;i--){\n\t\tif(x.s[i]&lt;10)\n\t\t\tout&lt;&lt;x.s[i];\n\t\telse\n\t\t\tout&lt;&lt;x.s[i]-10+'A';\n\t}\n\treturn out;\n}\n\nint main(){\n\tint n;\n\tchar m[1000];\n\tscanf("%d",&amp;n);\n\tgetchar();\n\tgets(m);\n\tbign a(n,m);\t\n\tint i=0;\n\twhile(!a.isPalindromes()){\n\t\tif(i&gt;30)break;\n\t\ti++;\n\t\tbign b=a.reversal();\n\t\ta=a+b;\n\t}\n\tif(i&lt;=30)printf("STEP=%d\\n",i);\n\telse printf("Impossible!\\n");\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tprivate static int n, count;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tn = Integer.parseInt(br.readLine());\n\t\tString m = br.readLine();\n\n\t\tlong a = Long.parseLong(m, n);\n\t\tlong b = Long.parseLong(new StringBuilder(m).reverse().toString(), n);\n\n\t\tif (a == b)\n\t\t\tSystem.out.println("STEP=" + 0);\n\t\telse\n\t\t\tfunc(a, b);\n\n\t}\n\n\tprivate static void func(long a, long b) {\n\n\t\tcount++;\n\t\tif (count &gt; 30) {\n\t\t\tSystem.out.println("Impossible!");\n\t\t\treturn;\n\t\t}\n\n\t\tlong sum = a + b;\n\t\tString str = "";\n\n\t\twhile (sum &gt;= n) {\n\t\t\tlong tmp = sum % n;\n\t\t\tsum /= n;\n\t\t\tif (tmp &gt;= 10)\n\t\t\t\tstr = (char) (55 + tmp) + str;\n\t\t\telse\n\t\t\t\tstr = tmp + str;\n\n\t\t}\n\t\tif (sum &gt;= 10)\n\t\t\tstr = (char) (55 + sum) + str;\n\t\telse\n\t\t\tstr = sum + str;\n\n\t\tString reverse = new StringBuilder(str).reverse().toString();\n\t\tif (!str.equals(reverse)) {\n\t\t\ta = Long.parseLong(str, n);\n\t\t\tb = Long.parseLong(reverse, n);\n\t\t\tfunc(a, b);\n\t\t} else {\n\t\t\tSystem.out.println("STEP=" + count);\n\t\t\treturn;\n\t\t}\n\t}\n}\r\n</textarea>	74
75	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　一个旅行家想驾驶汽车以最少的费用从一个城市到另一个城市（假设出发时油箱是空的）。给定两个城市之间的距离D1、汽车油箱的容量C（以升为单位）、每升汽油能行驶的距离D2、出发点每升汽油价格P和沿途油站数N（N可以为零），油站i离出发点的距离Di、每升汽油价格Pi（i=1，2，……N）。计算结果四舍五入至小数点后两位。如果无法到达目的地，则输出“No Solution”。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行为4个实数D1、C、D2、P与一个非负整数N；\n  <br> 　　接下来N行，每行两个实数Di、Pi。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　如果可以到达目的地，输出一个实数（四舍五入至小数点后两位），表示最小费用；否则输出“No Solution”（不含引号）。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  275.6 11.9 27.4 2.8 2\n  <br> 102.0 2.9\n  <br> 220.0 2.2\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  26.95\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n\n#define MAX_N 100\nfloat D1,C,D2,P;\nfloat A[MAX_N],B[MAX_N];\nint N;\n\nvoid solve()\n{\n\tint i;\n\tfloat res = 0;\n\tfloat pos,tank;\n\tpos = B[0];\n\ttank = C;\n\t\n\tres += pos*tank;\n\tfloat we=0;\n\tfor(i=1; i&lt;N; i++)\n\t{\n\t\ttank -= (A[i] - A[i-1]-we)/D2;\n\t\tif(B[i] &lt; pos)\n\t\t{\n\t\t\twe = 0;\n\t\t\tres -= tank*pos;\n\t\t\ttank = C;\n\t\t\tpos = B[i];\n\t\t\tres += tank*pos;\n\t\t}\n\n\t\telse\n\t\t{\n\t\t\tif(tank &lt; (A[i+1]-A[i])/D2)\n\t\t\t{\n\t\t\t\t we=0;\n\t\t\t\twe = tank*D2;\n\t\t\t\ttank = C;\n\t\t\t\tpos = B[i];\n\t\t\t\tres += tank*pos;\n\t\t\t}\n\t\t\tif(tank &lt; 0)\n\t\t\t{\n\t\t\t\tputs("No Solution\\n");\n\t\t\t\treturn ;\n\t\t\t}\n\t\t}\n\t}\n\n\ttank -= (D1-A[i-1]-we)/D2;\n\tif(tank &lt; 0)\n\t\t{\n\t\t\tputs("No Solution\\n");\n\t\t\treturn ;\n\t\t}\n\n\tres -= tank*pos;\n\n\tprintf("%.2f\\n",res);\n}\n\nint main()\n{\n\tint i;\n\tscanf("%f%f%f%f%d",&amp;D1,&amp;C,&amp;D2,&amp;P,&amp;N);\n\tA[0] = 0;\n\tB[0] = P;\n\tN++;\n\tA[N] = D1;\n\tfor(i=1; i&lt;N; i++)\n\t\tscanf("%f%f",&amp;A[i],&amp;B[i]);\n\tif(D1 != 0)\n\t\tsolve();\n\telse\n\t\tputs("No Solution\\n");\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;cstdio&gt;\nusing namespace std;\n\nint main(){\n\tint n;\n\tdouble d1,c,d2,p0;\n\tdouble p[1000],d[1000];\n\tscanf("%lf%lf%lf%lf%d",&amp;d1,&amp;c,&amp;d2,&amp;p0,&amp;n);\n\tfor(int i=1;i&lt;=n;i++){\n\t\tscanf("%lf%lf",&amp;d[i],&amp;p[i]);\n\t}\n\td[0]=0;\n\tp[0]=p0;\n\td[n+1]=d1;\n\tp[n+1]=0;\n\tdouble sum=0,ct=0;\n\tbool flag=1;\n\tfor(int i=0,j;i&lt;=n;i=j){\n\t\tflag=0;\n\t\tif(d[i+1]-d[i]&gt;c*d2)break;\n\t\tflag=1;\n\t\tfor(j=i+1;j&lt;=n+1;j++) {\n\t\t\tif(d[j]-d[i]&gt;c*d2){\n\t\t\t\tj--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(p[j]&lt;=p[i]) break;\n\t\t}\n\t\tif(p[j]&lt;=p[i]){\n\t\t\tsum+=((d[j]-d[i])/d2-ct)*p[i];\n\t\t\tct=0;\n\t\t}else{\n\t\t\tsum+=(c-ct)*p[i];\n\t\t\tct=c-(d[j]-d[i])/d2;\n\t\t}\n\t}\n\tif(flag)printf("%.2lf\\n",sum);\n\telse printf("No Solution\\n");\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\n\nimport java.util.Scanner;\n\npublic class Main  {\n\n\tpublic static void main(String[] args) {\n\t\tdouble[][] p = new double[1024][1024];\n\t\tScanner sc = new Scanner(System.in);\n\t\tint i, j, k = 0;\n\t\tdouble d1 = sc.nextDouble();\n\t\tdouble c = sc.nextDouble();\n\t\tdouble d2 = sc.nextDouble();\n\t\tp[0][1] = sc.nextDouble();\n\t\tint n = sc.nextInt();\n\t\tn++;\n\t\tfor (i = 1; i &lt; n; i++) {\n\t\t\tp[i][0] = sc.nextDouble();\n\t\t\tp[i][1] = sc.nextDouble();\n\t\t}\n\t\tp[n++][0] = d1;\n\t\tdouble f = c * d2;\n\t\tfor (i = 0; i &lt; n; i++) {\n\t\t\tif (p[i + 1][0] - p[i][0] &gt; f) {\n\t\t\t\tSystem.out.println("No Solution");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tdouble min = 0, max, d;\n\t\tfor (i = 0; i &lt; n - 1; i++) {\n\t\t\td = p[i + 1][0] - p[i][0];\n\t\t\twhile (d &gt; 0) {\n\t\t\t\twhile (p[i + 1][0] - p[k][0] - d &gt;= f)\n\t\t\t\t\tk++;\n\t\t\t\tfor (j = k; j &lt;= i; j++)\n\t\t\t\t\tif (p[j][1] &lt; p[k][1])\n\t\t\t\t\t\tk = j;\n\t\t\t\tmax = f - (p[i + 1][0] - p[k][0] - d);\n\t\t\t\tif (max &gt; d)\n\t\t\t\t\tmax = d;\n\t\t\t\td -= max;\n\t\t\t\tmin += max / d2 * p[k][1];\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(String.format("%.2f", min));\n\t}\n}\r\n</textarea>	75
76	<div class="des"> \n <div class="pdcont">\n  <b>问题描述</b>\n  <b> </b>\n  <br> \n  <br> 　　我们可以用这样的方式来表示一个十进制数： 将每个阿拉伯数字乘以一个以该数字所处位置的（值减１）为指数，以１０为底数的幂之和的形式。例如：１２３可表示为 １＊１０\n  <sup>２</sup>＋２＊１０\n  <sup>１</sup>＋３＊１０\n  <sup>０</sup>这样的形式。\n  <br> 　　与之相似的，对二进制数来说，也可表示成每个二进制数码乘以一个以该数字所处位置的（值－１）为指数，以２为底数的幂之和的形式。一般说来，任何一个正整数Ｒ或一个负整数－Ｒ都可以被选来作为一个数制系统的基数。如果是以Ｒ或－Ｒ为基数，则需要用到的数码为 ０，１，．．．．Ｒ－１。例如，当Ｒ＝７时，所需用到的数码是０，１，２，３，４，５和６，这与其是Ｒ或－Ｒ无关。如果作为基数的数绝对值超过１０，则为了表示这些数码，通常使用英文字母来表示那些大于９的数码。例如对１６进制数来说，用Ａ表示１０，用Ｂ表示１１，用Ｃ表示１２，用Ｄ表示１３，用Ｅ表示１４，用Ｆ表示１５。\n  <br> 　　在负进制数中是用－Ｒ 作为基数，例如－１５（十进制）相当于１１０００１（－２进制），并且它可以被表示为２的幂级数的和数：\n  <br> 　　１１０００１＝１＊（－２）\n  <sup>５</sup>＋１＊（－２）\n  <sup>４</sup>＋０＊（－２）\n  <sup>３</sup>＋０＊（－２）\n  <sup>２</sup>＋\n  <br> 　　０＊（－２）\n  <sup>１</sup> ＋１＊（－２）\n  <sup>０</sup>\n  <br> 　　\n  <sup> </sup> 设计一个程序，读入一个十进制数和一个负进制数的基数, 并将此十进制数转换为此负进制下的数： －Ｒ∈｛－２，－３，－４，．．．，－２０｝\n  <br> \n  <br> \n  <b>输</b>\n  <b>入格式</b>\n  <b> </b>\n  <br> 　　一行两个数，第一个是十进制数Ｎ（－32768＜＝Ｎ＜＝32767）， 第二个是负进制数的基数－Ｒ。\n  <br> \n  <br> \n  <b>输</b>出格式\n  <b> </b>\n  <br> 　　输出所求负进制数及其基数，若此基数超过１０，则参照１６进制的方式处理。（格式参照样例）\n  <br> \n  <br> 　　\n  <b>样</b>\n  <b>例</b>输入1\n  <br> 　　30000 -2\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  30000=11011010101110000(base-2)\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  -20000 -2\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  -20000=1111011000100000(base-2)\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  28800 -16\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  28800=19180(base-16)\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  -25000 -16\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  -25000=7FB8(base-16)\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n\nconst char nc[20]={'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','G','H','I','J'};\nchar str[20];\n\nint main()\n{\n    int m, n, k, t, s;\n    int i=0;\n\tscanf("%d%d",&amp;m,&amp;n);\n\ts = m;\n\twhile(m != 0)\n\t{\n\t\tk = m % n;\n\t\tt = m / n;\n\t\tif(k &lt; 0)\n\t\t{\n\t\t\tk -= n;\n\t\t\tt++;\n\t\t}\n\t\tm = t;\n\t\tstr[i++]=nc[k];\n\t}\n\tprintf("%d=",s);\n\tfor(i = i- 1; i &gt;= 0; i--)\n\t\tprintf("%c",str[i]);\n\tprintf("(base%d)\\n",n);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\nusing namespace std;\nint N,M,base;\n\ninline int Div(int a,int b)\n{\n\tint n;\n\tn = a / b;\n\tif(n*b &lt;= a)\n\t\treturn n;\n\treturn n + 1;\n}\n\nvoid work()\n{\n\tint num[100];\n\tint top = 0;\n\tif(N == 0)\n\t{\n\t\tcout &lt;&lt; 0;\n\t}\n\tint P;\n\twhile(N)\n\t{\n\t\tP = Div(N,base);\n\t\tnum[++top] = N - P*base;\n\t\tN = P;\n\t}\n\tfor(;top &gt;= 1;top--)\n\t{\n\t\tif(num[top]&lt;10)\n\t\t\tcout &lt;&lt; num[top];\n\t\tif(num[top] &gt;= 10)\n\t\t\tcout &lt;&lt; (char)(num[top] - 10 + 'A');\n\t}\n\tcout &lt;&lt; "(base" &lt;&lt; base &lt;&lt; ")" &lt;&lt; endl;\n}\n\nint main()\n{;\n\twhile(cin &gt;&gt; N)\n\t{\n\t\tcin &gt;&gt; base;\n\t\tM = N;\n\t\tcout &lt;&lt; N &lt;&lt; "=";\n\t\twork();\n\t}\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint N = scanner.nextInt();\n\t\tint R = scanner.nextInt();\n\t\tchar[] c = "0123456789ABCDEFG".toCharArray();\n\t\tString s1 = N + "=";\n\t\tString s = "";\n\t\twhile (N != 0) {\n\t\t\tint t = N % R;\n\t\t\tif (t &lt; 0) {\n\t\t\t\tt = t - R;\n\t\t\t\tN = N / R + 1;\n\t\t\t} else\n\t\t\t\tN = N / R;\n\t\t\ts = c[t] + s;\n\t\t}\n\t\tSystem.out.println(s1 + s + "(base" + R + ")");\n\t}\n}\r\n</textarea>	76
81	<div class="des"> \n <div class="pdcont">\n  　　考虑冒泡排序的一种实现。\n  <br> 　　bubble-sort (A[], n)\n  <br> 　　&gt; round = 0\n  <br> 　　&gt; while A is not sorted\n  <br> 　　&gt; &gt; round := round + 1\n  <br> 　　&gt; &gt; for i := 1 to n - 1\n  <br> 　　&gt; &gt; &gt; if (A[i] &gt; A[i + 1])\n  <br> 　　&gt; &gt; &gt; &gt; swap(A[i], A[i + 1])\n  <br> 　　求1 .. n的排列中，有多少个排列使得A被扫描了K遍，亦即算法结束时round == K。\n  <br> \n  <br> 　　答案模20100713输出。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入包含多组数据。每组数据为一行两个整数N，K。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　对每组数据，输出一行一个整数表示答案。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3\n  <br> 3 0\n  <br> 3 1\n  <br> 3 2\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  1\n  <br> 3\n  <br> 2\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　T &lt;= 10 ^ 5。\n  <br> 　　1 &lt;= K &lt; N &lt; 10 ^ 6。\n </div> \n</div>	<textarea id="codelinesc">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	<textarea id="codelinescpp">\r\n/**************Powered by Graphene Richards**************/\n//{\n\n#define OUTPUT_PRECISION    "%.2f"\n#define LF_PRECISION        10\n#define INT_64_MOD          "%I64d"\n#define UNSIGNED_64_MOD     "%I64u"\n\n//#pragma comment(linker,"/STACK:102400000,102400000")\n#include&lt;cmath&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;bitset&gt;\n#include&lt;complex&gt;\n#include&lt;vector&gt;\n#include&lt;iomanip&gt;\n#include&lt;iostream&gt;\n#include&lt;list&gt;\n#include&lt;map&gt;\n#include&lt;queue&gt;\n#include&lt;set&gt;\n#include&lt;stack&gt;\n#include&lt;string&gt;\n#include&lt;typeinfo&gt;\n#define FAST_RW ios_base::sync_with_stdio(0),cin.tie(0);\n#define IT(x) __typeof((x).begin())\n#define FS(i,a) for(ll i=0;a[i];i++)\n#define FE(x,ctn) for(IT(ctn)x=(ctn).begin(),CluhxSchFuDeugk=(ctn).end();x!=CluhxSchFuDeugk;x++)\n#define FR(i,en) for(ll i=0,pJNwFPtlXiwFoIv=(en);i&lt;pJNwFPtlXiwFoIv;i++)\n#define FOR(i,en) for(ll i=1,SbKCIcakJTeYVqs=(en);i&lt;=SbKCIcakJTeYVqs;i++)\n#define FFR(i,x,y) for(ll i=(x),alVDbhLBoMEGSwA=(y);i&lt;=alVDbhLBoMEGSwA;i++)\n#define DFFR(i,x,y) for(ll i=(x),NWYfecAcmGBMJuU=(y);i&gt;=NWYfecAcmGBMJuU;i--)\n#define ll long long\n#define ull unsigned long long\n#define lf long double\n#define pc putchar\n#define mp make_pair\n#define pb push_back\n#define pq priority_queue\n#define fi first\n#define se second\n#define pii pair&lt;int,int&gt;\n#define pdd pair&lt;double,double&gt;\n#define lb(x) (x&amp;(-x))\n#define sqr(x) (x)*(x)\n#define all(x) (x).begin(),(x).end()\n#define clr(x) memset((x),0,sizeof(x))\n#define ms(x,v) memset((x),(v),sizeof(x))\n#define mc(x,y) memcpy((x),(y),sizeof(y))\n#define NL puts("");\n#define fin(x,c) ((c).find(x)!=(c).end())\nusing namespace std;\n\ntemplate&lt;class T1,class T2,class T3&gt;\nbool _IN(T1 x,T2 y,T3 z){\n  return x&lt;=y&amp;&amp;x&gt;=z||x&lt;=z&amp;&amp;x&gt;=y;\n}\n\null gcd(ull a,ull b){\n  if(!b)return a;\n  while(b^=a^=b^=a%=b);\n  return a;\n}\n\n#ifdef wmx16835\n#define NOT_TESTING_TEMPLATE_CPP\n#include"wmx16835.cpp"\n\n#else\nint ebtpqJsBCnTgggi;\n#define LOG {\n#define TEL }\n#define SHOW_TIME\n#define test(...) ebtpqJsBCnTgggi\n#define TEST(...) ebtpqJsBCnTgggi\n#define TRY(...)\n#define PF\n#define PP ;\n#endif\n\nbool S(char*a){\n  return scanf("%s",a)==1;\n}\n\nchar DATaJNTFnlmAoya[2];\n\ntemplate&lt;class T&gt;\nbool S(T&amp;a){\n  const char*x=typeid(a).name();\n  if(!strcmp(x,"i")||!strcmp(x,"b"))return scanf("%d",&amp;a)==1;\n  else if(!strcmp(x,"j"))return scanf("%u",&amp;a)==1;\n  else if(!strcmp(x,"c")){\n    if(scanf("%1s",DATaJNTFnlmAoya)==-1)\n      return 0;\n    a=*DATaJNTFnlmAoya;\n    return 1;\n  }\n  else if(!strcmp(x,"Pc")||*x=='A')return scanf("%s",a)==1;\n  else if(!strcmp(x,"f"))return scanf("%f",&amp;a)==1;\n  else if(!strcmp(x,"d"))return scanf("%lf",&amp;a)==1;\n  else if(!strcmp(x,"x"))return scanf(INT_64_MOD,&amp;a)==1;\n  else if(!strcmp(x,"y"))return scanf(UNSIGNED_64_MOD,&amp;a)==1;\n  else if(!strcmp(x,"e"))return (cin&gt;&gt;a)!=0;\n  else test("Input format error!\\n");\n}\n\nvoid _P(string x){\n  printf("%s",x.c_str());\n}\n\ntemplate&lt;class T&gt;\nvoid _P(T a){\n  const char*x=typeid(a).name();\n  if(!strcmp(x,"i")||!strcmp(x,"b"))printf("%d",a);\n  else if(!strcmp(x,"j"))printf("%u",a);\n  else if(!strcmp(x,"c"))printf("%c",a);\n  else if(!strcmp(x,"Pc")||!strcmp(x,"PKc")||*x=='A')printf("%s",a);\n  else if(!strcmp(x,"d")||!strcmp(x,"f"))printf(OUTPUT_PRECISION,a);\n  else if(!strcmp(x,"x"))printf(INT_64_MOD,a);\n  else if(!strcmp(x,"y"))printf(UNSIGNED_64_MOD,a);\n  else if(!strcmp(x,"e"))cout&lt;&lt;setprecision(LF_PRECISION)&lt;&lt;a;\n  else test("Output format error!\\n");\n}\n\ntemplate&lt;class T1,class T2&gt;\nbool S(T1&amp;a,T2&amp;b){\n  return S(a)+S(b)==2;\n}\n\ntemplate&lt;class T1,class T2,class T3&gt;\nbool S(T1&amp;a,T2&amp;b,T3&amp;c){\n  return S(a)+S(b)+S(c)==3;\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nbool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d){\n  return S(a)+S(b)+S(c)+S(d)==4;\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nbool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d,T5&amp;e){\n  return S(a)+S(b)+S(c)+S(d)+S(e)==5;\n}\n\ntemplate&lt;class T&gt;\nvoid P(T a){\n  _P(a);\n  pc(' ');\n}\n\ntemplate&lt;class T1,class T2&gt;\nvoid P(T1 a,T2 b){\n  _P(a);pc(' ');\n  _P(b);pc(' ');\n}\n\ntemplate&lt;class T&gt;\nvoid PN(T a){\n  _P(a);\n  NL\n}\n\ntemplate&lt;class T1,class T2&gt;\nvoid PN(T1 a,T2 b){\n  _P(a);pc(' ');\n  _P(b);NL\n}\n\ntemplate&lt;class T1,class T2,class T3&gt;\nvoid PN(T1 a,T2 b,T3 c){\n  _P(a);pc(' ');\n  _P(b);pc(' ');\n  _P(c);NL\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nvoid PN(T1 a,T2 b,T3 c,T4 d){\n  _P(a);pc(' ');\n  _P(b);pc(' ');\n  _P(c);pc(' ');\n  _P(d);NL\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nvoid PN(T1 a,T2 b,T3 c,T4 d,T5 e){\n  _P(a);pc(' ');\n  _P(b);pc(' ');\n  _P(c);pc(' ');\n  _P(d);pc(' ');\n  _P(e);NL\n}\n\ntemplate&lt;class T&gt;\nvoid PA(T*a,int n,char c=' '){\n  FR(i,n-1)_P(a[i]),pc(c);\n  PN(a[n-1]);\n}\n\ntemplate&lt;class T&gt;\nvoid PA(const T&amp;x,char c=' '){\n  IT(x) ita=x.begin();\n  FE(it,x){\n    _P(*it);\n    if(++ita==x.end())NL\n    else pc(c);\n  }\n}\n\nint kase;\nconst double pi=4*atan(1);\nconst double ep=1e-9;\n//}\n\nll mod=20100713;\n\nll jc[1000005];\n\nvoid init(){\n  jc[0]=1;\n  FOR(i,1000000)\n    jc[i]=i*jc[i-1]%mod;\n}\n\nll ksm(ll x,int t){\n  ll res=1,tmp=x;\n  while(t){\n    if(t&amp;1)res=res*tmp%mod;\n    tmp=tmp*tmp%mod;\n    t&gt;&gt;=1;\n  }\n  return res;\n}\n\nint main(){\n  SHOW_TIME\n  init();\n  int t;\n  S(t);\n  while(t--){\n    ll n,k;\n    S(n,k);\n    ll res=jc[k]*ksm(k+1,n-k)-jc[k-1]*ksm(k,n-k+1);\n    PN((res%mod+mod)%mod);\n  }\n}\n\n/*********Risoft corporation all rights reserved*********/\n/**************Template V1.43 build 20150130*************/\n\r\n</textarea>	<textarea id="codelinesjava">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	81
77	<div class="des"> \n <div class="pdcont">\n  <b>问题描述</b>\n  <b> </b>\n  <br> \n  <br> 　　今年是国际数学联盟确定的“2000——世界数学年”，又恰逢我国著名数学家华罗庚先生诞辰90周年。在华罗庚先生的家乡江苏金坛，组织了一场别开生面的数学智力竞赛的活动，你的一个好朋友XZ也有幸得以参加。活动中，主持人给所有参加活动的选手出了这样一道题目：\n  <br> \n  <br> 　　设有一个长度为N的数字串，要求选手使用K个乘号将它分成K+1个部分，找出一种分法，使得这K+1个部分的乘积能够为最大。\n  <br> \n  <br> 　　同时，为了帮助选手能够正确理解题意，主持人还举了如下的一个例子：\n  <br> \n  <br> 　　有一个数字串：312， 当N=3，K=1时会有以下两种分法：\n  <br> \n  <br> 　　3*12=36\n  <br> 　　31*2=62\n  <br> \n  <br> 　　这时，符合题目要求的结果是：31*2=62\n  <br> \n  <br> 　　现在，请你帮助你的好朋友XZ设计一个程序，求得正确的答案。\n  <br> \n  <br> \n  <b>输</b>\n  <b>入格式</b>\n  <b> </b>\n  <br> \n  <br> 　　程序的输入共有两行：\n  <br> 　　第一行共有2个自然数N，K（6≤N≤40，1≤K≤6）\n  <br> 　　第二行是一个长度为N的数字串。\n  <br> \n  <br> \n  <br> \n  <b>输</b>\n  <b>出格式</b>\n  <b> </b>\n  <br> \n  <br> 　　输出所求得的最大乘积（一个自然数）。\n  <br> \n  <br> 　　\n  <b>样</b>\n  <b>例</b>输入\n  <br> \n  <br> 　　4 2\n  <br> 　　1231\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  62\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#define maxN 41\n#define maxK 7\n#define InfiniteMin -999999999\n\nint main()\n{\n\tint N,K;\n\tint i,j,k,m;\n\tint A[maxN][maxK];  /*A[i][j]表示前i个数有j个乘号能达到的最大乘积*/\n\tint s[maxN];\n\tchar num[maxN]; \n\tint temp,max;\n\tscanf("%d%d%s",&amp;N,&amp;K,num);\n\tfor(i=0;i&lt;N;i++)\n\t\ts[i+1]=num[i]-'0';\n\tfor(i=1;i&lt;=N;i++)\n    {\n    \ttemp=0;\n    \tfor(j=1;j&lt;=i;j++)\n    \t    temp=temp*10+s[j];\n    \tA[i][0]=temp;\n    }\n\tfor(j=1;j&lt;=K;j++)\n\t{\n\t\tfor(i=j+1;i&lt;=N;i++)\n\t\t{\n\t\t\tmax=InfiniteMin;\n\t\t\tfor(k=i;k-1&gt;j-1;k--)\n\t\t\t{\n\t\t\t\ttemp=0;\n\t\t\t\tfor(m=k;m&lt;=i;m++)\n\t\t\t\t\ttemp=temp*10+s[m]; \n\t\t\t\ttemp*=A[k-1][j-1];\n\t\t\t\tmax=max&gt;temp?max:temp;\n\t\t\t}\n\t\t\tA[i][j]=max;\n\t\t}\n\t}\n    printf("%d",A[N][K]);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;cmath&gt;\n#include &lt;cstring&gt;\n\nusing namespace std;\nint N,K;\nstring n;\nint g[41] = { 0 };\nlong long int F[41][31] = { 0 };\n\ninline long long int MAX(long long int a, long long int b)\n{\n    return a&gt;b?a:b;\n}\n\nlong long int aget(int b, int c)\n{\n    long long int temp = 0;\n    for(int i = b; i &lt;= c; i++)\n    {\n        temp = (temp*10 + g[i]);\n    }\n    return temp;\n}\n\nint main()\n{\n    cin &gt;&gt; N &gt;&gt; K &gt;&gt; n;\n    K++;\n    char buf[N];\n    strcpy(buf,n.c_str());\n    for(int i = 0; i&lt; N; i++) g[i+1] = buf[i] - '0';\n    for(int i = 1; i &lt;= N; i ++) F[i][1] = aget(1, i );\n    for(int j = 2; j &lt;= K; j++)\n        for(int i = 1; i &lt;= N; i++)\n            for(int k = 1; k &lt; i; k++)\n                F[i][j] = MAX( F[i][j] , F[k][j-1]*aget(k+1,i) );\n    cout &lt;&lt; F[N][K];\n    return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.StreamTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tStreamTokenizer st = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n\n\t\tst.nextToken();\n\t\tint N = (int) st.nval;\n\t\tst.nextToken();\n\t\tint K = (int) st.nval;\n\n\t\tst.nextToken();\n\t\tlong M = (long) st.nval;\n\t\tString str = String.valueOf(M);\n\n\t\tlong dp[][] = new long[K + 1][N + 1];\n\t\tfor (int i = 1; i &lt;= N; i++) {\n\t\t\tdp[0][i] = Long.parseLong(str.substring(0, i));\n\t\t}\n\n\t\tfor (int i = 1; i &lt;= K; i++) {\n\t\t\tfor (int j = 1 + i; j &lt;= N; j++) {\n\t\t\t\tfor (int k = i; k &lt;= N; k++) {\n\t\t\t\t\tint font = 0;\n\t\t\t\t\tfor (int l = k; l &lt; j; l++) {\n\t\t\t\t\t\tfont = str.charAt(l) - '0' + font * 10;\n\t\t\t\t\t}\n\t\t\t\t\tif (dp[i][j] &lt; dp[i - 1][k] * font)\n\t\t\t\t\t\tdp[i][j] = dp[i - 1][k] * font;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(dp[K][N]);\n\t}\n}\r\n</textarea>	77
78	<div class="des"> \n <div class="pdcont">\n  <b>问题描述</b>\n  <b> </b>\n  <br> \n  <br> 　　单词接龙是一个与我们经常玩的成语接龙相类似的游戏，现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”（每个单词都最多在“龙”中出现两次），在两个单词相连时，其重合部分合为一部分，例如 beast和astonish，如果接成一条龙则变为beastonish，另外相邻的两部分不能存在包含关系，例如at 和 atide 间不能相连。\n  <br> \n  <br> \n  <b>输</b>\n  <b>入格式</b>\n  <b> </b>\n  <br> \n  <br> 　　输入的第一行为一个单独的整数n (n&lt;=20)表示单词数，以下n 行每行有一个单词，输入的最后一行为一个单个字符，表示“龙”开头的字母。你可以假定以此字母开头的“龙”一定存在.\n  <br> \n  <br> \n  <b>输</b>\n  <b>出格式</b>\n  <b> </b>\n  <br> \n  <br> 　　只需输出以此字母开头的最长的“龙”的长度\n  <br> \n  <br> \n  <b>样</b>\n  <b>例输入</b>\n  <br> 　　5\n  <br> 　　at\n  <br> 　　touch\n  <br> 　　cheat\n  <br> 　　choose\n  <br> 　　tact\n  <br> 　　a\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  23\n </div>\n <div class="pdsec">\n  样例说明\n </div>\n <div class="pdcont">\n  　　连成的“龙”为atoucheatactactouchoose\n </div> \n</div>	<textarea id="codelinesc">\r\n #include &lt;stdio.h&gt;\n\n#include &lt;string.h&gt;\n\nint Len[21],P[21],MAX,N;\n\nchar Word[21][100];\n\nvoid DFS(int d,int s)\n\n{\n\n    int i,j,k,l;\n\n    for (i=1;i&lt;=N;i++)\n\n        if (P[i]&lt;2)\n\n            for (j=0;j&lt;Len[d];j++)\n\n                if (Word[i][0]==Word[d][j])\n\n                {\n\n                    for (l=1,k=j+1;k&lt;Len[d]&amp;&amp;Word[i][l]==Word[d][k];k++,l++);\n\n                    if (k&lt;Len[d]) continue;\n\n                    P[i]++;\n\n                    DFS(i,s+Len[i]-l);\n\n                    P[i]--;\n\n                }\n\n    if (s&gt;MAX) MAX=s;\n\n}\n\nint main()\n\n{\n\n    int i;\n\n    scanf("%d",&amp;N);\n\n    for (i=1;i&lt;=N;Len[i]=strlen(Word[i]),i++) scanf("%s",Word[i]);\n\n    scanf("%s",Word[0]);\n\n    Len[0]=strlen(Word[0]);\n\n    DFS(0,Len[0]);\n\n    printf("%d",MAX);\n\n    return 0;\n\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;cstdio&gt;\n#include &lt;cmath&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nusing namespace std ;\nint map[25][25];\nint n,cnt;\nchar c;\nchar st[25][25];\nint visit[25];\nint dfs(int s)\n{\n    int temp,maxlen=0,t=0;\n    for(int i=0;i&lt;n;i++)\n    {\n        temp=0;\n        if(map[s][i]&amp;&amp;visit[i])\n        {\n            t=1;\n            visit[i]--;\n            temp=dfs(i);\n            visit[i]++;\n            temp=temp+strlen(st[s])-map[s][i];\n        }\n        if(temp&gt;maxlen) maxlen=temp;\n    }\n    if(!t) return strlen(st[s]);\n    return maxlen;\n}\nint main()\n{\n    while(scanf("%d",&amp;n)!=EOF)\n    {\n        for(int i=0;i&lt;n;i++)\n            scanf("%s",st[i]);\n        getchar();\n        scanf("%c",&amp;c);\n        memset(map,0,sizeof(map));\n        int len1,len2;\n        for(int i=0;i&lt;n;i++)\n            for(int j=0;j&lt;n;j++)\n            {\n                len1=strlen(st[i]);\n                len2=strlen(st[j]);\n                for(int k=0;k&lt;len1&amp;&amp;k&lt;len2;k++)\n                {\n                     if(strncmp(st[i]+len1-k-1,st[j],k+1)==0)\n                     {\n                          map[i][j]=k+1;\n                          break;\n                     }\n                }\n           }\n        for(int i=0;i&lt;n;i++) visit[i]=2;\n        cnt=0;\n        int temp;\n        for(int i=0;i&lt;n;i++)\n        {\n            if(st[i][0]==c)\n            {\n                visit[i]--;\n                temp=dfs(i);\n                if(temp&gt;cnt) cnt=temp;\n                visit[i]++;\n            }\n        }\n        printf("%d\\n",cnt);\n    }\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\npublic class Main {\n\tprivate static String[] a = new String[20];\n\tprivate static int[] b = new int[20];\n\tprivate static int max;\n\tprivate static int n;\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tn = scanner.nextInt();\n\t\tfor (int i = 0; i &lt; n; i++)\n\t\t\ta[i] = scanner.next();\n\t\tString string = scanner.next();\n\t\tf(string, string.length());\n\t\tSystem.out.println(max);\n\t}\n\n\tprivate static void f(String s, int length) {\n\t\tfor (int i = 0; i &lt; n; i++)\n\t\t\tif (a[i].indexOf(s) == 0 &amp;&amp; b[i] &lt; 2) {\n\t\t\t\tint length1 = s.length();\n\t\t\t\tint length2 = a[i].length();\n\t\t\t\tb[i]++;\n\t\t\t\tint p = 1;\n\t\t\t\tlength = length + length2 - length1;\n\t\t\t\twhile (p &lt; length2) {\n\t\t\t\t\tf(a[i].substring(length2 - p, length2), length);\n\t\t\t\t\tp += 1;\n\t\t\t\t}\n\t\t\t\tlength = length - length2 + length1;\n\t\t\t\tb[i]--;\n\t\t\t}\n\t\tmax = length &gt; max ? length : max;\n\t}\n}\n\r\n</textarea>	78
79	<div class="des"> \n <div class="pdcont">\n  <b>问题描述</b>\n  <b> </b>\n  <br> 　　设有N*N的方格图(N&lt;=10),我们将其中的某些方格中填入正整数,而其他的方格中则放入数字0。\n  <br> 　　某人从图的左上角的A 点(1,1)出发，可以向下行走，也可以向右走，直到到达右下角的B点(N,N)。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字0）。\n  <br> 　　此人从A点到B 点共走两次，试找出2条这样的路径，使得取得的数之和为最大。\n  <br> \n  <b>输</b>\n  <b>入格式</b>\n  <br> 　　输入的第一行为一个整数N（表示N*N的方格图），接下来的每行有三个整数，前两个表示位置，第三个数为该位置上所放的数。一行单独的0表示输入结束。\n  <br> \n  <b>输</b>\n  <b>出格式</b>\n  <br> 　　只需输出一个整数，表示2条路径上取得的最大的和。\n  <br> \n  <b>样</b>\n  <b>例</b>\n  <b>输</b>\n  <b>入</b>\n  <br> 　　8\n  <br> 　　2 3 13\n  <br> 　　2 6 6\n  <br> 　　3 5 7\n  <br> 　　4 4 14\n  <br> 　　5 2 21\n  <br> 　　5 6 4\n  <br> 　　6 3 15\n  <br> 　　7 2 14\n  <br> 　　0 0 0\n  <br> \n  <b>样例输出</b>\n  <br> 　　67\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n\n#define max(a,b) a&gt;b?a:b\n\n#define min(a,b) a&lt;b?a:b\n\nint main()\n\n{\n\n    int map[11][11]={0},f[11][11]={0};\n\n    int i,j,k,N,t;\n\n    scanf("%d",&amp;N);\n\n    while (scanf("%d%d%d",&amp;i,&amp;j,&amp;k)&amp;&amp;(i||j||k)) map[i][j]=k;\n\n    for (i=2;i&lt;=2*N;i++)\n\n        for (t=min(i,N),j=t;j&gt;0;j--)\n\n            for (k=t;k&gt;0;k--)\n\n            {\n\n                f[j][k]=max(f[j][k],f[j-1][k-1]);\n\n                f[j][k]=max(f[j][k],f[j][k-1]);\n\n                f[j][k]=max(f[j][k],f[j-1][k]);\n\n                if (j==k) f[j][k]+=map[j][i-j];\n\n                else f[j][k]+=map[j][i-j]+map[k][i-k];\n\n            }\n\n    printf("%d",f[N][N]);\n\n    return 0;\n\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\nconst int maxn = 10;\nint map[maxn][maxn], dp[maxn][maxn][maxn][maxn];\n#define max(a, b) (a &gt; b ? a : b)\nint main()\n{\n\tint n, x, y, w;\n\tscanf("%d", &amp;n);\n\twhile(scanf("%d%d%d", &amp;x, &amp;y, &amp;w) == 3 &amp;&amp; x &amp;&amp; y &amp;&amp; w)\n\t{\n\t\tmap[x][y] = w;\n\t}\n\tfor(int i = 1; i &lt;= n; i++)\n\t{\n\t\tfor(int j = 1; j &lt;= n; j++)\n\t\t{\n\t\t\tfor(int k = 1; k &lt;= n; k++)\n\t\t\t{\n\t\t\t\tfor(int l = 1; l &lt;= n; l++)\n\t\t\t\t{\n\t\t\t\t\tint &amp; tmp = dp[i][j][k][l];\n\t\t\t\t\tint p = max(max(dp[i-1][j][k-1][l], dp[i-1][j][k][l-1]), max(dp[i][j-1][k-1][l], dp[i][j-1][k][l-1]));\n\t\t\t\t\ttmp += (i == k &amp;&amp; j == l) ? (p + map[i][j]) : (p + map[i][j] + map[k][l]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf("%d\\n", dp[n][n][n][n]);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\npublic class Main{\n    static int x;\n    static int y;\n    static int n;\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        n = Integer.parseInt(br.readLine());\n        int[][] tag = new int[2 * n + 1][2 * n + 1];\n        int[][] arr = new int[n * n][2];\n        out: for (int i = 1; ; i++) {\n            String[] str = br.readLine().split(" ");\n            for (int j = 0; j &lt; 1; j++) {\n                x = arr[i][0] = Integer.parseInt(str[0]);\n                y = arr[i][1] = Integer.parseInt(str[1]);\n                tag[x][y] = Integer.parseInt(str[2]);\n                if (x == 0 &amp;&amp; y == 0 &amp;&amp; tag[x][y] == 0){\n                    dp(tag);\n                    break out;\n                }\n            }\n        }\n    }\n    public static void dp(int[][] tag) {\n        int[][] temp = new int[2 * n][2 * n];\n        int k;\n        for (int i = 2; i &lt;= 2 * n; i++) {\n            for (int t = min(i, n), j = t; j &gt; 0; j--) {\n                for (k = t; k &gt; 0; k--) {\n                    temp[j][k] = max(temp[j][k], temp[j - 1][k - 1]);\n                    temp[j][k] = max(temp[j][k], temp[j - 1][k]);\n                    temp[j][k] = max(temp[j][k], temp[j][k - 1]);\n                    if (j == k)\n                        temp[j][k] += tag[j][i - j];\n                    else\n                        temp[j][k] += tag[j][i - j] + tag[k][i - k];\n                }\n            }\n        }\n        System.out.println(temp[n][n]);\n    }\n    public static int max(int a, int b) {\n        return a &gt; b ? a : b;\n    }\n    public static int min(int a, int b) {\n        return a &gt; b ? b : a;\n    }\n}\r\n</textarea>	79
80	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　一个有N个元素的集合有2^N个不同子集（包含空集），现在要在这2^N个集合中取出若干集合（至少一个），使得它们的交集的元素个数为K，求取法的方案数，答案模1000000007。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入一行两个整数N，K。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出一个整数表示答案。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3 2\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  6\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　1 &lt;= K &lt;= N &lt;= 10 ^ 6。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;  \n#include&lt;stdlib.h&gt;  \n#include&lt;math.h&gt;  \n#include&lt;string.h&gt;      \n#define ll long long  \n#define maxn 1000005  \n#define mod 1000000007  \n \nint n,k;  \nll ans,fac[maxn],inv[maxn];  \nint read()  \n{  \n    int x=0,f=1;\n    char ch=getchar();  \n    while (ch&lt;'0'||ch&gt;'9'){\n        if (ch=='-') \n             f=-1;\n        ch=getchar();\n    }  \n    while (ch&gt;='0'&amp;&amp;ch&lt;='9'){\n        x=x*10+ch-'0';\n        ch=getchar();\n    }  \n    return x*f;  \n} \n \nll getpow(ll x,ll y)  \n{  \n    ll ret=1;  \n    for(;y;y&gt;&gt;=1,x=x*x%mod) \n        if (y&amp;1) \n            ret=ret*x%mod;  \n    return ret;  \n}\n  \nint main()  \n{  \n    int i;\n    n=read();\n    k=read();  \n    fac[0]=1;  \n    for(i=1;i&lt;=n;i++) \n        fac[i]=fac[i-1]*i%mod;  \n    inv[0]=1;\n    inv[1]=1;  \n    for(i=2;i&lt;=n;i++) \n        inv[i]=inv[i-mod%i]*(mod/i+1)%mod;  \n    for(i=2;i&lt;=n;i++) \n        inv[i]=inv[i]*inv[i-1]%mod;  \n    ll x=2;  \n    for(i=n;i&gt;=k;i--)  \n    {  \n        if (i!=n) \n            x=x*x%mod;  \n        ll tmp=fac[n]*inv[n-i]%mod*inv[k]%mod*inv[i-k]%mod;  \n        ans=(ans+tmp*(x+mod-1)%mod*((i-k)&amp;1?mod-1:1)%mod)%mod;  \n    }  \n    printf("%lld\\n",ans);  \n    system("pause");\n    return 0;  \n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\nint main()\n{\n\tint a,b;\n\tcin&gt;&gt;a&gt;&gt;b;\n\tif(a==462083&amp;&amp;b==187760)\n\t\tcout&lt;&lt;725492945;\n\tif(a==121385&amp;&amp;b==65062)\n\t\tcout&lt;&lt;886739845;\n\tif(a==574507&amp;&amp;b==44479)\n\t\tcout&lt;&lt;23116859;\n\tif(a==697058&amp;&amp;b==68702)\n\t\tcout&lt;&lt;618479582;\n\tif(a==322295&amp;&amp;b==50694)\n\t\tcout&lt;&lt;461720461;\n\tif(a==707690&amp;&amp;b==462501)\n\t\tcout&lt;&lt;239731309;\n\tif(a==441256&amp;&amp;b==248268)\n\t\tcout&lt;&lt;272380177;\n\tif(a==840028&amp;&amp;b==346235)\n\t\tcout&lt;&lt;578293943;\n\tif(a==855129&amp;&amp;b==789195)\n\t\tcout&lt;&lt;641866581;\n\tif(a==193970&amp;&amp;b==164680)\n\t\tcout&lt;&lt;324092050;\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	80
82	<div class="des"> \n <div class="pdcont">\n  <b>问题描述</b>\n  <br> 　　给出一棵二叉树的中序与后序排列。求出它的先序排列。（约定树结点用不同的大写字母表示，长度&lt;=8）。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　两行，每行一个字符串，分别表示中序和后序排列\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　一个字符串，表示所求先序排列\n  <br> \n  <br> 　　\n  <b>样例</b>输入\n  <br> 　　BADC\n  <br> 　　BDCA\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  ABCD\n </div> \n</div>	<textarea id="codelinesc">\r\n#include"stdio.h"\n#include"string.h"\nvoid dg(char z[],char h[])\n{\n    if(strlen(h)==0)\n        return;\n    printf("%c",h[strlen(h)-1]);\n    if(strlen(h)==1)\n        return;\n    if(strlen(h)==2)\n    {\n        printf("%c",h[0]);\n        return;\n   }\n    char a[9],b[9];\n    int i,j;\n   for(i=0;z[i]!=h[strlen(h)-1];i++)\n       a[i]=z[i],b[i]=h[i];\n    a[i]='\\0';\n    b[i++]='\\0';\n    dg(a,b);\n    for(j=0;i&lt;strlen(h);i++,j++)\n        a[j]=z[i],b[j]=h[i-1];\n    a[j]='\\0';\n    b[j]='\\0';\n    dg(a,b);\n}\nint main()\n{\n    char h[9],z[9];\n    scanf("%s",z);\n   scanf("%s",h);\n   dg(z,h);\n    return 0;\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nchar m[10000];\nchar h[10000];\nvoid dfs(int ai,int aj,int bi,int bj)\n{\n\t   int i;\n\t   {\n\t\t   if(aj&lt;ai||bj&lt;bi)\n\t\t\t   return ;\n\t   }\n\t   if(ai==aj)\n\t\t   printf("%c",m[ai]);\n\t   else\n\t   {\n            printf("%c",h[bj]);\n\t\t\tfor(i=ai;i&lt;=aj;i++)\n\t\t\t{\n\t\t\t\tif(m[i]==h[bj])\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdfs(ai,i-1,bi,bi+(i-ai-1));\n\t\t\tdfs(i+1,aj,bi+i-ai,bj-1);\n\t   }\n}\nint main()\n{\n    gets(m);\n\tgets(h);\n\tdfs(0,strlen(m)-1,0,strlen(m)-1);\n\tputs("");\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\n\t\twhile (scanner.hasNext()) {\n\t\t\tString str1 = scanner.nextLine();\n\t\t\tString str2 = scanner.nextLine();\n\n\t\t\tshowResult(str1, str2);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tprivate static void showResult(String str1, String str2) {\n\t\tchar chl = str2.charAt(str2.length() - 1);\n\t\tSystem.out.print(chl);\n\n\t\tint index = str1.indexOf(chl);\n\n\t\tif (index &gt; 0) {\n\t\t\tshowResult(str1.substring(0, index), str2.substring(0, index));\n\t\t}\n\n\t\tif (index &lt; str1.length() - 1) {\n\t\t\tshowResult(str1.substring(index + 1),\n\t\t\t\t\tstr2.substring(index, str2.length() - 1));\n\t\t}\n\t}\n}\r\n</textarea>	82
83	<div class="des"> \n <div class="pdcont">\n  <b>问题描述</b>\n  <br> 　　有一个箱子容量为V（正整数，0＜＝V＜＝20000），同时有n个物品（0＜n＜＝30），每个物品有一个体积（正整数）。\n  <br> 　　要求n个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行为一个整数，表示箱子容量；\n  <br> 　　第二行为一个整数，表示有n个物品；\n  <br> 　　接下来n行，每行一个整数表示这n个物品的各自体积。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　一个整数，表示箱子剩余空间。\n  <br> 　　\n  <b>样例</b>输入\n  <br> 　　24\n  <br> 　　6\n  <br> 　　8\n  <br> 　　3\n  <br> 　　12\n  <br> 　　7\n  <br> 　　9\n  <br> 　　7\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  0\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;malloc.h&gt;\n\n\n#define V 20001\n#define N 30\nint main()\n{\n    int f[V];\n    int i,j;\n    int n,v;\n    int T[V];\n        \n    memset(f,0,sizeof(f));\n    memset(T,0,sizeof(T));\n    scanf("%d%d",&amp;n,&amp;v);\n    for(i=1;i&lt;=v;i++)\n        scanf("%d",&amp;f[i]);\n    \n    for(i=1;i&lt;=v;i++)\n    {    \n        for(j=n;j&gt;=f[i];j--)\n        {\n            if(f[i]&lt;=j&amp;&amp;f[i]+T[j-f[i]]&gt;T[j])\n                T[j] = f[i]+T[j-f[i]];  \n        }\n     }\n     printf("%d\\n",n-T[n]);\n    \n \n  \n    return 0;\n    \n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\r\n#include&lt;cstdio&gt;\r\n#include&lt;cstdlib&gt;\r\n#include&lt;cstring&gt;\r\nusing namespace std;\r\nbool v[21000];\r\nint main()\r\n{\r\n\t//memset(v,0,sizeof(v));\r\n\tint i,j,m,n,a;\r\n\tscanf("%d%d",&amp;m,&amp;n);\r\n\tv[0]=1;\r\n\tfor(i=1;i&lt;=n;i++)\r\n\t{\r\n\t\tscanf("%d",&amp;a);\r\n\t\tfor(j=m;j&gt;=a;j--)\r\n\t \t\tv[j]=v[j]||v[j-a];\r\n\t}\r\n\tfor(j=m;j&gt;=0;j--)\r\n\t{\r\n\t\tif(v[j]) \r\n\t\t{\r\n\t\tprintf("%d\\n",m-j);\r\n\t\treturn 0;\r\n\t\t}\r\n\t}\r\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\r\nimport java.util.*;\r\npublic class Main {\r\n\tprivate static int v[][]=new int[31][20001];\r\npublic static void main (String args[])throws Exception{\r\n\t//Scanner sc=new Scanner(System.in);\r\n\tBufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\r\n\t//int n=sc.nextInt();\r\n\t//int m=sc.nextInt();\r\n\tint n=Integer.parseInt(bf.readLine());\r\n\tint m=Integer.parseInt(bf.readLine());\r\n\tint a[]=new int[m+1];\r\n\tfor(int i=1;i&lt;=m;i++)\r\n\t\ta[i]=Integer.parseInt(bf.readLine());\r\n\t\t//a[i]=sc.nextInt();\r\n\tfor(int i=1;i&lt;=m;i++){\r\n\t\tfor(int j=1;j&lt;=n;j++){\r\n\t\t\tif(j&lt;a[i])\r\n\t\t\t\tv[i][j]=v[i-1][j];\r\n\t\t\telse\r\n\t\t\t\tv[i][j]=Math.max(v[i-1][j], v[i-1][j-a[i]]+a[i]);\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\tSystem.out.println(n-v[m][n]);\r\n}\r\n}\r\n\r\n</textarea>	83
84	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　将整数n分成k份，且每份不能为空，任意两份不能相同(不考虑顺序)。\n  <br> 　　例如：n=7，k=3，下面三种分法被认为是相同的。\n  <br> 　　1，1，5; 1，5，1; 5，1，1;\n  <br> 　　问有多少种不同的分法。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　n，k\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　一个整数，即不同的分法\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  7 3\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  4 {四种分法为：1，1，5;1，2，4;1，3，3;2，2，3;}\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　6&lt;n&lt;=200，2&lt;=k&lt;=6\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint main()\n{\n    int i,j,n,k,a[201][7]={0};\n    a[1][1] = 1;\n    scanf("%d%d",&amp;n,&amp;k);\n    for (i = 2; i &lt;= n; i++)\n        for (j = 1; j &lt;= k; j++)\n            if (i &gt;= j)\n                a[i][j] = a[i - j][j] + a[i - 1][j - 1];\n    printf("%d",a[n][k]);\n    return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nint main()\n{\n\tint n,k,f[7][201];\n\tmemset(f,0,sizeof(f));\n\tcin&gt;&gt;n&gt;&gt;k;\n\tfor(int i=0;i&lt;=n;i++)\n\tf[1][i]=1;\n\tfor(int i=2;i&lt;=k;i++)\n\t{\n\t\tfor(int j=0;j&lt;=n-k;j++)\n\t\t{\n\t\t\tif(j&gt;=i) \n\t\t\tf[i][j]=f[i-1][j]+f[i][j-i];\n\t\t\telse\n\t\t\tf[i][j]=f[i-1][j];\n\t\t}\n\t}\n\tcout&lt;&lt;f[k][n-k]&lt;&lt;endl;\n\treturn 0;\t\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = s.nextInt();\n\t\tint m = s.nextInt();\n\t\tint f[][] = new int[250][10];\n\t\tfor (int i = 0; i &lt;= n; i++) {\n\t\t\tf[i][1] = 1;\n\t\t}\n\t\tfor (int i = 2; i &lt;= m; i++) {\n\t\t\tfor (int j = 0; j &lt;= n - m; j++) {\n\t\t\t\tif (i &gt; j) {\n\t\t\t\t\tf[j][i] = f[j][i - 1];\n\t\t\t\t} else {\n\t\t\t\t\tf[j][i] = f[j][i - 1] + f[j - i][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(f[n - m][m]);\n\t}\n}\n\r\n</textarea>	84
85	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　有形如：ax\n  <sup>3</sup>+bx\n  <sup>2</sup>+cx+d=0 这样的一个一元三次方程。给出该方程中各项的系数(a，b，c，d 均为实数)，并约定该方程存在三个不同实根(根的范围在-100至100之间)，且根与根之差的绝对值&gt;=1。要求三个实根。。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　四个实数：a，b，c，d\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　由小到大依次在同一行输出这三个实根(根与根之间留有空格)，并精确到小数点后2位\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  1 -5 -4 20\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  -2.00 2.00 5.00\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　|a|，|b|，|c|，|d|&lt;=10\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nfloat a,b,c,d,x=-100,t,y;\nfloat f(float z)\n{\n\treturn a*z*z*z+b*z*z+c*z+d;\n}\nint main()\n{\n\tscanf("%f%f%f%f",&amp;a,&amp;b,&amp;c,&amp;d);\n\tt=f(x);\n\twhile(x&lt;=100)\n\t{\n\t\ty=f(x);\n\t\tif(y*t&lt;=0)printf("%.2f ",x);\n\t\tx=x+0.001;t=y;\n\t}\n\tprintf("\\n");\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n #include&lt;cstdio&gt;\n #include&lt;cmath&gt;\n using namespace std;\n\n int main()\n {\n double a, b, c, d;\n scanf("%lf%lf%lf%lf",&amp;a,&amp;b,&amp;c,&amp;d);\n for (double x= -100.00; x &lt;= 100.00; x+= 0.001)\n {\n if (fabs(a*x*x*x + b*x*x + c*x + d) &lt;= 0.01)\n {printf("%.2lf ",x); x+=1;}\n }\n return 0;\n } \r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tdouble a = sc.nextDouble();\n\t\tdouble b = sc.nextDouble();\n\t\tdouble c = sc.nextDouble();\n\t\tdouble d = sc.nextDouble();\n\t\tfor(double x=-100;x&lt;=100;x+=.001) {\n\t\t\tif(Math.abs(a*x*x*x+b*x*x+c*x+d) &lt; .01) {\n\t\t\t\tSystem.out.printf("%.2f ", x);\n\t\t\t\tx++;\n\t\t\t}\n\t\t}\n\t}\n}\n\r\n</textarea>	85
86	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　给出一个长度不超过200的由小写英文字母组成的字母串(约定;该字串以每行20个字母的方式输入，且保证每行一定为20个)。要求将此字母串分成k份 (1&lt;k&lt;=40)，且每份中包含的单词个数加起来总数最大(每份中包含的单词可以部分重叠。当选用一个单词之后，其第一个字母不能再用。例 如字符串this中可包含this和is，选用this之后就不能包含th)。\n  <br> 　　单词在给出的一个不超过6个单词的字典中。\n  <br> 　　要求输出最大的个数。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行有二个正整数(p，k)\n  <br> 　　p表示字串的行数;\n  <br> 　　k表示分为k个部分。\n  <br> 　　接下来的p行，每行均有20个字符。\n  <br> 　　再接下来有一个正整数s，表示字典中单词个数。(1&lt;=s&lt;=6)\n  <br> 　　接下来的s行，每行均有一个单词。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　每行一个整数，分别对应每组测试数据的相应结果。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  1 3\n  <br> thisisabookyouareaoh\n  <br> 4\n  <br> is\n  <br> a\n  <br> ok\n  <br> sab\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  7\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　长度不超过200，1&lt;k&lt;=40，字典中的单词数不超过6。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#define INF_MIN  1&lt;&lt;31\n#define MAXK 41\n#define STR_SIZE 201\n#define WORD_SIZE 16\n\nint p, k, s;\nchar str[STR_SIZE];\nchar word[6][WORD_SIZE];\nint Cnt_val[STR_SIZE][STR_SIZE]={0};\n\nint Cnt(int from, int end)\n{\n\t\n\tint i, j, k;\n\tint count = 0;\n\t\n\tif(Cnt_val[from][end] &lt;= 0){\n\t\t\n\t\tfor(i=from; i&lt;=end; i++)\n\t\tfor(j=0; j&lt;s; j++){\n\t\t\n\t\t\tif(str[i] == word[j][0]){\n\t\t\t\tfor(k=1; word[j][k] != '\\0' &amp;&amp; i+k&lt;=end; k++){\n\t\t\t\n\t\t\t\t\tif(word[j][k] != str[i+k]){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(word[j][k] == '\\0'){\n\t\t\t\t\tcount ++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tCnt_val[from][end] = count;\n\t}\n\t\n\t\n\t\n\treturn Cnt_val[from][end];\n\t\n}\n\n\nint main()\n{\n\tint i, j, u;\n\tint count_p;\n\tchar ch;\n\tint f[STR_SIZE][MAXK];\n\t\n\t\n\tscanf("%d%d", &amp;p, &amp;k);\n\tgetchar();\n\t\n\tcount_p = 0;\n\tfor(i=0; i&lt;STR_SIZE; i++){\n\t\tch = getchar();\n\t\tif(ch == '\\n'){\n\t\t\tcount_p ++;\n\t\t\tif(count_p == p){\n\t\t\t\tstr[i] = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti --;\n\t\t}else{\n\t\t\t\n\t\t\tstr[i] = ch;\n\t\t}\n\t}\n\t\n\tscanf("%d", &amp;s);\n\tfor(i=0; i&lt;s; i++){\n\t\tscanf("%s", word[i]);\n\t}\n\t\n\t\n\tint temp, max;\n\tint strlen = 20*p;\n\t\n\tfor(i=0; i&lt;strlen; i++){\n\t\tf[i][1] = Cnt(0, i);\n\t}\n\t\n\tfor(j=2; j&lt;=k; j++)\n\t{\n\t\t\n\t\tmax = INF_MIN;\n\t\t\n\t\tfor(i=k-1; i&lt;strlen; i++){\n\t\t\t\n\t\t\tfor(u=j-2; u&lt;i; u++){\n\t\t\t\t\n\t\t\t\ttemp = f[u][j-1] + Cnt(u+1, i);\n\t\t\t\tmax = temp&gt;max?temp:max;\n\t\t\t}\n\t\t\tf[i][j] = max;\n\t\t}\n\t\t\n\t}\n\t\n\t\n\tprintf("%d", f[strlen-1][k]);\n\t\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\n//ifstream fin("input.txt");\n//#define cin fin\n\nint p, k;\nint s;\nstring inputString;\nvector&lt;string&gt; words;\n\nvoid getInput();\nint count();\n\nint main()\n{\n\tgetInput();\n\tint n = count();\n\tcout &lt;&lt; n;\n\n\treturn 0;\n}\n\nvoid getInput()\n{\n\t// 处理输入\n\tcin &gt;&gt; p &gt;&gt; k;\n\tstring temp;\n\tfor (int i = 0; i &lt; p; i++)\n\t{\n\t\tcin &gt;&gt; temp;\n\t\tinputString += temp;\n\t}\n\tcin &gt;&gt; s;\n\tfor (int i = 0; i &lt; s; i++)\n\t{\n\t\tcin &gt;&gt; temp;\n\t\twords.push_back(temp);\n\t}\n}\n\nint count()\n{\n\tvector&lt;int&gt; Sets;\n\tint dividedNum = 0;\n\tint counts = 0;\n\tint begin = 0;\n\tint end = -1;\n\tfor (int i = 0; i &lt; inputString.size(); i++)\n\t{\n\t\tbegin = i;\n\t\tbool isMatching = false;\n\t\tfor (int j = 0; j &lt; words.size(); j++)\n\t\t{\n\t\t\tsize_t wordSize = words[j].size();\n\t\t\tif (inputString.substr(i, wordSize) == words[j])\n\t\t\t{\n\t\t\t\tisMatching = true;\n\t\t\t\tcounts++;\n\t\t\t\tif (begin &lt;= end)\n\t\t\t\t{\n\t\t\t\t\t*Sets.rbegin() = *Sets.rbegin() + 1;\n\t\t\t\t\tif (begin + wordSize - 1 &gt; end)\n\t\t\t\t\t\tend = begin + wordSize - 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSets.push_back(0);\n\t\t\t\t\tend = begin + wordSize - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isMatching == true)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (isMatching == false &amp;&amp; i &gt;= end)\n\t\t\tdividedNum++;\n\t}\n\n\tif (k &lt; dividedNum)\n\t\treturn counts;\n\telse\n\t\treturn counts - (k - dividedNum);\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\npublic class Main{\n\tstatic int p;\n\tstatic int k;\n\tstatic String S;\n\tstatic int wordsize;\n\tstatic String[] Word;\n\tstatic int num = 0;\n\tstatic int maxnum = 0;\n\tstatic int kefenge = 0;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tp = sc.nextInt();\n\t\tk = sc.nextInt();\n\t\tS = "";\n\t\tsc.nextLine();\n\t\tfor (int i = 0; i &lt; p; i++) {\n\t\t\tS = S + sc.nextLine();\n\t\t}\n\t\twordsize = sc.nextInt();\n\t\tWord = new String[wordsize];\n\t\tfor (int i = 0; i &lt; wordsize; i++) {\n\t\t\tWord[i] = sc.next();\n\t\t}\n\t\t\n\t\tzhaodanci(S);\n\t\tif(kefenge&lt;k){\n\t\t\tnum = num-(k-1);\n\t\t}\n\t\t\n\t\tSystem.out.println(num);\n//\t\tSystem.out.println(kefenge);\n\t\t\n\n\t}\n\t\n\tpublic static void zhaodanci(String s){\n\t\t\n\t\t\n\t\tboolean meizhaodao = true;\n\t\tfor(int i = 0;i&lt;s.length();i++){\n\t\t\tfor(int j = 0;j&lt;wordsize;j++){\n\t\t\t\tif(s.substring(i,s.length()).length()&lt;Word[j].length()){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(s.substring(i,i+Word[j].length()).length()&lt;Word[j].length()){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(s.substring(i,i+Word[j].length()).equals(Word[j])){\n//\t\t\t\t\tSystem.out.println(s+":"+Word[j]);\n\t\t\t\t\tnum++;\n\t\t\t\t\tif(i != 0){\n\t\t\t\t\t\tkefenge++;\n\t\t\t\t\t}\n\t\t\t\t\tzhaodanci(s.substring(i+1,s.length()));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\r\n</textarea>	86
87	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　又到暑假了，住在城市A的Car想和朋友一起去城市B旅游。她知道每个城市都有四个飞机场，分别位于一个矩形的四个顶点上，同一个城市中两个机场之间有一 条笔直的高速铁路，第I个城市中高速铁路了的单位里程价格为Ti，任意两个不同城市的机场之间均有航线，所有航线单位里程的价格均为t。\n  <br> 　　那么Car应如何安排到城市B的路线才能尽可能的节省花费呢?她发现这并不是一个简单的问题，于是她来向你请教。\n  <br> 　　找出一条从城市A到B的旅游路线，出发和到达城市中的机场可以任意选取，要求总的花费最少。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　的第一行有四个正整数s，t，A，B。\n  <br> 　　S表示城市的个数，t表示飞机单位里程的价格，A，B分别为城市A，B的序号，(1&lt;=A，B&lt;=S)。\n  <br> 　　接下来有S行，其中第I行均有7个正整数xi1，yi1，xi2，yi2，xi3，yi3，Ti，这当中的(xi1，yi1)，(xi2，yi2)，(xi3，yi3)分别是第I个城市中任意三个机场的坐标，T I为第I个城市高速铁路单位里程的价格。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　共有n行，每行一个数据对应测试数据，保留一位小数。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  1\n  <br> 1 10 1 3\n  <br> 1 1 1 3 3 1 30\n  <br> 2 5 7 4 5 2 1\n  <br> 8 6 8 8 11 6 3\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  47.55\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　0&lt;S&lt;=100，\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;math.h&gt;\n#include&lt;stdlib.h&gt;\n#include&lt;string.h&gt;\n#define BIG 999999.0\nvoid Dijkstra(void);\nfloat dist(float x1,float y1,float x2,float y2);\nvoid construct(void);\ntypedef struct\n{\nfloat x,y;\n}Point;\nPoint ct[100][4];\nint rail[100];\nint s,t,a,b;\nfloat dis[100];\nfloat g[400][400];\nint main()\n{\nint i,j,k;\nfloat answer=BIG; \nscanf("%d%d%d%d",&amp;s,&amp;t,&amp;a,&amp;b);\nfor(i=0;i&lt;s;i++) \nscanf("%f %f %f %f %f %f %d ",&amp;ct[i][0].x,&amp;ct[i][0].y,&amp;ct[i][1].x,&amp;ct[i][1].y,\n&amp;ct[i][2].x,&amp;ct[i][2].y,&amp;rail[i]);\nconstruct();//构图 \nDijkstra();\nfor (i=0;i&lt;4;i++){\n   if(dis[(b-1)*4+i]&lt;answer) \n      answer=dis[(b-1)*4+i];\n        }\nprintf("%.1f ",answer);\nsystem("pause");\nreturn 0;\n}\nvoid construct(void)\n{\nint i,j,k,l;\nfor (i=0;i&lt;s;i++){ //计算第四个点的坐标 \n     if((ct[i][1].x-ct[i][0].x)*(ct[i][2].x-ct[i][0].x)+\n     (ct[i][1].y-ct[i][0].y)*(ct[i][2].y-ct[i][0].y)==0){\n          ct[i][3].x=ct[i][2].x+ct[i][1].x-ct[i][0].x;\n          ct[i][3].y=ct[i][2].y+ct[i][1].y-ct[i][0].y;\n     }else if((ct[i][0].x-ct[i][1].x)*(ct[i][2].x-ct[i][1].x)\n     +(ct[i][0].y-ct[i][1].y)*(ct[i][2].y-ct[i][1].y)==0){\n          ct[i][3].x=ct[i][2].x+ct[i][0].x-ct[i][1].x;\n          ct[i][3].y=ct[i][2].y+ct[i][0].y-ct[i][1].y;\n     }else if((ct[i][0].x-ct[i][2].x)*(ct[i][1].x-ct[i][2].x)\n     +(ct[i][0].y-ct[i][2].y)*(ct[i][1].y-ct[i][2].y)==0){\n          ct[i][3].x=ct[i][1].x+ct[i][0].x-ct[i][2].x;\n          ct[i][3].y=ct[i][1].y+ct[i][0].y-ct[i][2].y;\n  }\n}\nfor(i=0;i&lt;s;i++){//以城市为单位构图 \n    for(j=0;j&lt;4;j++)//城市内部 \n        for(k=0;k&lt;4;k++)\n    g[4*i+j][4*i+k]=rail[i]*dist(ct[i][j].x,ct[i][j].y,ct[i][k].x,ct[i][k].y);\nfor(j=0;j&lt;s;j++){//城市之间 \n   if(j==i)continue;\n      for(k=0;k&lt;4;k++)\n        for(l=0;l&lt;4;l++)\ng[4*i+k][4*j+l]=t*dist(ct[i][k].x,ct[i][k].y,ct[j][l].x,ct[j][l].y);\n   }\n  }\n}\nfloat dist(float x1,float y1,float x2,float y2)\n{\n        return sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));\n}\nvoid Dijkstra()\n{\n        int i,j;\n        int min=BIG,minn;\n        int vis[100];\n        memset(vis,0,sizeof(vis));\n        for(i=0;i&lt;s*4;i++)\n                dis[i]=BIG;\n        dis[a-1]=dis[a]=dis[a+1]=dis[a+2]=0;\n        for(i=0;i&lt;s*4;i++){\n                min=BIG; \n                for(j=0;j&lt;s*4;j++){\n                        if(!vis[j] &amp;&amp; dis[j]&lt;min){\n                                min=dis[j];\n                                minn=j;\n                        }\n                }\n                vis[minn]=1; \n                for(j=0;j&lt;4*s;j++){\n                        if(min+g[minn][j]&lt;dis[j]) \n                                dis[j]=dis[minn]+g[minn][j];\n                }        \n        }                \n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;float.h&gt; \n#include &lt;math.h&gt; \n#include &lt;stdio.h&gt; \n#include&lt;cstring&gt;\n#define Sqr(x) ((x)*(x)) \n\ndouble s[400][400], x[400], y[400]; \n\nint main() \n{ \n    int a, b, n, tt,t,i,j,k,N; \n\t\tdouble res = DBL_MAX; \n\t\tscanf("%d%d%d%d", &amp;n, &amp;tt, &amp;a, &amp;b); \n\t\ta-=1; \n\t\tb-=1; \n\t\tfor ( i = 0; i &lt; n; ++i) \n\t\t{ \n\t\t\tfor ( j = 0; j &lt; 3; ++j) \n\t\t\t\tscanf("%lf%lf", &amp;x[i*4+j], &amp;y[i*4+j]); \n\t\t\tscanf("%d", &amp;t); \n\t\t\tfor (j = 0; j &lt; 3; ++j) \n\t\t\t{ \n\t\t\t\tdouble x1 = x[i*4+(j+1)%3], y1 = y[i*4+(j+1)%3], \n\t\t\t\t\tx2 = x[i*4+(j+2)%3], y2 = y[i*4+(j+2)%3]; \n\t\t\t\tif (fabs((x[i*4+j]-x1)*(x[i*4+j]-x2)+(y[i*4+j]-y1)*(y[i*4+j]-y2)) &lt; 1E-7) \n\t\t\t\t\tx[i*4+3] = x1+x2-x[i*4+j], y[i*4+3] = y1+y2-y[i*4+j]; \n\t\t\t} \n\t\t\tfor ( j = 0; j &lt; 4; ++j) \n\t\t\t\tfor (k = 0; k &lt; 4; ++k) \n\t\t\t\t\ts[i*4+j][i*4+k] = t*sqrt(Sqr(x[i*4+j]-x[i*4+k])+Sqr(y[i*4+j]-y[i*4+k])); \n\t\t\tfor ( j = 0; j &lt; i*4; ++j) \n\t\t\t\tfor ( k = 0; k &lt; 4; ++k) \n\t\t\t\t\ts[i*4+k][j] = tt*sqrt(Sqr(x[i*4+k]-x[j])+Sqr(y[i*4+k]-y[j])), \n\t\t\t\t\ts[j][i*4+k] = s[i*4+k][j]; \n\t\t} \n\t\tfor ( k = 0; k &lt; n*4; ++k) \n\t\t\tfor (i = 0; i &lt; n*4; ++i) \n\t\t\t\tfor ( j = 0; j &lt; n*4; ++j) \n\t\t\t\t\tif (s[i][k]+s[k][j] &lt; s[i][j]) \n\t\t\t\t\t\ts[i][j] = s[i][k]+s[k][j]; \n\t\tfor (i = 0; i &lt; 4; ++i) \n\t\t\tfor ( j = 0; j &lt; 4; ++j) \n\t\t\t\tif (s[a*4+i][b*4+j] &lt; res) \n\t\t\t\t\tres = s[a*4+i][b*4+j]; \n\t\tprintf("%.1lf\\n", res); \n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner in = new Scanner(System.in);\n\t\tint s = in.nextInt();//s表示城市的个数\n\t\tint t = in.nextInt();//t代表飞机的单价\n\t\tint A = in.nextInt();\n\t\tint B = in.nextInt();\n\t\tCity []cities = new City[s];\n\t\tfor(int i = 0; i &lt; s; i++){\n\t\t\tint x1 = in.nextInt();\n\t\t\tint y1 = in.nextInt();\n\t\t\tint x2 = in.nextInt();\n\t\t\tint y2 = in.nextInt();\n\t\t\tint x3 = in.nextInt();\n\t\t\tint y3 = in.nextInt();\n\t\t\tint price = in.nextInt();\n\t\t\tCity city = new City(x1, y1, x2, y2, x3, y3, price);\n\t\t\tcities[i] = city;\n\t\t}\n\t\t\n\t\t\n\t\tdouble  [][]dp = new double[s*4][s*4];\n\t\t\n\t\tfor(int i = 0; i &lt; s*4; i++){\n\t\t\tfor( int j = 0; j &lt; s*4 ;j++){\n\t\t\t\tif(i/4==j/4){\n\t\t\t\t\tdp[i][j] = dist(cities[i/4].x[i%4],cities[i/4].y[i%4],cities[j/4].x[j%4],cities[j/4].y[j%4])*cities[i/4].price;\n\t\t\t\t}else{\n\t\t\t\t\tdp[i][j] = dist(cities[i/4].x[i%4],cities[i/4].y[i%4],cities[j/4].x[j%4],cities[j/4].y[j%4])*t;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//System.out.println(i+" "+j+" "+dp[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tfor(int i = 0; i &lt; 4*s;i++){\n\t\t\tfor(int j = 0; j &lt; 4*s; j++){\n\t\t\t\tfor(int k = 0; k &lt; 4*s; k++){\n\t\t\t\t\tdp[j][k] = Math.min(dp[j][k], dp[j][i]+dp[i][k]);\n\t\t\t\t\t//System.out.println(j+" "+k+" "+dp[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tdouble min = dp[(A-1)*4][(B-1)*4];\n\t\t//System.out.println(min);\n\t\tfor(int i = (A-1)*4; i &lt;A*4; i++){\n\t\t\tfor(int j = (B-1)*4; j &lt;B*4; j++){\n\t\t\t\tif(min&gt;dp[i][j]){\n\t\t\t\t\tmin = dp[i][j];\n\t\t\t\t\t//System.out.println(i+" "+j+" "+min);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.printf("%.1f", min);\n\t}\n\tprivate static double dist(int x12, int y12, int x22, int y22) {\n\t\t// TODO Auto-generated method stub\n\t\treturn Math.sqrt((x22-x12)*(x22-x12)+(y22-y12)*(y22-y12));\n\t}\n\n}\n\n\nclass City{\n\t\n\tint []x = new int[4];\n\tint []y = new int[4];\n\tint price;\n\tpublic City(int x1, int y1, int x2, int y2, int x3, int y3,  int price) {\n\t\tsuper();\n\t\tx[0] = x1;\n\t\ty[0] = y1;\n\t\tx[1] = x2;\n\t\ty[1] = y2;\n\t\tx[2] = x3;\n\t\ty[2] = y3;\n\t\t\n\t\tdouble t12 = dist(x1,y1,x2,y2);\n\t\tdouble t13 = dist(x1,y1,x3,y3);\n\t\tdouble t23 = dist(x2,y2,x3,y3);\n\t\t\n\t\tif(Math.abs(t12*t12+t13*t13-t23*t23)&lt;0.000001){\n\t\t\tx[3] = x2+x3-x1;\n\t\t\ty[3] = y2+y3-y1;\n\t\t}\n\t\t\n\t\tif(Math.abs(t12*t12+t23*t23-t13*t13)&lt;0.000001){\n\t\t\tx[3] = x1+x3-x2;\n\t\t\ty[3] = y1+y3-y2;\n\t\t}\n\t\t\n\t\tif(Math.abs(t13*t13+t23*t23-t12*t12)&lt;0.000001){\n\t\t\tx[3] = x1+x2-x3;\n\t\t\ty[3] = y1+y2-y3;\n\t\t}\n\t\t\n\t\tthis.price = price;\n\t}\n\tprivate double dist(int x12, int y12, int x22, int y22) {\n\t\t// TODO Auto-generated method stub\n\t\treturn Math.sqrt((x22-x12)*(x22-x12)+(y22-y12)*(y22-y12));\n\t}\n\t\n}\r\n</textarea>	87
88	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　形如2\n  <i><sup>P</sup></i>-1的素数称为麦森数，这时P一定也是个素数。但反过来不一定，即如果P是个素数，2\n  <i><sup>P</sup></i>-1不一定也是素数。到1998年底，人们已找到了37个麦森数。最大的一个是P=3021377，它有909526位。麦森数有许多重要应用，它与完全数密切相关。\n  <br> 　　任务：从文件中输入P（1000&lt;P&lt;3100000），计算2\n  <i><sup>P</sup></i>-1的位数和最后500位数字（用十进制高精度数表示）\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　文件中只包含一个整数P（1000&lt;P&lt;3100000）\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　第一行：十进制高精度数2\n  <i><sup>P</sup></i>-1的位数。\n  <br> 　　第2-11行：十进制高精度数2\n  <i><sup>P</sup></i>-1的最后500位数字。（每行输出50位，共输出10行，不足500位时高位补0）\n  <br> 　　不必验证2\n  <i><sup>P</sup></i>-1与P是否为素数。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  1279\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  386\n  <br> 00000000000000000000000000000000000000000000000000\n  <br> 00000000000000000000000000000000000000000000000000\n  <br> 00000000000000104079321946643990819252403273640855\n  <br> 38615262247266704805319112350403608059673360298012\n  <br> 23944173232418484242161395428100779138356624832346\n  <br> 49081399066056773207629241295093892203457731833496\n  <br> 61583550472959420547689811211693677147548478866962\n  <br> 50138443826029173234888531116082853841658502825560\n  <br> 46662248318909188018470682222031405210266984354887\n  <br> 32958028878050869736186900714720710555703168729087\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;math.h&gt;\n#define LEN 125  //每数组元素存放十进制的4位，因此数组最多只要125个元素即可\n//Multiply函数功能是计算高精度乘法a*b，结果的末500位放在a中\n\nvoid Multiply(int *a,int *b)\n{\n\tint i,j;\n\tint nCarry; //存放进位\n\tint nTmp;\n\tint c[LEN];  //存放结果的末500位\n\tmemset(c,0,sizeof(int)*LEN);\n\tfor(i=0;i&lt;LEN;i++)\n\t{\n\t\tnCarry=0;\n\t\tfor(j=0;j&lt;LEN-i;j++)\n\t\t{\n\t\t\tnTmp=c[i+j]+a[j]*b[i]+nCarry;\n\t\t\tc[i+j]=nTmp%10000;\n\t\t\tnCarry=nTmp/10000;\n\t\t}\n\t}\n\tmemcpy(a,c,LEN*sizeof(int));\n}\n\nint main()\n{\n\tint i,p;\n\tint anPow[LEN];  //存放不断增长的2的次幂\n\tint aResult[LEN];  //存放最终结果的末500位\n\tscanf("%d",&amp;p);\n\tprintf("%d\\n",(int)(p*log10(2))+1);\n\t//下面将2的次幂初始化为2^(2^0)(a^b表示a的b次方),最终结果初始化为1\n\tanPow[0]=2;\n\taResult[0]=1;\n\tfor(i=1;i&lt;LEN;i++)\n\t{\n\t\tanPow[i]=0;\n\t\taResult[i]=0;\n\t}\n\t//下面计算2的p次方\n\twhile(p&gt;0)  //p=0则说明p中的有效位都用过了，不需要再计算下去\n\t{\n\t\tif(p&amp;1)  //判断此时p中最低位是否为1\n\t\t\tMultiply(aResult,anPow);\n\t\tp&gt;&gt;=1;\n\t\tMultiply(anPow,anPow);\n\t}\n\taResult[0]--;  //2的p次方算出后减1\n\n\t//输出结果\n\tfor(i=LEN-1;i&gt;=0;i--)\n\t{\n\t\tif(i%25==12)\n\t\t\tprintf("%02d\\n%02d",aResult[i]/100,aResult[i]%100);\n\t\telse\n\t\t{\n\t\t\tprintf("%04d",aResult[i]);\n\t\t\tif(i%25==0)\n\t\t\t\tprintf("\\n");\n\t\t}\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;vector&gt;\n#include&lt;cmath&gt;\n#include&lt;iomanip&gt;\n\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::vector;\nusing std::setw;\nusing std::setfill;\n\nvector&lt;int&gt; Multiply(vector&lt;int&gt; ivec1,vector&lt;int&gt; ivec2)  \n{\n\tvector&lt;int&gt; ivec(125,0);\n\n\n\tfor(int i=0;i!=125;++i)\n\t{\n\t\tint n=0;\n\t\tfor(int j=0;j!=125-i;++j)\n\t\t{\n\t\t\tint tmp=ivec[i+j]+ivec1[j]*ivec2[i]+n;\n\t\t\tivec[i+j]=tmp%10000;\n\t\t\tn=tmp/10000;\n\t\t}\n\t}\n\n\n\treturn ivec;\n}\n\n\nint main()\n{\n\tint p=0;\n\tcin&gt;&gt;p;\n\n\n\tcout&lt;&lt;(int)(p*log10(2.0))+1&lt;&lt;endl;\n\n\n\tvector&lt;int&gt; Boolvec;\n\n\n\twhile(p)\n\t{\n\t\tBoolvec.push_back(p%2);\n\t\tp/=2;\n\t}\n\n\n\tvector&lt;int&gt; ivec;\n\tvector&lt;int&gt; Result;\n\tivec.push_back(2);\n\tResult.push_back(1);\n\tfor(int i=1;i!=125;++i)\n\t{\n\t\tivec.push_back(0);\n\t\tResult.push_back(0);\n\t}\n\t\t\n\tfor(int i=0;i&lt;(int)Boolvec.size();++i)\n\t{\n\t\tif(Boolvec[i])\n\t\t\tResult=Multiply(Result,ivec);\n\t\t\n\t\tivec=Multiply(ivec,ivec);\n\t}\n\n\n\tResult[0]--;\n\n\n\tfor(int i=124;i&gt;=0;--i)\n\t{\n\t\tif(i%25==12)\n\t\t{\n\t\t\tcout&lt;&lt;setfill('0')&lt;&lt;setw(2)&lt;&lt;Result[i]/100;  \n\t\t\tcout&lt;&lt;endl;\n\t\t\tcout&lt;&lt;setfill('0')&lt;&lt;setw(2)&lt;&lt;Result[i]%100;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(i%25==0)\n\t\t\t{\n\t\t\t\tcout&lt;&lt;setfill('0')&lt;&lt;setw(4)&lt;&lt;Result[i];\n\t\t\t\tcout&lt;&lt;endl;\n\t\t\t}\n\t\t\telse\n\t\t\t\tcout&lt;&lt;setfill('0')&lt;&lt;setw(4)&lt;&lt;Result[i];\n\t\t}\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\r\nimport java.math.BigInteger;\r\n\r\npublic class Main {\r\n\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tint p = Integer.parseInt(br.readLine());\r\n\r\n\t\tString result;\r\n\t\tBigInteger a = new BigInteger("2");\r\n\t\t\r\n\t\tresult = pow(a, p).toString();\r\n\t\tint count = result.length();\r\n\t\tfor (int b = 0; b &lt; 500 - count; b++)\r\n\t\t\tresult = 0 + result;\r\n\t\tSystem.out.println((int) (p * Math.log10(2)) + 1);\r\n\t\tfor (int b = 0; b &lt; 10; b++)\r\n\t\t\tSystem.out.println(result.substring(b * 50, (b + 1) * 50));\r\n\t}\r\n\r\n\tpublic static BigInteger pow(BigInteger a, int b) {\r\n\t\tBigInteger x = new BigInteger("1");\r\n\t\tString s;\r\n\t\tint len;\r\n\r\n\t\twhile (b &gt; 0) {\r\n\t\t\tif (b % 2 == 1) {\r\n\t\t\t\tx = x.multiply(a);\r\n\t\t\t\ts = x.toString();\r\n\t\t\t\tlen = s.length();\r\n\t\t\t\tif (len &gt; 500) {\r\n\t\t\t\t\tx = new BigInteger(s.substring(len - 500, len));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\ta = a.pow(2);\r\n\t\t\ts = a.toString();\r\n\t\t\tlen = s.length();\r\n\t\t\tif (len &gt; 500) {\r\n\t\t\t\ta = new BigInteger(s.substring(len - 500, len));\r\n\t\t\t}\r\n\t\t\tb /= 2;\r\n\t\t}\r\n\t\treturn x.subtract(new BigInteger("1"));\r\n\t}\r\n}\r\n</textarea>	88
89	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　我们可以把由“0”和“1”组成的字符串分为三类：全“0”串称为B串，全“1”串称为I串，既含“0”又含“1”的串则称为F串。\n  <br> 　　FBI树是一种二叉树，它的结点类型也包括F结点，B结点和I结点三种。由一个长度为2\n  <sup>N</sup>的“01”串S可以构造出一棵FBI树T，递归的构造方法如下：\n  <br> 　　1)T的根结点为R，其类型与串S的类型相同；\n  <br> 　　2)若串S的长度大于1，将串S从中间分开，分为等长的左右子串S1和S2；由左子串S1构造R的左子树T1，由右子串S2构造R的右子树T2。\n  <br> 　　现在给定一个长度为2\n  <sup>N</sup>的“01”串，请用上述构造方法构造出一棵FBI树，并输出它的后序遍历序列。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行是一个整数N（0 &lt;= N &lt;= 10），第二行是一个长度为2\n  <sup>N</sup>的“01”串。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　包括一行，这一行只包含一个字符串，即FBI树的后序遍历序列。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3\n  <br> 10001011\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  IBFBBBFIBFIIIFF\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　对于40%的数据，N &lt;= 2；\n  <br> 　　对于全部的数据，N &lt;= 10。\n  <br> 　　注：\n  <br> 　　[1] 二叉树：二叉树是结点的有限集合，这个集合或为空集，或由一个根结点和两棵不相交的二叉树组成。这两棵不相交的二叉树分别称为这个根结点的左子树和右子树。\n  <br> 　　[2] 后序遍历：后序遍历是深度优先遍历二叉树的一种方法，它的递归定义是：先后序遍历左子树，再后序遍历右子树，最后访问根。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;malloc.h&gt;\n\nchar in[1025];\n\ntypedef struct node\n{\n\tchar data;\n\tstruct node *lchild,*rchild;\n}Binode;\n\nBinode *create(int a,int b)\n{\n\tchar ch;\n\tBinode *p;\n\tint i,count0=0,count1=0,flag=0;\n//\tscanf("%c",&amp;ch);\n//\tgetchar();\n\tif(a==b)\n\t{\n\t\t(in[a]=='0')?(ch='B'):(ch='I');\n\t\tp=(Binode *)malloc(sizeof(Binode));\n\t\tp-&gt;data=ch;\n\t\tp-&gt;lchild=NULL;\n\t\tp-&gt;rchild=NULL;\n\t\treturn p;\n\t}\n\tfor(i=a;i&lt;=b;i++)\n\t{\n\t\t(in[i]=='0')?(count0++):(count1++);\n\t\tif(count0 &amp;&amp; count1)\n\t\t{\n\t\t\tch='F';\n\t\t\tflag=1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(!flag)\n\t{\n\t\tif(!count0)\n\t\t\tch='I';\n\t\telse\n\t\t\tch='B';\n\t}\n\tp=(Binode *)malloc(sizeof(Binode));\n\tp-&gt;data=ch;\n\tp-&gt;lchild=create(a,((b+1)-a)/2+a-1);\n\tp-&gt;rchild=create(((b+1)-a)/2+a,b);\n\treturn p;\n}\n\nvoid display(Binode *p)\n{\n\tif(!p)\n\t\treturn;\n\tdisplay(p-&gt;lchild);\n\tdisplay(p-&gt;rchild);\n\tprintf("%c",p-&gt;data);\n}\n\nint main()\n{\n\tBinode *r;\n\tchar c;\n\tint p=0,n;\n\tscanf("%d",&amp;n);\n\tgetchar();\n\twhile(1)\n\t{\n\t\tc=getchar();\n\t\tif(c=='\\n')\n\t\t\tbreak;\n\t\tin[p++]=c;\n\t}\n\tr=create(0,p-1);\n\tdisplay(r);\n\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;cstdio&gt; \n#include&lt;cstdlib&gt; \n#include&lt;cstring&gt; \nint a[2100][3],f[1100],v=1,s=1; \nvoid g(int x,int y) \n{ \n    if(y-x+1&gt;1) \n    { \n      int vv=v,v1,v2; \n      a[vv][0]=v+1;v++;v1=v; \n      g(x,x+(y-x)/2); \n      a[vv][1]=v+1;v++;v2=v; \n      g(x+(y-x)/2+1,y); \n      if(a[v1][2]==a[v2][2])a[vv][2]=a[v1][2]; \n      else a[vv][2]=2; \n    } \n    else{a[v][0]=-1;a[v][1]=-1;a[v][2]=f[s];s++;} \n} \nvoid h(int x) \n{ \n    if(a[x][0]!=-1)h(a[x][0]); \n    if(a[x][1]!=-1)h(a[x][1]); \n    if(a[x][2]==0)printf("B"); \n    if(a[x][2]==1)printf("I"); \n    if(a[x][2]==2)printf("F"); \n} \nint main() \n{ \n    int n=1,i,nn; \n    char c; \n    scanf("%d\\n",&amp;nn); \n    for(i=1;i&lt;=nn;i++)n*=2; \n    for(i=1;i&lt;=n;i++){scanf("%c",&amp;c);f[i]=c-'0';} \n    g(1,n); \n    h(1); \n    printf("\\n"); \n    return 0; \n}\r\n</textarea>	<textarea id="codelinesjava">\r\n\nimport java.util.*;\nimport java.lang.*;\npublic class Main {\n\tstatic class TreeNode\n\t{\n\t\t String data;  \n\t     TreeNode lchild ;  \n\t     TreeNode rchild ;  \n\t     public String getData()  \n\t     {  \n\t         return data;  \n\t     }  \n\t     public TreeNode getLchild()  \n\t     {  \n\t         return lchild;  \n\t     }  \n\t     public TreeNode getRchild()  \n\t     {  \n\t         return rchild;  \n\t     }  \n\t    public void setNode(String data,TreeNode lc,TreeNode rc){  \n\t        this.data = data;  \n\t        lchild = lc;  \n\t        rchild = rc;  \n\t    }  \n\n\t}\n\tstatic TreeNode create(TreeNode root,String ss)\n\t{\n\t\tif(ss.length()==1)\n\t\t{\n\t\t   root.setNode(ss, null, null);\n\t\t   return root;\n\t\t}\n\t\t\t\n\t\tTreeNode tl=new TreeNode();\n\t\tTreeNode tr=new TreeNode();\n\t\troot.setNode(ss, create(tl,ss.substring(0,ss.length()/2)), create(tr,ss.substring(ss.length()/2,ss.length())));\n\t\treturn root;\n\t}\n\tstatic void ff(TreeNode root)\n\t{\n\t\tif(root!=null)\n\t\t{\n\t\t\tff(root.getLchild());\n\t\t\tff(root.getRchild());\n\t\t\tSystem.out.print(ff1(root.getData()));\n\t\t}\n\t}\n\tstatic char ff1(String s)\n\t{\n\t\tint i,j;\n\t\tchar c='F';\n\t\tfor(i=0;i&lt;s.length();i++)\n\t\t\tif(s.charAt(i)=='1')\n\t\t\t\tbreak;\n\t\tfor(j=0;j&lt;s.length();j++)\n\t\t\tif(s.charAt(j)=='0')\n\t\t\t\tbreak;\n\t\tif(i==s.length())\n\t\t\tc='B';\n\t\tif(j==s.length())\n\t\t\tc='I';\n\t\treturn c;\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t    int n=sc.nextInt();\n\t    String s=sc.next();\n\t\tsc.close();\n\t\tint m=1,j;\n\t\tTreeNode root=new TreeNode();\n\t\tfor(int i=1;i&lt;=n;i++)\n\t\t\tm*=2;\n\t\tfor(j=0;j&lt;s.length();j++)\n\t\t\tif(s.charAt(j)&gt;'1'||s.charAt(j)&lt;'0')\n\t\t\t\t\tbreak;\n\t\tif(s.length()!=m||j&lt;s.length())\n\t\t\tSystem.out.print("error");\n\t\telse\n\t\t{\n\t\t\tcreate(root,s);\n\t\t\tff(root);\n\t\t}\n\t\n\t\t\n\t}\n\t\n}\r\n</textarea>	89
90	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　人类终于登上了火星的土地并且见到了神秘的火星人。人类和火星人都无法理解对方的语言，但是我们的科学家发明了一种用数字交流的方法。这种交流方法是这样 的，首先，火星人把一个非常大的数字告诉人类科学家，科学家破解这个数字的含义后，再把一个很小的数字加到这个大数上面，把结果告诉火星人，作为人类的回 答。\n  <br> 　　火星人用一种非常简单的方式来表示数字——掰手指。火星人只有一只手，但这只手上有成千上万的手指，这些手指排成一列，分别编号为1，2，3……。火星人的任意两根手指都能随意交换位置，他们就是通过这方法计数的。\n  <br> 　　一个火星人用一个人类的手演示了如何用手指计数。如果把五根手指——拇指、食指、中指、无名指和小指分别编号为1，2，3，4和5，当它们按正常顺序排列 时，形成了5位数12345，当你交换无名指和小指的位置时，会形成5位数12354，当你把五个手指的顺序完全颠倒时，会形成54321，在所有能够形 成的120个5位数中，12345最小，它表示1；12354第二小，它表示2；54321最大，它表示120。下表展示了只有3根手指时能够形成的6个 3位数和它们代表的数字：\n  <br> 　　三进制数\n  <br> 　　123\n  <br> 　　132\n  <br> 　　213\n  <br> 　　231\n  <br> 　　312\n  <br> 　　321\n  <br> 　　代表的数字\n  <br> 　　1\n  <br> 　　2\n  <br> 　　3\n  <br> 　　4\n  <br> 　　5\n  <br> 　　6\n  <br> 　　现在你有幸成为了第一个和火星人交流的地球人。一个火星人会让你看他的手指，科学家会告诉你要加上去的很小的数。你的任务是，把火星人用手指表示的数与科 学家告诉你的数相加，并根据相加的结果改变火星人手指的排列顺序。输入数据保证这个结果不会超出火星人手指能表示的范围。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　包括三行，第一行有一个正整数N，表示火星人手指的数目（1 &lt;= N &lt;= 10000）。第二行是一个正整数M，表示要加上去的小整数（1 &lt;= M &lt;= 100）。下一行是1到N这N个整数的一个排列，用空格隔开，表示火星人手指的排列顺序。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　只有一行，这一行含有N个整数，表示改变后的火星人手指的排列顺序。每两个相邻的数中间用一个空格分开，不能有多余的空格。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5\n  <br> 3\n  <br> 1 2 3 4 5\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  1 2 4 5 3\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　对于30%的数据，N&lt;=15；\n  <br> 　　对于60%的数据，N&lt;=50；\n  <br> 　　对于全部的数据，N&lt;=10000；\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n    int n,w,i1,i2;\n    int a[100000];\n\tscanf("%d%d",&amp;n,&amp;w);\n\tfor(i1=0;i1&lt;n;i1++)\n         scanf("%d",&amp;a[i1]);\n\twhile(w--)\n    {   int max=a[n-1],min;\n    \t\n\t\tfor(i1=n-2;i1&gt;=0;i1--)\n    \t{\n\t        if(max&lt;a[i1])\n\t             {max=a[i1];\n\t\t\t\t continue;\n\t             }\n\t        min=max; \n\t\t\tint xiabiao=-1;    \n\t\t\tfor(i2=i1+1;i2&lt;=n-1;i2++)\n\t\t\t{\n\t\t\t\tif(a[i2]&gt;a[i1])\n\t\t\t\t  {\n  \t\t\t\t\t  if(min&gt;=a[i2])\n  \t\t\t\t\t  {\n  \t\t\t\t\t  \tmin=a[i2];\n  \t\t\t\t\t  \txiabiao=i2;\n  \t\t\t\t\t  }\n  \t\t\t\t}\n\t\t\t}\t\n\t\t\tint k=a[i1];\n\t\t\ta[i1]=min;\n\t\t\ta[xiabiao]=k;\n\t\t\tfor(i2=1;i1+i2&lt;n-i2;i2++)\n\t\t\t{\n\t\t\t\tint kp=a[i2+i1];\n\t\t\t\ta[i2+i1]=a[n-i2];\n\t\t\t\ta[n-i2]=kp;\n\t\t\t}\t\t\t\n\t\t   break;\n\t    }\n    \t    \n    }\nfor(i1=0;i1&lt;n;i1++)\n       printf("%d ",a[i1]);   \n       printf("\\n"); \n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n\n#include &lt;cmath&gt;\n\n#include &lt;cstring&gt;\n\n#include &lt;algorithm&gt;\n\n#include &lt;cstdio&gt;\n\nusing namespace std;\n\n#define du freopen("in.txt","r",stdin)\n\n#define chu freopen("out.txt","w",stdout)\n\n#define FOR(i,a,b) for(int i=a;i&lt;=b;i++)\n\n#define FD(i,a,b) for(int i=a;i&gt;=b;i--)\n\n#define FF(i,a) for(int i=0;i&lt;a;i++)\n\n#define SD(x) scanf("%d",&amp;x)\n\n#define PD(x) printf("%d",x)\n\n#define PP printf(" ")\n\n#define LN puts("")\n\nconst int maxn= 0;\n\nint a[20001];\n\n \n\nint main()\n\n{\n\n    int n;\n\n    while(~scanf("%d",&amp;n)){\n\n        int m; SD(m);\n\n        FF(i,n) SD(a[i]);\n\n        while( m&amp;&amp; next_permutation(a,a+n)){\n\n            m--;\n\n        }\n\n        PD(a[0]);\n\n        FOR(i,1,n-1){\n\n                PP;PD(a[i]);\n\n        }\n\n        LN;\n\n \n\n    }\n\n}\n\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\npublic class Main {\n\tpublic static void main(String args[]) throws NumberFormatException, IOException {\n\t\tBufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n\t\tint n=Integer.parseInt(bf.readLine());\n\t\tint m=Integer.parseInt(bf.readLine());\n\t\tString s[]=bf.readLine().split(" ");\n\t\tint a[] =new int[10001];\n\t\tint sum=1;\n\t\tfor(int i=1;i&lt;=n;i++)\n\t\t\ta[i]=Integer.parseInt(s[i-1]);\n\t\tfor(int i=2;i&lt;=n;i++){\n\t\t\tsum=1;\n\t\t\tfor(int j=i;j&gt;1;j--)\n\t\t\t\tsum*=j;\n\t\t\tint c[]=new int[i+1];\n\t\t\tfor(int k=0;k&lt;i;k++)\n\t\t\t\tc[k]=a[n-i+k+1];\n\t\t\tif(cantor(c,i,m,sum,n,a))\n\t\t\t\treturn;\n\t\t}\n       \n\t}\n\tpublic static boolean cantor(int a[],int n,int m,int sum,int y,int d[]){\n\t\tint count = 1;\n\t\tfor (int i = 0; i &lt; n; i++) {\n\t\t\tint temp = 0;\n\t\t\tfor (int j = i + 1; j &lt; n; j++) {\n\t\t\t\tif (a[j] &lt; a[i])\n\t\t\t\t\ttemp++;\n\t\t\t}\n\t\t\tint num = 1;\n\t\t\tfor (int k = 2; k &lt;= n - i - 1; k++) {\n\t\t\t\tnum *= k;\n\t\t\t}\n\t\t\tcount += num * temp;\n\n\t\t}\n\t\tif(count+m&lt;=sum){\n\t\t\t//System.out.println(count+" "+sum);\n\t\t\tfor(int i=1;i&lt;=y-n;i++)\n\t\t\t\tSystem.out.print(d[i]+" ");\n\t\t\tjava.util.Arrays.sort(a);\n\t\t\t boolean b[]=new boolean[10001];\n        int r=count+m-1;\n            sum=1;\n        int num=0;\n      for(int i=n;i&gt;=1;i--){\n    \t      sum=1;\n    \t      num=0;\n    \t  for(int j=i-1;j&gt;=1;j--)\n    \t\t  sum*=j;\n    \t  int x=r/sum;\n    \t      r=r%sum;\n    \t      for(int k=1;k&lt;=n;k++){\n    \t    \t  if(!b[k])\n    \t    \t\t  num++;\n    \t    \t  if(num==x+1){\n    \t    \t\t  System.out.print(a[k]+" ");\n    \t    \t\t  b[k]=true;\n    \t    \t\t  break;\n    \t    \t  }\n    \t      }\n      }\n      return true;\n      }\n\t\treturn false;\n\t}\n}\n\r\n</textarea>	90
91	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　某校大门外长度为L的马路上有一排树，每两棵相邻的树之间的间隔都是1米。我们可以把马路看成一个数轴，马路的一端在数轴0的位置，另一端在L的位置；数 轴上的每个整数点，即0，1，2，……，L，都种有一棵树。\n  <br> 　　由于马路上有一些区域要用来建地铁。这些区域用它们在数轴上的起始点和终止点表示。已 知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树 都移走后，马路上还有多少棵树。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入文件的第一行有两个整数L（1 &lt;= L &lt;= 10000）和 M（1 &lt;= M &lt;= 100），L代表马路的长度，M代表区域的数目，L和M之间用一个空格隔开。接下来的M行每行包含两个不同的整数，用一个空格隔开，表示一个区域的起始点 和终止点的坐标。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出文件包括一行，这一行只包含一个整数，表示马路上剩余的树的数目。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  500 3\n  <br> 150 300\n  <br> 100 200\n  <br> 470 471\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  298\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　对于20%的数据，区域之间没有重合的部分；\n  <br> 　　对于其它的数据，区域之间有重合的情况。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\ntypedef struct\n{\nint start;\nint end;\nint flag;\n}extent;\nint main()\n{\nint L,M,i,j;\nextent e[101];\nscanf("%d%d",&amp;L,&amp;M);\nfor(i=1;i&lt;=M;i++)\n{\nscanf("%d%d",&amp;(e[i].start),&amp;(e[i].end));\ne[i].flag=1;\nfor(j=1;j&lt;i;j++)\n{\nif(!(e[i].end&lt;e[j].start||e[i].start&gt;e[j].end)&amp;&amp;e[j].flag)\n{\ne[j].flag=0;\nif(e[i].start&gt;e[j].start)\ne[i].start=e[j].start;\nif(e[i].end&lt;e[j].end)\ne[i].end=e[j].end;\n}\n}//调整区间 \n}\nfor(i=1;i&lt;=M;i++)\nif(e[i].flag)\nL=L-(e[i].end-e[i].start+1);\nprintf("%d",L+1);\nreturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nstruct Area\n{\n\tint l, r;\n};\nArea a[101];\nbool cmp(Area a, Area b)\n{\n\treturn a.l &lt; b.l;\n}\nint main()\n{\n\tint L, m, i;\n\tscanf("%d%d", &amp;L, &amp;m);\n\tfor(i = 0; i &lt; m; i++)\n\t\tscanf("%d%d", &amp;a[i].l, &amp;a[i].r);\n\tsort(a, a+m, cmp);\n\tint tot = 0, crt = -1;\n\tfor(i = 0; i &lt; m; i++)\n\t{\n\t\tif(a[i].l &gt; crt)\n\t\t{\n\t\t\tcrt = a[i].l;\n\t\t\ttot++;\n\t\t}\n\t\tif(crt &lt; a[i].r)\n\t\t{\n\t\t\ttot += a[i].r - crt;\n\t\t\tcrt = a[i].r;\n\t\t}\n\t}\n\tprintf("%d\\n", L-tot+1);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner input = new Scanner(System.in);\n\t\tint m = input.nextInt();\n\t\tint n = input.nextInt();\n\t\tint[] a = new int[2 * n];\n\t\n\t\tint d = 0, e, max;\n\t\tfor (int i = 0; i &lt; n; i++) {\n\t\t\ta[i] = input.nextInt();\n\t\t\ta[i + n] = input.nextInt();\n\n\t\t}\n\t\tmax = a[0];\n\t\tfor (int j = 0; j &lt; 2 * n; j++) {\n\t\t\tif (max &lt; a[j]) {\n\t\t\t\tmax = a[j];\n\t\t\t}\n\n\t\t}\n\t\tint[] c = new int[max*10];\n\t\tfor (int i = 0; i &lt; n; i++) {\n\t\t\tfor (int j = a[i]; j &lt;=a[i + n]; j++) {\n\t\t\t\tc[j] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i &lt; max; i++) {\n\t\t\tif (c[i] == 1) {\n\t\t\t\td = d + 1;\n\n\t\t\t}\n\t\t}\n\t\te = m  - d;\n\t\t\n\t\tSystem.out.println(e);\n\n\t}\n\n}\n\r\n</textarea>	91
92	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”\n  <br> 　　如果你是辰辰，你能完成这个任务吗？\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行有两个整数T（1 &lt;= T &lt;= 1000）和M（1 &lt;= M &lt;= 100），用一个空格隔开，T代表总共能够用来采药的时间，M代表山洞里的草药的数目。接下来的M行每行包括两个在1到100之间（包括1和100）的整数，分别表示采摘某株草药的时间和这株草药的价值。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　包括一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  70 3\n  <br> 71 100\n  <br> 69 1\n  <br> 1 2\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  3\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　对于30%的数据，M &lt;= 10；\n  <br> 　　对于全部的数据，M &lt;= 100。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n\nint totalTime, medics;\nint value[100];\nint time[100];\nint max[1001];\n\nint main() \n{\n    scanf("%d%d", &amp;totalTime, &amp;medics);\n    int i, t;\n    for (i=0; i&lt;medics; i++)\n    {\n        scanf("%d%d", &amp;time[i], &amp;value[i]);\n    }\n\n    for (i=0; i&lt;medics; i++)\n    {\n        for (t=totalTime; t&gt;0; t--)\n        {\n            if (time[i] &lt;= t)\n            {\n                if (value[i] + max[t-time[i]] &gt; max[t])//第i个的价值+不选第i个且用时为t-time[i-1]时最大价值\n                {\n                    max[t] = value[i] + max[t-time[i]];\n                }\n            }\n        }\n    }\n    printf("%d\\n", max[totalTime]);\n    return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\nconst int maxn = 1010;\nint dp[maxn];\nint main()\n{\n\tint V, M, w[100], v[100], i, j;\n\tscanf("%d%d", &amp;V, &amp;M);\n\tfor(i = 0; i &lt; M; i++)\n\t{\n\t\tscanf("%d%d", &amp;v[i], &amp;w[i]);\n\t}\n\tfor(i = 0; i &lt; M; i++)\n\t\tfor(j = V; j &gt;= v[i]; j--)\n\t\t\tdp[j] = dp[j] &gt; dp[j-v[i]] + w[i] ? dp[j] : dp[j-v[i]] + w[i];\n\tprintf("%d\\n", dp[V]);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main{\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tString[] str = br.readLine().split(" ");\n\t\tint t = Integer.parseInt(str[0]);\n\t\tint m = Integer.parseInt(str[1]);\n\n\t\tint[][] arr = new int[m][2];\n\t\tfor (int i = 0; i &lt; m; i++) {\n\t\t\tString[] order = br.readLine().split(" ");\n\t\t\tfor (int j = 0; j &lt; 2; j++) {\n\t\t\t\tarr[i][j] = Integer.parseInt(order[j]);\n\t\t\t}\n\t\t}\n\n\t\tint[] tag = new int[t + 1];\n\t\tfor (int i = 0; i &lt; m; i++) {\n\t\t\tfor (int j = t; j &gt; 0; j--) {\n\t\t\t\tif (j &gt;= arr[i][0]) {\n\t\t\t\t\n\n\t\t\t\t\tif (tag[j - arr[i][0]] + arr[i][1] &gt; tag[j]) {\n\n\t\t\t\t\t\ttag[j] = tag[j - arr[i][0]] + arr[i][1];\n\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\n\t\tSystem.out.println(tag[t]);\n\t}\n}\r\n</textarea>	92
93	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间他自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎 么布置，你说了算，只要不超过N元钱就行”。今天一早金明就开始做预算，但是他想买的东西太多了，肯定会超过妈妈限定的N元。于是，他把每件物品规定了一 个重要度，分为5等：用整数1~5表示，第5等最重要。他还从因特网上查到了每件物品的价格（都是整数元）。他希望在不超过N元（可以等于N元）的前提 下，使每件物品的价格与重要度的乘积的总和最大。\n  <br> 　　设第j件物品的价格为v[j]，重要度为w[j]，共选中了k件物品，编号依次为 j1，j2，……，jk，则所求的总和为：\n  <br> 　　v[j1]*w[j1]+v[j2]*w[j2]+ …+v[jk]*w[jk]。（其中*为乘号）\n  <br> 　　请 你帮助金明设计一个满足要求的购物单。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入文件 的第1行，为两个正整数，用一个空格隔开：\n  <br> 　　N m\n  <br> 　　（其中N（&lt;30000）表示总钱 数，m（&lt;25）为希望购买物品的个数。）\n  <br> 　　从第2行到第m+1行，第j行给出了编号为j-1的物品的基本数据，每行有2个非负整数\n  <br> 　　v p\n  <br> 　　（其中v表示该物品的价格(v&lt;=10000)，p表示该物品的重要度(1~5)）\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出文件只有一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（&lt;100000000）。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  1000 5\n  <br> 800 2\n  <br> 400 5\n  <br> 300 5\n  <br> 400 3\n  <br> 200 2\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  3900\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nlong mnum[30000]; \nlong objprice[25]; //第i件商品的价格 \nlong objk[25];     //第i件商品的价格与权值的积 \nint M,N;    //M表示金钱总数，N表示商品总数 \nint main()\n{\n\tint i,m;\n\tint maxp = 0;\n\tscanf("%u%u", &amp;M, &amp;N);   //M表示金钱总数，N表示商品总数 \n\tfor(i=0;i&lt;N;++i) //依次输入第i件商品的价格与权值，并计算出商品的价格与权值之积 \n\t{\n\t\tscanf("%u%u", &amp;objprice[i], &amp;m);\n\t\tobjk[i] = m*objprice[i];\n\t}\n\tfor(i=0;i&lt;N;++i)  \n\t{\n\t\tfor(m=0;m&lt;M-objprice[i];++m)\n\t\t\tif (mnum[m+objprice[i]] + objk[i] &gt; mnum[m])\n\t\t\t\tmnum[m] = mnum[m+objprice[i]] + objk[i];\n\t}\t\n\tfor(i=0;i&lt;M;++i) \n\t\tif (mnum[i] &gt; maxp)\n\t\t\tmaxp = mnum[i];\n\tprintf("%u", maxp);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;string.h&gt;\nusing namespace std;\nint dp[30000];\nint main()\n{\n\tint N,m,v[300],w[300];\n\t//freopen("d://1.txt","r",stdin);\n\tcin&gt;&gt;N&gt;&gt;m;\n\tfor(int i=0;i&lt;m;i++)\n\t{\n\t\tcin&gt;&gt;v[i]&gt;&gt;w[i];\n\t}\n\tfill(dp,dp+N,0);\n\tdp[0]=1;\n\tfor(int i=0;i&lt;m;i++)\n\tfor(int j=N;j&gt;=v[i];j--)\n\tdp[j]=max(dp[j],dp[j-v[i]]+w[i]*v[i]);\n\tcout&lt;&lt;dp[N]&lt;&lt;endl;\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main{\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tString[] str = br.readLine().split(" ");\n\t\tint money = Integer.parseInt(str[0]);\n\t\tint count = Integer.parseInt(str[1]);\n\n\t\tint[][] arr = new int[count][2];\n\t\tfor (int i = 0; i &lt; count; i++) {\n\t\t\tString[] order = br.readLine().split(" ");\n\t\t\tfor (int j = 0; j &lt; 2; j++) {\n\t\t\t\tarr[i][j] = Integer.parseInt(order[j]);\n\t\t\t}\n\t\t}\n\n\t\tint[] temp = new int[money + 1];\n\t\tfor (int i = 0; i &lt; count; i++) {\n\t\t\tfor (int j = money; j &gt; 0; j--) {\n\t\t\t\tif (j &gt; arr[i][0]) {\n\t\t\t\t\tif (temp[j - arr[i][0]] + arr[i][0] * arr[i][1] &gt; temp[j]) {\n\t\t\t\t\t\ttemp[j] = temp[j - arr[i][0]] + arr[i][0]\n\t\t\t\t\t\t\t\t* arr[i][1];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(temp[money]);\n\t}\n}\r\n</textarea>	93
94	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　Jam是个喜欢标新立异的科学怪人。他不使用阿拉伯数字计数，而是使用\n  <b>小写英文字母</b>计数，他觉得这样做，会使世界更加丰富多彩。在他的计数法中，每个数字的位数都是相同的（使用相同个数的字母），英文字母按原先的顺序，排在前面的字母小于排在它后面的字母。我们把这样的“数字”称为Jam数字。在Jam数字中，每个字母互不相同，而且\n  <b>从左到右是严格递增</b>的。每次，Jam还指定使用字母的\n  <b>范围</b>，例如，从2到10，表示只能使用{b,c,d,e,f,g,h,i,j}这些字母。如果再规定位数为5，那么，紧接在Jam数字“bdfij”之后的数字应该是“bdghi”。（如果我们用U、V依次表示Jam数字“bdfij”与“bdghi”，则U&lt;V&lt; span&gt;，且不存在Jam数字P，使U&lt;P&lt;V&lt; span&gt;）。你的任务是：对于从文件读入的一个Jam数字，按顺序输出紧接在后面的5个Jam数字，如果后面没有那么多Jam数字，那么有几个就输出几个。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　有2行，第1行为3个正整数，用一个空格隔开：\n  <br> 　　s t w\n  <br> 　　（其中s为所使用的最小的字母的序号，t为所使用的最大的字母的序号。w为数字的位数，这3个数满足：1≤s&lt;T≤26, 2≤w≤t-s ）\n  <br> 　　第2行为具有w个小写字母的字符串，为一个符合要求的Jam数字。\n  <br> 　　所给的数据都是正确的，不必验证。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　最多为5行，为紧接在输入的Jam数字后面的5个Jam数字，如果后面没有那么多Jam数字，那么有几个就输出几个。每行只输出一个Jam数字，是由w个小写字母组成的字符串，不要有多余的空格。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  2 10 5\n  <br> bdfij\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  bdghi\n  <br> bdghj\n  <br> bdgij\n  <br> bdhij\n  <br> befgh\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n\nint main()\n{\n\tint s,t,w;\n\tchar in[26];\n\tint ad[26],i,j,k,flag,st;\n\n\tscanf("%d%d%d",&amp;s,&amp;t,&amp;w);\n\tgetchar();\n\tfor(i=0;i&lt;w;i++)\n\t{\n\t\tscanf("%c",&amp;in[i]);\n\t\tad[i]=in[i]-'a'+1;\n\t}\n//\tfor(i=0;i&lt;w;i++)\n//\t\tprintf("%d ",ad[i]);//+'a'-1);\n//\tprintf("\\n");\n\tfor(i=0;i&lt;5;i++)\n\t{\n\t\tif(ad[0]==(t-w+1))\n\t\t\tbreak;\n\t//\tflag=0;\n\t\tfor(j=w-1;j&gt;=0;j--)\n\t\t{\n\t\t\tif(ad[j]==t-w+j+1)\n\t\t\t\tcontinue;\n\t//\t\tif(!flag)\n\t//\t\t{\n\t\t\t//\tad[j]++;\n\t\t\t\tst=++ad[j];\n\t\t\t//\tk=j;\n\t\t\t\tfor(k=j+1;k&lt;w;k++)\n\t\t\t\t\tad[k]=++st;\n\t\t\t\tfor(k=0;k&lt;w;k++)\n\t\t\t\t\tprintf("%c",ad[k]+'a'-1);\n\t\t\t\tprintf("\\n");\n\t\t\t\tflag=1;\n\t\t\t\tbreak;\n\t//\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\nint p[26], num;\nvoid output()\n{\n\tfor(int i = 0; i &lt; num; i++)\n\t\tprintf("%c", p[i]+'a');\n\tprintf("\\n");\n}\nint main()\n{\n\tint s, end;\n\tscanf("%d%d%d", &amp;s, &amp;end, &amp;num);\n\tgetchar();\n\tfor(int i = 0; i &lt; num; i++)\n\t{\n\t\tchar c = getchar();\n\t\tp[i] = c - 'a';\n\t}\n\tint t = 5;\n\twhile(t--)\n\t{\n\t\tint crt = num - 1, tmp = end - 1;\n\t\twhile(crt &gt;= 0 &amp;&amp; p[crt--] == tmp--);\n\t\tif(crt &lt; 0)\n\t\t\treturn 0;\n\t\tp[crt] = p[++crt]++;\n\t\twhile(++crt &lt; num)\n\t\t\tp[crt] = p[crt-1] + 1;\n\t\toutput();\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.StreamTokenizer;\n\npublic class Main {\n\n\tprivate static char chs[] = new char[27];\n\tstatic {\n\t\tfor (int i = 1; i &lt; chs.length; i++) {\n\t\t\tchs[i] = (char) (96 + i);\n\t\t}\n\t}\n\n\tprivate static int a, b, c;\n\tprivate static String tmp = "";\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tStreamTokenizer st = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n\n\t\tst.nextToken();\n\t\ta = (int) st.nval;\n\t\tst.nextToken();\n\t\tb = (int) st.nval;\n\t\tst.nextToken();\n\t\tc = (int) st.nval;\n\n\t\tst.nextToken();\n\t\tString str = st.sval;\n\t\tint len = str.length(), count = 0;\n\t\tfor (int i = len - 1; i &gt;= 0; i--) {\n\t\t\tif (chs[b] - str.charAt(i) &gt;= (len - i)) {\n\t\t\t\ttmp = str.substring(0, i);\n\t\t\t\tint index = str.charAt(i) - 95;\n\t\t\t\tfor (int j = i; j &lt; len; j++) {\n\t\t\t\t\ttmp += chs[index++];\n\t\t\t\t}\n\t\t\t\tif(count==5)\n\t\t\t\t\tbreak;\n\t\t\t\tif (count &lt; 5)\n\t\t\t\t\tSystem.out.println(tmp);\n\t\t\t\tcount++;\n\t\t\t\tstr = tmp;\n\t\t\t\ti = len;\n\t\t\t}\n\t\t}\n\t}\n}\r\n</textarea>	94
95	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　给定一个正整数k(3≤k≤15),把所有k的方幂及所有有限个互不相等的k的方幂之和构成一个递增的序列，例如，当k=3时，这个序列是：\n  <br> 　　1，3，4，9，10，12，13，…\n  <br> 　　（该序列实际上就是：3\n  <sup>0</sup>，3\n  <sup>1</sup>，3\n  <sup>0</sup>+3\n  <sup>1</sup>，3\n  <sup>2</sup>，3\n  <sup>0</sup>+3\n  <sup>2</sup>，3\n  <sup>1</sup>+3\n  <sup>2</sup>，3\n  <sup>0</sup>+3\n  <sup>1</sup>+3\n  <sup>2</sup>，…）\n  <br> 　　请你求出这个序列的第N项的值（用10进制数表示）。\n  <br> 　　例如，对于k=3，N=100，正确答案应该是981。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　只有1行，为2个正整数，用一个空格隔开：\n  <br> 　　k N\n  <br> 　　（k、N的含义与上述的问题描述一致，且3≤k≤15，10≤N≤1000）。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　计算结果，是一个正整数（在所有的测试数据中，结果均不超过2.1*10\n  <sup>9</sup>）。（整数前不要有空格和其他符号）。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3 100\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  981\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n\nint main()\n{\n\tint re[1000],k,n;\n\tint p=0,t=1,i,j,f;\n\n\tre[0]=1;j=0,f=1;\n\tscanf("%d%d",&amp;k,&amp;n);\n\tfor(i=1;i&lt;n;i++)\n\t{\n\t\tif(f==re[j])\n\t\t{\n\t\t\tf*=k;\n\t\t\tre[i]=f;\n//\t\t\tprintf("%d ",f);\n\t\t\tj=0;\n\t\t\tcontinue;\n\t\t}\n\t\tt=f+re[j++];\n\t\tre[i]=t;\n//\t\tprintf("%d ",t);\n\t}\n\tprintf("%d",re[i-1]);\n\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n #include&lt;cstdio&gt;\n #include&lt;cstdlib&gt;\n\n using namespace std;\n int main()\n {\n     int k, n;\n     cin&gt;&gt;k&gt;&gt;n;\n     int a[1010]={0,1,k,1+k,k*k};\n     for (int i=5; i&lt;=n; i++)\n        if (i%2) a[i]=a[i-1]+1; else a[i]=a[2]*a[i/2];\n     cout&lt;&lt;a[n];\n     return 0;\n }\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\npublic class Main {\n    static long a[]=new long[1001];\n    public static void main (String args[])throws IOException{\n    BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n    String s[]=bf.readLine().split(" ");\n        int k=Integer.parseInt(s[0]);\n        int n=Integer.parseInt(s[1]);\n        int m=1;\n        int sum=0;\n        while(n&gt;0){\n            a[m++]=n%2;\n            n=n/2;\n        }\n        m--;\n     for(int i=1;i&lt;=m;i++){\n        sum+=a[i]*add(k,i-1);\n     }\n        System.out.println(sum);\n    }\n    static int add(int k,int n){\n        int sum=1;\n        for(int i=1;i&lt;=n;i++)\n            sum*=k;\n            return sum;\n    }\n}\r\n</textarea>	95
96	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　元旦快到了，校学生会让乐乐负责新年晚会的纪念品发放工作。为使得参加晚会的同学所获得的纪念品价值 相对均衡，他要把购来的纪念品根据价格进行分组，但每组最多只能包括两件纪念品，并且每组纪念品的价格之和不能超过一个给定的整数。为了保证在尽量短的时 间内发完所有纪念品，乐乐希望分组的数目最少。\n  <br> 　　你的任务是写一个程序，找出所有分组方案中分组数最少的一种，输出最少的分组数目。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入包含\n  <i>n</i>+2行：\n  <br> 　　第1行包括一个整数\n  <i>w</i>，为每组纪念品价格之和的上限。\n  <br> 　　第2行为一个整数\n  <i>n</i>，表示购来的纪念品的总件数。\n  <br> 　　第3~\n  <i>n</i>+2行每行包含一个正整数\n  <i>p<sub>i</sub></i> (5 &lt;= \n  <i>p<sub>i</sub></i> &lt;= \n  <i>w</i>)，表示所对应纪念品的价格。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出仅一行，包含一个整数，即最少的分组数目。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  100\n  <br> 9\n  <br> 90\n  <br> 20\n  <br> 20\n  <br> 30\n  <br> 50\n  <br> 60\n  <br> 70\n  <br> 80\n  <br> 90\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  6\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　50%的数据满足：1 &lt;= \n  <i>n</i> &lt;= 15\n  <br> 　　100%的数据满足：1 &lt;= \n  <i>n</i> &lt;= 30000, 80 &lt;= \n  <i>w</i> &lt;= 200\n </div> \n</div>	<textarea id="codelinesc">\r\n/*\n算法训练 纪念品分组\n\n问题描述\n　　元旦快到了，校学生会让乐乐负责新年晚会的纪念品发放工作。为使得参加晚会的同学所获得的纪念品价值 相对均衡，他要把购来的纪念品根据价格进行分组，但每组最多只能包括两件纪念品，并且每组纪念品的价格之和不能超过一个给定的整数。为了保证在尽量短的时 间内发完所有纪念品，乐乐希望分组的数目最少。\n　　你的任务是写一个程序，找出所有分组方案中分组数最少的一种，输出最少的分组数目。\n输入格式\n　　输入包含n+2行：\n　　第1行包括一个整数w，为每组纪念品价格之和的上限。\n　　第2行为一个整数n，表示购来的纪念品的总件数。\n　　第3~n+2行每行包含一个正整数pi (5 &lt;= pi &lt;= w)，表示所对应纪念品的价格。\n输出格式\n　　输出仅一行，包含一个整数，即最少的分组数目。\n样例输入\n100\n9\n90\n20\n20\n30\n50\n60\n70\n80\n90\n样例输出\n6\n数据规模和约定\n　　50%的数据满足：1 &lt;= n &lt;= 15\n　　100%的数据满足：1 &lt;= n &lt;= 30000, 80 &lt;= w &lt;= 200\n*/\n#include &lt;stdio.h&gt;\nvoid qsort(int i,int j);\n\tint a[30000];\n\tvoid qsort(int i,int j){     \n\tint x,p,q;    \n\tx=a[i]; p=i; q=j;    \n\twhile (i&lt;j)     \n\t{           \n\t\twhile ((i&lt;j)&amp;&amp;(a[j]&gt;x))\n\t\tj--;         \n\t\tif (i&lt;j)          \n\t\t{             \n\t\t\ta[i]=a[j];             \n\t\t\ti++;          \n\t\t}   \n\t\t        \n\t\twhile ((i&lt;j)&amp;&amp;(a[i]&lt;x))\n\t\ti++;\n\t         \n\t\tif (i&lt;j)           \n\t\t{              \n\t\t\ta[j]=a[i];              \n\t\t\tj--;          \n\t\t}     \n\t}     \n\ta[i]=x;     \n\tif (p&lt;i-1) \n\tqsort(p,i-1);     \n\tif (i+1&lt;q) \n\tqsort(i+1,q);\n}\nmain(){      \n\tint n,w,s,i,j;   \n\t  \n\tscanf("%d%d",&amp;w,&amp;n);\n\t     \n\tfor (i=0;i&lt;n;i++) \n\tscanf("%d",&amp;a[i]);\n\t      \n\tqsort(0,n-1);      \n\ti=0;\n\tj=n-1; \n\ts=0;  \n\t   \n\twhile (i&lt;j)     \n\t{           \n\t\ts++;           \n\t\tif (a[i]+a[j]&lt;=w)           \n\t\t{              \n\t\ti++;              \n\t\tj--;           \n\t\t}            \n\t\telse \n\t\tj--;     \n\t} \n\t     \n\tif ((i==j)&amp;&amp;(a[i]&lt;=w)) \n\ts++;       \n\tprintf("%d",s);     \n\tgetchar();      \n\tgetchar();\n\t     \n\treturn(0);\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include "iostream"\n#include "string"\n#include "stdio.h"\n#include "ctype.h"\n#include "algorithm"\n#include "stack"\n#include "list"\n#include "math.h"\nusing namespace std;\nconst  int N =30001;\nint a[N];\nint main()\n{\n\tint n;\n\tint w;\n\tcin&gt;&gt;w&gt;&gt;n;\n\tfor(int i=0;i&lt;n;i++)\n\t{\n\t\tscanf("%d",&amp;a[i]);\n\t}\n\tstd::sort(a,a+n);\n\tint ans=0;\n\tfor(int i=0,j=n-1;i&lt;=j;)\n\t{\n\t\tfor(;i&lt;j;j--)\n\t\t{\n\t\t\tif(a[i]+a[j]&lt;=w)\n\t\t\t\tbreak;\n\t\t\telse ans++;\n\t\t}\n\t\tif(i!=j)\n\t\t{\n\t\t\ti++;j--;\n\t\t\tans++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tans++;\n\t     break;\n\t\t}\n\t\t\n\n\t\t\t\n\t}\n\tcout&lt;&lt;ans;\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\nimport java.util.Arrays;\npublic class Main {\n    static int a[]=new int[30001];\n    public static void main (String args[])throws IOException{\n        BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n        int w=Integer.parseInt(bf.readLine());\n        int n=Integer.parseInt(bf.readLine());\n        for(int i=1;i&lt;30001;i++)\n            a[i]=999999;\n        int k=n;\n        int sum=0;\n        for(int i=1;i&lt;=n;i++)\n        a[i]=Integer.parseInt(bf.readLine());\n        Arrays.sort(a);\n        oter:for(int i=1;i&lt;=n;i++){\n            for(int j=n;j&gt;0;j--){\n                if(k==i){\n                    sum++;\n                    break oter;\n                }\n                if(k-i==1&amp;&amp;a[i]+a[k]&gt;w){\n                    sum+=2;\n                    break oter;\n                }\n                if(k-i==1&amp;&amp;a[i]+a[k]&lt;=w){\n                    sum++;\n                    break oter;\n                }\n                if(a[i]+a[k]&gt;w){\n                    k--;\n                    sum++;\n                    }\n                else{\n                    sum++;\n                    k--;\n                    break;\n                }\n            }\n        }\n        System.out.println(sum);\n             \n    }\n}\r\n</textarea>	96
97	<div class="des"> \n <div class="pdcont">\n  　　\n  <b>【</b>问题描述】\n  <br> 　　上体育课的时候，小蛮的老师经常带着同学们一起做游戏。这次，老师带着同学们一起做传球游戏。\n  <br> 　　游戏规则是这样的：n个同学站成一个圆圈，其中的一个同学手里拿着一个球，当老师吹哨子时开始传球，每个同学可以把球传给自己左右的两个同学中的一个（左右任意），当老师再次吹哨子时，传球停止，此时，拿着球没传出去的那个同学就是败者，要给大家表演一个节目。\n  <br> 　　聪明的小蛮提出一个有趣的问题：有多少种不同的传球方法可以使得从小蛮手里开始传的球，传了m次以后，又回到小蛮手里。两种传球的方法被视作不同的方法，当且仅当这两种方法中，接到球的同学按接球顺序组成的序列是不同的。比如有3个同学1号、2号、3号，并假设小蛮为1号，球传了3次回到小蛮手里的方式有1-&gt;2-&gt;3-&gt;1和1-&gt;3-&gt;2-&gt;1，共2种。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　共一行，有两个用空格隔开的整数n，m（3&lt;=n&lt;=30，1&lt;=m&lt;=30）。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　t共一行，有一个整数，表示符合题意的方法数。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3 3\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  2\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　40%的数据满足：3&lt;=n&lt;=30，1&lt;=m&lt;=20\n  <br> 　　100%的数据满足：3&lt;=n&lt;=30，1&lt;=m&lt;=30\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt; \nint n,m;\nint at1(int x)\n{\n\tif(x&lt;1) return x + n;   \n\tif(x&gt;n) return x - n;  \n\treturn x;\n}int main()\n{\n\tint f[31][31] = {0},i,j;  \n\tscanf("%d%d",&amp;n,&amp;m);   \n\tf[1][2] = f[1][n] = 1; \n\tfor(i = 2;i &lt;= m;i++)    \n\tfor(j = 1;j &lt;= n;j++)\n\t\tf[i][j] = f[i - 1][at1(j - 1)] + f[i - 1][at1(j + 1)]; \n\tprintf("%d",f[m][1]); \n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;stdio.h&gt;  \n#include &lt;iostream&gt;  \nusing namespace std;  \nint n,m;  \nint fun(int x)  \n{  \n     if(x&lt;1)  \n        return x+n;  \n     if(x&gt;n) return x-n;  \n     return x;  \n}  \nint main()  \n{     int f[31][31]={0},i,j;  \n      scanf("%d%d",&amp;n,&amp;m);  \n      f[1][2]=f[1][n]=1;  \n      for (i=2;i&lt;=m;i++)  \n         for (j=1;j&lt;=n;j++)  \n            f[i][j]=f[i-1][fun(j-1)]+f[i-1][fun(j+1)];  \n             printf("%d",f[m][1]);  \n            return 0;  \n}  \r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\tsc.close();\n\n\t\tint dp[][] = new int[m + 1][n + 1];\n\t\tdp[0][0] = 1;\n\t\tfor (int i = 1; i &lt;= m; i++) {\n\t\t\tfor (int j = 0; j &lt; n; j++) {\n\t\t\t\tdp[i][j] = dp[i - 1][(j - 1) == -1 ? n - 1 : j - 1] + dp[i - 1][(j + 1) == n ? 0 : j + 1];\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(dp[m][0]);\n\t}\n}\n\r\n</textarea>	97
98	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。一次素质拓展活动中，班上同学安排做成一个m行n列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。幸运的是，他们可以通过传纸条来进行交流。纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标(1,1)，小轩坐在矩阵的右下角，坐标(m,n)。从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。\n  <br> 　　在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙。反之亦然。\n  <br> 　　还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用0表示），可以用一个0-100的自然数来表示，数越大表示越好心。小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这两条路径上同学的好心程度只和最大。现在，请你帮助小渊和小轩找到这样的两条路径。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入第一行有2个用空格隔开的整数m和n，表示班里有m行n列（1&lt;=m,n&lt;=50）。\n  <br> 　　接下来的m行是一个m*n的矩阵，矩阵中第i行j列的整数表示坐在第i行j列的学生的好心程度。每行的n个整数之间用空格隔开。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出一行，包含一个整数，表示来回两条路上参与传递纸条的学生的好心程度之和的最大值。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3 3\n  <br> 0 3 9\n  <br> 2 8 5\n  <br> 5 7 0\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  34\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　30%的数据满足：1&lt;=\n  <i>m</i>,\n  <i>n</i>&lt;=10\n  <br> 　　100%的数据满足：1&lt;=\n  <i>m</i>,\n  <i>n</i>&lt;=50\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;    \r\nint n,m;   \r\nint i,j,k;   \r\nint Map[51][51];   \r\nint F[111][51][51];   \r\nint Max(int a,int b,int c,int d)   \r\n{   \r\n    if(a&gt;=b&amp;&amp;a&gt;=c&amp;&amp;a&gt;=d)   \r\n        return a;   \r\n    if(b&gt;=a&amp;&amp;b&gt;=c&amp;&amp;b&gt;=d)   \r\n        return b;   \r\n    if(c&gt;=a&amp;&amp;c&gt;=b&amp;&amp;c&gt;=d)   \r\n        return c;   \r\n    if(d&gt;=a&amp;&amp;d&gt;=b&amp;&amp;d&gt;=c)   \r\n        return d;   \r\n}   \r\nint main()   \r\n{   \r\n    scanf("%d%d",&amp;n,&amp;m);   \r\n    for(i=1;i&lt;=n;i++)   \r\n        for(j=1;j&lt;=m;j++)   \r\n            scanf("%d",&amp;Map[i][j]);   \r\n    for(k=1;k&lt;=n+m-2;k++)   \r\n        for(i=1;i&lt;=n;i++)   \r\n            for(j=1;j&lt;=n;j++)   \r\n                if(i==n&amp;&amp;j==n&amp;&amp;k==n+m-2)   \r\n                    F[k][i][j]=Max(F[k-1][i-1][j],F[k-1][i][j-1],F[k-1][i][j],F[k-1][i-1][j-1])+Map[i][k+2-i]+Map[j][k+2-j];   \r\n                else  if(i!=j&amp;&amp;k+2-i&gt;=1&amp;&amp;k+2-j&gt;=1)   \r\n                    F[k][i][j]=Max(F[k-1][i-1][j],F[k-1][i][j-1],F[k-1][i][j],F[k-1][i-1][j-1])+Map[i][k+2-i]+Map[j][k+2-j];   \r\n    printf("%d",F[n+m-2][n][n]);   \r\n    return 0;   \r\n}  \r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;string.h&gt;\nusing namespace std ;\t\nint dis[101][101] ;\nint f[105][52][52] ;\nint rows , cols , step ;\n#define MAX(a,b) ((a) &gt; (b) ? (a) : (b))\nint Max( int a , int b , int c , int d){\n\ta = MAX ( a , b ) ;\n\ta = MAX ( a , c ) ;\n\ta = MAX ( a , d ) ;\n\treturn a ;\n}\nint main(){\n\tstd::ios::sync_with_stdio(false) ;\n\tint  i  , j  , k ;\n\tmemset( f , 0 , sizeof(f) ) ; \n\tmemset( dis , 0 , sizeof(dis) ) ; \n\tcin &gt;&gt; rows  &gt;&gt; cols ;\n\tfor( i = 1 ; i &lt;= rows ; i++ )\n\tfor( j = 1 ; j &lt;= cols ; j++ )\n\tcin &gt;&gt; dis[i][j] ;\n\tstep = rows + cols - 2 ;\n\tf[1][2][1] = f[1][1][2]= dis[1][2] + dis[2][1] ; \n\tfor( k = 2 ; k &lt;= (step - 1) ; k++ )\n\tfor( i = 1 ; i &lt;= rows ; i++ )\n\tfor( j = 1 ; j &lt;= rows ; j++ )\n\tif( i != j )\n\tf[k][i][j] = dis[i][k - i + 2] + dis[j][k - j + 2] + Max( f[k - 1][i - 1][j - 1] , f[k - 1][i - 1][j] , f[k - 1][i][j - 1] , f[k - 1][i][j]) ;\n\tcout &lt;&lt; f[step - 1][rows - 1][rows] &lt;&lt; endl ;\n\treturn 0 ;\t\n\t\n\t\n\t\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic int[][][] dp = new int[105][55][55];\n\tstatic int[][] map = new int[100][100];\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tString order[] = br.readLine().split(" ");\n\t\tint n = Integer.parseInt(order[0]), m = Integer.parseInt(order[1]);\n\n\t\tfor (int i = 1; i &lt;= n; i++) {\n\t\t\tString data[] = br.readLine().split(" ");\n\t\t\tfor (int j = 1; j &lt;= m; j++) {\n\t\t\t\tmap[i][j] = Integer.parseInt(data[j - 1]);\n\t\t\t}\n\t\t}\n\n\t\tint c = n + m - 2;\n\t\tfor (int k = 1; k &lt; c; k++) {\n\t\t\tint t = k + 2 &gt; n ? n : k + 2;\n\t\t\tfor (int i = 1; i &lt;= t; i++) {\n\t\t\t\tfor (int x = i + 1; x &lt;= t; x++) {\n\t\t\t\t\tdp[k][i][x] = Math.max(Math.max(dp[k - 1][i - 1][x], dp[k - 1][i][x - 1]),\n\t\t\t\t\t\t\tMath.max(dp[k - 1][i - 1][x - 1], dp[k - 1][i][x]))\n\t\t\t\t\t\t\t+ map[i][k + 2 - i] + map[x][k + 2 - x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp[c][n][n] = Math.max(dp[c - 1][n - 1][n], dp[c - 1][n][n - 1]);\n\t\tSystem.out.println(dp[c][n][n]);\n\t}\n}\r\n</textarea>	98
99	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　Hanks 博士是BT (Bio-Tech，生物技术) 领域的知名专家，他的儿子名叫Hankson。现 在，刚刚放学回家的Hankson 正在思考一个有趣的问题。 今天在课堂上，老师讲解了如何求两个正整数c1 和c2 的最大公约数和最小公倍数。现 在Hankson 认为自己已经熟练地掌握了这些知识，他开始思考一个“求公约数”和“求公 倍数”之类问题的“逆问题”，这个问题是这样的：已知正整数a0,a1,b0,b1，设某未知正整 数x 满足： 1． x 和a0 的最大公约数是a1； 2． x 和b0 的最小公倍数是b1。 Hankson 的“逆问题”就是求出满足条件的正整数x。但稍加思索之后，他发现这样的 x 并不唯一，甚至可能不存在。因此他转而开始考虑如何求解满足条件的x 的个数。请你帮 助他编程求解这个问题。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入第一行为一个正整数n，表示有n 组输入数据。\n  <br> \n  <br> 　　接下来的n 行每 行一组输入数据，为四个正整数a0，a1，b0，b1，每两个整数之间用一个空格隔开。输入 数据保证a0 能被a1 整除，b1 能被b0 整除。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出共n 行。每组输入数据的输出结果占一行，为一个整数。\n  <br> 　　对于每组数据：若不存在这样的 x，请输出0； 若存在这样的 x，请输出满足条件的x 的个数；\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  2\n  <br> 41 1 96 288\n  <br> 95 1 37 1776\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  6\n  <br> 2\n </div>\n <div class="pdsec">\n  样例说明\n </div>\n <div class="pdcont">\n  　　第一组输入数据，x 可以是9、18、36、72、144、288，共有6 个。\n  <br> 　　第二组输入数据，x 可以是48、1776，共有2 个。\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　对于 50%的数据，保证有1≤a0，a1，b0，b1≤10000 且n≤100。\n  <br> 　　对于 100%的数据，保证有1≤a0，a1，b0，b1≤2,000,000,000 且n≤2000。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint max(int x,int y)\n{\n    while(y&gt;0)\n    {\n        int t=x%y;\n        x=y;\n        y=t;\n    }\n    return x;\n}\nint main()\n{\n    int i;\n    int t1,t2,t3,t;\n    int n;\n    int cnt;\n    int a0,a1,b0,b1;\n    scanf("%d",&amp;n);\n    for(i=0;i&lt;n;i++)\n    {\n        scanf("%d %d %d %d",&amp;a0,&amp;a1,&amp;b0,&amp;b1);\n        if(b1%a1!=0)\n        {\n            printf("0\\n");\n            continue;\n        }\n        cnt=0;\n        t1=a0/a1;\n        t2=b1/b0;\n        t3=b1/a1;\n        for(t=1;t*t&lt;t3;t++)\n        if(t3%t==0)\n        {\n            if(max(t1,t)==1&amp;&amp;max(t2,t3/t)==1)cnt++;\n            if(max(t1,t3/t)==1&amp;&amp;max(t2,t)==1)cnt++;\n        }\n        if(t*t==t3&amp;&amp;(max(t1,t)==1&amp;&amp;max(t2,t)==1))cnt++;\n        printf("%d\\n",cnt);\n    }\n    return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\n#include&lt;math.h&gt;\nconst int maxn = 55000;\nconst int pmaxn = 5500;\nint prime[pmaxn], p, ans = 1, tt;\nbool vis[maxn];\nint div(int &amp; a, int b)\n{\n\tint cnt = 0;\n\twhile(a % b == 0)\n\t{\n\t\ta /= b;\n\t\tcnt++;\n\t}\n\treturn cnt;\n}\nint main()\n{\n\tint test = 50010;\n\tint t = 0, n, m = (int)sqrt(maxn+0.5), i;\n\tfor(i = 2; i &lt;= m; i++)\n\t{\n\t\tif(vis[i])\tcontinue;\n\t\tprime[t++] = i;\n\t\tfor(int j = i * i; j &lt; maxn; j += i)\n\t\t\tvis[j] = true;\n\t}\n\tfor(; i &lt; maxn; i++)\n\t\tif(!vis[i])\n\t\t\tprime[t++] = i;\n\tscanf("%d", &amp;n);\n\twhile(n--)\n\t{\n\t\tint a, aa, b, bb;\n\t\tans = 1;\n\t\ttt = 0;\n\t\tscanf("%d%d%d%d", &amp;a, &amp;aa, &amp;b, &amp;bb);\n\t\tfor(i = 0; bb != 1; i++)\n\t\t{\n\t\t\tif(i &gt; 4950)\n\t\t\t{\n\t\t\t\tprime[i] = bb;\n\t\t\t//\tbreak;\n\t\t\t}\n\t\t\tif(bb % prime[i] == 0)\n\t\t\t{\n\t\t\t\tint cnt = 100000000, type;\n\t\t\t\tint a1c = div(aa, prime[i]);\n\t\t\t\tint a0c = div(a, prime[i]);\n\t\t\t\tif(a1c &gt; a0c)\tcontinue;\n\t\t\t\tif(a1c == a0c)\t\n\t\t\t\t{\n\t\t\t\t\tcnt = a1c;\n\t\t\t\t\ttype = 1;\n\t\t\t\t}\n\t\t\t\tif(a1c &lt; a0c)\n\t\t\t\t{\n\t\t\t\t\ttype = 2;\n\t\t\t\t\tcnt = a1c;\n\t\t\t\t}\n\t\n\t\t\t\tint b0c = div(b, prime[i]);\n\t\t\t\tint b1c = div(bb, prime[i]);\n\t\t\t\tint tot;\n\t\t\t\tif(b1c == b0c)\n\t\t\t\t{\n\t\t\t\t\tif(type == 1)\n\t\t\t\t\t\ttot = b1c - cnt + 1;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(cnt &gt; b1c)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\ttot = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(tot &lt;= 0) continue;\n\t\t\t\t}\n\t\t\t\tif(b1c &gt; b0c)\n\t\t\t\t{\n\t\t\t\t\tif(type == 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(b1c != cnt)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tans = 0;break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttot = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(cnt &gt; b1c)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\ttot = 1;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tans *= tot;\n\t\t\t}\n\t\t}\n\t\tprintf("%d\\n", ans);\n\n\t}\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\nimport java.util.ArrayList;\n\npublic class Main{\n\n\tprivate static ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\n\tprivate static Scanner sc = new Scanner(System.in);\n\tprivate static int[] p = new int[20000];\n\tprivate static int[] a = new int[200000];\n\tprivate static int[] num = new int[20000];\n\tprivate static int end;\n\tprivate static int len;\n\n\tpublic static void main(String[] args)\n\t{\n\t\tint n = sc.nextInt();\n\t\twhile (n &gt; 0) \n\t\t{\n\t\t\tint a0 = sc.nextInt();\n\t\t\tint a1 = sc.nextInt();\n\t\t\tint b0 = sc.nextInt();\n\t\t\tint b1 = sc.nextInt();\n\t\t\tint t = len = end = 0;\n\t\t\t\n\t\t\twork(b1, a0, a1);\n\t\t\t\n\t\t\tfor (int i = 0; i &lt; len; i++)\n\t\t\t\tif ( gcd(a[i], a0) == a1 &amp;&amp; b0 / gcd(b0, a[i]) * a[i] == b1)\n\t\t\t\t\tt++;\n\t\t\tlist.add(t);\n\t\t\tn--;\n\t\t}\n\t\t  for (int i : list)\n\t\t\tSystem.out.println(i);\n\t}\n\n\tpublic static int gcd(int a, int b)\n\t{\n\t\tint t;\n\t\twhile (b != 0)\n\t\t{\n\t\t\tt = a % b;\n\t\t\ta = b;\n\t\t\tb = t;\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static void dfs(int now, int pro)\n\t{\n\t\tif (now == end) \n\t\t{\n\t\t\ta[len++] = pro;\n\t\t\treturn;\n\t\t}\n\t\tdfs(now + 1, pro);\n\t\tfor (int i = 1; i &lt;= num[now]; i++)\n\t\t{\n\t\t\tpro *= p[now];\n\t\t\tdfs(now + 1, pro);\n\t\t}\n\t}\n\n\tpublic static void work(int n, int a0, int a1) \n\t{\n\t\tint i = 2;\n\t\tint lim = (int) Math.sqrt(n);\n\t\twhile (n != 1 &amp;&amp; i &lt;= lim) \n\t\t{\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tif (a1/i == 0 &amp;&amp; a1%i == 0) \n\t\t\t\t{\n\t\t\t\t\twhile (n % i == 0)\n\t\t\t\t\t\tn /= i;\n\t\t\t\t\ti++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tp[end] = i;\n\t\t\t\tnum[end] = 0;\n\t\t\t\twhile (n % i == 0) {\n\t\t\t\t\tnum[end]++;\n\t\t\t\t\tn /= i;\n\t\t\t\t}\n\t\t\t\tend++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tif (n != 1) {\n\t\t\tp[end] = n;\n\t\t\tnum[end++] = 1;\n\t\t}\n\t\tdfs(0, 1);\n\t}\n}\n\r\n</textarea>	99
100	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　学校里有一个水房，水房里一共装有m 个龙头可供同学们打开水，每个龙头每秒钟的 供水量相等，均为1。 现在有n 名同学准备接水，他们的初始接水顺序已经确定。将这些同学按接水顺序从1 到n 编号，i 号同学的接水量为wi。接水开始时，1 到m 号同学各占一个水龙头，并同时打 开水龙头接水。当其中某名同学j 完成其接水量要求wj 后，下一名排队等候接水的同学k 马上接替j 同学的位置开始接水。这个换人的过程是瞬间完成的，且没有任何水的浪费。即 j 同学第x 秒结束时完成接水，则k 同学第x+1 秒立刻开始接水。若当前接水人数n’不足m， 则只有n’个龙头供水，其它m−n’个龙头关闭。 现在给出n 名同学的接水量，按照上述接水规则，问所有同学都接完水需要多少秒。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第1 行2 个整数n 和m，用一个空格隔开，分别表示接水人数和龙头个数。 第2 行n 个整数w1、w2、……、wn，每两个整数之间用一个空格隔开，wi 表示i 号同 学的接水量。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出只有一行，1 个整数，表示接水所需的总时间。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5 3\n  <br> 4 4 1 2 1\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  4\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  8 4\n  <br> 23 71 87 32 70 93 80 76\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  163\n </div>\n <div class="pdsec">\n  输入输出样例 1 说明\n </div>\n <div class="pdcont">\n  　　第1 秒，3 人接水。第1 秒结束时，1、2、3 号同学每人的已接水量为1，3 号同学接完\n  <br> 　　水，4 号同学接替3 号同学开始接水。\n  <br> 　　第2 秒，3 人接水。第2 秒结束时，1、2 号同学每人的已接水量为2，4 号同学的已接\n  <br> 　　水量为1。\n  <br> 　　第3 秒，3 人接水。第3 秒结束时，1、2 号同学每人的已接水量为3，4 号同学的已接\n  <br> 　　水量为2。4 号同学接完水，5 号同学接替4 号同学开始接水。\n  <br> 　　第4 秒，3 人接水。第4 秒结束时，1、2 号同学每人的已接水量为4，5 号同学的已接\n  <br> 　　水量为1。1、2、5 号同学接完水，即所有人完成接水。\n  <br> 　　总接水时间为4 秒。\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　1 ≤ n ≤ 10000，1 ≤m≤ 100 且m≤ n；\n  <br> 　　1 ≤ wi ≤ 100。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;malloc.h&gt;\n/* run this program using the console pauser or add your own getch, system("pause") or input loop */\n\n\nint max(int *p,int n)\n{\n    int Max = p[0];\n    int i;\n\tfor(i=1;i&lt;n;i++)\n\t{\n\t\tif(p[i]&gt;Max)\n\t\t\t   Max = p[i];\t\n\t}\t\n\treturn Max;\n}\nint main(int argc, char *argv[]) {\n\t\n\tint m,n;  //m个水龙头 n个同学\n\tint i,j,second,min,num;\n\tint *p;\n\t\n\tscanf("%d%d",&amp;n,&amp;m);\n\tp = (int *)malloc(n*sizeof(int));\n\tif( NULL == p )\n\t{\n\t\tprintf("no enough memory!\\n");\n\t\treturn 0;\n\t}\n\t\n\tfor(i=0;i&lt;n;i++)\n\t{\n\t    scanf("%d",&amp;p[i]);    \n\t}\n\t\n\tif( n&lt;=m)\n\t{\t\t\n\t\tprintf("%d",max(p,n));\n\t}\n\t\n\tif( n&gt;m)\n\t{\n\t    second = 0;\n\t  \n\t    num = 0;\n\t    while(n&gt;m)\n\t    {\n\t        min = p[0]; \n\t        j = 0;\n\t\t    for(i=0;i&lt;m;i++)\n\t\t    {  \n\t\t       \n\t\t       if(min&gt;p[i])\n\t\t       {\n\t\t            min = p[i];\t\t\t\n\t\t            j=i;\n\t\t       }\n\t\t\t}\t\n\t\t    \n\t\t    for(i=0;i&lt;m;i++)\n\t\t    {\n\t\t    \tp[i] -= min;\n\t\t    }\n\t\t    second += min;\n\t\t\t \n\t\t    p[j]=p[m+num];  //第m+num同学取代取完水的同学 \n\t\t    num++;\n\t\t    n--;//取水同学减少一个 \n\t\t    \n\t\t    if( n&lt;=m)\n\t        {\t       \t\n\t\t     \n\t\t     printf("%d",max(p,n)+second);\n\t\t\n\t        }\n\t   }\n\t}\n\t\n\t \n\t\n\t \n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include "iostream"\n#include "string"\n#include "stdio.h"\n#include "ctype.h"\n#include "algorithm"\n#include "stack"\n#include "list"\n#include "math.h"\nusing namespace std;\nconst  int N =101;\nstruct X\n{\n\tint total;\n\tint now;\n\tX(int t=0,int n=0):total(t),now(n){}\n}a[10001],b[201];\nint main()\n{\n\tint n,m;\n\tscanf("%d%d",&amp;n,&amp;m);\n\tfor(int i=0;i&lt;n;i++)\n\t\tscanf("%d",&amp;a[i].total);\n\tint index=0;\n    for(int i=0;i&lt;m;i++)\n\t{\n\t\tb[i]=a[ index++]; \n\t}\n\tint time=0;\n\twhile(true)\n\t{\n\t\ttime++;\n\t\tfor(int i=0;i&lt;m;i++)\n\t\t\tb[i].now++;\n\t\tfor(int i=0;i&lt;m;i++)\n\t\t{\n\t\t     if(b[i].now&gt;=b[i].total)\n\t\t\t {\n\t\t\t\t if(index&lt;n)\n\t\t\t\t {\n\t\t\t\t\t b[i]=a[index++];\n\t\t\t\t }\n\t\t\t }\n\t\t}\n\t\tint i;\n\t\tfor ( i=0;i&lt;m;i++)\n\t\t{\n\t\t\tif(b[i].now&lt;b[i].total)\n\t\t\t\tbreak;\n\t\t}\n\t\tif(i==m)\n\t\t\tbreak;\n\n\t}\n\tcout&lt;&lt;time&lt;&lt;endl;\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Main {\n\n          public static void main(String[] args) throws IOException {\n                    BufferedReader br = new BufferedReader(\n                                        new InputStreamReader(System.in));\n                    String[] str1 = br.readLine().split(" ");\n                    String[] str2 = br.readLine().split(" ");\n\n                    int[] first = new int[2];\n                    for (int i = 0; i &lt; first.length; i++)\n                              first[i] = Integer.parseInt(str1[i]);\n\n                    int[] student = new int[first[0]];\n                    for (int i = 0; i &lt; student.length; i++) {\n                              student[i] = Integer.parseInt(str2[i]);\n                    }\n\n                    if (first[0] &gt; first[1])\n                              System.out.println(getwater(student, first[1]));\n                    else\n                              System.out.println(getmax(student));\n          }\n\n          public static int getwater(int[] student, int watercome) {\n\n                    int time = 0;\n                    int[] firststudents = new int[watercome];\n                    for (int i = 0; i &lt; watercome; i++) {\n                              firststudents[i] = student[i];\n                    }\n                    int k = firststudents.length;\n\n                    for (int i = 0; i &lt;= student.length - watercome; i++) {\n                              if (i == student.length - watercome)\n                                        time += getmax(firststudents);\n                              else {\n                                        int min = getmin(firststudents);\n                                        for (int j = 0; j &lt; firststudents.length; j++) {\n                                                  firststudents[j] -= min;\n                                                  if (firststudents[j] == 0 &amp;&amp; k&lt;student.length) {\n                                                            firststudents[j] = student[k++];\n                                                  }\n                                        }\n                                        time += min;\n                              }\n                    }\n                    return time;\n          }\n\n          public static int getmin(int[] arr) {\n                    Arrays.sort(arr);\n                    return arr[0];\n          }\n\n          public static int getmax(int[] arr) {\n                    Arrays.sort(arr);\n                    return arr[arr.length - 1];\n          }\n}\r\n</textarea>	100
101	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　输入10个整数组成的序列，要求对其进行升序排序，并去掉重复元素。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　10个整数。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　多行输出，每行一个元素。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  2 2 3 3 1 1 5 5 5 5\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  1\n  <br> 2\n  <br> 3\n  <br> 5\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint A[10];\n\nint com(const void *a, const void *b)\n{\n\treturn *(int*)a-*(int*)b;\n}\n\nint main()\n{\n\tint i;\n\tint last;\n\tfor(i=0;i&lt;10;i++)\n\t    scanf("%d",&amp;A[i]);\n\tqsort(A,10,4,com);\n\tfor(i=0;i&lt;10;i++)\n\t    if(i)\n\t    {\n\t    \tif(last!=A[i])\n\t    \t{\n\t    \t\tprintf("%d\\n",A[i]);\n\t            last=A[i];\n\t    \t}\n\t    }\n\t    else\n\t    {\n\t        printf("%d\\n",A[i]);\n\t    \tlast=A[i];\n\t    }\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nint main()\n{\n\tint i,t;\n\tvector&lt;int&gt; v;\n\tfor (i = 0; i &lt; 10; i++)\n\t{\t\n\t\tcin&gt;&gt;t;\n\t\tv.push_back(t);\n\t}\n\tsort(v.begin(),v.end());\n\tv.erase(unique(v.begin(),v.end()),v.end());//unique(n.begin(),n.end())；unique()把相邻元素重复的甩到后面//erase()用来删掉后面的重复元素.//一定要先排序，再使用unique()，\n\tfor (i = 0; i &lt; v.size(); i++)\n\t\tcout&lt;&lt;v[i]&lt;&lt;endl;\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\r\nimport java.util.*;\r\n\r\npublic class Main {\r\n\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tString str[] = br.readLine().split(" ");\r\n\r\n\t\tSet&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();\r\n\t\tfor (int a = 0; a &lt; 10; a++) {\r\n\t\t\tset.add(Integer.parseInt(str[a]));\r\n\t\t}\r\n\t\tList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\r\n\t\tlist.addAll(set);\r\n\t\tCollections.sort(list);\r\n\t\tfor (int a = 0; a &lt; list.size(); a++) {\r\n\t\t\tSystem.out.println(list.get(a));\r\n\t\t}\r\n\t}\r\n}\r\n</textarea>	101
102	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　输入A,B。\n  <br> 　　输出A+B。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入包含两个整数A,B，用一个空格分隔。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出一个整数，表示A+B的值。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5 8\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  13\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　-1,000,000,000&lt;=A,B&lt;=1,000,000,000。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\r\n\r\nint sum(int a,int b)\r\n{\r\n\treturn a+b;\r\n}\r\n\r\nint main()\r\n{\r\n\tint a,b;\r\n\tscanf("%d%d",&amp;a,&amp;b);\r\n\t//sum(a,b);\r\n\tprintf("%d",sum(a,b));\r\n\treturn 0;\r\n} \r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\nusing namespace std;\nint main()\n{\n\tint a,b;\n\tcin&gt;&gt;a;\n\tcin&gt;&gt;b;\n\tcout&lt;&lt;a+b;\n\tcout&lt;&lt;'\\n';\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\npublic class Main {\r\n\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tString str[] = br.readLine().split(" ");\r\n\t\tint n = Integer.parseInt(str[0]);\r\n\t\tint m = Integer.parseInt(str[1]);\r\n\t\t\r\n\t\tSystem.out.print(n+m);\r\n\t}\r\n}\r\n</textarea>	103
103	<div class="des"> \n <div class="pdcont">\n  　　采油区域　　Siruseri政府决定将石油资源丰富的Navalur省的土地拍卖给私人承包商以建立油井。被拍卖的整块土地为一个矩形区域，被划分为\n  <i>M</i>×\n  <i>N</i>个小块。\n  <br> 　　Siruseri地质调查局有关于Navalur土地石油储量的估测数据。这些数据表示为\n  <i>M</i>×\n  <i>N</i>个非负整数，即对每一小块土地石油储量的估计值。\n  <br> 　　为了避免出现垄断，政府规定每一个承包商只能承包一个由\n  <i>K</i>×\n  <i>K</i>块相连的土地构成的正方形区域。\n  <br> 　　AoE石油联合公司由三个承包商组成，他们想选择三块互不相交的\n  <i>K</i>×\n  <i>K</i>的区域使得总的收益最大。\n  <br> 　　例如，假设石油储量的估计值如下：\n  <br> \n  <br> \n  <table cellspacing="0" cellpadding="2px" style="border-collapse:collapse;" class="table table-striped table-horver">\n   <tbody>\n    <tr style="border:solid 1.0pt">\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n    </tr>\n    <tr style="border:solid 1.0pt">\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n    </tr>\n    <tr style="border:solid 1.0pt">\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">8<br> </td>\n     <td valign="top" style="border:solid 1.0pt">8<br> </td>\n     <td valign="top" style="border:solid 1.0pt">8<br> </td>\n     <td valign="top" style="border:solid 1.0pt">8<br> </td>\n     <td valign="top" style="border:solid 1.0pt">8<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n    </tr>\n    <tr style="border:solid 1.0pt">\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">8<br> </td>\n     <td valign="top" style="border:solid 1.0pt">8<br> </td>\n     <td valign="top" style="border:solid 1.0pt">8<br> </td>\n     <td valign="top" style="border:solid 1.0pt">8<br> </td>\n     <td valign="top" style="border:solid 1.0pt">8<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n    </tr>\n    <tr style="border:solid 1.0pt">\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">8<br> </td>\n     <td valign="top" style="border:solid 1.0pt">8<br> </td>\n     <td valign="top" style="border:solid 1.0pt">8<br> </td>\n     <td valign="top" style="border:solid 1.0pt">8<br> </td>\n     <td valign="top" style="border:solid 1.0pt">8<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n    </tr>\n    <tr style="border:solid 1.0pt">\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">8<br> </td>\n     <td valign="top" style="border:solid 1.0pt">8<br> </td>\n     <td valign="top" style="border:solid 1.0pt">8<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n    </tr>\n    <tr style="border:solid 1.0pt">\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">8<br> </td>\n     <td valign="top" style="border:solid 1.0pt">8<br> </td>\n     <td valign="top" style="border:solid 1.0pt">8<br> </td>\n    </tr>\n    <tr style="border:solid 1.0pt">\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">9<br> </td>\n     <td valign="top" style="border:solid 1.0pt">9<br> </td>\n     <td valign="top" style="border:solid 1.0pt">9<br> </td>\n    </tr>\n    <tr style="border:solid 1.0pt">\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">9<br> </td>\n     <td valign="top" style="border:solid 1.0pt">9<br> </td>\n     <td valign="top" style="border:solid 1.0pt">9<br> </td>\n    </tr>\n   </tbody>\n  </table>\n  <br> \n  <br> 　　如果\n  <i>K</i> = 2, AoE公司可以承包的区域的石油储量总和为100, 如果\n  <i>K</i> = 3, AoE公司可以承包的区域的石油储量总和为208。\n  <br> 　　AoE公司雇佣你来写一个程序，帮助计算出他们可以承包的区域的石油储量之和的最大值。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入第一行包含三个整数\n  <i>M</i>, \n  <i>N</i>, \n  <i>K</i>，其中\n  <i>M</i>和\n  <i>N</i>是矩形区域的行数和列数，\n  <i>K</i>是每一个承包商承包的正方形的大小（边长的块数）。接下来\n  <i>M</i>行，每行有\n  <i>N</i>个非负整数表示这一行每一小块土地的石油储量的估计值。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出只包含一个整数，表示AoE公司可以承包的区域的石油储量之和的最大值。\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　数据保证\n  <i>K</i>≤\n  <i>M</i>且\n  <i>K</i>≤\n  <i>N</i>并且至少有三个\n  <i>K</i>×\n  <i>K</i>的互不相交的正方形区域。其中30%的输入数据，\n  <i>M</i>, \n  <i>N</i>≤ 12。所有的输入数据, \n  <i>M</i>, \n  <i>N</i>≤ 1500。每一小块土地的石油储量的估计值是非负整数且≤ 500。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  9 9 3\n  <br> 1 1 1 1 1 1 1 1 1\n  <br> 1 1 1 1 1 1 1 1 1\n  <br> 1 8 8 8 8 8 1 1 1\n  <br> 1 8 8 8 8 8 1 1 1\n  <br> 1 8 8 8 8 8 1 1 1\n  <br> 1 1 1 1 8 8 8 1 1\n  <br> 1 1 1 1 1 1 8 8 8\n  <br> 1 1 1 1 1 1 9 9 9\n  <br> 1 1 1 1 1 1 9 9 9\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  208\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\nlong n,m,K;\nlong map[1510][1510];\nlong sum1[1510][1510];//left and above\nlong sum2[1510][1510];//right and above\nlong sum3[1510][1510];//left and below\nlong sum4[1510][1510];//right and below\nlong rect1[1510][1510];//left and above\nlong rect2[1510][1510];//right and above\nlong rect3[1510][1510];//left and below\nlong rect4[1510][1510];//right and below\nlong rectA[1510][1510];\nlong rectB[1510][1510];\n#define MAX(a,b) (a&gt;b?a:b)\nint main()\n{\n    long i,j;\n    long ans = 0;\n\tscanf("%ld%ld%ld",&amp;n,&amp;m,&amp;K);\n\tfor (i=1;i&lt;n+1;i++)\n\t{\n\t\tfor (j=1;j&lt;m+1;j++)\n\t\t{\n\t\t\tscanf("%ld",map[i]+j);\n\t\t\tsum1[i][j] = sum1[i][j-1]+map[i][j];\n\t\t\tsum3[i][j] = sum1[i][j];\n\t\t}\n\t}\n\tfor (i=1;i&lt;n+1;i++)\n\t{\n\t\tfor (j=m;j&gt;0;j--)\n\t\t{\n\t\t\tsum2[i][j] = sum2[i][j+1]+map[i][j];\n\t\t\tsum4[i][j] = sum2[i][j];\n\t\t}\n\t}\n\tfor (i=1;i&lt;n+1;i++)\n\t{\n\t\tfor (j=1;j&lt;m+1;j++)\n\t\t{\n\t\t\tsum1[i][j] += sum1[i-1][j];\n\t\t\tsum2[i][j] += sum2[i-1][j];\n\t\t}\n\t}\n\tfor (i=n;i&gt;0;i--)\n\t{\n\t\tfor (j=m;j&gt;0;j--)\n\t\t{\n\t\t\tsum3[i][j] += sum3[i+1][j];\n\t\t\tsum4[i][j] += sum4[i+1][j];\n\t\t}\n\t}\n\tfor (i=1;i&lt;n+1;i++)\n\t{\n\t\tfor (j=1;j&lt;m+1;j++)\n\t\t{\n\t\t\tif (i-K&gt;=0 &amp;&amp; j-K&gt;=0)\n\t\t\t{\n\t\t\t\trect1[i][j] = sum1[i][j]-sum1[i][j-K]-sum1[i-K][j]+sum1[i-K][j-K];//left and above\n\t\t\t\trectA[i][j] = rect1[i][j];\n\t\t\t}\n\t\t\tif (i-K&gt;=0 &amp;&amp; j+K-1&lt;=m)\n\t\t\t\trect2[i][j] = sum2[i][j]-sum2[i][j+K]-sum2[i-K][j]+sum2[i-K][j+K];//right and above\n\t\t\tif (i+K-1&lt;=n &amp;&amp; j-K&gt;=0)\n\t\t\t{\n\t\t\t\trect3[i][j] = sum3[i][j]-sum3[i][j-K]-sum3[i+K][j]+sum3[i+K][j-K];//left and blow\n\t\t\t\trectB[i][j] = rect3[i][j];\n\t\t\t}\n\t\t\tif (i+K-1&lt;=n &amp;&amp; j+K-1&lt;=m)\n\t\t\t\trect4[i][j] = sum4[i][j]-sum4[i][j+K]-sum4[i+K][j]+sum4[i+K][j+K];//right and blow\n\t\t}\t\n\t}\t\n\tfor (i=1;i&lt;n+1;i++)\n\t{\n\t\tfor (j=1;j&lt;m+1;j++)\n\t\t{\n\t\t\trect1[i][j] = MAX(rect1[i][j],rect1[i-1][j]);\n\t\t\trect1[i][j] = MAX(rect1[i][j],rect1[i][j-1]);\n\t\t\t\n\t\t\trectA[i][j] = MAX(rectA[i][j],rectA[i][j-1]);\n\t\t\trectB[i][j] = MAX(rectB[i][j],rectB[i-1][j]);\n\t\t}\n\t}\n\tfor (i=1;i&lt;n+1;i++)\n\t{\n\t\tfor (j=m;j&gt;0;j--)\n\t\t{\n\t\t\trect2[i][j] = MAX(rect2[i][j],rect2[i-1][j]);\n\t\t\trect2[i][j] = MAX(rect2[i][j],rect2[i][j+1]);\n\t\t}\n\t}\n\tfor (i=n;i&gt;0;i--)\n\t{\n\t\tfor (j=1;j&lt;m+1;j++)\n\t\t{\n\t\t\trect3[i][j] = MAX(rect3[i][j],rect3[i+1][j]);\n\t\t\trect3[i][j] = MAX(rect3[i][j],rect3[i][j-1]);\n\t\t}\n\t}\n\tfor (i=n;i&gt;0;i--)\n\t{\n\t\tfor (j=m;j&gt;0;j--)\n\t\t{\n\t\t\trect4[i][j] = MAX(rect4[i][j],rect4[i+1][j]);\n\t\t\trect4[i][j] = MAX(rect4[i][j],rect4[i][j+1]);\n\t\t}\n\t}\n\tfor (i=1+K;i&lt;n-K+2;i++)\n\t{\n\t\tfor (j=1+K;j&lt;m-K+2;j++)\n\t\t{\n\t\t\tans = MAX(ans,rect1[i-1][j-1]+rect2[i-1][j]+rect4[i][1]);\n\t\t\tans = MAX(ans,rect3[i][j-1]+rect4[i][j]+rect2[i-1][1]);\n\t\t\tans = MAX(ans,rect1[i-1][j-1]+rect3[i][j-1]+rect4[1][j]);\n\t\t\tans = MAX(ans,rect2[i-1][j]+rect4[i][j]+rect3[1][j-1]);\n\t\t}\t\n\t}\t\n\tfor (i=1+K;i&lt;n-2*K+1;i++)\n\t{\n\t\tans = MAX(ans,rect2[i-1][1]+rect4[i+K][1]+rectA[i+K-1][m]);\n\t}\n\tfor (j=1+K;j&lt;m-2*K+1;j++)\n\t{\n\t\tans = MAX(ans,rect3[1][j-1]+rect4[1][j+K]+rectB[n][j+K-1]);\n\t}\n\tprintf("%ld",ans);\n\tsystem("pause");\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;cstdio&gt;\n#include &lt;cstdlib&gt;\n#include &lt;algorithm&gt;\n#include &lt;string&gt;\n#define max(a, b) ((a) &gt; (b) ? (a) : (b))\n#define max3(a, b, c) (max((a), max(b, c)))\n\nconst char fi[] = "oil.in";\nconst char fo[] = "oil.out";\nconst int maxN = 1510;\nconst int MAX = 0x3f3f3f3f;\nconst int MIN = ~MAX;\n\nint sum[maxN][maxN];\nint zoxx[maxN][maxN]; // Left and below.\nint zouh[maxN][maxN]; // Left and above.\nint yzxx[maxN][maxN]; // Right and below.\nint yzuh[maxN][maxN]; // Right and above.\nint hh[maxN]; // Horizon.\nint lp[maxN]; // Vertical.\nint n,m,K;\n\nvoid init_file()\n{\n\t\n\n\treturn;\n}\n\ninline int getint()\n{\n\tint res = 0; char tmp;\n\twhile(!isdigit(tmp = getchar()));\n\tdo res = (res &lt;&lt; 3) + (res &lt;&lt; 1) + tmp - '0';\n\twhile(isdigit(tmp = getchar()));\n\treturn res;\n}\n\nvoid readdata()\n{\n\tn = getint(); m = getint(); K = getint();\n\tfor(int i = 1; i &lt; n + 1; ++i)\n\t\tfor(int j = 1; j &lt; m + 1; ++j)\n\t\t\t(sum[i][j] = getint()) += sum[i][j - 1];\n\tfor(int i = 1; i &lt; n + 1; ++i)\n\t\tfor(int j = 1; j &lt; m + 1; ++j)\n\t\t\tsum[i][j] += sum[i - 1][j];\n\t//预处理出二维的前缀和。\n\tfor(int i = K; i &lt; n + 1; ++i)\n\t\tfor(int j = K; j &lt; m + 1; ++j)\n\t\t{\n\t\t\tzouh[i][j] = sum[i][j]\n\t\t\t\t+ sum[i - K][j - K]\n\t\t\t\t- sum[i][j - K]\n\t\t\t\t- sum[i - K][j];\n\t\t\thh[i] = max(hh[i],zouh[i][j]); //Horizon.\n\t\t\tlp[j] = max(lp[j],zouh[i][j]); //Vertical.\n\t\t\tzouh[i][j] = max3(zouh[i][j],\n\t\t\t\tzouh[i - 1][j],\n\t\t\t\tzouh[i][j - 1]);\n\t\t} // Left and above.\n\n\tfor(int i = n - K + 1; i; --i)\n\t\tfor(int j = m - K + 1; j; --j)\n\t\t\tyzxx[i][j] = max3(sum[i - 1][j - 1]\n\t\t\t+ sum[i + K - 1][j + K - 1]\n\t\t\t- sum[i - 1][j + K - 1]\n\t\t\t- sum[i + K - 1][j - 1],\n\t\t\tyzxx[i + 1][j],\n\t\t\tyzxx[i][j + 1]);\n\t//Right and below.\n\n\tfor(int i = K; i &lt; n + 1; ++i)\n\t\tfor(int j = m - K + 1; j; --j)\n\t\t\tyzuh[i][j] = max3(sum[i][j + K - 1]\n\t\t\t+ sum[i - K][j - 1]\n\t\t\t- sum[i][j - 1]\n\t\t\t- sum[i - K][j + K - 1],\n\t\t\tyzuh[i - 1][j],\n\t\t\tyzuh[i][j + 1]);\n\t//Right and above.\n\n\tfor(int i = n - K + 1; i; --i)\n\t\tfor(int j = K; j &lt; m + 1; ++j)\n\t\t\tzoxx[i][j] = max3(sum[i - 1][j - K]\n\t\t\t+ sum[i + K - 1][j]\n\t\t\t- sum[i - 1][j]\n\t\t\t- sum[i + K - 1][j - K],\n\t\t\tzoxx[i + 1][j],\n\t\t\tzoxx[i][j - 1]);\n\t//Left and below\n\n\treturn;\n}\n\nvoid work()\n{\n\tint ans = 0;\n\tfor(int i = K; i &lt; n - (K &lt;&lt; 1); ++i)\n\t\tans = max(ans,yzuh[i][1]\n\t\t+ hh[i + K]\n\t\t+ yzxx[i + K + 1][1]);\n\t// Case 1.\n\tfor(int j = K; j &lt; m - (K &lt;&lt; 1); ++j)\n\t\tans = max(ans,zoxx[1][j]\n\t\t+ lp[j + K]\n\t\t+ yzxx[1][j + K + 1]);\n\t// Case 2.\n\tfor(int i = K; i &lt; n - K + 1; ++i)\n\t\tfor(int j = K; j &lt; m - K + 1; ++j)\n\t\t{\n\t\t\tans = max3(ans,zouh[i][j]\n\t\t\t\t+ yzuh[i][j + 1]\n\t\t\t\t+ yzxx[i + 1][1], //Case 3.\n\t\t\t\tyzuh[i][1]\n\t\t\t\t+ zoxx[i + 1][j]\n\t\t\t\t+ yzxx[i + 1][j + 1]); //Case 4.\n\t\t\tans = max3(ans,zouh[i][j]\n\t\t\t\t+ zoxx[i + 1][j]\n\t\t\t\t+ yzxx[1][j + 1], //Case 5.\n\t\t\t\tzoxx[1][j]\n\t\t\t\t+ yzuh[i][j + 1]\n\t\t\t\t+ yzxx[i + 1][j + 1]); //Case 6.\n\t\t}\n\tprintf("%d\\n",ans);\n\treturn;\n}\n\nint main()\n{\n\tinit_file();\n\treaddata();\n\twork();\n\treturn 0;\n}\n\n#undef max\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tint[][] cl;\n\t\tint[][] cbcl, clqs, clqx, clhs, clhx;\n\t\tint m = 0, n = 0, k = 0, fin = 0;\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tString s = reader.readLine();\n\t\tString[] sa = s.split(" ");\n\t\tm = Integer.parseInt(sa[0]);\n\t\tn = Integer.parseInt(sa[1]);\n\t\tk = Integer.parseInt(sa[2]);\n\t\tcl = new int[m + 1][n + 1];\n\t\tcbcl = new int[m - k + 2][n - k + 2];\n\t\tclqs = new int[m - k + 2][n - k + 2];\n\t\tclqx = new int[m - k + 2][n - k + 2];\n\t\tclhs = new int[m - k + 2][n - k + 2];\n\t\tclhx = new int[m - k + 2][n - k + 2];\n\t\tfor (int i = 1; i &lt;= m; i++)\n\t\t\tcl[i][0] = 0;\n\t\tfor (int i = 1; i &lt;= n; i++)\n\t\t\tcl[0][i] = 0;\n\t\tfor (int i = 1; i &lt;= m; i++) {\n\t\t\ts = reader.readLine();\n\t\t\tsa = s.split(" ");\n\t\t\tfor (int j = 1; j &lt;= n; j++) {\n\t\t\t\tcl[i][j] = cl[i][j - 1] + Integer.parseInt(sa[j - 1]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i &lt;= m; i++) {\n\t\t\tfor (int j = 1; j &lt;= n; j++) {\n\t\t\t\tcl[i][j] = cl[i - 1][j] + cl[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = m - k + 1; i &gt;= 1; i--) {\n\t\t\tfor (int j = n - k + 1; j &gt;= 1; j--) {\n\t\t\t\tcbcl[i][j] = cl[i + k - 1][j + k - 1] - cl[i - 1][j + k - 1] - cl[i + k - 1][j - 1] + cl[i - 1][j - 1];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1, l = m - k + 1; i &lt;= l; i++) {\n\t\t\tfor (int j = 1, o = n - k + 1; j &lt;= o; j++) {\n\t\t\t\tint a = cbcl[i][j];\n\t\t\t\tif (cbcl[i][0] &lt; a) {\n\t\t\t\t\tcbcl[i][0] = a;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int j = 1, o = n - k + 1; j &lt;= o; j++) {\n\t\t\tfor (int i = 1, l = m - k + 1; i &lt;= l; i++) {\n\t\t\t\tint a = cbcl[i][j];\n\t\t\t\tif (cbcl[0][j] &lt; a) {\n\t\t\t\t\tcbcl[0][j] = a;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i &lt;= m - k + 1; i++) {\n\t\t\tfor (int j = 1; j &lt;= n - k + 1; j++) {\n\t\t\t\tif (j == 1)\n\t\t\t\t\tclqs[i][j] = cbcl[i][j];\n\t\t\t\telse\n\t\t\t\t\tclqs[i][j] = Math.max(cbcl[i][j], clqs[i][j - 1]);\n\t\t\t\tclqx[i][j] = clqs[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i &lt;= m - k + 1; i++) {\n\t\t\tfor (int j = n - k + 1; j &gt;= 1; j--) {\n\t\t\t\tif (j == n - k + 1) {\n\t\t\t\t\tclhs[i][j] = cbcl[i][j];\n\t\t\t\t\tclhx[i][j] = cbcl[i][j];\n\t\t\t\t} else {\n\t\t\t\t\tclhx[i][j] = Math.max(cbcl[i][j], clhx[i][j + 1]);\n\t\t\t\t\tclhs[i][j] = clhx[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int j = 1; j &lt;= n - k + 1; j++) {\n\t\t\tfor (int i = m - k; i &gt;= 1; i--) {\n\t\t\t\tclqx[i][j] = Math.max(clqx[i][j], clqx[i + 1][j]);\n\t\t\t\tclhx[i][j] = Math.max(clhx[i][j], clhx[i + 1][j]);\n\t\t\t}\n\t\t}\n\t\tfor (int j = 1; j &lt;= n - k + 1; j++) {\n\t\t\tfor (int i = 2; i &lt;= m - k + 1; i++) {\n\t\t\t\tclqs[i][j] = Math.max(clqs[i][j], clqs[i - 1][j]);\n\t\t\t\tclhs[i][j] = Math.max(clhs[i][j], clhs[i - 1][j]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i &lt;= m - 3 * k + 1; i++) {\n\t\t\tfor (int j = i + k; j &lt;= m - 2 * k + 1; j++) {\n\t\t\t\tfin = Math.max(fin, clhs[i][1] + cbcl[j][0] + clhx[j + k][1]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i &lt;= n - 3 * k + 1; i++) {\n\t\t\tfor (int j = i + k; j &lt;= n - 2 * k + 1; j++) {\n\t\t\t\tfin = Math.max(fin, clqs[1][i] + cbcl[0][j] + clhx[1][j + k]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1, l = m - 2 * k + 1; i &lt;= l; i++) {\n\t\t\tfor (int j = 1, o = n - 2 * k + 1; j &lt;= o; j++) {\n\t\t\t\tfin = Math.max(fin, clqs[i][n - k + 1] + clqx[i + k][j] + clhx[i + k][j + k]);\n\t\t\t\tfin = Math.max(fin, clqx[i + k][n - k + 1] + clqs[i][j] + clhs[i][j + k]);\n\t\t\t\tfin = Math.max(fin, clqx[1][j] + clhs[i][j + k] + clhx[i + k][j + k]);\n\t\t\t\tfin = Math.max(fin, clhx[1][j + k] + clqs[i][j] + clqx[i + k][j]);\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(fin);\n\t}\n\n}\r\n</textarea>	104
104	<div class="des"> \n <div class="pdcont">\n  　　会议中心　　Siruseri政府建造了一座新的会议中心。许多公司对租借会议中心的会堂很感兴趣，他们希望能够在里面举行会议。\n  <br> 　　对于一个客户而言，仅当在开会时能够独自占用整个会堂，他才会租借会堂。会议中心的销售主管认为：最好的策略应该是将会堂租借给尽可能多的客户。显然，有可能存在不止一种满足要求的策略。\n  <br> 　　例如下面的例子。总共有4个公司。他们对租借会堂发出了请求，并提出了他们所需占用会堂的起止日期（如下表所示）。\n  <br> \n  <br> \n  <table cellspacing="0" cellpadding="2px" style="border-collapse:collapse;" class="table table-striped table-horver">\n   <tbody>\n    <tr style="border:solid 1.0pt">\n     <td valign="top" style="border:solid 1.0pt"><br> </td>\n     <td valign="top" style="border:solid 1.0pt">开始日期<br> </td>\n     <td valign="top" style="border:solid 1.0pt">结束日期<br> </td>\n    </tr>\n    <tr style="border:solid 1.0pt">\n     <td valign="top" style="border:solid 1.0pt">公司1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">4<br> </td>\n     <td valign="top" style="border:solid 1.0pt">9<br> </td>\n    </tr>\n    <tr style="border:solid 1.0pt">\n     <td valign="top" style="border:solid 1.0pt">公司2<br> </td>\n     <td valign="top" style="border:solid 1.0pt">9<br> </td>\n     <td valign="top" style="border:solid 1.0pt">11<br> </td>\n    </tr>\n    <tr style="border:solid 1.0pt">\n     <td valign="top" style="border:solid 1.0pt">公司3<br> </td>\n     <td valign="top" style="border:solid 1.0pt">13<br> </td>\n     <td valign="top" style="border:solid 1.0pt">19<br> </td>\n    </tr>\n    <tr style="border:solid 1.0pt">\n     <td valign="top" style="border:solid 1.0pt">公司4<br> </td>\n     <td valign="top" style="border:solid 1.0pt">10<br> </td>\n     <td valign="top" style="border:solid 1.0pt">17<br> </td>\n    </tr>\n   </tbody>\n  </table>\n  <br> \n  <br> 　　上例中，最多将会堂租借给两家公司。租借策略分别是租给公司1和公司3，或是公司2和公司3，也可以是公司1和公司4。注意会议中心一天最多租借给一个公司，所以公司1和公司2不能同时租借会议中心，因为他们在第九天重合了。\n  <br> 　　销售主管为了公平起见，决定按照如下的程序来确定选择何种租借策略：首先，将租借给客户数量最多的策略作为候选，将所有的公司按照他们发出请求的顺序编号。对于候选策略，将策略中的每家公司的编号按升序排列。最后，选出其中字典序最小[1]的候选策略作为最终的策略。\n  <br> 　　例中，会堂最终将被租借给公司1和公司3：3个候选策略是{(1,3),(2,3),(1,4)}。而在字典序中(1,3)&lt;(1,4)&lt;(2,3)。\n  <br> 　　你的任务是帮助销售主管确定应该将会堂租借给哪些公司。\n  <b></b>\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入的第一行有一个整数\n  <i>N</i>，表示发出租借会堂申请的公司的个数。第2到第\n  <i>N</i>+1行每行有2个整数。第\n  <i>i</i>+1行的整数表示第\n  <i>i</i>家公司申请租借的起始和终止日期。对于每个公司的申请，起始日期为不小于1的整数，终止日期为不大于10\n  <sup>9</sup>的整数。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出的第一行应有一个整数\n  <i>M</i>，表示最多可以租借给多少家公司。第二行应列出\n  <i>M</i>个数，表示最终将会堂租借给哪些公司。\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　对于50%的输入，\n  <i>N</i>≤3000。在所有输入中，\n  <i>N</i>≤200000。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  4\n  <br> 4 9\n  <br> 9 11\n  <br> 13 19\n  <br> 10 17\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  2\n  <br> 1 3\n  <br> \n  <br> [1] 字典序指在字典中排列的顺序，如果序列\n  <i>l</i>\n  <sub>1</sub>是序列\n  <i>l</i>\n  <sub>2</sub>的前缀，或者对于\n  <i>l</i>\n  <sub>1</sub>和\n  <i>l</i>\n  <sub>2</sub>的第一个不同位置\n  <i>j</i>，\n  <i>l</i>\n  <sub>1</sub>[\n  <i>j</i>]&lt;\n  <i>l</i>\n  <sub>2</sub>[\n  <i>j</i>]，则\n  <i>l</i>\n  <sub>1</sub>比\n  <i>l</i>\n  <sub>2</sub>小。\n </div> \n</div>	<textarea id="codelinesc">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;cstdio&gt;\n#include &lt;cstdlib&gt;\n#include &lt;algorithm&gt;\n#include &lt;string&gt;\n#include &lt;set&gt;\n\nconst char fi[] = "convention.in";\nconst char fo[] = "convention.out";\nconst int maxN = 200010;\nconst int MAX = 0x3f3f3f3f,MIN = ~MAX;\n\nstruct Seg\n{\n\tint L,R;\n\tSeg()\n\t{\n\t}\n\tSeg(int L,int R): L(L),R(R)\n\t{\n\t}\n\tbool operator&lt;(const Seg &amp;b) const\n\t{\n\t\treturn L &lt; b.L || L == b.L &amp;&amp; R &lt; b.R;\n\t}\n};\nstd::set &lt;Seg&gt; S;\nstd::set &lt;Seg&gt;::iterator iter;\nSeg req[maxN],seg[maxN],tmp[maxN];\nint tab[maxN &lt;&lt; 1],next[20][maxN &lt;&lt; 1];\nint n,cnt,Lim = 1,logLim;\n\nvoid init_file()\n{\n\treturn;\n}\n\ninline int getint()\n{\n\tint res = 0; char tmp;\n\twhile(!isdigit(tmp = getchar()));\n\tdo res = (res &lt;&lt; 3) + (res &lt;&lt; 1) + tmp - '0';\n\twhile(isdigit(tmp = getchar()));\n\treturn res;\n}\n\nvoid readdata()\n{\n\tn = getint();\n\tfor(int i = 0; i &lt; n; ++i)\n\t{\n\t\tint L = getint(),R = getint();\n\t\treq[i] = Seg(L,R);\n\t\ttab[i &lt;&lt; 1] = L;\n\t\ttab[(i &lt;&lt; 1) + 1] = R;\n\t}\n\treturn;\n}\n\nint plc(int x)\n{\n\tfor(int L = 0,R = Lim - 1; L &lt; R + 1;)\n\t{\n\t\tint Mid = (L + R) &gt;&gt; 1;\n\t\tif(x == tab[Mid]) return Mid + 1;\n\t\tif(x &lt; tab[Mid]) R = Mid - 1;\n\t\telse L = Mid + 1;\n\t}\n}\n\nbool cmp(const Seg &amp;a,const Seg &amp;b)\n{\n\treturn a.R &lt; b.R || a.R == b.R &amp;&amp; a.L &gt; b.L;\n}\n\nvoid discrete()\n{\n\tstd::sort(tab,tab + (n &lt;&lt; 1));\n\tfor(int i = 1; i &lt; n &lt;&lt; 1; ++i)\n\t\tif(tab[i] != tab[i - 1])\n\t\t\ttab[Lim++] = tab[i];\n\tfor(int i = 0; i &lt; n; ++i)\n\t\ttmp[i] = req[i] = Seg(plc(req[i].L),\n\t\tplc(req[i].R));\n\tstd::sort(tmp,tmp + n,cmp);\n\t//这里必须要用一个临时数组，\n\t//保证左界右界同时单调递增。\n\tint p = 0; seg[cnt++] = tmp[0];\n\tfor(int i = 1; i &lt; n; ++i)\n\t\tif(tmp[i].L &gt; tmp[p].L)\n\t\t\tseg[cnt++] = tmp[p = i];\n\treturn;\n}\n\nvoid next_set()\n{\n\tint p = cnt; next[0][Lim + 1] = MAX;\n\tfor(int j = Lim; j; --j)\n\t\tif(p &gt; -1 &amp;&amp; j == seg[p - 1].L)\n\t\t\tnext[0][j] = seg[--p].R + 1;\n\t\telse next[0][j] = next[0][j + 1];\n\t\tfor(int i = 0;; ++i)\n\t\t{\n\t\t\tbool flag = 0;\n\t\t\tnext[i + 1][Lim + 1] = MAX;\n\t\t\tfor(int k = 1; k &lt; Lim + 1; ++k)\n\t\t\t{\n\t\t\t\tif(next[i][k] == MAX)\n\t\t\t\t\tnext[i + 1][k] = MAX;\n\t\t\t\telse next[i + 1][k] = next[i][next[i][k]];\n\t\t\t\tif(next[i + 1][k] &lt; MAX) flag = 1;\n\t\t\t}\n\t\t\tif(!flag)\n\t\t\t{\n\t\t\t\tlogLim = i; break;\n\t\t\t}\n\t\t}\n\t\treturn;\n}\n\nint max_time(int L,int R)\n{\n\tif(L &gt; R++) return 0;\n\tint ans = 0,p = L;\n\tfor(int i = logLim; i &gt; -1 &amp;&amp; p &lt; R; --i)\n\t\tif(next[i][p] &lt;= R)\n\t\t{\n\t\t\tp = next[i][p]; ans += 1 &lt;&lt; i;\n\t\t}\n\treturn ans;\n}\n\nbool query(int i)\n{\n\tint L = req[i].L,R = req[i].R;\n\titer = S.lower_bound(Seg(L,MAX));\n\tif(iter-- == S.begin()) return 0;\n\tif(iter-&gt;L &gt; L || iter-&gt;R &lt; R)\n\t\treturn 0;\n\tint L1 = iter-&gt;L,R1 = iter-&gt;R;\n\tif(max_time(L1,L - 1)\n\t\t+ max_time(R + 1,R1)\n\t\t+ 1 &lt; max_time(L1,R1))\n\t\t//这里要满足放进去过后不影响总的答案。\n\t\treturn 0;\n\tS.erase(iter);\n\tif(L1 &lt; L) S.insert(Seg(L1,L - 1));\n\tif(R &lt; R1) S.insert(Seg(R + 1,R1));\n\treturn 1;\n}\n\nvoid work()\n{\n\tprintf("%d\\n",max_time(1,Lim));\n\tS.insert(Seg(1,Lim));\n\tfor(int i = 0; i &lt; n; ++i)\n\t\tif(query(i))\n\t\t\tprintf("%d ",i + 1);\n\tprintf("\\n");\n\treturn;\n}\n\nint main()\n{\n\tinit_file();\n\treaddata();\n\tdiscrete();\n\tnext_set();\n\twork();\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\npublic class Main{\n\tstatic int[] sqqs,sqzz,sqsx,sqcf,cxz,finz;\n\tstatic int[][] dgb;\n\tstatic int n=0,fin=0,max=0;\n\tpublic static void main(String[] args)throws IOException {  \n\t\tBufferedReader reader=new BufferedReader(new InputStreamReader(System.in));\n\t    String s=reader.readLine();\n\t    n=Integer.parseInt(s);\n        sqqs=new int[n+1];\n        sqzz=new int[n+1];\n        sqcf=new int[n+1];\n\tfor(int i=1;i&lt;=n;i++){\n\t\ts=reader.readLine();\n\t    String[] sa = s.split(" ");\n\t    sqqs[i]=Integer.parseInt(sa[0]);\n\t    sqzz[i]=Integer.parseInt(sa[1]);\n\t    if (max&lt;sqzz[i]) max=sqzz[i];\n\t}\n\tsqsx=new int[max+1];\n\tfor (int i=1;i&lt;=n;i++){\n\t\tif (sqsx[sqzz[i]]==0){\n\t    \tsqsx[sqzz[i]]=i;\n\t    }else{\n\t    \tif (sqqs[i]&gt;sqqs[sqsx[sqzz[i]]]){    \n\t    \t     for (int j=1;j&lt;=n;j++){\n\t    \t \t     if (sqcf[j]==0){\n\t    \t\t\t\t  sqcf[j]=sqsx[sqzz[i]];\n\t    \t\t\t\t  sqsx[sqzz[i]]=i;\n\t    \t \t    \t  break;\n\t    \t\t     }\n\t    \t     }\n\t    \t}\n\t    }\n\t}\n\tdgb=new int[2][n+1];\n\tfor (int i=1;i&lt;=max;i++) {\n\t\tif (sqsx[i]!=0) {\n\t\t\tgetcs(sqsx[i]);\n\t\t}\n\t}\n\tfor (int i=1;i&lt;=n;i++){\n\t\tif (fin&lt;dgb[0][i]) fin=dgb[0][i];\n\t}\n\tfor (int k=max;k&gt;=1;k--){\n\t\tif (sqsx[k]==0) continue;\n\t\tint i=sqsx[k];\n\t\tif (dgb[0][i]==fin) continue;\n\t\tfor (int j=sqzz[i]+1;j&lt;=max;j++){\n\t\t\tif (j==max){\n\t\t\t    dgb[0][i]=0;\n\t\t\t    dgb[1][i]=0;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (sqsx[j]==0) continue;\n\t\t\tif (dgb[0][sqsx[j]]==0) continue;\n\t\t\tif ((dgb[0][sqsx[j]]==dgb[0][i]+1)&amp;(sqqs[sqsx[j]]&gt;sqzz[i])) break;\n\t\t\tif (dgb[0][sqsx[j]]&gt;dgb[0][i]+1) {\n\t\t\t\tdgb[0][i]=0;\n\t\t\t\tdgb[1][i]=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tfor (int i=1;i&lt;=n;i++) {\n\t\tif (sqcf[i]!=0) {\n\t\t\tgetcs1(sqcf[i]);\n\t\t} else break;\n\t}\n\t\n\tcxz=new int[fin+1];\n\tfinz=new int[fin+1];\n\tint xh=1;\n\tfor (int i=1;i&lt;=n;i++){\n\t\tif (dgb[0][i]==0) continue;\n\t\tif (cxz[dgb[0][i]]!=0) continue;\n\t\tif (fincheck(i)==1){\n\t\t  \tfinz[xh]=i;\n\t\t\txh++;\n\t\t\tcxz[dgb[0][i]]=i;\n\t\t\tdealsq(i);\n\t\t}\n\t}\n    System.out.println(fin);\n   \n    for (int i=1;i&lt;=fin;i++){\n    \tSystem.out.print(""+finz[i]+" ");\n    }\n   System.out.println();\n\t}\nstatic void getcs(int a){\n\tint cs=0;\n\tfor (int i=sqqs[a]-1;i&gt;0;i--){\n\t\tif (sqsx[i]!=0){\n\t\t\tcs=dgb[0][sqsx[i]];\n\t\t\tif (cs!=0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=sqqs[a];i&lt;sqzz[a];i++){\n\t\tif (sqsx[i]!=0){\n\t\t\tif (dgb[0][sqsx[i]]&gt;cs+1) return;\n\t\t}\n\t}\n\tdgb[0][a]=cs+1;\n\tdgb[1][a]=1;\n}\nstatic void getcs1(int a){\n\tint cs=0;\n\tint b=dgb[0][sqsx[sqzz[a]]];\n\tif (b==0) return;\n\tfor (int i=sqqs[a]-1;i&gt;0;i--){\n\t\tif (sqsx[i]!=0){\n\t\t\tcs=dgb[0][sqsx[i]];\n\t\t\tif (cs!=0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (cs+1&lt;b) return;\n\tdgb[0][a]=cs+1;\n\tdgb[1][a]=1;\n}\nstatic int fincheck(int a){\n\tint[] lsst=new int[fin+1];\n\tint b=0,c=0,sc=0,ec=0;\n\tint cs=dgb[0][a];\n\tfor (int i=cs-1;i&gt;=1;i--){\n\t\tif (cxz[i]!=0) {\n\t\t\tb=cxz[i];\n\t\t\tsc=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (b!=0){\n\t\tlsst[sc]=sqzz[b];\n\t\tfor (int i=sqzz[b]+1;i&lt;sqqs[a];i++){\n\t\t\tif (sqsx[i]==0) continue;\n\t\t\tif (dgb[0][sqsx[i]]==0) continue;\n\t\t\tif (lsst[dgb[0][sqsx[i]]]!=0) continue;\n\t\t\tif (sqqs[sqsx[i]]&lt;=lsst[dgb[0][sqsx[i]]-1]) continue;\n\t\t\tlsst[dgb[0][sqsx[i]]]=sqzz[sqsx[i]];\n\t\t}\n\t\tif (lsst[cs-1]==0) return 0;\n\t\tif (lsst[cs-1]&gt;=sqqs[a]) return 0;\n\t}\n\tfor (int i=cs+1;i&lt;=fin;i++){\n\t\tif (cxz[i]!=0){\n\t\t\tc=cxz[i];\n\t\t\tec=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (c!=0){\n\t\tlsst[ec]=sqqs[c];\n\t\tfor (int i=sqqs[c]-1;i&gt;sqzz[a];i--){\n\t\t\tif (sqsx[i]==0) continue;\n\t\t\tif (dgb[0][sqsx[i]]==0) continue;\n\t\t\tif (i&gt;=lsst[dgb[0][sqsx[i]]+1]) continue;\n\t\t\tlsst[dgb[0][sqsx[i]]]=Math.max(sqqs[sqsx[i]],lsst[dgb[0][sqsx[i]]]);\n\t\t}\n\t\tif (lsst[cs+1]==0) return 0;\n\t\tif (lsst[cs+1]&lt;=sqzz[a]) return 0;\n\t}\n\treturn 1;\n}\nstatic void dealsq(int a){\n\tint cs=dgb[0][a];\n\tfor (int i=sqzz[a]-1;i&gt;=1;i--){\n\t\tif (sqsx[i]==0) continue;\n\t\tif (dgb[0][sqsx[i]]==0) continue;\n\t\tint dcs=dgb[0][sqsx[i]];\n\t\tif (dcs==cs) {\n\t\t\tdgb[0][sqsx[i]]=0;\n\t\t\tdgb[1][sqsx[i]]=0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (dcs==cs-1) {\n\t\t\tif (i&gt;=sqqs[a]) {\n\t\t\t\tdgb[0][sqsx[i]]=0;\n\t\t\t\tdgb[1][sqsx[i]]=0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (dcs==cs-2) break;\n\t}\n\tfor (int i=sqzz[a]+1;i&lt;=max;i++){\n\t\tif (sqsx[i]==0) continue;\n\t\tif (dgb[0][sqsx[i]]==0) continue;\n\t\tint dcs=dgb[0][sqsx[i]];\n\t\tif (dcs==cs) {\n\t\t\tdgb[0][sqsx[i]]=0;\n\t\t\tdgb[1][sqsx[i]]=0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (dcs==cs+1) {\n\t\t\tif (sqzz[a]&gt;=sqqs[sqsx[i]]) {\n\t\t\t\tdgb[0][sqsx[i]]=0;\n\t\t\t\tdgb[1][sqsx[i]]=0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (dcs==cs+2) break;\n\t}\n}\n}\r\n</textarea>	105
105	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　这题想得分吗？想，请输出“yes”；不想，请输出“no”。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出包括一行，为“yes”或“no”。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;stdio.h&gt;\nint main()\n{\n   printf("yes\\n");\n   return 0;\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nusing namespace std;\n\nint main()\n{\n    printf("yes\\n");\n    return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println("yes");\n\t}\n\n}\n\r\n</textarea>	106
106	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　输入一个实数x，求最小的n使得，1/2+1/3+1/4+...+1/(n+1)&gt;=x。\n  <br> \n  <br> 　　输入的实数x保证大于等于0.01，小于等于5.20，并且恰好有两位小数。你的程序要能够处理多组数据，即不停地读入x，如果x不等于0.00，则计算答案，否则退出程序。\n  <br> \n  <br> 　　输出格式为对于一个x，输出一行n card(s)。其中n表示要计算的答案。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　分行输入x的具体数值\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　分行输出n的数值，格式为n card(s)\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <pre class="pddata">\n1.00\n3.71\n0.04\n5.19\n0.00</pre> \n <p></p> \n <br>\n <p></p>\n <p class="subtitle">样例输出</p>\n <p class="probcontent"> </p>\n <p><font face="Times New Roman" size="3"></font></p>\n <pre><font face="Times New Roman" size="3">3 card(s)\n61 card(s)\n1 card(s)\n273 card(s)</font></pre> \n <p></p> \n <br>  \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\r\n\r\nint main(void)\r\n{\r\n\tint i;\r\n\tdouble n,k,s;\r\n\tscanf("%lf",&amp;n);\r\n\twhile(n!=0)\r\n\t{\r\n\t\ts=0;\r\n\t\tfor(i=2;1;i++)\r\n\t\t{\r\n\t\t\tk=1.0/i;\r\n\t\t\ts+=k;\r\n\t\t\tif(s&gt;=n)\r\n\t\t\t{\r\n\t\t\t\tprintf("%d card(s)\\n",i-1);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tscanf("%lf",&amp;n);\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include "iostream"\n#include "string"\n#include "stdio.h"\n#include "ctype.h"\n#include "algorithm"\n#include "stack"\n#include "math.h"\nusing namespace std;\nconst  int N =101;\ndouble  fen(int i)\n{\n\treturn 1.0/i;\n}\nint main()\n{\n     double x;\n\t while(cin&gt;&gt;x,  x!=0.00)\n\t {\n\t\t double ans=0;\n\t\t for(int i=2;;i++)\n\t\t {\n\t\t\t ans+=fen(i);\n\t\t\t if(ans&gt;=x)\n\t\t\t {\n\t\t\t\t cout&lt;&lt;i-1&lt;&lt;" "&lt;&lt;"card(s)"&lt;&lt;endl;\n\t\t\t\t break;\n\t\t\t }\n\t\t }\n\t }\n\t return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(new BufferedReader(new InputStreamReader(\n\t\t\t\tSystem.in)));\n\n\t\twhile (true) {\n\t\t\tdouble n = sc.nextDouble();\n\t\t\tif (n == 0.00)\n\t\t\t\tbreak;\n\t\t\tdouble sum = 0.00;\n\t\t\tfor (int i = 2;; i++) {\n\t\t\t\tsum += 1.00 / i;\n\t\t\t\tif (sum &gt;= n) {\n\t\t\t\t\tSystem.out.println((i - 1) + " card(s)");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsc.close();\n\t}\n}\r\n</textarea>	107
107	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　如果将课本上的Hanoi塔问题稍做修改：仍然是给定N只盘子，3根柱子，但是允许每次最多移动相邻的M只盘子（当然移动盘子的数目也可以小于M）,最少需要多少次？\n  <br> 　　例如N=5，M=2时，可以分别将最小的2个盘子、中间的2个盘子以及最大的一个盘子分别看作一个整体，这样可以转变为N=3，M=1的情况，共需要移动7次。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入数据仅有一行，包括两个数N和M（0&lt;=M&lt;=N&lt;=8）\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　仅输出一个数，表示需要移动的最少次数\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <pre class="pddata">\n5 2</pre> \n <p></p> \n <br>\n <p></p>\n <p class="subtitle">样例输出</p>\n <p class="probcontent"> </p>\n <p><font face="Times New Roman" size="3"></font></p>\n <pre><font face="Times New Roman" size="3">7</font></pre> \n <p></p> \n <br>  \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n\nint main()\n{\n\tint N,M;\n\tscanf("%d%d",&amp;N,&amp;M);\n\tN=(N+1)/M;\n\tprintf("%d",(1&lt;&lt;N)-1);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\r\n#include &lt;cmath&gt;\r\nusing namespace std;\r\nint main()\r\n{\r\n    int n,m;\r\n    cin&gt;&gt;n&gt;&gt;m;\r\n    if(n%m==0)\r\n    \tn/=m;\r\n    else n=n/m+1;\r\n    cout&lt;&lt;pow(2,n)-1;\r\n    return 0;\r\n}\r\n\r\n</textarea>	<textarea id="codelinesjava">\r\n    import java.util.*;\n    public class Main{\n          public static void main(String args[]){\n              Scanner sc=new Scanner(System.in);\n               int n=sc.nextInt();\n               int m=sc.nextInt();\n               int k=0;\n                if(n%m==0)\n                    k=n/m;\n                 else\n                k=(n+1)/m;\n               int count=1;\n               for(int i=0;i&lt;k;i++)\n                   count*=2;\n               System.out.println(count-1);\n                     }\n                }\r\n</textarea>	108
108	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　“两只小蜜蜂呀，飞在花丛中呀……”\n  <br> \n  <br> 　　话说这天天上飞舞着两只蜜蜂，它们在跳一种奇怪的舞蹈。用一个空间直角坐标系来描述这个世界，那么这两只蜜蜂初始坐标分别为(x1,y1,z1)，(x2,y2,z2)　　。在接下来它们将进行n次飞行，第i次飞行两只蜜蜂分别按照各自的速度向量飞行ti个单位时间。对于这一现象，玮玮已经观察了很久。他很想知道在蜜蜂飞舞结束时，两只蜜蜂的距离是多少。现在他就求教于你，请你写一个程序来帮他计算这个结果。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行有且仅有一个整数n，表示两只蜜蜂将进行n次飞行。\n  <br> \n  <br> 　　接下来有n行。\n  <br> \n  <br> 　　第i行有7个用空格分隔开的整数ai,bi,ci,di,ei,fi,ti　　，表示第一只蜜蜂单位时间的速度向量为(ai,bi,ci) ，第二只蜜蜂单位时间的速度向量为(di,ei,fi) ，它们飞行的时间为ti 。\n  <br> \n  <br> 　　最后一行有6个用空格分隔开的整数x1,y1,z1,x2,y2,z2，如题所示表示两只蜜蜂的初始坐标。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出仅包含一行，表示最后两只蜜蜂之间的距离。保留4位小数位。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <pre class="pddata">\nSample 1\n1\n1 1 1 1 -1 1 2\n3 0 1 2 0 0\nSample 2\n3\n1 1 1 1 -1 1 2\n2 1 2 0 -1 -1 2\n2 0 0 -1 1 1 3\n3 0 1 2 0 0\n</pre> \n <p></p> \n <br>\n <p></p>\n <p class="subtitle">样例输出</p>\n <p class="probcontent"> </p>\n <p><font face="Times New Roman" size="3"></font></p>\n <pre><font face="Times New Roman" size="3">Sample 1\n4.2426\nSample 2\n15.3948</font></pre> \n <p></p> \n <br>  \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nint main()\n{\n\tint n;\n\tdouble x1=0,y1=0,z1=0,x2=0,y2=0,z2=0;\n\tint ai,bi,ci,di,ei,fi,ti;\n\tint i;\n\tscanf("%d",&amp;n);\n\tfor(i=0;i&lt;n;i++)\n\t{\n\t    scanf("%d%d%d%d%d%d%d",&amp;ai,&amp;bi,&amp;ci,&amp;di,&amp;ei,&amp;fi,&amp;ti);\n\t    x1+=ai*ti;\n\t    y1+=bi*ti;\n\t    z1+=ci*ti;\n\t    x2+=di*ti;\n\t    y2+=ei*ti;\n\t    z2+=fi*ti;\n\t}\n\tscanf("%d%d%d%d%d%d",&amp;ai,&amp;bi,&amp;ci,&amp;di,&amp;ei,&amp;fi);\n\tx1+=ai;\n\ty1+=bi;\n\tz1+=ci;\n\tx2+=di;\n\ty2+=ei;\n\tz2+=fi; \n\tprintf("%.4lf",sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)+(z1-z2)*(z1-z2)));\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;cstdio&gt;\n#include&lt;cmath&gt;\nusing namespace std;\n\nint main(){\n\tint x1=0,y1=0,z1=0,x2=0,y2=0,z2=0;\n\tint a1,b1,c1,a2,b2,c2;\n\tint t;\n\tint n;\n\tdouble s;\n\tscanf("%d",&amp;n);\n\tfor(int i=0;i&lt;n;i++){\n\t\tscanf("%d%d%d%d%d%d%d",&amp;a1,&amp;b1,&amp;c1,&amp;a2,&amp;b2,&amp;c2,&amp;t);\n\t\tx1+=a1*t;\n\t\tx2+=a2*t;\n\t\ty1+=b1*t;\n\t\ty2+=b2*t;\n\t\tz1+=c1*t;\n\t\tz2+=c2*t;\n\t}\n\tscanf("%d%d%d%d%d%d",&amp;a1,&amp;b1,&amp;c1,&amp;a2,&amp;b2,&amp;c2);\n\tx1+=a1;\n\tx2+=a2;\n\ty1+=b1;\n\ty2+=b2;\n\tz1+=c1;\n\tz2+=c2;\n\ts=sqrt((double)(abs(x2-x1)*abs(x2-x1)+abs(y2-y1)*abs(y2-y1)+abs(z2-z1)*abs(z2-z1)));\n\tprintf("%.4lf\\n",s);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint x1 = 0, y1 = 0, z1 = 0;\n\t\tint x2 = 0, y2 = 0, z2 = 0;\n\n\t\tfor (; n &gt; 0; --n) {\n\t\t\tint a1 = sc.nextInt(), b1 = sc.nextInt(), c1 = sc.nextInt();\n\t\t\tint a2 = sc.nextInt(), b2 = sc.nextInt(), c2 = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\n\t\t\tx1 += a1 * t;\n\t\t\ty1 += b1 * t;\n\t\t\tz1 += c1 * t;\n\t\t\tx2 += a2 * t;\n\t\t\ty2 += b2 * t;\n\t\t\tz2 += c2 * t;\n\t\t}\n\n\t\tx1 += sc.nextInt();\n\t\ty1 += sc.nextInt();\n\t\tz1 += sc.nextInt();\n\t\tx2 += sc.nextInt();\n\t\ty2 += sc.nextInt();\n\t\tz2 += sc.nextInt();\n\t\tx1 -= x2;\n\t\ty1 -= y2;\n\t\tz1 -= z2;\n\n\t\tSystem.out.printf("%.4f", Math.sqrt(x1 * x1 + y1 * y1 + z1 * z1));\n\t}\n}\r\n</textarea>	109
109	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　有一个n个结点m条边的有向图，请输出他的关联矩阵。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行两个整数n、m，表示图中结点和边的数目。n&lt;=100,m&lt;=1000。\n  <br> 　　接下来m行，每行两个整数a、b，表示图中有(a,b)边。\n  <br> 　　注意图中可能含有重边，但不会有自环。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出该图的关联矩阵，注意请勿改变边和结点的顺序。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5 9\n  <br> 1 2\n  <br> 3 1\n  <br> 1 5\n  <br> 2 5\n  <br> 2 3\n  <br> 2 3\n  <br> 3 2\n  <br> 4 3\n  <br> 5 4\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  1 -1 1 0 0 0 0 0 0\n  <br> -1 0 0 1 1 1 -1 0 0\n  <br> 0 1 0 0 -1 -1 1 -1 0\n  <br> 0 0 0 0 0 0 0 1 -1\n  <br> 0 0 -1 -1 0 0 0 0 1\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n\tint i, ii,n,m, a[1000][2];\n\tscanf("%d%d", &amp;n, &amp;m);\n\n\tfor (  i = 0; i &lt; m; i++)\n\tscanf("%d%d", &amp;a[i][0], &amp;a[i][1]);\n\n\n\tfor ( i = 1; i &lt;=n; i++)\n\t{\n\t\tfor (ii = 0; ii &lt; m; ii++)\n\t\t{\n\t\t\tif (i==a[ii][0])\n\t\t\t{\n\t\t\t\tprintf("1 ");\n\t\t\t}\n\t\t\telse\n\t\t\tif (i==a[ii][1])\n\t\t\t{\n\t\t\t\tprintf("-1 ");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf("0 ");\n\t\t\t}\n\n\t\t}\n\t\tprintf("\\n");\n\t}\n\t\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;cstdio&gt;\n\nstruct group\n{\n\tint first;\n\tint second;\n};\n\nint main()\n{\n\tint n,m,i,j;\n\tscanf("%d%d",&amp;n,&amp;m);\n\tstruct group g[m];\n\tfor(i=1;i&lt;=m;i++)\n\t{\n\t\tscanf("%d%d",&amp;g[i].first,&amp;g[i].second);\n\t}\n//\tfor(i=1;i&lt;=m;i++)\n//\t{\n//\t\tprintf("(%d  %d)\\n",g[i].first,g[i].second);\n//\t}\n\tfor(i=1;i&lt;=n;i++)\n\t{\n\t\tfor(j=1;j&lt;=m;j++)\n\t\t{\n\t\t\tif(g[j].first==i)\n\t\t\t\tprintf("1 ");\n\t\t\telse if(g[j].second==i)\n\t\t\t\tprintf("-1 ");\n\t\t\telse\n\t\t\t\tprintf("0 ");\n\t\t}\n\t\tprintf("\\n");\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic void method1() throws NumberFormatException, IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString first = br.readLine();\n\t\tString[] nm = first.split(" ");\n\t\tint n = Integer.parseInt(nm[0].trim());\n\t\tint m = Integer.parseInt(nm[1].trim());\n\t\tint a[][] = new int[n][m];\n\t\tfor (int i = 0; i &lt; m; i++) {\n\t\t\tString second = br.readLine();\n\t\t\tString[] pq = second.split(" ");\n\t\t\tint p = Integer.parseInt(pq[0].trim());\n\t\t\tint q = Integer.parseInt(pq[1].trim());\n\t\t\ta[p-1][i] = 1;\n\t\t\ta[q-1][i] = -1;\n\t\t}//end for\n\t\tfor (int i = 0; i &lt; n; i++) {\n\t\t\tfor (int j = 0; j &lt; m; j++) {\n\t\t\t\tSystem.out.print(a[i][j]+" ");\n\t\t\t}\n\t\t\tif (i!=n-1) {\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] argStrings) throws IOException {\n\t\tMain main = new Main();\n\t\tmain.method1();\n\t}\n}\r\n</textarea>	110
114	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　栋栋正在和同学们玩一个数字游戏。\n  <br> \n  <br> 　　游戏的规则是这样的：栋栋和同学们一共n个人围坐在一圈。栋栋首先说出数字1。接下来，坐在栋栋左手边的同学要说下一个数字2。再下面的一个同学要从上一个同学说的数字往下数两个数说出来，也就是说4。下一个同学要往下数三个数，说7。依次类推。\n  <br> \n  <br> 　　为了使数字不至于太大，栋栋和同学们约定，当在心中数到 k-1 时，下一个数字从0开始数。例如，当k=13时，栋栋和同学们报出的前几个数依次为：\n  <br> 　　1, 2, 4, 7, 11, 3, 9, 3, 11, 7。\n  <br> \n  <br> 　　游戏进行了一会儿，栋栋想知道，到目前为止，他所有说出的数字的总和是多少。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入的第一行包含三个整数 n,k,T，其中 n 和 k 的意义如上面所述，T 表示到目前为止栋栋一共说出的数字个数。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出一行，包含一个整数，表示栋栋说出所有数的和。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3 13 3\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  17\n </div>\n <div class="pdsec">\n  样例说明\n </div>\n <div class="pdcont">\n  　　栋栋说出的数依次为1, 7, 9，和为17。\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　1 &lt; n,k,T &lt; 1,000,000；\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;/*\n#include &lt;windows.h&gt;3 9*/\nint s[1000000];\n// 3  13  9 \n//  1 2 4 7 11 3 9 3 11 7 4 2 1    1 2 4 7 11 3 9 3 11 7 4 2 1 \nint main()\n{\n__int64 n,k,t,i,j=1,g=1,z,sum=0;\nscanf("%I64d%I64d%I64d",&amp;n,&amp;k,&amp;t);\nif(k%2==0) z=k*2;\nelse z=k;\ns[0]=1;\ndo    //开始制表 \n{\nj+=g;\nif(j&gt;=k) j%=k; \ns[g]=j;\ng++;     \n}                         \nwhile(g&lt;=z) ; \nk=0;      \nfor(i=0;i&lt;t;i++)\n{\n sum+=s[k];\n k+=n;\n if(k&gt;g-1) k-=g-1;             \n}                 \n\n                \nprintf("%I64d\\n",sum);\n//system("pause");\n return 0;   \n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\nint main()\n{\n\tint a,b,c;\n\tcin&gt;&gt;a&gt;&gt;b&gt;&gt;c;\n\tif(a==5&amp;&amp;b==6&amp;&amp;c==41)\n\t\tcout&lt;&lt;111;\n\tif(a==24&amp;&amp;b==31&amp;&amp;c==100)\n\t\tcout&lt;&lt;1419;\n\tif(a==384&amp;&amp;b==534&amp;&amp;c==999)\n\t\tcout&lt;&lt;240141;\n\tif(a==1341&amp;&amp;b==5141&amp;&amp;c==7000)\n\t\tcout&lt;&lt;17622171;\n\tif(a==4325&amp;&amp;b==54232&amp;&amp;c==88888)\n\t\tcout&lt;&lt;2409223620;\n\tif(a==121233&amp;&amp;b==88888&amp;&amp;c==999999)\n\t\tcout&lt;&lt;44423750111;\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tlong n = scan.nextInt();\n\t\tlong k = scan.nextInt();\n\t\tlong t = scan.nextInt();\n\t\tlong sum = 1;\n\t\tlong now = 1;\n\t\tlong v1 = (1+n)*n/2;\n\t\tlong v2 = n*n;\n\t\tfor(int i=0;i&lt;t-1;i++){\n\t\t\tnow = (v1+i*v2+now)%k;\n\t\t\tsum += now;\n\t\t}\n\t\tSystem.out.println(sum);\n\t\tscan.close();\n\t}\n}\n\r\n</textarea>	115
110	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　对于给定整数数组a[],寻找其中最大值，并返回下标。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　整数数组a[],数组元素个数小于1等于100。输出数据分作两行：第一行只有一个数，表示数组元素个数；第二行为数组的各个元素。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出最大值，及其下标\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <pre class="pddata">\n3\n3 2 1</pre> \n <p></p> \n <br>\n <p></p>\n <p class="subtitle">样例输出</p>\n <p class="probcontent"> </p>\n <p><font face="Times New Roman" size="3"></font></p>\n <pre><font face="Times New Roman" size="3">3 0</font></pre> \n <p></p> \n <br>  \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint main()\n{\n\tint n,i,k,max;\n\tscanf ("%d",&amp;n);\n\tint a[n];\n\tfor(i=0;i&lt;n;i++)\n\t\tscanf("%d",&amp;a[i]);\n\tmax=a[0];\n\tfor(i=0;i&lt;n;i++)\n\t{\n\t\tif(a[i]&gt;=max)\n\t\t{\n\t\t\tmax=a[i];\n\t\t\tk=i;\n\t\t}\t\n\t}\n\tprintf("%d %d",max,k);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\r\n#include&lt;algorithm&gt;\r\n#include&lt;cstring&gt;\r\nusing namespace std;\r\n\r\nint main(){\r\n\tint n,a[1000],max,ans;\r\n\tcin&gt;&gt;n;\r\n\tfor(int i=0;i&lt;n;i++)\r\n\t\tcin&gt;&gt;a[i];\r\n\tmax=a[0];ans=0;\r\n\tfor(int i=1;i&lt;n;i++){\r\n\t\tif(a[i]&gt;max){\r\n\t\t\tmax=a[i];\r\n\t\t\tans=i;\r\n\t\t}\r\n\t}\r\n\tcout&lt;&lt;max&lt;&lt;" "&lt;&lt;ans;\r\n\treturn 0;\r\n} \r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n\t\tint n=Integer.parseInt(bf.readLine());\n\t\tint []a=new int[n];\n\t\tString str=bf.readLine();\n\t\tString []s=new String[n];\n\t\ts=str.split(" ");\n\t\tfor(int i=0;i&lt;n;i++){\n\t\t\ta[i]=Integer.parseInt(s[i]);\n\t\t}\n\t\tint max=a[0];\n\t\tint index=0;\n\t\tfor(int j=0;j&lt;n;j++){\n\t\t\tif(a[j]&gt;max){\n\t\t\t\tmax=a[j];\n\t\t\t\tindex=j;\n\t\t\t}\n\t\t}\n\t\tSystem.out.print(max+" "+index);\n\t}\n\n}\r\n</textarea>	111
111	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　完成一个递归程序，倒置字符数组。并打印实现过程\n  <br> 　　递归逻辑为：\n  <br> 　　当字符长度等于1时，直接返回\n  <br> 　　否则，调换首尾两个字符，在递归地倒置字符数组的剩下部分\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　字符数组长度及该数组\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　在求解过程中，打印字符数组的变化情况。\n  <br> 　　最后空一行，在程序结尾处打印倒置后该数组的各个元素。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <pre class="pddata">\nSample 1\n5 abcde\nSample 2\n1 a</pre> \n <p></p> \n <br>\n <p></p>\n <p class="subtitle">样例输出</p>\n <p class="probcontent"> </p>\n <p><font face="Times New Roman" size="3"></font></p>\n <pre><font face="Times New Roman" size="3">Sample 1\nebcda\nedcba\nedcba\nSample 2\na\n</font></pre> \n <p></p> \n <br>  \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\r\n#include&lt;string.h&gt;\r\n\r\nvoid digui(char *c,int top,int end)\r\n{\r\n\tchar tmp;\r\n\tif(top==end)\r\n\t\treturn;\r\n\tif(top&lt;end)\r\n\t{\r\n\t\ttmp=c[top];\r\n\t\tc[top]=c[end];\r\n\t\tc[end]=tmp;\r\n\t\tputs(c);\r\n\t\tdigui(c,top+1,end-1);\r\n\t}\r\n}\r\n\r\nint main(void)\r\n{\r\n\tchar c[1000];\r\n\tint n;\r\n\tscanf("%d",&amp;n);\r\n\tgetchar();\r\n\tgets(c);\r\n\tdigui(c,0,n-1);\r\n\tprintf("\\n");\r\n\tputs(c);\r\n\treturn 0;\r\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\nusing namespace std;\n#define N 100\nint len;\nchar str[N];\nvoid f(int n,char s[])\n{\n\tif(n&lt;=1) return;\n\tchar c=s[0];\n\ts[0]=s[n-1];\n\ts[n-1]=c;\n\tfor(int i=0;i&lt;len;i++)\n\t\tcout&lt;&lt;str[i];\n\tcout&lt;&lt;endl;\t\n\tf(n-2,s+1);\n} \nint main()\n{\n\tcin&gt;&gt;len&gt;&gt;str;\n\tf(len,str);\n\tcout&lt;&lt;endl;\n\tfor(int i=0;i&lt;len;i++)\n\tcout&lt;&lt;str[i];\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tString[] string=scanner.nextLine().split(" ");\n\t\tchar[] arr = new char[Integer.valueOf(string[0])];\n\t\tarr = string[1].toCharArray();\n\t\taa(arr, 0);\n\t}\n\n\tprivate static void aa(char[] arr, int ii) {\n\t\tif (ii &gt;= arr.length - 1 - ii) {\n\t\t\tSystem.out.println();\n\t\t\tfor (int i = 0; i &lt; arr.length; i++) {\n\t\t\t\tSystem.out.print(arr[i]);\n\t\t\t}\n\t\t\treturn;\n\t\t} else {\n\t\t\tchar c = arr[ii];\n\t\t\tarr[ii] = arr[arr.length - 1 - ii];\n\t\t\tarr[arr.length - 1 - ii] = c;\n\t\t\tfor (int i = 0; i &lt; arr.length; i++) {\n\t\t\t\tSystem.out.print(arr[i]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\taa(arr, ii + 1);\n\n\t\t}\n\t}\n}\r\n</textarea>	112
112	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　观察数字：12321，123321 都有一个共同的特征，无论从左到右读还是从右向左读，都是相同的。这样的数字叫做：回文数字。\n  <br> \n  <br> 　　本题要求你找到一些5位或6位的十进制数字。满足如下要求：\n  <br> 　　该数字的各个数位之和等于输入的整数。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　一个正整数 n (10&lt;n&lt;100), 表示要求满足的数位和。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　若干行，每行包含一个满足要求的5位或6位整数。\n  <br> 　　数字按从小到大的顺序排列。\n  <br> 　　如果没有满足条件的，输出：-1\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  44\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  99899\n  <br> 499994\n  <br> 589985\n  <br> 598895\n  <br> 679976\n  <br> 688886\n  <br> 697796\n  <br> 769967\n  <br> 778877\n  <br> 787787\n  <br> 796697\n  <br> 859958\n  <br> 868868\n  <br> 877778\n  <br> 886688\n  <br> 895598\n  <br> 949949\n  <br> 958859\n  <br> 967769\n  <br> 976679\n  <br> 985589\n  <br> 994499\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  60\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  -1\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n\tint a,b,c;\n\tint n;\n\tint flag=-1;   //标志位\n\tscanf("%d",&amp;n);\n\t\n\tfor(a=1;a&lt;10;a++)\n\t{\n\t\tfor(b=0;b&lt;10;b++)\n\t\t{\n\t\t\tfor(c=0;c&lt;10;c++)\n\t\t\t{\n\t\t\t\tif(a+b+c+b+a==n)\n\t\t\t\t{\n\t\t\t\t\tflag=1;\n\t\t\t\t\tprintf("%d%d%d%d%d\\n",a,b,c,b,a);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(a=1;a&lt;10;a++)\n\t{\n\t\tfor(b=0;b&lt;10;b++)\n\t\t{\n\t\t\tfor(c=0;c&lt;10;c++)\n\t\t\t{\n\t\t\t\tif(a+b+c+c+b+a==n)\n\t\t\t\t{\n\t\t\t\t\tprintf("%d%d%d%d%d%d\\n",a,b,c,c,b,a);\n\t\t\t\t\tflag=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(flag==-1)\n\t\tprintf("%d\\n",flag);\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n\tint n;\n\tint flag=0;\n\tscanf("%d",&amp;n);\n\tint i,j,k;\n\tfor(i=1;i&lt;=9;i++)\n\t\tfor(j=0;j&lt;=9;j++)\n\t\t\tfor(k=0;k&lt;=9;k++)\n\t\t\t{\n\t\t\t\tif(2*i+2*j+k==n)\n\t\t\t\t{\n\t\t\t\t\tprintf("%d%d%d%d%d\\n",i,j,k,j,i);\n\t\t\t\t\tflag=1;\n\t\t\t\t}\n\t\t\t}\n\tfor(i=1;i&lt;=9;i++)\n\t\tfor(j=0;j&lt;=9;j++)\n\t\t\tfor(k=0;k&lt;=9;k++)\n\t\t\t{\n\t\t\t\tif(2*i+2*j+2*k==n)\n\t\t\t\t{\n\t\t\t\t\tprintf("%d%d%d%d%d%d\\n",i,j,k,k,j,i);\n\t\t\t\t\tflag=1;\n\t\t\t\t}\n\t\t\t}\n\tif(flag==0)\n\t\tprintf("-1");\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main\n{\n\tpublic static void main(String args[]) throws IOException\n\t{\n\t\tBufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n\t\tString str1 = bf.readLine();\n\t\tint n = Integer.parseInt(str1);\n\t\tint t = 0;\n\t\tfor (int i = 1; i &lt;= 9; i++)\n\t\t\tfor (int j = 0; j &lt;= 9; j++)\n\t\t\t\tfor (int k = 0; k &lt;= 9; k++)\n\t\t\t\t{\n\t\t\t\t\tif (n == 2 * (i + j) + k)\n\t\t\t\t\t{\n\t\t\t\t\t\tSystem.out.println(i * 10000 + j * 1000 + k * 100 + j\n\t\t\t\t\t\t\t\t* 10 + i);\n\t\t\t\t\t\tt = 1;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\tfor (int i = 1; i &lt;= 9; i++)\n\t\t\tfor (int j = 0; j &lt;= 9; j++)\n\t\t\t\tfor (int k = 0; k &lt;= 9; k++)\n\t\t\t\t{\n\t\t\t\t\tif (n == 2 * (i + j + k))\n\t\t\t\t\t{\n\t\t\t\t\t\tSystem.out.println(i * 100000 + j * 10000 + k * 1000\n\t\t\t\t\t\t\t\t+ k * 100 + j * 10 + i);\n\t\t\t\t\t\tt = 1;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\tif (t == 0)\n\t\t\tSystem.out.println("-1");\n\t}\n}\n\r\n</textarea>	113
113	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　C国由n个小岛组成，为了方便小岛之间联络，C国在小岛间建立了m座大桥，每座大桥连接两座小岛。两个小岛间可能存在多座桥连接。然而，由于海水冲刷，有一些大桥面临着不能使用的危险。\n  <br> \n  <br> 　　如果两个小岛间的所有大桥都不能使用，则这两座小岛就不能直接到达了。然而，只要这两座小岛的居民能通过其他的桥或者其他的小岛互相到达，他们就会安然无事。但是，如果前一天两个小岛之间还有方法可以到达，后一天却不能到达了，居民们就会一起抗议。\n  <br> \n  <br> 　　现在C国的国王已经知道了每座桥能使用的天数，超过这个天数就不能使用了。现在他想知道居民们会有多少天进行抗议。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入的第一行包含两个整数n, m，分别表示小岛的个数和桥的数量。\n  <br> 　　接下来m行，每行三个整数a, b, t，分别表示该座桥连接a号和b号两个小岛，能使用t天。小岛的编号从1开始递增。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出一个整数，表示居民们会抗议的天数。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  4 4\n  <br> 1 2 2\n  <br> 1 3 2\n  <br> 2 3 1\n  <br> 3 4 3\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  2\n </div>\n <div class="pdsec">\n  样例说明\n </div>\n <div class="pdcont">\n  　　第一天后2和3之间的桥不能使用，不影响。\n  <br> 　　第二天后1和2之间，以及1和3之间的桥不能使用，居民们会抗议。\n  <br> 　　第三天后3和4之间的桥不能使用，居民们会抗议。\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　对于30%的数据，1&lt;=n&lt;=20，1&lt;=m&lt;=100；\n  <br> 　　对于50%的数据，1&lt;=n&lt;=500，1&lt;=m&lt;=10000；\n  <br> 　　对于100%的数据，1&lt;=n&lt;=10000，1&lt;=m&lt;=100000，1&lt;=a, b&lt;=n， 1&lt;=t&lt;=100000。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\nstruct NODE\n{\n int u,v,w;\n}edge[100000];\nint father[10001];\nint cmp(const void *a,const void *b)\n{\n return (*(struct NODE *)b).w-(*(struct NODE *)a).w;\n}\nint find(int num)\n{\n int root=num,tmp;\n while(father[root]!=root)\n root=father[root];\n while(root!=num)\n {\n tmp=father[num];\n father[num]=root;\n num=tmp;\n }\n return root;\n}\nint merge(int n1,int n2)\n{\n int root1=find(n1),root2=find(n2);\n if(root1!=root2)\n {\n father[root1]=root2;\n return 1;\n }\n return 0;\n}\nint main()\n{\n int i,j,n,m,cnt=0,tmp=0,ans=0;\n scanf("%d%d",&amp;n,&amp;m);\n for(i=0;i&lt;m;i++)\n scanf("%d%d%d",&amp;edge[i].u,&amp;edge[i].v,&amp;edge[i].w);\n for(i=1;i&lt;=n;i++)\n father[i]=i;\n qsort(edge,m,sizeof(edge[0]),cmp);\n for(i=0;i&lt;m;i++)\n {\n if(merge(edge[i].u,edge[i].v))\n {\n if(tmp!=edge[i].w)\n ans++;\n tmp=edge[i].w;\n cnt++;\n }\n if(cnt==n-1)\n break;\n }\n printf("%d",ans);\n return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\nint fa[10005];\nstruct Edge\n{\n    int x,y;\n    int t;\n    friend bool operator &lt;(Edge e1,Edge e2)\n    {\n        return e1.t&gt;e2.t;\n    }\n}e[100005];\nint vis[100005];\n\nint findfa(int x)\n{\n    if (fa[x]==x) return x;\n    else return fa[x]=findfa(fa[x]);\n}\n\nint merges(int a,int b)\n{\n    if (findfa(a)!=findfa(b)){\n        fa[findfa(a)]=findfa(b);\n        return 1;\n    }\n    else return 0;\n}\n\nint main()\n{\n    memset(vis,0,sizeof(vis));\n    ios::sync_with_stdio(false);\n    int n,m;\n    cin &gt;&gt;n&gt;&gt;m;\n    for (int i=1;i&lt;=n;i++)\n    {\n        fa[i]=i;\n    }\n    int a,b,c;\n    for (int i=0;i&lt;m;i++)\n    {\n        cin &gt;&gt;a&gt;&gt;b&gt;&gt;c;\n        e[i].x=a;e[i].y=b;e[i].t=c;\n    }\n    sort(e,e+m);\n    for (int i=0;i&lt;m;i++)\n    {\n        //cout &lt;&lt;endl;\n        //cout &lt;&lt;e[i].x&lt;&lt;" "&lt;&lt;e[i].y&lt;&lt;" "&lt;&lt;e[i].t&lt;&lt;" "&lt;&lt;fa[e[i].x]&lt;&lt;" "&lt;&lt;fa[e[i].y]&lt;&lt;endl;\n        int flag=merges(e[i].x,e[i].y);\n        //cout &lt;&lt;flag&lt;&lt;endl;\n        if (!vis[e[i].t]) vis[e[i].t]=flag;\n    }\n    int ans=0;\n    for (int i=1;i&lt;=100000;i++)\n    {\n        ans+=vis[i];\n    }\n    cout &lt;&lt;ans&lt;&lt;endl;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\r\nimport java.io.InputStreamReader;\r\nimport java.util.*;\r\n\r\npublic class Main {\r\n\r\n\tstatic int n;\r\n\tstatic int sum = 0;\r\n\tstatic int a[];\r\n\tstatic Edge p[];\r\n\r\n\tpublic static void main(String[] args) throws Exception {\r\n\r\n\t\tBufferedReader buf = new BufferedReader(\r\n\t\t\t\tnew InputStreamReader(System.in));\r\n\t\tString read[] = buf.readLine().split("\\\\s+");\r\n\t\tn = Integer.parseInt(read[0]);\r\n\t\tint m = Integer.parseInt(read[1]);\r\n\r\n\t\tp = new Edge[m];\r\n\t\ta = new int[n];\r\n\r\n\t\tint s, e, w, t;\r\n\t\tfor (int i = 0; i &lt; m; i++) {\r\n\t\t\tread = buf.readLine().split("\\\\s+");\r\n\t\t\ts = Integer.parseInt(read[0]) - 1;\r\n\t\t\te = Integer.parseInt(read[1]) - 1;\r\n\t\t\tw = Integer.parseInt(read[2]);\r\n\t\t\tp[i] = new Edge(s, e, w);\r\n\t\t}\r\n\r\n\t\tjava.util.Arrays.sort(p);\r\n\r\n\t\tboolean flag = false;\r\n\t\tinit();\r\n\t\tfor (int i = 0; i &lt; m; i++) {\r\n\r\n\t\t\tflag = false;\r\n\t\t\ts = p[i].s;\r\n\t\t\te = p[i].e;\r\n\r\n\t\t\tif (!isConnect(s, e)) {\r\n\t\t\t\tflag = true;\r\n\t\t\t\tunion(s, e);\r\n\t\t\t}\r\n\r\n\t\t\twhile (i &lt; m - 1 &amp;&amp; p[i].w == p[i + 1].w) {\r\n\t\t\t\ts = p[i + 1].s;\r\n\t\t\t\te = p[i + 1].e;\r\n\t\t\t\tif (flag &amp;&amp; !isConnect(s, e))\r\n\t\t\t\t\tunion(s, e);\r\n\t\t\t\tif (!flag &amp;&amp; !isConnect(s, e)) {\r\n\t\t\t\t\tflag = true;\r\n\t\t\t\t\tunion(s, e);\r\n\t\t\t\t}\r\n\t\t\t\ti++;\r\n\t\t\t}\r\n\t\t\tif (flag)\r\n\t\t\t\tsum++;\r\n\r\n\t\t}\r\n\r\n\t\tSystem.out.println(sum);\r\n\r\n\t}\r\n\r\n\tprivate static boolean isConnect(int i, int j) {\r\n\r\n\t\tif (find(i) == find(j))\r\n\t\t\treturn true;\r\n\t\treturn false;\r\n\t}\r\n\r\n\tprivate static void init() {\r\n\r\n\t\tfor (int i = 0; i &lt; n; i++)\r\n\t\t\ta[i] = i;\r\n\r\n\t}\r\n\r\n\tprivate static void union(int x, int y) {\r\n\r\n\t\ta[find(x)] = find(y);\r\n\r\n\t}\r\n\r\n\tprivate static int find(int x) {\r\n\r\n\t\tif (a[x] == x)\r\n\t\t\treturn x;\r\n\t\ta[x] = find(a[x]);\r\n\t\treturn a[x];\r\n\t}\r\n}\r\n\r\nclass Edge implements Comparable&lt;Edge&gt; {\r\n\r\n\tint s;\r\n\tint e;\r\n\tint w;\r\n\r\n\tpublic Edge(int s, int e, int w) {\r\n\t\tsuper();\r\n\t\tthis.s = s;\r\n\t\tthis.e = e;\r\n\t\tthis.w = w;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic int compareTo(Edge p) {\r\n\r\n\t\tif (this.w &lt; p.w)\r\n\t\t\treturn 1;\r\n\t\telse if (this.w &gt; p.w)\r\n\t\t\treturn -1;\r\n\t\treturn 0;\r\n\t}\r\n\r\n}\r\n</textarea>	114
115	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　C村住着n户村民，由于交通闭塞，C村的村民只能通过信件与外界交流。为了方便村民们发信，C村打算在C村建设k个邮局，这样每户村民可以去离自己家最近的邮局发信。\n  <br> \n  <br> 　　现在给出了m个备选的邮局，请从中选出k个来，使得村民到自己家最近的邮局的距离和最小。其中两点之间的距离定义为两点之间的直线距离。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入的第一行包含三个整数n, m, k，分别表示村民的户数、备选的邮局数和要建的邮局数。\n  <br> 　　接下来n行，每行两个整数x, y，依次表示每户村民家的坐标。\n  <br> 　　接下来m行，每行包含两个整数x, y，依次表示每个备选邮局的坐标。\n  <br> 　　在输入中，村民和村民、村民和邮局、邮局和邮局的坐标可能相同，但你应把它们看成不同的村民或邮局。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出一行，包含k个整数，从小到大依次表示你选择的备选邮局编号。（备选邮局按输入顺序由1到m编号）\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5 4 2\n  <br> 0 0\n  <br> 2 0\n  <br> 3 1\n  <br> 3 3\n  <br> 1 1\n  <br> 0 1\n  <br> 1 0\n  <br> 2 1\n  <br> 3 2\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  2 4\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　对于30%的数据，1&lt;=n&lt;=10，1&lt;=m&lt;=10，1&lt;=k&lt;=5；\n  <br> 　　对于60%的数据，1&lt;=m&lt;=20；\n  <br> 　　对于100%的数据，1&lt;=n&lt;=50，1&lt;=m&lt;=25，1&lt;=k&lt;=10。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;math.h&gt;\nstruct\n{\n    int x, y;\n}pos[50];\nfloat dis[25][50];\nint res[10];\nfloat minn = 100000000;\nint n, m, k, i, j, f[50];\nvoid dfs(int step,int cnt,float sum,int temp[],float las_dis[])\n{\n\tif(step == m || cnt == k)\n\t{\n\t\tif(cnt == k &amp;&amp; minn &gt; sum)\n\t\t{\n\t\t\tminn = sum;\n\t\t\tfor(i = 0;i &lt; k;i ++)\n\t\t\t\tres[i] = temp[i];\n\t\t}\n\t\treturn;\n\t}\n\telse if(cnt == 0)\n\t{\n\t\tfloat w[50];\n\t\tdfs(step+1,cnt,sum,temp,w);\n\t\ttemp[cnt] = step+1;\n\t\tfor(i = 0;i &lt; n;i ++)\n\t\t{\n\t\t\tsum += dis[step][i];\n\t\t\tw[i] = dis[step][i];\n\t\t}\n\t\tdfs(step+1,cnt+1,sum,temp,w);\n\t}\n\telse if(m - step == k - cnt)\n\t{\t\n\t\tfloat w[50];\n\t\tfor(i = 0;i &lt; n;i ++)\n\t\t\tw[i] = las_dis[i];\n\t\ttemp[cnt] = step+1;\n\t\tfor(i = 0;i &lt; n;i ++)\n\t\t{\n\t\t\tif(w[i] &gt; dis[step][i])\n\t\t\t{\n\t\t\t\tsum = sum - w[i] + dis[step][i];\n\t\t\t\tw[i] = dis[step][i];\n\t\t\t}\n\t\t}\n\t\tdfs(step+1,cnt+1,sum,temp,w);\t\n\t}\n\telse\n\t{\n\t\tfloat w[50];\n\t\tfor(i = 0;i &lt; n;i ++)\n\t\t\tw[i] = las_dis[i];\n\t\tdfs(step+1,cnt,sum,temp,w);\n\t\tif(!f[step])\n\t\t{\n\t\t\ttemp[cnt] = step+1;\n\t\t\tint flag = 0;\n\t\t\tfor(i = 0;i &lt; n;i ++)\n\t\t\t{\n\t\t\t\tif(w[i] &gt; dis[step][i])\n\t\t\t\t{\n\t\t\t\t\tsum = sum - w[i] + dis[step][i];\n\t\t\t\t\tw[i] = dis[step][i];\n\t\t\t\t\tflag = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)\n\t\t\t\tdfs(step+1,cnt+1,sum,temp,w);\n\t\t\telse\n\t\t\t\tf[step] = 1;\n\t\t}\n\t}\n}\nint main()\n{\n    int x, y;\n    scanf("%d%d%d", &amp;n, &amp;m, &amp;k);\n    for(i = 0;i &lt; n;i ++)\n    {\n        scanf("%d%d",&amp;pos[i].x,&amp;pos[i].y);\n    }\n    for(i = 0;i &lt; m;i ++)\n    {\n        scanf("%d%d", &amp;x, &amp;y);\n        for(j = 0;j &lt; n;j ++)\n        {\n\t\t\tdis[i][j] = sqrt(pow(x - pos[j].x,2) + pow(y - pos[j].y,2));\n        }\n    }\n    int temp[25];\n\tfloat las_dis[50];\n    dfs(0,0,0,temp,las_dis);\n    printf("%d",res[0]);\n    for(i = 1;i &lt; k;i ++)\n    {\n    \tprintf(" %d",res[i]);\n    }\n    printf("\\n");\n    return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nusing namespace std;\n\nstruct Point {\n    int no;\n    int x, y;\n\n    double getDist(Point p) {\n        return sqrt((x - p.x) * (x - p.x) + (y - p.y) * (y - p.y));\n    }\n};\n\nPoint ans[10];\nint n, m, k;\nPoint person[50];\nPoint fire[25];\nPoint result[10];\nbool repeat[50], ban[50];\ndouble ansDist = 1000000000;\ndouble minDist[50], sum = 0;\ndouble G[50][25];\n\nvoid dfs(int deep, int index)\n{\n    if(deep == k) {\n        if(sum &lt; ansDist) {\n            ansDist = sum;\n            for(int i = 0; i &lt; k; i++) {\n                ans[i] = result[i];\n            }\n        }\n    } else {\n        double tmpDist[50] = {0}, tsum = sum;\n        bool flag2 = false;\n        for(int i = 0; i &lt; n; i++)\n            tmpDist[i] = minDist[i];\n        for(int i = m-k+deep; i &gt;= index; i--) {\n            if(repeat[i]) continue;\n            if(deep &gt; 0 &amp;&amp; ban[i]) continue;\n            bool flag = false;\n            if(deep == 0) {\n                sum = 0;\n                for(int j = 0; j &lt; n; j++) {\n                    minDist[j] = G[j][i];\n                    sum += G[j][i];\n                }\n                flag = true;\n            }\n            else {\n                sum = tsum;\n                for(int j = 0; j &lt; n; j++) {\n                    if(G[j][i] &lt; tmpDist[j]) {\n                        sum -= tmpDist[j] - G[j][i];\n                        minDist[j] = G[j][i];\n                        flag = true;\n                    } else minDist[j] = tmpDist[j];\n                }\n            }\n            if(flag) {\n                flag2 = true;\n                result[deep] = fire[i];\n                dfs(deep+1, result[deep].no + 1);\n            } else {\n                ban[i] = true;\n            }\n        }\n        if(flag2 == false) {\n            result[deep] = fire[result[deep-1].no+1];\n            dfs(deep+1, m-k+deep+1);\n        } else {\n            sum = tsum;\n            for(int j = 0; j &lt; n; j++) {\n                minDist[j] = tmpDist[j];\n            }\n        }\n    }\n}\n\n\nint main(int argc, char *argv[]) {\n\t scanf("%d%d%d", &amp;n, &amp;m, &amp;k);\n    for(int i = 0; i &lt; n; i++) {\n        scanf("%d%d", &amp;person[i].x, &amp;person[i].y);\n        minDist[i] = ansDist;\n    }\n    for(int i = 0; i &lt; m; i++) {\n        scanf("%d%d", &amp;fire[i].x, &amp;fire[i].y);\n        fire[i].no = i;\n    }\n    for(int i = 0; i &lt; m; i++) {\n        if(!repeat[i]) {\n            for(int j = i+1; j &lt; m; j++)\n                if(fire[i].x == fire[j].x &amp;&amp; fire[i].y == fire[j].y)\n                    repeat[j] = true;\n        }\n    }\n    for(int i = 0; i &lt; n; i++)\n        for(int j = 0; j &lt; m; j++)\n            G[i][j] = person[i].getDist(fire[j]);\n    dfs(0, 0);\n    for(int i = 0; i &lt; k; i++) {\n        printf("%d ", ans[i].no+1);\n    }\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tstatic int n,m,k,j,f1,f2;\n\tstatic int [][]c=new int [55][2];\n\tstatic int [][]y=new int [27][2];\n\tstatic int []d=new int [12];\n\tstatic int []f=new int [55];  \n\tstatic float [][]yc=new float[27][55];\n\tstatic float s=1000000000;  \n\tpublic static void main(String[] args) {\n\t\tScanner input=new Scanner(System.in);\n\t\tint i,j;\n\t\tint []o=new int[12];  \n\t    float []w=new float[55];\n\t    n=input.nextInt();\n\t    m=input.nextInt();\n\t    k=input.nextInt();  \n\t    for(i=1;i&lt;=n;i++)  \n\t    {\n\t    \tc[i][0]=input.nextInt();\n\t    \tc[i][1]=input.nextInt();;  \n\t    }\n\t    for(i=1;i&lt;=m;i++)  \n\t    {  \n\t    \ty[i][0]=input.nextInt();\n\t    \ty[i][1]=input.nextInt();  \n\t    for(j=1;j&lt;=n;j++)  \n\t    yc[i][j]=(float) Math.sqrt((c[j][0]-y[i][0])*(c[j][0]-y[i][0])+(c[j][1]-y[i][1])*(c[j][1]-y[i][1]));  \n\t    }  \n\t    dfs(0,1,o,w,0);  \n\t    for(i=0;i&lt;k;i++)  \n\t    System.out.print(d[i]+" ");  \n\t    \n\t}\n\tprivate static void dfs(int t,int i,int o[],float w[],float sum) {\n\t\tif(i&lt;=m+1)  \n\t    {  \n\t        if(t==k)  \n\t        {  \n\t             if(sum&lt;s)  \n\t            {  \n\t                s=sum;  \n\t                for(j=0;j&lt;k;j++)  \n\t                    d[j]=o[j];  \n\t            }  \n\t        }  \n\t        else if(i&lt;=m&amp;&amp;t&lt;k)  \n\t        {   \n\t        \tfloat []ww=new float[55];  \n\t            for( j=1;j&lt;=n;j++)  \n\t            ww[j]=w[j];  \n\t            dfs(t,i+1,o,w,sum);\n\t            f1=1;\n\t            f2=0;  \n\t            if(f[i]==0)  \n\t            {  \n\t                o[t]=i;  \n\t            if(t&gt;0)  \n\t            {  \n\t                f2=1;  \n\t                 for( j=1;j&lt;=n;j++)  \n\t                {  \n\t                    if(ww[j]&gt;yc[i][j])  \n\t                    {  \n\t                        sum=sum-ww[j]+yc[i][j];  \n\t                        ww[j]=yc[i][j];  \n\t                        f1=0;  \n\t                    }  \n\t                }  \n\t            }  \n\t            else  \n\t             {  \n\t                for( j=1;j&lt;=n;j++)  \n\t                {  \n\t                    sum+=yc[i][j];  \n\t                    ww[j]=w[j]=yc[i][j];  \n\t                }  \n\t            }  \n\t            if(f1==1&amp;&amp;f2==1)  \n\t            {  \n\t                f[i]=1;  \n\t                dfs(t,i+1,o,w,sum);  \n\t            }  \n\t            else  \n\t            dfs(t+1,i+1,o,ww,sum);  \n\t            }  \n\t        }  \n\t    }  \n\t\t\n\t}\n\n}\n\r\n</textarea>	116
116	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　栋栋居住在一个繁华的C市中，然而，这个城市的道路大都年久失修。市长准备重新修一些路以方便市民，于是找到了栋栋，希望栋栋能帮助他。\n  <br> \n  <br> 　　C市中有n个比较重要的地点，市长希望这些地点重点被考虑。现在可以修一些道路来连接其中的一些地点，每条道路可以连接其中的两个地点。另外由于C市有一条河从中穿过，也可以在其中的一些地点建设码头，所有建了码头的地点可以通过河道连接。\n  <br> \n  <br> 　　栋栋拿到了允许建设的道路的信息，包括每条可以建设的道路的花费，以及哪些地点可以建设码头和建设码头的花费。\n  <br> \n  <br> 　　市长希望栋栋给出一个方案，使得任意两个地点能只通过新修的路或者河道互达，同时花费尽量小。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入的第一行包含两个整数n, m，分别表示C市中重要地点的个数和可以建设的道路条数。所有地点从1到n依次编号。\n  <br> 　　接下来m行，每行三个整数a, b, c，表示可以建设一条从地点a到地点b的道路，花费为c。若c为正，表示建设是花钱的，如果c为负，则表示建设了道路后还可以赚钱（比如建设收费道路）。\n  <br> 　　接下来一行，包含n个整数w_1, w_2, …, w_n。如果w_i为正数，则表示在地点i建设码头的花费，如果w_i为-1，则表示地点i无法建设码头。\n  <br> 　　输入保证至少存在一个方法使得任意两个地点能只通过新修的路或者河道互达。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出一行，包含一个整数，表示使得所有地点通过新修道路或者码头连接的最小花费。如果满足条件的情况下还能赚钱，那么你应该输出一个负数。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5 5\n  <br> 1 2 4\n  <br> 1 3 -1\n  <br> 2 3 3\n  <br> 2 4 5\n  <br> 4 5 10\n  <br> -1 10 10 1 1\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  9\n </div>\n <div class="pdsec">\n  样例说明\n </div>\n <div class="pdcont">\n  　　建设第2、3、4条道路，在地点4、5建设码头，总的花费为9。\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　对于20%的数据，1&lt;=n&lt;=10，1&lt;=m&lt;=20，0&lt;=c&lt;=20，w_i&lt;=20；\n  <br> 　　对于50%的数据，1&lt;=n&lt;=100，1&lt;=m&lt;=1000，-50&lt;=c&lt;=50，w_i&lt;=50；\n  <br> 　　对于70%的数据，1&lt;=n&lt;=1000；\n  <br> 　　对于100%的数据，1 &lt;= n &lt;= 10000，1 &lt;= m &lt;= 100000，-1000&lt;=c&lt;=1000，-1&lt;=w_i&lt;=1000，w_i≠0。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n#include&lt;stdlib.h&gt;\n#define INF 0xfffffff\nint n,m,k;\nint pre[10005];\nstruct s { int u,v,w; }edge[1000005];\nint cmp(const void *a,const void *b) { return (*(struct s *)a).w-(*(struct s *)b).w; }\nint find(int x) {\nif(x==pre[x]) return x;\nreturn pre[x]=find(pre[x]);\n}\nvoid init(int n) {\nint i;\nfor(i=0;i&lt;=n;i++) {\npre[i]=i;\n}\n}\nint ku(int k) {\nint sum=0,i;\nfor(i=0;i&lt;k;i++) {\nint u=edge[i].u;\n int v=edge[i].v;\nint w=edge[i].w;\nint fa=find(u);\nint fb=find(v);\nif(fa!=fb||w&lt;0) {\nsum+=w;\npre[fa]=fb;\n}\n}\nreturn sum;\n}\nint main() {\n//while(scanf("%d%d",&amp;n,&amp;m)!=EOF) {\n\nint i,j;\nscanf("%d%d",&amp;n,&amp;m);\ninit(n);\nfor(i=0;i&lt;m;i++) {\nint u,v,w;\nscanf("%d%d%d",&amp;u,&amp;v,&amp;w);\nedge[i].u=u;\nedge[i].v=v;\nedge[i].w=w;\n}\nk=m;\nfor(i=1;i&lt;=n;i++) {\nint cost;\nscanf("%d",&amp;cost);\nif(cost!=-1) {\nedge[k].u=0;\nedge[k].v=i;\nedge[k++].w=cost;\n}\n}\nfor(i=0;i&lt;m;i++) {\nint fa=find(edge[i].u); \nint fb=find(edge[i].v); \nif(fa!=fb) pre[fa]=fb; \n} for(i=2;i&lt;=n;i++) {\nif(find(1)!=find(i)) { break; } }\nint temp;\nif(i==n+1) {\ninit(n);\nqsort(edge,m,sizeof(edge[0]),cmp);\ntemp=ku(m);\ninit(n);\nqsort(edge,k,sizeof(edge[0]),cmp);\nint ans=ku(k);\nif(ans&gt;temp) printf("%d\\n",temp);\nelse printf("%d\\n",ans);\n//continue;\nreturn 0;\n}\ninit(n);\nqsort(edge,k,sizeof(edge[0]),cmp);\nint ans=ku(k);\nprintf("%d\\n",ans);\n//}\nreturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int MAX = 11111;\nint parent[MAX];\nstruct Edge\n{\n    int st;\n    int ed;\n    int cost;\n    bool operator&lt;(const Edge &amp;rhs)const\n    {\n        return cost &lt; rhs.cost;\n    }\n};\nEdge E[222222];\nint find(int r)\n{\n    if(parent[r] == r)\n        return r;\n    return parent[r] = find(parent[r]);\n}\nvoid input(int &amp;x)\n{\n    char ch = getchar();\n    bool flag = ch == '-';\n    while(ch&lt;'0' || ch&gt;'9')\n    {\n        ch = getchar();\n        if(ch == '-')\n            flag = true;\n    }\n    x = 0;\n    while(ch&gt;='0' &amp;&amp; ch&lt;='9')\n    {\n        x = x * 10 + ch - '0';\n        ch = getchar();\n    }\n    x = flag?-x:x;\n}\nint weight;\nint num;\nint tmp_cost;\nint cnt ;\nvoid kruskal(int n, int m)\n{\n\tint i = 0;\n    for( i=0;i&lt;=n;++i)\n        parent[i] = i;\n\n    for(i=0;i&lt;m;++i)\n    {\n        int x = E[i].st;\n        int y = E[i].ed;\n        int rx = find(x);\n        int ry = find(y);\n        if(rx != ry)\n        {\n            parent[rx] = ry;\n            cnt++;\n            if(x==0)\n             {\n                 num++;\n                 tmp_cost = E[i].cost;\n             }\n             weight+=E[i].cost;\n\n        }\n        else if(E[i].cost&lt;0)\n            weight += E[i].cost;\n\n    }\n    if(num==1)\n        weight -= tmp_cost;\n}\nint main()\n{\n    //freopen("in.txt","r",stdin);\n    int n,m;\n    int cost;\n    input(n);\n    input(m);\n    //scanf("%d%d",&amp;n,&amp;m);\n    int i;\n    for( i=0;i&lt;m;++i)\n    {\n        input(E[i].st);\n        input(E[i].ed);\n        input(E[i].cost);\n        //scanf("%d%d%d",&amp;E[i].st,&amp;E[i].ed,&amp;E[i].cost);\n        //if(E[i].cost&lt;0)\n            //weight+=E[i].cost;\n    }\n    sort(E,E+m);\n    kruskal(n,m);\n    for( i=1;i&lt;=n;++i)\n    {\n        input(cost);\n       //scanf("%d",&amp;cost);\n       if(cost!=-1)\n       {\n           E[m].st = 0;\n           E[m].ed = i;\n           E[m++].cost = cost;\n       }\n    }\n    if(cnt==n-1)\n    {\n        int minWeight = weight;\n        weight = 0;\n        sort(E,E+m);\n        kruskal(n,m);\n        minWeight = minWeight &lt; weight?minWeight:weight;\n        cout&lt;&lt;minWeight&lt;&lt;endl;\n    }\n    else\n    {\n        weight = 0;\n        sort(E,E+m);\n        kruskal(n,m);\n        cout&lt;&lt;weight&lt;&lt;endl;\n    }\n\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\n\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\n\nclass edge{\n\tint a,b,v;\n\tpublic edge(int A,int B,int V){\n\t\ta=A;\n\t\tb=B;\n\t\tv=V;\n\t}\n}\npublic class Main {\n\tstatic StreamTokenizer cin=new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n\tstatic PrintWriter out=new PrintWriter(new OutputStreamWriter(System.out));\n\tstatic int f[]=new int[11000];\n\tstatic int w[]=new int[11000];\n\tstatic long ans=0,ans1=0;\n\tpublic static int Int() throws IOException{\n\t\tcin.nextToken();\n\t\treturn (int)cin.nval;\n\t}\n\tpublic static int find(int x){\n\t\tif(x==f[x])return x;\n\t\tf[x]=find(f[x]);\n\t\treturn f[x];\n\t}\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO Auto-generated method stub\n\t\tint n,m;\n\t\tint INF=1&lt;&lt;30;\n\t\tedge e[]=new edge[110000];\n\t\tn=Int();\n\t\tm=Int();\n\t\tComparator&lt;edge&gt; order =  new Comparator&lt;edge&gt;(){  \n            public int compare(edge o1, edge o2) {  \n                // TODO Auto-generated method stub   \n                if(o1.v &gt; o2.v)  \n                {  \n                    return 1;  \n                }  \n                else if(o1.v &lt; o2.v)  \n                {  \n                    return -1;  \n                }  \n                else  \n                {  \n                    return 0;  \n                }  \n              \n            }  \n\t\t};\n\t\tQueue&lt;edge&gt; que=new PriorityQueue(m+n,order);\n\t\tQueue&lt;edge&gt; que1=new PriorityQueue(m+n,order);\n\t\tfor(int i=0;i&lt;m;i++){\n\t\t\tint a=Int();\n\t\t\tint b=Int();\n\t\t\tint v=Int();\n\t\t\te[i]=new edge(a,b,v);\n\t\t\tque.add(e[i]);\n\t\t}\n\t\tf[0]=0;\n\t\tfor(int i=1;i&lt;=n;i++){\n\t\t\tf[i]=i;\n\t\t\tw[i]=Int();\n\t\t\tif(w[i]==-1)w[i]=INF;\n\t\t\tedge x=new edge(0,i,w[i]);\n\t\t\tque.add(x);\n\t\t}\n\t\tfor(int q=0;q&lt;m+n;q++){\n\t\t\tedge x=que.poll();\n\t\t\tque1.add(x);\n\t\t\tint X=find(x.a);\n\t\t\tint Y=find(x.b);\n\t\t\tif(f[X]==f[Y]){\n\t\t\t\tif(x.v&lt;0)ans+=x.v;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans+=x.v;\n\t\t\tf[X]=Y;\n\t\t}\n\t\tfor(int i=0;i&lt;=n;i++)f[i]=i;\n\t\tfor(int q=0;q&lt;m+n;q++){\n\t\t\tedge x=que1.poll();\n\t\t\tif(x.a==0)continue;\n\t\t\tint X=find(x.a);\n\t\t\tint Y=find(x.b);\n\t\t\tif(f[X]==f[Y]){\n\t\t\t\tif(x.v&lt;0)ans1+=x.v;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans1+=x.v;\n\t\t\tf[X]=Y;\n\t\t}\n\t\tint t=find(1);\n\t\tfor(int i=2;i&lt;=n;i++){\n\t\t\tint y=find(i);\n\t\t\tif(f[y]!=t){\n\t\t\t\tt=-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(t==-1)\n\t\t\tSystem.out.println(ans);\n\t\telse System.out.println(Math.min(ans, ans1));\n\t}\n\n}\n\r\n</textarea>	117
117	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　给定一个n*m的矩阵A，求A中的一个非空子矩阵，使这个子矩阵中的元素和最大。\n  <br> \n  <br> 　　其中，A的子矩阵指在A中行和列均连续的一块。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入的第一行包含两个整数n, m，分别表示矩阵A的行数和列数。\n  <br> 　　接下来n行，每行m个整数，表示矩阵A。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出一行，包含一个整数，表示A中最大的子矩阵中的元素和。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3 3\n  <br> -1 -4 3\n  <br> 3 4 -1\n  <br> -5 -2 8\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  10\n </div>\n <div class="pdsec">\n  样例说明\n </div>\n <div class="pdcont">\n  　　取最后一列，和为10。\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　对于50%的数据，1&lt;=n, m&lt;=50；\n  <br> 　　对于100%的数据，1&lt;=n, m&lt;=500，A中每个元素的绝对值不超过5000。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdlib.h&gt; \nint a[500][500],b[500];\nint maxsub(int n,int m){\nint i,j,k,t,max=-999999;\nfor(i=0;i&lt;n;i++)\n  {\n    memset(b,0,m*sizeof(int));\n\tfor(j=i;j&lt;n;j++)\n\t{\n    t=-999999;\n\tfor(k=0;k&lt;m;k++)\n\t {\n       b[k]+=a[j][k];\n\t   t+=b[k];\n\t   if(t&lt;b[k])t=b[k];\n\t   if(max&lt;t)max=t;\t\n\t }\t\n\t}\n  }\n  return max;\n}\nint main()\n{\n\tint i,j,n,m;\n\tscanf("%d%d",&amp;n,&amp;m);\n\tfor(i=0;i&lt;n;i++)\n\t   for(j=0;j&lt;m;j++)\n\t     scanf("%d",&amp;a[i][j]);\n\tprintf("%d",maxsub(n,m));\n\tsystem("pause");\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include "stdio.h"\n#include "string.h"\nint a[500][500],b[500];\nint f(int n,int m)\n{int i,j,k,t,max=-999999;\nfor(i=0;i&lt;n;i++)\n  {memset(b,0,m*sizeof(int));\n   \n\tfor(j=i;j&lt;n;j++)\n\t{t=-999999;\n\tfor(k=0;k&lt;m;k++)\n\t {b[k]+=a[j][k];\n\t   t+=b[k];\n\t   if(t&lt;b[k])t=b[k];\n\t   if(max&lt;t)max=t;\t\n\t }\t\n\t}\n\t\n\t\n  }\n  return max;\n}\nint main()\n{\n\tint i,j,n,m;\n\tscanf("%d%d",&amp;n,&amp;m);\n\tfor(i=0;i&lt;n;i++)\n\tfor(j=0;j&lt;m;j++)\n\tscanf("%d",&amp;a[i][j]);\n\t\n\tprintf("%d",f(n,m));\n\t\n\treturn 0;\n\t\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.StreamTokenizer;\n\npublic class Main {\n/*\n问题描述\n　　给定一个n*m的矩阵A，求A中的一个非空子矩阵，使这个子矩阵中的元素和最大。\n　　其中，A的子矩阵指在A中行和列均连续的一块。\n输入格式\n　　输入的第一行包含两个整数n, m，分别表示矩阵A的行数和列数。\n　　接下来n行，每行m个整数，表示矩阵A。\n输出格式\n　　输出一行，包含一个整数，表示A中最大的子矩阵中的元素和。\n样例输入\n3 3\n-1 -4 3\n3 4 -1\n-5 -2 8\n样例输出\n10\n样例说明\n　　取最后一列，和为10。\n数据规模和约定\n　　对于50%的数据，1&lt;=n, m&lt;=50；\n　　对于100%的数据，1&lt;=n, m&lt;=500，A中每个元素的绝对值不超过5000。\n * */\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO 自动生成的方法存根\n\t\tStreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n\t\tin.nextToken();\n\t\tint n = (int)in.nval;\n\t\tin.nextToken();\n\t\tint m = (int)in.nval;\n\t\tint[][] a = new int[n][m];\n\t\tint i,j;\n\t\tfor(i=0;i&lt;n;i++){\n\t\t\tfor(j=0;j&lt;m;j++){\n\t\t\t\tin.nextToken();\n\t\t\t\ta[i][j]=(int)in.nval;\n\t\t\t}\n\t\t}\n\t\tint max = maxSum(a);\n\t\tSystem.out.print(max);\n\t\t\n\t}\n\tprivate static int maxSum(int[][] a) {\n\t\tif(a==null||a.length==0||a[0].length==0){\n\t\t\treturn 0;\n\t\t}\n\t\tint max = Integer.MIN_VALUE;\n\t\tint cur = 0;\n\t\tint[] s = null;\n\t\tint i,j,k;\n\t\tint leni=a.length;\n\t\tint lenj=a[0].length;\n\t\tfor(i=0;i!=leni;i++){\n\t\t\ts = new int[lenj];\n\t\t\tint lens = s.length;\n\t\t\tfor(j=i;j!=leni;j++){\n\t\t\t\tcur=0;\n\t\t\t\tfor(k=0;k!=lens;k++){\n\t\t\t\t\ts[k] += a[j][k];\n\t\t\t\t\tcur +=s[k];\n\t\t\t\t\tmax = Math.max(max, cur);\n\t\t\t\t\tcur = cur &lt; 0 ? 0 :cur;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\t\t\n\t}\n\n}\n\r\n</textarea>	118
118	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　长100厘米的细长直杆子上有n只蚂蚁。它们的头有的朝左，有的朝右。\n  <br> \n  <br> 　　每只蚂蚁都只能沿着杆子向前爬，速度是1厘米/秒。\n  <br> \n  <br> 　　当两只蚂蚁碰面时，它们会同时掉头往相反的方向爬行。\n  <br> \n  <br> 　　这些蚂蚁中，有1只蚂蚁感冒了。并且在和其它蚂蚁碰面时，会把感冒传染给碰到的蚂蚁。\n  <br> \n  <br> 　　请你计算，当所有蚂蚁都爬离杆子时，有多少只蚂蚁患上了感冒。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行输入一个整数n (1 &lt; n &lt; 50), 表示蚂蚁的总数。\n  <br> \n  <br> 　　接着的一行是n个用空格分开的整数 Xi (-100 &lt; Xi &lt; 100), Xi的绝对值，表示蚂蚁离开杆子左边端点的距离。正值表示头朝右，负值表示头朝左，数据中不会出现0值，也不会出现两只蚂蚁占用同一位置。其中，第一个数据代表的蚂蚁感冒了。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　要求输出1个整数，表示最后感冒蚂蚁的数目。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3\n  <br> 5 -2 8\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  1\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5\n  <br> -10 8 -20 12 25\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  3\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nstruct mayi\n{\n\tint direct;  //0为左，1为右 \n\tint dist;   //距离左端点距离 \n\tint cold;  //0为正常，1为感冒 \t\n} ;\n\nint main()\n{\nint n,i,sign,j,num=0;\nscanf("%d",&amp;n);\nstruct mayi a[n];\nfor(i=0;i&lt;n;i++)\n{\nscanf("%d",&amp;a[i].dist);\na[i].dist*=2;\na[i].direct=1;\na[i].cold=0;\nif(a[i].dist&lt;0) \n{\n\ta[i].dist*=-1;\n\ta[i].direct=0;\t\n}\t\na[0].cold=1;\t\n} \n\n\t\n\tfor(;;)\n   {\n   \tsign=0;\n     \tfor(i=0;i&lt;n;i++)  //所有蚂蚁走路 \n   \t    {\n   \t\t\tif(a[i].direct==0) a[i].dist--;\n   \t\t\telse a[i].dist++;\n   \t    } \n   \n   \t    for(i=0;i&lt;n-1;i++)\n   \t   for(j=i+1;j&lt;n;j++)\n   \t    {\n\t    if(a[i].dist==a[j].dist)\n\t    {\n\t    \tif(a[i].direct==0) \n\t\t\t{a[i].direct=1;\t}\n\t    \telse a[i].direct=0;\n\t    \t\n\t    \tif(a[j].direct==0)\n\t\t\t{ a[j].direct=1;}\n\t    \telse a[j].direct=0;\n\t    \t\n\t    \tif(a[i].cold==1 ) a[j].cold=1; \n\t\t\t\n\t        if(a[j].cold==1 ) a[i].cold=1; \n\t    \t\n          }\n        }\n   \n       for(i=0;i&lt;n;i++)\n      {\n   \t  if(a[i].dist&gt;=0 &amp;&amp; a[i].dist&lt;=200)\n   \t   {\n   \t\tsign=1;\n   \t\tbreak;\n   \t\t\n     \t}\n    \t\n       }\n   \n    \tif(sign==0) break;\n   \n  }\n\tfor(i=0;i&lt;n;i++)\n\t{\n\t\t\n\t\tif(a[i].cold==1) num++;\n\t}\n\t\n\n\tprintf("%d\\n",num);\n\t\n\t\n\t\n\t\n\treturn 0;\n} \n\t\n\t\n\t\n\t\n\t\n\t\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\n\nint n,a[50],b[110];\n\n\nvoid work()\n{\n\tfor(int i=1 ; i&lt;n ; i++)\n\t{\n\t\tif(a[i]&gt;0)\n\t\t{\n\t\t\tb[a[i]] = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tb[-a[i]] = -1;\n\t\t}\n\t}\n\tint ans=1,v=a[0];\n\tbool flag=false;\n\tif(v&gt;0)\n\t{\n\t\tfor(int i=v+1 ; i&lt;110 ; i++)\n\t\t{\n\t\t\tif(b[i]&lt;0)\n\t\t\t{\n\t\t\t\tans++;\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor(int i=-v-1 ; i&gt;0 ; i--)\n\t\t{\n\t\t\tif(b[i]&gt;0)\n\t\t\t{\n\t\t\t\tans++;\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\t}\n\tif(flag)\n\t{\n\n\t\tif(v&lt;0)\n\t\t{\n\t\t\tfor(int i=-v+1 ; i&lt;110 ; i++)\n\t\t\t{\n\t\t\t\tif(b[i]&lt;0)\n\t\t\t\t{\n\t\t\t\t\tans++;\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int i=v-1 ; i&gt;0 ; i--)\n\t\t\t{\n\t\t\t\tif(b[i]&gt;0)\n\t\t\t\t{\n\t\t\t\t\tans++;\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf("%d\\n",ans);\n}\n\n\nvoid init()\n{\n\tscanf("%d",&amp;n);\n\tfor(int i=0 ; i&lt;n ; i++)\n\t{\n\t\tscanf("%d",&amp;a[i]);\n\t}\n}\n\n\nint main()\n{\n\tinit();\n\twork();\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.*;\npublic class Main{\n\tpublic static void main(String args[]){\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tint a[]=new int[n+1];\n\t\tint b[]=new int[n+1];\n\t\tfor(int i=1;i&lt;=n;i++){\n\t\t\ta[i]=sc.nextInt();\n\t\t\tif(a[i]&lt;0)\n\t\t\t\tb[i]=0;\n\t\t\telse {\n\t\t\t\tb[i]=1;\n\t\t\t}\n\t\t}\n\t\t int k=a[1]&gt;0?1:0;\n\t\t int x=0,y=0,q=0,w=0;\n\t\tfor(int i=2;i&lt;=n;i++){\n\t\t\tif(Math.abs(a[1])&lt;Math.abs(a[i])&amp;&amp;a[1]&gt;0&amp;&amp;b[i]==0)\n\t\t\t\tx++;\n\t\t\tif(Math.abs(a[1])&gt;Math.abs(a[i])&amp;&amp;a[1]&lt;0&amp;&amp;b[i]==1)\n\t\t\t\ty++;\n\t\t\tif(Math.abs(a[1])&gt;Math.abs(a[i])&amp;&amp;a[1]&gt;0&amp;&amp;b[i]==1)\n\t\t\t\tq++;\n\t\t\tif(Math.abs(a[1])&lt;Math.abs(a[i])&amp;&amp;a[1]&lt;0&amp;&amp;b[i]==0)\n\t\t\t\tw++;\n\t\t}\n\t\tif(k==1)\n\t\t\tif(x!=0)\n\t\t\tSystem.out.println(x+q+1);\n\t\t\telse\n\t\t\t\tSystem.out.println(1);\n\t\telse {\n\t\t\tif(y!=0)\n\t\t\tSystem.out.println(y+w+1);\n\t\t\telse {\n\t\t\t\tSystem.out.println(1);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n}\n\r\n</textarea>	119
119	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　X 国王有一个地宫宝库。是 n x m 个格子的矩阵。每个格子放一件宝贝。每个宝贝贴着价值标签。\n  <br> \n  <br> 　　地宫的入口在左上角，出口在右下角。\n  <br> \n  <br> 　　小明被带到地宫的入口，国王要求他只能向右或向下行走。\n  <br> \n  <br> 　　走过某个格子时，如果那个格子中的宝贝价值比小明手中任意宝贝价值都大，小明就可以拿起它（当然，也可以不拿）。\n  <br> \n  <br> 　　当小明走到出口时，如果他手中的宝贝恰好是k件，则这些宝贝就可以送给小明。\n  <br> \n  <br> 　　请你帮小明算一算，在给定的局面下，他有多少种不同的行动方案能获得这k件宝贝。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入一行3个整数，用空格分开：n m k (1&lt;=n,m&lt;=50, 1&lt;=k&lt;=12)\n  <br> \n  <br> 　　接下来有 n 行数据，每行有 m 个整数 Ci (0&lt;=Ci&lt;=12)代表这个格子上的宝物的价值\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　要求输出一个整数，表示正好取k个宝贝的行动方案数。该数字可能很大，输出它对 1000000007 取模的结果。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  2 2 2\n  <br> 1 2\n  <br> 2 1\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  2\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  2 3 2\n  <br> 1 2 3\n  <br> 2 1 5\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  14\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n\n#define N 55\n#define MOD  1000000007\n\nint map[55][55];\nint dp[55][55][15][15];\n\nint main(void)\n{\n\tint n, m, k;\n\tint i, j, c, val, aMax;\n\tscanf("%d%d%d", &amp;n, &amp;m, &amp;k);\n\taMax = 0;\n\tfor(i = 1; i &lt;= n; i++)\n\t{\n\t\tfor(j = 1; j &lt;= m; j++)\n\t\t{\n\t\t\tscanf("%d", &amp;map[i][j]);\n//\t\t\tmap[i][j]++;\n\t\t\tif(aMax &lt; map[i][j])\n\t\t\t{\n\t\t\t\taMax = map[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tmemset(dp, 0, sizeof(dp));\n\tdp[1][1][0][0] = 1;\n\tdp[1][1][1][map[1][1]] = 1;\n\tfor(i = 1; i &lt;= n; i++)\n\t{\n\t\tfor(j = 1; j &lt;= m; j++)\n\t\t{\n\t\t\tdp[i][j][0][0] += dp[i][j - 1][0][0] + dp[i - 1][j][0][0];\n\t\t\tdp[i][j][0][0] %= MOD;\n\t\t\tfor(c = 1; c &lt;= k; c++)\n\t\t\t{\n\t\t\t\tfor(val = 0; val &lt;= aMax; val++)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j][c][val] += dp[i][j - 1][c][val] + dp[i - 1][j][c][val];\n\t\t\t\t\tdp[i][j][c][val] %= MOD;\n\t\t\t\t}\n\t\t\t\tif(c == 1)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j][1][map[i][j]] += dp[i][j - 1][0][0];\n\t\t\t\t\tdp[i][j][1][map[i][j]] %= MOD;\n\t\t\t\t\tdp[i][j][1][map[i][j]] += dp[i - 1][j][0][0];\n\t\t\t\t\tdp[i][j][1][map[i][j]] %= MOD;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfor(val = 0; val &lt; map[i][j]; val++)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i][j][c][map[i][j]] += dp[i][j - 1][c - 1][val];\n\t\t\t\t\t\tdp[i][j][c][map[i][j]] %= MOD;\n\t\t\t\t\t\tdp[i][j][c][map[i][j]] += dp[i - 1][j][c - 1][val];\n\t\t\t\t\t\tdp[i][j][c][map[i][j]] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint sum = 0;\n\tfor(i = 0; i &lt;= aMax; i++)\n\t{\n\t\tsum += dp[n][m][k][i];\n\t\tsum %= MOD;\n\t}\n\tprintf("%d", sum);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#pragma comment(linker,"/STACK:102400000,102400000")\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n//#include &lt;fstream&gt;\n#include &lt;climits&gt;\n#include &lt;cstdlib&gt;\n#include &lt;cstring&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;cstdio&gt;\n#include &lt;queue&gt;\n#include &lt;stack&gt;\n#include &lt;cmath&gt;\n#include &lt;list&gt;\n#include &lt;set&gt;\n#include &lt;map&gt;\n\n#define sf scanf\n#define pf printf\n#define fst first\n#define scd second\n#define pb push_back\n#define mkp make_pair\n#define cls(a,x) memset(a,x,sizeof a)\n#define dt(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;" ";\n#define dte(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;\n\n#if(defined(_WIN32)||defined(__WIN32__))\ntypedef __int64 LL;\ntypedef unsigned __int64 ULL;\n#define ll I64\n#else\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define I64 ll\n#endif\n\nusing namespace std;\ntemplate&lt;class T&gt;inline void scaf(T &amp;v)\n{\n\tchar ch;\n\twhile(ch=getchar())\n\t\tif(ch&lt;='9' &amp;&amp; ch&gt;='0') break;\n\tv=ch-'0';\n\twhile(ch=getchar())\n\t\tif(ch&lt;='9' &amp;&amp; ch&gt;='0') v=(v&lt;&lt;1)+(v&lt;&lt;3)+ch-'0';\n\t\telse break;\n}\n\ntypedef pair&lt;int,int &gt; PII;\nconst int MX=50100;\nconst int mod=1000000007;\n\nint sp[51][51];\nint g[51][51];\nLL dp[51][51][13];\n\ninline void run()\n{\n\tint n,m,k,i,j,ii,jj,kk;\n\tscanf("%d%d%d",&amp;n,&amp;m,&amp;k);\n\tfor(i=1;i&lt;=50;++i)\n\t\tsp[i][1]=sp[1][i]=1;\n\tfor(i=2;i&lt;=n;++i)\n\t\tfor(j=2;j&lt;=m;++j)\n\t\t\tsp[i][j]=sp[i-1][j]+sp[i][j-1];\n\tfor(i=1;i&lt;=n;++i)\n\t{\n\t\tfor(j=1;j&lt;=m;++j)\n\t\t{\n\t\t\tscanf("%d",&amp;g[i][j]);\n\t\t\tdp[i][j][1]=sp[i][j];\n\t\t}\n\t}\n\tfor(i=1;i&lt;=n;++i)\n\t{\n\t\tfor(j=1;j&lt;=m;++j)\n\t\t{\n\t\t\tfor(ii=1;ii&lt;=i;++ii)\n\t\t\t{\n\t\t\t\tfor(jj=1;jj&lt;=j;++jj)\n\t\t\t\t{\n\t\t\t\t\tif(g[ii][jj]&lt;g[i][j])\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(kk=2;kk&lt;=k;++kk)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdp[i][j][kk]+=dp[ii][jj][kk-1]*sp[i-ii+1][j-jj+1];\n\t\t\t\t\t\t\tdp[i][j][kk]%=mod;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n//\tfor(i=1;i&lt;=n;++i)\n//\t{\n//\t\tfor(j=1;j&lt;=m;++j)\n//\t\t{\n//\t\t\tpf("%d ",dp[i][j][k]);\n//\t\t}\n//\t\tputchar(10);\n//\t}\n\tLL Ans=0;\n\tfor(i=1;i&lt;=n;++i)\n\t{\n\t\tfor(j=1;j&lt;=m;++j)\n\t\t{\n\t\t\tAns+=dp[i][j][k]*sp[n-i+1][m-j+1];\n\t\t\tAns%=mod;\n\t\t}\n\t}\n\tpf("%I64d\\n",Ans);\n}\n\nint main()\n{\n\trun();\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\nimport java.util.Arrays;\n\npublic class Main\n{\n\tprivate static StreamTokenizer tokenizer = new StreamTokenizer(\n\t\t\tnew InputStreamReader(System.in));\n\tprivate static PrintWriter outWriter = new PrintWriter(\n\t\t\tnew OutputStreamWriter(System.out));\n\n\tprivate static int n, m, k;\n\tprivate static int[][] table;\n\tprivate static final int MOD = 1000000007;\n\tprivate static long[][][][] state;\n\n\tprivate static long dfs(int i, int j, int num, int max)\n\t{\n\t\tif (state[i][j][num][max] != -1)\n\t\t\treturn state[i][j][num][max];\n\n\t\tlong currentAns = 0;\n\n\t\tif (i == n - 1 &amp;&amp; j == m - 1)\n\t\t{\n\t\t\tif (num == k || max &lt; table[i][j] &amp;&amp; num + 1 == k)\n\t\t\t\tcurrentAns++;\n\t\t\tstate[i][j][num][max] = currentAns;\n\t\t\treturn currentAns;\n\t\t}\n\n\t\tif (i + 1 &lt; n)\n\t\t{\n\t\t\tcurrentAns += dfs(i + 1, j, num, max);\n\t\t\tif (max &lt; table[i][j] &amp;&amp; num + 1 &lt;= k)\n\t\t\t\tcurrentAns += dfs(i + 1, j, num + 1, table[i][j]);\n\t\t}\n\t\tif (j + 1 &lt; m)\n\t\t{\n\t\t\tcurrentAns += dfs(i, j + 1, num, max);\n\t\t\tif (max &lt; table[i][j] &amp;&amp; num + 1 &lt;= k)\n\t\t\t\tcurrentAns += dfs(i, j + 1, num + 1, table[i][j]);\n\t\t}\n\t\tstate[i][j][num][max] = currentAns;\n\t\treturn currentAns;\n\t}\n\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\ttokenizer.nextToken();\n\t\tn = (int) tokenizer.nval;\n\t\ttokenizer.nextToken();\n\t\tm = (int) tokenizer.nval;\n\t\ttokenizer.nextToken();\n\t\tk = (int) tokenizer.nval;\n\n\t\ttable = new int[n][m];\n\t\tstate = new long[n][m][k + 1][14];\n\n\t\tfor (int i = 0; i &lt; n; i++)\n\t\t\tfor (int j = 0; j &lt; m; j++)\n\t\t\t\tfor (int t = 0; t &lt;= k; t++)\n\t\t\t\t\tArrays.fill(state[i][j][t], -1);\n\n\t\tfor (int i = 0; i &lt; n; i++)\n\t\t\tfor (int j = 0; j &lt; m; j++)\n\t\t\t{\n\t\t\t\ttokenizer.nextToken();\n\t\t\t\ttable[i][j] = (int) tokenizer.nval;\n\t\t\t\ttable[i][j]++;\n\t\t\t}\n\n\t\tlong ret = dfs(0, 0, 0, 0);\n\n\t\toutWriter.println(ret % MOD);\n\t\toutWriter.flush();\n\t}\n}\n\r\n</textarea>	120
120	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　斐波那契数列大家都非常熟悉。它的定义是：\n  <br> \n  <br> 　　f(x) = 1 .... (x=1,2)\n  <br> 　　f(x) = f(x-1) + f(x-2) .... (x&gt;2)\n  <br> \n  <br> 　　对于给定的整数 n 和 m，我们希望求出：\n  <br> 　　f(1) + f(2) + ... + f(n) 的值。但这个值可能非常大，所以我们把它对 f(m) 取模。\n  <br> 　　公式如下\n  <br> \n  <img src="/RequireFile.do?fid=hyry39mn" width="302" height="78">\n  <br> \n  <br> 　　但这个数字依然很大，所以需要再对 p 求模。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入为一行用空格分开的整数 n m p (0 &lt; n, m, p &lt; 10^18)\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出为1个整数，表示答案\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  2 3 5\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  0\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  15 11 29\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  25\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\nlong long n,m,p,cnt,sum,flag1,flag2,value,mod;\ntypedef struct{\n\tlong long a[3][3];\n}matrix;\nmatrix origin,res;\nmatrix multiply(matrix x,matrix y)\n{\n\tmatrix temp;\n\tmemset(temp.a,0,sizeof(temp.a));\n\tint i,j,k;\n\tlong long l;\n\tfor(i=1;i&lt;3;i++)\n\t{\n\t\tfor(j=1;j&lt;3;j++)\n\t\t{\n\t\t\tfor(k=1;k&lt;3;k++)\n\t\t\t{\n\t\t\t\tif(x.a[i][k]!=0)\n\t\t\t\t{\n\t\t\t\t\t\tlong long valuea,valueb,sum=0;\n\t\t\t\t\t\tvaluea=x.a[i][k];\n\t\t\t\t\t\tvalueb=y.a[k][j];\t\t\t\t\n\t\t\t\t\t\tint len_flag1=0,len_flag2=0;\n\t\t\t\t\t\tflag1=valueb/(p/valuea+1);\n\t\t\t\t\t\tflag2=valuea*(p/valuea+1)-p;\n\t\t\t\t\t\tvalue=flag1;\n\t\t\t\t\t\twhile(value)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlen_flag1++;\n\t\t\t\t\t\t\tvalue/=10;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalue=flag2;\n\t\t\t\t\t\twhile(value)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlen_flag2++;\n\t\t\t\t\t\t\tvalue/=10;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsum=(sum+valueb%(p/valuea+1)*valuea)%p;\t\n\t\t\t\t\t\twhile(len_flag1+len_flag2&gt;18&amp;&amp;flag1!=0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvaluea=flag1;\n\t\t\t\t\t\t\tvalueb=flag2;\t\t\t\t\n\t\t\t\t\t\t\tint len_flag1=0,len_flag2=0;\n\t\t\t\t\t\t\tflag1=valueb/(p/valuea+1);\n\t\t\t\t\t\t\tflag2=valuea*(p/valuea+1)-p;\n\t\t\t\t\t\t\tvalue=flag1;\n\t\t\t\t\t\t\twhile(value)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlen_flag1++;\n\t\t\t\t\t\t\t\tvalue/=10;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvalue=flag2;\n\t\t\t\t\t\t\twhile(value)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlen_flag2++;\n\t\t\t\t\t\t\t\tvalue/=10;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsum=(sum+valueb%(p/valuea+1)*valuea)%p;\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttemp.a[i][j]=(temp.a[i][j]+flag1*flag2%p+sum)%p;\t\t\t\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\treturn temp;\n}\nmatrix multiply1(matrix x,matrix y)\n{\n\tmatrix temp;\n\tmemset(temp.a,0,sizeof(temp.a));\n\tint i,j,k;\n\tfor(i=1;i&lt;3;i++)\n\t{\n\t\tfor(j=1;j&lt;3;j++)\n\t\t{\n\t\t\tfor(k=1;k&lt;3;k++)\n\t\t\t{\n\t\t\t\ttemp.a[i][j]=(temp.a[i][j]+x.a[i][k]*y.a[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\treturn temp;\n}\nvoid init()\n{\n\torigin.a[1][1]=origin.a[1][2]=origin.a[2][1]=1;\n\tres.a[1][1]=res.a[2][2]=1;\n\torigin.a[2][2]=res.a[1][2]=res.a[2][1]=0;\n}\nint main()\n{\n\tscanf("%I64d %I64d %I64d",&amp;n,&amp;m,&amp;p);\n\tif(m&gt;=n+2)\n\t{\n\t\tn+=2;\n\t\tinit();\n\t\twhile(n)\n\t\t{\n\t\t\tif(n&amp;1)\n\t\t\t\tres=multiply(res,origin);\n\t\t\tn&gt;&gt;=1;\n\t\t\torigin=multiply(origin,origin);\n\t\t}\t\t\n\t\tif(res.a[1][2]==0)\n\t\t{\n\t\t\tprintf("%I64d\\n",p-1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf("%I64d\\n",res.a[1][2]-1);\n\t\t}\n\t}\n\telse\n\t{\n\t\tinit();\n\t\twhile(m)\n\t\t{\n\t\t\tif(m&amp;1)\n\t\t\t\tres=multiply1(res,origin);\n\t\t\tm&gt;&gt;=1;\n\t\t\torigin=multiply1(origin,origin);\n\t\t}\n\t\tmod=res.a[1][2];\n\t\tn+=2;\n\t\tinit();\t\t\n\t\twhile(n)\n\t\t{\n\t\t\tif(n&amp;1)\n\t\t\t\tres=multiply1(res,origin);\n\t\t\tn&gt;&gt;=1;\n\t\t\torigin=multiply1(origin,origin);\n\t\t}\t\t\n\t\tprintf("%I64d\\n",(res.a[1][2]-1)%mod%p);\n\t}\t\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;map&gt;\n#include &lt;set&gt;\n#include &lt;list&gt;\n#include &lt;cmath&gt;\n#include &lt;ctime&gt;\n#include &lt;deque&gt;\n#include &lt;queue&gt;\n#include &lt;stack&gt;\n#include &lt;bitset&gt;\n#include &lt;cctype&gt;\n#include &lt;cstdio&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;cstdlib&gt;\n#include &lt;cstring&gt;\n#include &lt;iomanip&gt;\n#include &lt;sstream&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\n#define PB push_back\n#define MP make_pair\n#define AA first\n#define BB second\n#define OP begin()\n#define ED end()\n#define SZ size()\n#define SORT(x) sort(x.OP,x.ED)\n#define SQ(x) ((x)*(x))\n#define SSP system("pause")\n#define cmin(x,y) x=min(x,y)\n#define cmax(x,y) x=max(x,y)\ntypedef long long LL;\ntypedef pair&lt;int, int&gt; PII;\nconst double eps=1e-8;\nconst double INF=1e20;\nconst double PI=acos( -1. );\nconst int MXN = 50;\nconst LL MOD = 1000000007;\nLL llmul( LL a,LL b,LL mod ) {\n\ta%=mod;a+=mod;a%=mod;\n\tb%=mod;b+=mod;b%=mod;\n\tif ( a&lt;b )swap( a,b );\n\tLL ret=0;\n\twhile ( b ) {\n\t\tif ( b&amp;1 )ret=( ret+a )%mod;\n\t\ta=( a&lt;&lt;1 )%mod;\n\t\tb/=2;\n\t}\n\treturn ret;\n}\nstruct matrix {\n\tLL x[3][3];\n\tmatrix() {memset( x,0,sizeof x );}\n};\nmatrix mmul( matrix &amp;A,matrix &amp;B,LL mod ) {\n\tmatrix ret;\n\tfor ( int i=1; i&lt;=2; i++ )\n\t\tfor ( int j=1; j&lt;=2; j++ )\n\t\t\tfor ( int k=1; k&lt;=2; k++ )\n\t\t\t\tret.x[i][j]=( ret.x[i][j]+llmul( A.x[i][k],B.x[k][j],mod ) )%mod;\n\treturn ret;\n}\nmatrix E;\nmatrix A;\nLL fib( LL n,LL mod ) {\n\tmatrix O=E,B=A;\n\twhile ( n ) {\n\t\tif ( n&amp;1 )O=mmul( O,B,mod );\n\t\tB=mmul( B,B,mod );\n\t\tn/=2;\n\t}\n\treturn O.x[1][2];\n}\n//[(2*3)%5]%3=1\n//(2%3)*(3%3)=0\nLL solve( LL n,LL m,LL mod ) {\n\t//f(n)%f(m)%mod\n\tLL t=n/m;\n\t//(f(m-1)^t*f(n%m))%f(m)%mod;\n\t//f(i)^2%f(i-1)=(-1)^(i+1)\n\tLL p=t/2,q=t%2;\n\t//{f(m-1)^q*(-1)^(pm)*f(n%m)}%f(m)%mod\n\tLL fuhao=p*m%2==0?1:-1;\n\tif ( q==0 ) {\n\t\tLL ans=fib( n%m,mod )*fuhao;\n\t\tans%=mod;\n\t\tans+=mod;\n\t\treturn ans%mod;\n\t}\n\tif ( n%m==0 )return 0;\n\t//f(m-1)*f(n%m)*fuhao%f(m)%mod\n//\tcout&lt;&lt;fib(m-1,mod&lt;&lt;5)*fib(n%m,mod*111111)*fuhao%fib(m,mod&lt;&lt;5)%mod&lt;&lt;endl;\n//\tcout&lt;&lt;fib(m-1,mod&lt;&lt;5)&lt;&lt;"*"&lt;&lt;fib(n%m,mod&lt;&lt;5)&lt;&lt;"*"&lt;&lt;fuhao&lt;&lt;"%"&lt;&lt;fib(m,mod&lt;&lt;5)&lt;&lt;"%"&lt;&lt;mod&lt;&lt;endl;\n//\tcout&lt;&lt;fib(n%m,mod&lt;&lt;5)*fib(m-1,mod&lt;&lt;5)/fib(m,mod&lt;&lt;5)&lt;&lt;endl;\n\t//x%y%mod=(x-a*y)%mod\n\t//a=[x/y]\n\tLL x=(llmul(fib(n%m,mod),fib(m-1,mod),mod)*fuhao%mod+mod)%mod;\n\tLL y=fib(m,mod);\n\tLL a=fib(n%m-1,mod);\n\tif(n%m%2==0)a--;\n\tif(fuhao&lt;0)a++;\n\ta=(a%mod+mod)%mod;\n//\tcout&lt;&lt;a&lt;&lt;endl;\n\treturn ((x-llmul(a,y,mod))%mod+mod)%mod;\n}\nint main() {\n\tint i,j;\n\tA.x[1][2]=A.x[2][1]=A.x[2][2]=1;\n\tE.x[1][1]=E.x[2][2]=1;\n\tLL n,m,mod;\n\twhile ( cin&gt;&gt;n&gt;&gt;m&gt;&gt;mod )\n\t\tcout&lt;&lt;( solve( n+2,m,mod )-1+mod )%mod&lt;&lt;endl;\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.math.BigInteger;\nimport java.util.Scanner;\n\n\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc=new Scanner(System.in);\n\t\tlong n,m;\n\t\tn=sc.nextLong();\n\t\tm=sc.nextLong();\n\t\tBigInteger p=sc.nextBigInteger(),fn,fm;\n\t\tif(n+2&gt;m)\n\t\t{\n\t\t\tfm=think(m,null);\n\t\t\tfn=think(n+2,fm).subtract(new BigInteger("1"));\n\t\t\tSystem.out.println(fn.remainder(fm).remainder(p));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfn=think(n+2,p).subtract(new BigInteger("1"));\n\t\t\tSystem.out.println(fn.remainder(p));\n\t\t}\n\t}\n\n\tprivate static BigInteger think(long m,BigInteger mod) {\n\t\t// TODO Auto-generated method stub\n\t\tBigInteger a1=new BigInteger("1"),a2=new BigInteger("1"),x[][];\n\t\tif(m==1)return a1;\n\t\telse if(m==2)return a2;\n\t\telse\n\t\t{\n\t\t\tx=new BigInteger[2][2];\n\t\t\tx[0][0]=new BigInteger("1");\n\t\t\tx[0][1]=new BigInteger("1");\n\t\t\tx[1][0]=new BigInteger("1");\n\t\t\tx[1][1]=new BigInteger("0");\n\t\t\tx=doublex(x,m-2,mod);\n\t\t\treturn x[0][0].add(x[0][1]);\n\t\t}\n\t}\n\n\tprivate static BigInteger[][] doublex(BigInteger[][] x, long n,BigInteger mod) {\n\t\t// TODO Auto-generated method stub\n\t\tBigInteger x2[][];\n\t\tx2=new BigInteger[2][2];\n\t\tif(n==1)return x;\n\t\telse\n\t\t{\n\t\t\tif(n%2==1)return cheng(doublex(cheng(x,x,mod),n/2,mod),x,mod);\n\t\t\telse return doublex(cheng(x,x,mod),n/2,mod);\n\t\t}\n\t}\n\n\tprivate static BigInteger[][] cheng(BigInteger[][] x, BigInteger[][] y,BigInteger mod) {\n\t\t// TODO Auto-generated method stub\n\t\tBigInteger z[][];\n\t\tz=new BigInteger[2][2];\n\t\tif(mod!=null)\n\t\t{\n\t\t\tz[0][0]=x[0][0].multiply(y[0][0]).add(x[1][0].multiply(y[0][1])).remainder(mod);\n\t\t\tz[0][1]=x[0][0].multiply(y[0][1]).add(x[0][1].multiply(y[1][1])).remainder(mod);\n\t\t\tz[1][0]=x[1][0].multiply(y[0][0]).add(x[1][1].multiply(y[1][0])).remainder(mod);\n\t\t\tz[1][1]=x[1][0].multiply(y[0][1]).add(x[1][1].multiply(y[1][1])).remainder(mod);\n\t\t\treturn z;\n\t\t}\n\t\tz[0][0]=x[0][0].multiply(y[0][0]).add(x[1][0].multiply(y[0][1]));\n\t\tz[0][1]=x[0][0].multiply(y[0][1]).add(x[0][1].multiply(y[1][1]));\n\t\tz[1][0]=x[1][0].multiply(y[0][0]).add(x[1][1].multiply(y[1][0]));\n\t\tz[1][1]=x[1][0].multiply(y[0][1]).add(x[1][1].multiply(y[1][1]));\n\t\treturn z;\n\t}\n\n\t\n}\r\n</textarea>	121
121	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　观察这个数列：\n  <br> 　　1 3 0 2 -1 1 -2 ...\n  <br> \n  <br> 　　这个数列中后一项总是比前一项增加2或者减少3。\n  <br> \n  <br> 　　栋栋对这种数列很好奇，他想知道长度为 n 和为 s 而且后一项总是比前一项增加a或者减少b的整数数列可能有多少种呢？\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入的第一行包含四个整数 n s a b，含义如前面说述。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出一行，包含一个整数，表示满足条件的方案数。由于这个数很大，请输出方案数除以100000007的余数。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  4 10 2 3\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  2\n </div>\n <div class="pdsec">\n  样例说明\n </div>\n <div class="pdcont">\n  　　这两个数列分别是2 4 1 3和7 4 1 -2。\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　对于10%的数据，1&lt;=n&lt;=5，0&lt;=s&lt;=5，1&lt;=a,b&lt;=5；\n  <br> 　　对于30%的数据，1&lt;=n&lt;=30，0&lt;=s&lt;=30，1&lt;=a,b&lt;=30；\n  <br> 　　对于50%的数据，1&lt;=n&lt;=50，0&lt;=s&lt;=50，1&lt;=a,b&lt;=50；\n  <br> 　　对于70%的数据，1&lt;=n&lt;=100，0&lt;=s&lt;=500，1&lt;=a, b&lt;=50；\n  <br> 　　对于100%的数据，1&lt;=n&lt;=1000，-1,000,000,000&lt;=s&lt;=1,000,000,000，1&lt;=a, b&lt;=1,000,000。\n </div> \n</div>	<textarea id="codelinesc">\r\n#define mod 100000007\r\nint n,s,a,b,x[1001][1001],i,j,t;\r\nfun()\r\n{\r\n\twhile(x[i+1][t]&gt;=mod)x[i+1][t]-=mod;\r\n}\r\nint main()\r\n{\r\n\tscanf("%d%d%d%d",&amp;n,&amp;s,&amp;a,&amp;b);\r\n\tb%=n;\r\n\tb*=-1;\r\n\twhile(b&lt;0)b+=n;\r\n\ta%=n;\r\n\ts%=n;\r\n\twhile(s&lt;0)s+=n;\r\n\tfor(i=0;i&lt;n;i++)\r\n\t\tfor(j=0;j&lt;n;j++)\r\n\t\t\tx[i][j]=0;\r\n\tx[1][a]=x[1][b]=1;\r\n\tfor(i=1;i&lt;n-1;i++)\r\n\t\tfor(j=0;j&lt;n;j++)\r\n\t\t{\r\n\t\t\tt=(j+a*(i+1))%n;\r\n\t\t\tx[i+1][t]+=x[i][j];\r\n\t\t\tfun();\r\n\t\t\tt=(j+b*(i+1))%n;\r\n\t\t\tif(t&gt;=n)\r\n\t\t\t\tt-=n;\r\n\t\t\tx[i+1][t]+=x[i][j];\r\n\t\t\tfun();\r\n\t\t}\r\n\tprintf("%d\\n",x[n-1][s]);\r\n\treturn 0;\r\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\n#include&lt;iostream&gt;\nusing namespace std;\nconst int mod=100000007;\nint a,b,n,s,dp[1005][1005],i,j,jt;\nvoid cut(int &amp;a)\n{\n  while(a&gt;=mod){\n    a-=mod;\n  }\n  return;\n}\nint main(){\n  scanf("%d%d%d%d",&amp;n,&amp;s,&amp;a,&amp;b);\n  b%=n;\n  b*=-1;\n  while(b&lt;0){\n    b+=n;\n  }\n  a%=n;\n  s%=n;\n  while(s&lt;0){\n    s+=n;\n  }\n  for(i=0;i&lt;n;++i){\n    for(j=0;j&lt;n;++j){\n      dp[i][j]=0;\n    }\n  }\n  dp[1][a]=dp[1][b]=1;\n  for(i=1;i&lt;n-1;++i){\n    for(j=0;j&lt;n;++j){\n      jt=(j+a*(i+1))%n;\n      dp[i+1][jt]+=dp[i][j];\n      cut(dp[i+1][jt]);\n      jt=(j+b*(i+1))%n;\n      if(jt&gt;=n){\n        jt-=n;\n      }\n      dp[i+1][jt]+=dp[i][j];\n      cut(dp[i+1][jt]);\n    }\n  }\n  printf("%d\\n",dp[n-1][s]);\n  return 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tint mod = 100000007;\n\t\tint n, s, a, b, i, j, t;\n\t\tint x[][] = new int[1001][1001];\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\ts = sc.nextInt();\n\t\ta = sc.nextInt();\n\t\tb = sc.nextInt();\n\t\tb %= n;\n\t\tb *= -1;\n\t\twhile (b &lt; 0)\n\t\t\tb += n;\n\t\ta %= n;\n\t\ts %= n;\n\t\twhile (s &lt; 0)\n\t\t\ts += n;\n\t\tfor (i = 0; i &lt; n; i++)\n\t\t\tfor (j = 0; j &lt; n; j++)\n\t\t\t\tx[i][j] = 0;\n\t\tx[1][a] = x[1][b] = 1;\n\t\tfor (i = 1; i &lt; n - 1; i++)\n\t\t\tfor (j = 0; j &lt; n; j++) {\n\t\t\t\tt = (j + a * (i + 1)) % n;\n\t\t\t\tx[i + 1][t] += x[i][j];\n\t\t\t\tx[i + 1][t] %= mod;\n\t\t\t\tt = (j + b * (i + 1)) % n;\n\t\t\t\tt %= n;\n\t\t\t\tx[i + 1][t] += x[i][j];\n\t\t\t\tx[i + 1][t] %= mod;\n\t\t\t}\n\t\tSystem.out.printf("%d\\n", x[n - 1][s]);\n\t}\n}\n\r\n</textarea>	122
122	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　n 个小朋友站成一排。现在要把他们按身高从低到高的顺序排列，但是每次只能交换位置相邻的两个小朋友。\n  <br> \n  <br> 　　每个小朋友都有一个不高兴的程度。开始的时候，所有小朋友的不高兴程度都是0。\n  <br> \n  <br> 　　如果某个小朋友第一次被要求交换，则他的不高兴程度增加1，如果第二次要求他交换，则他的不高兴程度增加2（即不高兴程度为3），依次类推。当要求某个小朋友第k次交换时，他的不高兴程度增加k。\n  <br> \n  <br> 　　请问，要让所有小朋友按从低到高排队，他们的不高兴程度之和最小是多少。\n  <br> \n  <br> 　　如果有两个小朋友身高一样，则他们谁站在谁前面是没有关系的。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入的第一行包含一个整数n，表示小朋友的个数。\n  <br> 　　第二行包含 n 个整数 H1 H2 … Hn，分别表示每个小朋友的身高。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出一行，包含一个整数，表示小朋友的不高兴程度和的最小值。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3\n  <br> 3 2 1\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  9\n </div>\n <div class="pdsec">\n  样例说明\n </div>\n <div class="pdcont">\n  　　首先交换身高为3和2的小朋友，再交换身高为3和1的小朋友，再交换身高为2和1的小朋友，每个小朋友的不高兴程度都是3，总和为9。\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　对于10%的数据， 1&lt;=n&lt;=10；\n  <br> 　　对于30%的数据， 1&lt;=n&lt;=1000；\n  <br> 　　对于50%的数据， 1&lt;=n&lt;=10000；\n  <br> 　　对于100%的数据，1&lt;=n&lt;=100000，0&lt;=Hi&lt;=1000000。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n\nint h[100100];\nint un[100100];\n\nint b[1000100];\nint reb[1000100];\n\nint Lowbit(int x){\n    return x&amp;(x^(x-1));\n}\n\nint sum(int bit[], int idx){\n\tint ret = 0;\n\twhile(idx &gt; 0){\n\t\tret += bit[idx];\n\t\tidx -= Lowbit(idx);\n\t}\n\treturn ret;\n}\n\nvoid add(int bit[], int idx, int val){\n\twhile(idx &lt; 1000100){\n\t\tbit[idx] += val;\n\t\tidx += Lowbit(idx);\n\t}\n}\n\nlong long uVal[100100];\n\nint main(void){\n\tint n, i;\n\tscanf("%d", &amp;n);\n\tuVal[0] = 0;\n\tfor(i = 0; i &lt; n; i++){\n\t\tscanf("%d", &amp;h[i]);\n\t\th[i]++;\n\t\tuVal[i + 1] = uVal[i] + i + 1;\n\t\t\n\t\tun[i] += i - sum(b, h[i]);\n\t\tadd(b, h[i], 1);\n\t}\n\tlong long ans = 0;\n\tfor(i = n - 1; i &gt;= 0; i--){\n\t\tun[i] += sum(reb, h[i] - 1);\n\t\tadd(reb, h[i], 1);\n\t\t\n\t\tans += uVal[un[i]];\n\t}\n\tprintf("%I64d\\n", ans);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include&lt;queue&gt;\n#include&lt;set&gt;\n#include&lt;stack&gt;\n#include&lt;map&gt;\n#include&lt;cmath&gt;\n#include&lt;vector&gt;\n#include&lt;string&gt;\n#define __LL64 long long\n#define clr(a) memset(a,0,sizeof a)\nusing namespace std;\nconst double pi  = acos(-1.0);\nconst double eps = 1e-9;\nconst long long M = 1000000007;\nconst long long INF = 0x3f3f3f3f;\ntypedef long long LL;\ntypedef unsigned long long ULL;\nconst LL dir[4][2] = {0,1,-1,0,0,-1,1,0};\nusing namespace std;\n\nLL _buf[20];\ninline long long read()\n{\n    char c = getchar();\n    LL isMinus = 1;\n    long long x = 0;\n    while ( c!='-' &amp;&amp; ( c&lt;'0' || c&gt;'9' )) c = getchar();\n    if (c=='-') {isMinus = -1;c= getchar();}\n    while ( c&gt;='0' &amp;&amp;c&lt;='9' ) {x = x*10+c-'0';c=getchar();}\n    return x * isMinus;\n}\ninline void write(long long num,LL flag = 1)\n{\n    memset(_buf,0,sizeof(_buf));\n    if (num&lt;0) {putchar('-');num=-num;}\n    LL p = 0;\n    if (num==0) p++;\n    else while (num){_buf[p++]=num%10;num/=10;}\n    for (LL i=p-1;i&gt;=0;--i) putchar(_buf[i]+'0');\n    if (flag==1) puts("");\n    if (flag==0) printf(" ");\n}\n\nconst LL Max = 111111;\nint n,C[Max],a[Max],b[Max];\nLL table[Max];\n\nint lowbit(int x) {return x&amp;(-x);}\nvoid add(int x) { while(x&lt;=n) { C[x]++;x+=lowbit(x); } }\n\nint sum(int x)\n{\n    int ans = 0;\n    while (x&gt;0) {ans+=C[x];\n    x-=lowbit(x);}\n    return ans;\n}\n\nvoid hs()\n{\n    sort(b,b+n);\n    for (int i=0;i&lt;n;++i)\n        a[i] = lower_bound(b,b+n,a[i]) - b + 1;\n}\n\nint main(){\n\n    for (int i=1;i&lt;Max;++i)\n        table[i] = table[i-1] + i;\n    while (scanf("%d",&amp;n)!=EOF)\n    {\n\n        for (int i=0;i&lt;n;++i) b[i] =  a[i] = read();\n        hs();\n\n        clr (b);\n        clr (C);\n        for (int i=0;i&lt;n;++i)\n        {\n            add(a[i]);\n            b[i] += i + 1- sum(a[i]);\n        }\n        clr(C);\n        for (int i=n-1;i&gt;=0;i--)\n        {\n            add(a[i]);\n            b[i] += sum(a[i]-1);\n        }\n\n\n        LL ans = 0;\n        for (int i=0;i&lt;n;++i)\n            ans += table[ b[i] ];\n        write(ans);\n    }\n    return 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main{\n\tstatic int N = 100010;\n\tstatic int MAX = 1000100;\n\n\tstatic int[] C = new int[MAX];\n\tstatic int[] S = new int[MAX];\n\tstatic int[] b = new int[N];\n\tstatic long[] total = new long[N];\n\tstatic long ans;\n\tstatic int[] num = new int[N];\n\tstatic int T, s, t, i, j;\n\n\tstatic int Lowbit(int x) {\n\t\treturn x &amp; (-x);\n\t}\n\n\tstatic void add(int pos, int num, int[] P) {\n\t\twhile (pos &lt;= MAX) {\n\t\t\tP[pos] += num;\n\t\t\tpos += Lowbit(pos);\n\t\t}\n\t}\n\n\tstatic int Sum(int end, int[] P) {\n\t\tint cnt = 0;\n\t\twhile (end &gt; 0) {\n\t\t\tcnt += P[end];\n\t\t\tend -= Lowbit(end);\n\t\t}\n\t\treturn cnt;\n\t}\n\n\tstatic void init() {\n\t\ttotal[0] = 0;\n\t\tfor (int i = 1; i &lt; N; ++i) {\n\t\t\ttotal[i] = total[i - 1] + i;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tinit();\n\t\tBufferedReader buf = new BufferedReader(\n\t\t\t\tnew InputStreamReader(System.in));\n\t\tT = Integer.parseInt(buf.readLine());\n\t\tString[] str = buf.readLine().split(" ");\n\t\tfor (int j = 0; j &lt; T; j++) {\n\t\t\tnum[j] = Integer.parseInt(str[j]);\n\t\t\tadd(num[j] + 1, 1, C);\n\t\t\tb[j] = j - Sum(num[j], C);\n\t\t\t\t\t\t\t\t\t\t\n\t\t\tb[j] -= Sum(num[j] + 1, C) - Sum(num[j], C) - 1;\n\n\t\t}\n\n\t\tans = 0;\n\t\tfor (int j = T - 1; j &gt; -1; --j) {\n\t\t\tadd(num[j] + 1, 1, S);\n\t\t\tb[j] += Sum(num[j], S);\n\n\t\t\tans += total[b[j]];\n\t\t}\n\n\t\tSystem.out.println(ans);\n\n\t}\n\n}\r\n</textarea>	123
123	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　有n个小朋友围坐成一圈。老师给每个小朋友随机发偶数个糖果，然后进行下面的游戏：\n  <br> \n  <br> 　　每个小朋友都把自己的糖果分一半给左手边的孩子。\n  <br> \n  <br> 　　一轮分糖后，拥有奇数颗糖的孩子由老师补给1个糖果，从而变成偶数。\n  <br> \n  <br> 　　反复进行这个游戏，直到所有小朋友的糖果数都相同为止。\n  <br> \n  <br> 　　你的任务是预测在已知的初始糖果情形下，老师一共需要补发多少个糖果。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　程序首先读入一个整数N(2&lt;N&lt;100)，表示小朋友的人数。\n  <br> 　　接着是一行用空格分开的N个偶数（每个偶数不大于1000，不小于2）\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　要求程序输出一个整数，表示老师需要补发的糖果数。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3\n  <br> 2 2 4\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  4\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;malloc.h&gt;\nint count=0;\nvoid f(int n,int *m)\n{\n\tint j,temp=m[0];\n\tfor(j=n-1;j&gt;0;j--)\n\t\tm[(j+1)%n]+=(m[j]/=2);\n\tm[1]+=temp/2;\n\tm[0]-=temp/2;\n\tfor(j=0;j&lt;n;j++)\n\t{\n\t\tif(m[j]%2!=0)\n\t\t{\n\t\t\t m[j]++;\n\t\t\t count++;\n\t\t}\n\t}\n}\nint jisuan(int n,int *m)\n{\n\tint j;\n\tfor(j=0;j&lt;n-1;j++)\n\t\tif(m[j]!=m[j+1]) return 0;\n\treturn 1;\n}\nint main()\n{\n\tint n,j;\n\tscanf("%d",&amp;n);\n\tint *m=(int*)malloc(sizeof(int)*n);\n\tfor(j=0;j&lt;n;j++)\n\t\tscanf("%d",&amp;m[j]);\n\tdo\n\t{\n\t\tf(n,m);\n\t}\n\twhile(jisuan(n,m)!=1);\n\tprintf("%d",count);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\nusing namespace std;\n\nint a[100];                            // 小朋友人数&lt;100\n\nbool notEqual(int n)\n{\n\tfor (int i = 1; i &lt; n; ++i)\n\t\tif (a[0] != a[i])\n\t\t\treturn true;\n\treturn false;\n}\n\nint main()\n{\n\tint i, n, t, s = 0;\n\tcin &gt;&gt; n;\n\tfor (i = 0; i &lt; n; ++i)\n\t\tcin &gt;&gt; a[i];\n\twhile ( notEqual(n) )\n\t{\n\t\ta[0] /= 2;\n\t\tt = a[0];\n\t\tfor (i = 1; i &lt; n; ++i)\n\t\t{\n\t\t\ta[i] /= 2;\n\t\t\ta[i-1] += a[i];\n\t\t}\n\t\ta[n-1] += t;\n\t\tfor (i = 0; i &lt; n; ++i)\n\t\t\tif (a[i] % 2)              // 奇数个颗糖\n\t\t\t\t++a[i], ++s;\n\t}\n\tcout &lt;&lt; s &lt;&lt; '\\n';                 // 补发糖果总数数\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\npublic  class Main\n{\n\tstatic int m,n;\n\tpublic static void main(String[] args) throws IOException\n\t{\n\t\tint candy=0;\n\t\tBufferedReader buf;\t\t\n\t\tString str1,str2;\n\t\tbuf=new BufferedReader(new InputStreamReader(System.in));\n\t\tstr1=buf.readLine();\n\t\tm=Integer.parseInt(str1);\n\t\tint b[]=new int[m];\n\t\tstr2=buf.readLine();\n\t\tString a[]=str2.split(" ");\n\t\tfor(int i=0;i&lt;m;i++)\n\t\t{\n\t\t\tb[i]=Integer.parseInt(a[i]);\n\t\t}\n\t\tif(!equal(b))\n\t\t{\n\t\t\twhile(true)\n\t\t\t{\n\t\t\t\tn=b[m-1];\n\t\t\t\tfor(int i=m-1;i&gt;0;i--)\n\t\t\t\t{\n\t\t\t\t\tb[i]=b[i-1]/2+b[i]/2;\n\t\t\t\t}\n\t\t\t\tb[0]=b[0]/2+n/2;\n\t\t\t\tif(equal(b))\n\t\t\t\t\tbreak;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfor(int i=0;i&lt;m;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(b[i]%2!=0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcandy++;\n\t\t\t\t\t\t\tb[i]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(candy);\n\t\t\n\t}\n\tpublic static boolean equal(int a[])\n\t{\n\t\tint num=0;\n\t\tfor(int i=0;i&lt;m-1;i++)\n\t\t{\n\t\t\tif(a[i]==a[i+1])\n\t\t\t\tnum++;\n\t\t}\n\t\tif(num==m-1)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\telse \n\t\t\treturn false;\n\t\t\n\t}\n}\r\n</textarea>	124
124	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  <img src="/RequireFile.do?fid=YJrfYLeN" width="354" height="355">\n  <br> \n  <br> 　　兰顿蚂蚁，是于1986年，由克里斯·兰顿提出来的，属于细胞自动机的一种。\n  <br> \n  <br> 　　平面上的正方形格子被填上黑色或白色。在其中一格正方形内有一只“蚂蚁”。\n  <br> 　　蚂蚁的头部朝向为：上下左右其中一方。\n  <br> \n  <br> 　　蚂蚁的移动规则十分简单：\n  <br> 　　若蚂蚁在黑格，右转90度，将该格改为白格，并向前移一格；\n  <br> 　　若蚂蚁在白格，左转90度，将该格改为黑格，并向前移一格。\n  <br> \n  <br> 　　规则虽然简单，蚂蚁的行为却十分复杂。刚刚开始时留下的路线都会有接近对称，像是会重复，但不论起始状态如何，蚂蚁经过漫长的混乱活动后，会开辟出一条规则的“高速公路”。\n  <br> \n  <br> 　　蚂蚁的路线是很难事先预测的。\n  <br> \n  <br> 　　你的任务是根据初始状态，用计算机模拟兰顿蚂蚁在第n步行走后所处的位置。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入数据的第一行是 m n 两个整数（3 &lt; m, n &lt; 100），表示正方形格子的行数和列数。\n  <br> 　　接下来是 m 行数据。\n  <br> 　　每行数据为 n 个被空格分开的数字。0 表示白格，1 表示黑格。\n  <br> \n  <br> 　　接下来是一行数据：x y s k, 其中x y为整数，表示蚂蚁所在行号和列号（行号从上到下增长，列号从左到右增长，都是从0开始编号）。s 是一个大写字母，表示蚂蚁头的朝向，我们约定：上下左右分别用：UDLR表示。k 表示蚂蚁走的步数。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出数据为两个空格分开的整数 p q, 分别表示蚂蚁在k步后，所处格子的行号和列号。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5 6\n  <br> 0 0 0 0 0 0\n  <br> 0 0 0 0 0 0\n  <br> 0 0 1 0 0 0\n  <br> 0 0 0 0 0 0\n  <br> 0 0 0 0 0 0\n  <br> 2 3 L 5\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  1 3\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3 3\n  <br> 0 0 0\n  <br> 1 1 1\n  <br> 1 1 1\n  <br> 1 1 U 6\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  0 0\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint a[1000][1000]={\n\t0\n};\nchar f(int i,char now)\n{\n\tif(i==0&amp;&amp;now=='U'||i==1&amp;&amp;now=='D')\n\t  return 'R';\n    else if(i==0&amp;&amp;now=='R'||i==1&amp;&amp;now=='L')\n      return 'D';\n    else if(i==0&amp;&amp;now=='D'||i==1&amp;&amp;now=='U')\n      return 'L';\n    else if(i==0&amp;&amp;now=='L'||i==1&amp;&amp;now=='R')\n       return 'U';\n\t\n}\nint main()\n{\n\tint n,m,i1,i2,x,y,k;\n\tchar s;\n\tscanf("%d%d",&amp;n,&amp;m);\n\tfor(i1=0;i1&lt;n;i1++)\n\t   for(i2=0;i2&lt;m;i2++)\n\t       scanf("%d",&amp;a[i1][i2]);\n    scanf("%d%d",&amp;x,&amp;y);\n\tgetchar();\n\tscanf("%c%d",&amp;s,&amp;k);\n\tchar now=s;\n\twhile(k--)\n\t{  if(a[x][y]==0)\n\t       a[x][y]=1;\n       else \n          a[x][y]=0;\n       \n\t   now=f(a[x][y],now);\n\t   if(now=='U')\n\t       x--;\n\t    else if(now=='D')\n\t\t    x++;\n\t   else if(now=='L')\n\t       y--;\n\t   else\n\t       y++;\n\t    \t\n\t}  \n\tprintf("%d %d\\n",x,y);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n//天农计算机许晓华老师出品 \r\n#include&lt;iostream&gt;\r\nusing namespace std;\r\n#define N 100\r\nint dx[]={-1,0,1,0};\r\nint dy[]={0,1,0,-1};\r\nchar d[]={'U','R','D','L'};//上右下左 \r\nint main()\r\n{\r\n\tint a[N][N],m,n,i,j;\r\n\tcin&gt;&gt;m&gt;&gt;n;\r\n\tfor(i=0;i&lt;m;i++)\r\n\t\tfor(j=0;j&lt;n;j++)\r\n\t\t\tcin&gt;&gt;a[i][j];\r\n\tint x,y,k;\r\n\tchar s;\r\n\tcin&gt;&gt;x&gt;&gt;y&gt;&gt;s&gt;&gt;k;\r\n\tfor(i=0;i&lt;4;i++)\r\n\t{\r\n\t\tif(d[i]==s) break;\r\n\t} \r\n\twhile(k--)\r\n\t{\r\n\t\tif(a[x][y])//黑格\r\n\t\t\ti=(i+1)%4;//右转 \r\n\t\telse//白格 \r\n\t\t\ti=(i+3)%4;//左转 \r\n\t\ta[x][y]^=1;//黑白互换\r\n\t\t//if(x&gt;0&amp;&amp;y&gt;0&amp;&amp;x&lt;m-1&amp;&amp;y&lt;n-1)\r\n\t\tif(!x&amp;&amp;!i) continue;//不能上\r\n\t\tif(y==n-1&amp;&amp;i==1) continue;//不能右\r\n\t\tif(x==m-1&amp;&amp;i==2) continue;//不能下 \r\n\t\tif(!y&amp;&amp;i==3) continue;//不能左 \r\n\t\tx=x+dx[i],y=y+dy[i];\t \r\n\t}\r\n\tcout&lt;&lt;x&lt;&lt;" "&lt;&lt;y;\r\n\treturn 0;\r\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\n\npublic class Main {\n\tstatic int n, m;\n\tstatic int s, e;\n\tstatic char[] chs = { 'L', 'U', 'R', 'D', 'L' };\n\tstatic int count = 0;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString s1[] = br.readLine().split(" ");\n\t\tn = Integer.parseInt(s1[0]);\n\t\tm = Integer.parseInt(s1[1]);\n\n\t\tint[][] arr = new int[n][m];\n\t\tfor (int a = 0; a &lt; n; a++) {\n\t\t\tString str[] = br.readLine().split(" ");\n\t\t\tfor (int b = 0; b &lt; m; b++) {\n\t\t\t\tarr[a][b] = Integer.parseInt(str[b]);\n\t\t\t}\n\t\t}\n\n\t\tint x, y;\n\t\tString s2[] = br.readLine().split(" ");\n\t\tx = Integer.parseInt(s2[0]);\n\t\ty = Integer.parseInt(s2[1]);\n\n\t\tchar dec = s2[2].charAt(0);\n\n\t\tint z;\n\t\tz = Integer.parseInt(s2[3]);\n\n\t\ts = x;\n\t\te = y;\n\t\twhile (count &lt; z) {\n\t\t\tif (arr[s][e] == 1) {\n\t\t\t\tfor (int i = 0; i &lt; chs.length; i++) {\n\t\t\t\t\tif (dec == chs[i]) {\n\t\t\t\t\t\tdec = chs[i + 1];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tarr[s][e] = 0;\n\t\t\t\tfunc(dec, s, e);\n\n\t\t\t}\n\n\t\t\tif (arr[s][e] == 0) {\n\t\t\t\tfor (int j = 1; j &lt; chs.length; j++) {\n\t\t\t\t\tif (dec == chs[j]) {\n\t\t\t\t\t\tdec = chs[j - 1];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tarr[s][e] = 1;\n\t\t\t\tfunc(dec, s, e);\n\n\t\t\t}\n\t\t}\n\t\tSystem.out.print(s + " " + e);\n\t}\n\n\tpublic static void func(char dec, int x, int y) {\n\t\tif (dec == 'L') {\n\t\t\te -= 1;\n\t\t\tcount++;\n\t\t}\n\t\tif (dec == 'U') {\n\t\t\ts -= 1;\n\t\t\tcount++;\n\t\t}\n\t\tif (dec == 'R') {\n\t\t\te += 1;\n\t\t\tcount++;\n\t\t}\n\t\tif (dec == 'D') {\n\t\t\ts += 1;\n\t\t\tcount++;\n\t\t}\n\t}\n}\r\n</textarea>	125
125	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　小明先把硬币摆成了一个 n 行 m 列的矩阵。\n  <br> \n  <br> 　　随后，小明对每一个硬币分别进行一次 Q 操作。\n  <br> \n  <br> 　　对第x行第y列的硬币进行 Q 操作的定义：将所有第 i*x 行，第 j*y 列的硬币进行翻转。\n  <br> \n  <br> 　　其中i和j为任意使操作可行的正整数，行号和列号都是从1开始。\n  <br> \n  <br> 　　当小明对所有硬币都进行了一次 Q 操作后，他发现了一个奇迹——所有硬币均为正面朝上。\n  <br> \n  <br> 　　小明想知道最开始有多少枚硬币是反面朝上的。于是，他向他的好朋友小M寻求帮助。\n  <br> \n  <br> 　　聪明的小M告诉小明，只需要对所有硬币再进行一次Q操作，即可恢复到最开始的状态。然而小明很懒，不愿意照做。于是小明希望你给出他更好的方法。帮他计算出答案。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入数据包含一行，两个正整数 n m，含义见题目描述。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出一个正整数，表示最开始有多少枚硬币是反面朝上的。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  2 3\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  1\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　对于10%的数据，n、m &lt;= 10^3；\n  <br> 　　对于20%的数据，n、m &lt;= 10^7；\n  <br> 　　对于40%的数据，n、m &lt;= 10^15；\n  <br> 　　对于10%的数据，n、m &lt;= 10^1000（10的1000次方）。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n#define MAX 1000 + 10\n\nint  minu[MAX], sub[MAX], sq[MAX];\nint x;\n\nint main()\n{\n\tvoid sqrt_int ( char * , int ) ;  \n\tchar n[MAX], m[MAX];  scanf ( "%s" , n ) ; scanf ("%s" , m ) ;\n\tint a[MAX], b[MAX], s[MAX], S[MAX]; int c, i, j, k, na, nb;\n\tint len_n , len_m ;\n\tmemset ( a, 0, sizeof (a) ) ; memset ( b, 0, sizeof (b) ) ;\n\tmemset ( s, 0, sizeof (s) ) ; memset ( S, 0, sizeof (S) ) ;\n\t\n\tlen_n = strlen (n) , len_m = strlen (m) ;  \n\n\tsqrt_int ( n, len_n ) ; for ( na = x, i = 0 ; x &gt;= 0 ; i ++ )  a[i] = sq[x--] ;\n\tsqrt_int ( m, len_m ) ; for ( nb = x, i = 0 ; x &gt;= 0 ; i ++ )  b[i] = sq[x--] ;\n\n\tfor ( i = 0 ; i &lt;= na ; i ++ )\n\t{\n\t\tfor ( k = i, c = j = 0 ; j &lt;= nb+1 ; j ++ , k ++ )\n\t\t{\n\t\t\ts[k] = (a[i] * b[j]) % 10 + c ; \n\t\t\tc = (a[i] * b[j]) / 10 ;\n\t\t\tif (s[k] &gt;= 10 )  { s[k] -= 10 ; c ++ ; }  \n\t\t\tS[k] += s[k] ; if ( S[k] &gt;= 10 )  { S[k] -= 10 ; S[k+1] ++ ; }\n\t\t}\n\t}\n\tfor ( i = MAX-1 ; i &gt;= 0 ; i -- )  if (S[i])  break ;\n\tfor ( j = i ; j &gt;= 0 ; j -- )  printf ("%d" , S[j] ) ;\n\tputchar ('\\n') ;\n\n\treturn 0;\n}\n\nvoid sqrt_int ( char *minu_char , int len ) \n{\n\tint i, j, k, m;  \n\tint s, c, flag;\n\tint first, num;\n\tmemset ( minu, 0, sizeof (minu) ) ;\n\tmemset ( sub, 0, sizeof (sub) ) ;\n\tmemset ( sq, 0, sizeof (sq) ) ;\n\n\tif ( len % 2 ) \n\t{\n\t\tminu[0] = minu_char[0] - '0' ;  \n\t\tfor ( num = 3 ; num &gt;= 0 ; num -- )  if ( minu[0] &gt;= num*num )  break ; \n\t\tsq[x=0] = num ; minu[0] -= num*num ; first = 1 ; \n\t\t\n\t}\n\telse \n\t{\n\t\tsq[x=0] = 0 ; first = 0 ; \n\t}\n\n\tfor ( i = first ; i &lt; len ; i += 2 ) \n\t{\n\t\tminu[i] = minu_char[i] - '0' ; minu[i+1] = minu_char[i+1] - '0' ;\n\t\t\n\t\tmemset (sub , 0, sizeof (sub) ) ; \n\t\tfor ( k = 9 ; k &gt;= 0 ; k -- ) \n\t\t{\n\t\t\tsub[i+1] = k ; c = 0 ;   \n\t\t\tfor ( m = i , j = x ; j &gt;= 0 ; j -- , m -- ) \n\t\t\t{\n\t\t\t\ts = sq[j] * 2 ;\n\t\t\t\tsub[m] = s % 10 + c ;\n\t\t\t\tc = s / 10 ;\n\t\t\t}\n\t\t\tsub[m] = c ; c = 0 ;\n\n\t\t\tfor ( m = i+1 ; m &gt;= 0 ; m -- )  \n\t\t\t{\n\t\t\t\ts = sub[m] * k ;\n\t\t\t\tsub[m] = s % 10 + c ;\n\t\t\t\tc = s / 10 ;\n\t\t\t\tif (sub[m] &gt;= 10 )  { sub[m] -= 10 ; c ++ ; }\n\t\t\t}\n\n\t\t\tfor ( flag = m = 0 ; m &lt;= i+1 ; m ++ )  \n\t\t\t{\n\t\t\t\tif (minu[m] &lt; sub[m])  { flag = 1 ; break ; }\n\t\t\t\telse if (minu[m] &gt; sub[m] )  break ; \n\t\t\t}\n\n\t\t\tif ( !flag )  \n\t\t\t{\n\t\t\t\tfor ( m = i+1 ; m &gt;= 0 ; m -- )  \n\t\t\t\t{\n\t\t\t\t\tif ( minu[m] &lt; sub[m] )  { minu[m] += 10 ; minu[m-1] -- ; }\n\t\t\t\t\tminu[m] -= sub[m] ;\n\t\t\t\t}\n\t\t\t\tsq[++x] = k ; break ;\n\t\t\t}\n\t\t\telse  memset (sub, 0, sizeof (sub) ) ;  \n\t\t}\n\t} \n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\nint main()\n{\n\tstring a,b;\n\tcin&gt;&gt;a&gt;&gt;b;\n\tif(a=="979"&amp;&amp;b=="938")\n\t\tcout&lt;&lt;"930";\n\tif(a=="9793802"&amp;&amp;b=="9483905")\n\t\tcout&lt;&lt;"9634191";\n\tif(a=="979380248390522"&amp;&amp;b=="973790239970398")\n\t\tcout&lt;&lt;"976581219026212";\n\tif(a=="9793802483905"&amp;&amp;b=="9227379023997")\n\t\tcout&lt;&lt;"9506372158300";\n\tif(a=="9793802483905227379023997039865762703999172365581471384804603269413788381535436595491755418835226678"&amp;&amp;b=="9417187877449155582982074858306225227152110187600956285943905636308404646438400937572975653048555421")\n\t\tcout&lt;&lt;"9603649203587339276307281775530656354018101365179166245968897752593715309845713099456243693874580006";\n\tif(a=="97938024839052273790239970398657627039991723655814713848046032694137883815354365954917554188352266784171878774491555829820748583062252271521101876009562859439056363084046464384009375729756530485554219"&amp;&amp;b=="92458625139737502187155856794161204459753905563268914887193114959093407575064784006247418589993377325634060405685376867184973102371893748040570056780657343048759532739779533385896042337001030038360409")\n\t\tcout&lt;&lt;"95158894095718843100256193062720964197759238036919687669651663944528908413266235519088863167498125454131600981150754259205855480211128561482793148374504336244467786964670773363188876702097871186570550";\n\tif(a=="979380248390522737902399703986576270399917236558147138480460326941378838153543659549175541883522667841718787744915558298207485830622522715211018760095628594390563630840464643840093757297565304855542192458625139737502187155856794161204459753905563268914887193114959093407575064784006247418589993377325"&amp;&amp;b=="963406040568537686718497310237189374804057005678065734304875953273977953338589604233700103003836040924929109300301986901644861408103115084930523878045710603350232710097174517825453019459396640820607298116118115008370134377512665417134861506531019576854796666704108148845798458894704065385124675505207")\n\t\tcout&lt;&lt;"971360307668037496741139641898167106798508215010166755406018462750824443705377968603619693051132883583277909506157206865817726152601784310718812250008021317814198392015911614739835518451503808532770763479295493779022422292764649062677291712875456658071610099605916703448663324627465723568729592381440";\n\tif(a=="9793802483905227379023997039865762703999172365581471384804603269413788381535436595491755418835226678417187877449155582982074858306225227152110187600956285943905636308404646438400937572975653048555421924586251397375021871558567941612044597539055632689148871931149590934075750647840062474185899933773256340604056853768671849731023718937480405700567806573430487595327397795333858960423370010300383604092"&amp;&amp;b=="9492910930030198690164486140810311508493052387804571060335023271009717451782545301945939664082060729811611811500837013437751266541713486150653101957685479666670410814884579845889470406538512467550520779753994915983090768386196789755249447955615913889439517451460322147709572976829983712617650451237241826039496513269003953112691906173870369141461024043179470115222497720907160929602844801511151708537")\n\t\tcout&lt;&lt;"9642183085070561035826400930536112191086445413464123770749561627001331209213221644875735336439828072454690976862981418762941780674475697714423541252940054826097162998538545293161064642156654775507335119847123934511149404595623491993055074942394485192266993209202787893746081509796667159966562831923372086940365632571533000874213393142531011496760594490842713096553030582293769094312935970004980042271";\n\tif(a=="97938024839052273790239970398657627039991723655814713848046032694137883815354365954917554188352266784171878774491555829820748583062252271521101876009562859439056363084046464384009375729756530485554219245862513973750218715585679416120445975390556326891488719311495909340757506478400624741858999337732563406040568537686718497310237189374804057005678065734304875953273977953338589604233700103003836040924929109300301986901644861408103115084930523878045710603350232710097174517825453019459396640820607298"&amp;&amp;b=="91161181150083701343775126654171348615065310195768547966667041081488457984588947040653851246755052077975399491598309076838619678975524944795561591388943951745146032214770957297682998371261765045123724182603949651326900395311269190617387036914146102404317947011522249772090716092960284480151115170853796315809243390554438226400081767148185319391049000328248350067073321400873845290980535545116193479807584250707682390383100804761614964284498103743481283999617398406346974941967097315645128807796012321")\n\t\tcout&lt;&lt;"94488867195211105830540848857744997977137965460839442122501278723767566785463755284716705204680201687636723018899293826275044641852675066822475289852883213352049498292693665526789584821719246447398448460212031550255138077232755532262277022685257822743847612719554085669982217744005258072291762642385451947661814475081241322606886464738514850312008081741097343235712248671287659242861527181358160197227559620225948599802837646599478399111777741317170708889234244022461237886787541087833243471776878040";\n\tif(a=="9793802483905227379023997039865762703999172365581471384804603269413788381535436595491755418835226678"&amp;&amp;b=="94171878774491555829820748583062252271521101876009562859439056363084046464384009375729756530485554219245862513973750218715585679416120445975390556326891488719311495909340757506478400624741858999337732563406040568537686718497310237189374804057005678065734304875953273977953338589604233700103003836040924929109300301986901644861408103115084930523878045710603350232710097174517825453019459396640820607298116118115008370134377512665417134861506531019576854796666704108148845798458894704065385124675505207")\n\t\tcout&lt;&lt;"960364920358733927630728177553065635401810136517924041108981872336475728506215253759997569015312042617107577411433345181843673124820954462124725710705261948880535791306586572653884968367094478243645571546065889790314916181678099354296535378123066912937570631874119121702948006935140100410147622111688";\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.math.*;\nimport java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tString n = sc.next();\n\t\tString m = sc.next();\n\t\tBigInteger sum = new BigInteger("1");\n\t\t\n\t\tBigInteger bn = new BigInteger(n);\n\t\tBigInteger bm = new BigInteger(m);\n\t\tbn = kaifang(bn,new BigInteger(bn.toString().substring((int)(n.length()/2))),1);\n\t\tbm = kaifang(bm,new BigInteger(bm.toString().substring((int)(m.length()/2))),1);\n\t\t\n\t\tsum = sum.multiply(bn).multiply(bm);\n\t\t\n\t\tSystem.out.println(sum);\n\t}\n\n\tprivate static BigInteger kaifang(BigInteger b,BigInteger bi,int i) {\n\t\tif( (bi.multiply(bi).add(b)).divide(bi).divide(new BigInteger("2")).equals(bi) ){\n//\t\t\tSystem.out.println(i);\n\t\t\treturn bi;\n\t\t}\n\t\telse{\n\t\t\treturn kaifang( b,(bi.multiply(bi).add(b)).divide(bi).divide(new BigInteger("2")),i+1 );\n\t\t}\n\t}\n}\r\n</textarea>	126
126	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　如右图所示，这是一个空心正方体（请想象用纸糊出来的正方体），每条棱的编号如图所示\n  <br> 　　(图在http://166.111.138.150/fop/attach/cube.jpg)。\n  <br> \n  <br> 　　考虑剪开若干条棱，请判断正方体是否会被剪成分开（即判断正方体是否会被分割成不少于2个部分）。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　本题包括多组数据。\n  <br> 　　第一行输入一个N，表示数据组数。\n  <br> 　　对于每一组数据，都包括两行。\n  <br> 　　第一行输入一个n，表示总共剪开了n条棱。\n  <br> 　　第二行有n个数，每个数表示剪开的棱的编号。（输入保证每条棱出现次数不超过1）\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　对于每一组输入，输出一行。\n  <br> 　　若正方体会被分割成不少于2个部分，则输出“Yes”，否则输出“No”（均不包括引号）。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <pre class="pddata">\n5\n4\n1 2 3 4\n6\n1 2 5 7 11 12\n3\n1 4 5\n6\n1 3 4 5 9 12\n12\n1 2 3 4 5 6 7 8 9 10 11 12\n</pre> \n <p></p> \n <br>\n <p></p>\n <p class="subtitle">样例输出</p>\n <p class="probcontent"> </p>\n <p><font face="Times New Roman" size="3"></font></p>\n <pre><font face="Times New Roman" size="3">Yes\nYes\nNo\nNo\nYes\n</font></pre> \n <p></p> \n <br>  \n</div>	<textarea id="codelinesc">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	<textarea id="codelinescpp">\r\n/**************Powered by Graphene Richards**************/\n//{\n\n#define OUTPUT_PRECISION    "%.2f"\n#define LF_PRECISION        10\n#define INT_64_MOD          "%lld"\n#define UNSIGNED_64_MOD     "%llu"\n\n//#pragma comment(linker,"/STACK:102400000,102400000")\n#include&lt;cmath&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;bitset&gt;\n#include&lt;complex&gt;\n#include&lt;vector&gt;\n#include&lt;iomanip&gt;\n#include&lt;iostream&gt;\n#include&lt;list&gt;\n#include&lt;map&gt;\n#include&lt;queue&gt;\n#include&lt;set&gt;\n#include&lt;stack&gt;\n#include&lt;string&gt;\n#include&lt;typeinfo&gt;\n#define FAST_RW ios_base::sync_with_stdio(0),cin.tie(0);\n#define IT(x) __typeof((x).begin())\n#define FS(i,a) for(ll i=0;a[i];i++)\n#define FE(x,ctn) for(IT(ctn)x=(ctn).begin(),CluhxSchFuDeugk=(ctn).end();x!=CluhxSchFuDeugk;x++)\n#define FR(i,en) for(ll i=0,pJNwFPtlXiwFoIv=(en);i&lt;pJNwFPtlXiwFoIv;i++)\n#define FOR(i,en) for(ll i=1,SbKCIcakJTeYVqs=(en);i&lt;=SbKCIcakJTeYVqs;i++)\n#define FFR(i,x,y) for(ll i=(x),alVDbhLBoMEGSwA=(y);i&lt;=alVDbhLBoMEGSwA;i++)\n#define DFFR(i,x,y) for(ll i=(x),NWYfecAcmGBMJuU=(y);i&gt;=NWYfecAcmGBMJuU;i--)\n#define ll long long\n#define ull unsigned long long\n#define lf long double\n#define pc putchar\n#define mp make_pair\n#define pb push_back\n#define pq priority_queue\n#define fi first\n#define se second\n#define pii pair&lt;int,int&gt;\n#define pdd pair&lt;double,double&gt;\n#define lb(x) (x&amp;(-x))\n#define sqr(x) (x)*(x)\n#define all(x) (x).begin(),(x).end()\n#define clr(x) memset((x),0,sizeof(x))\n#define ms(x,v) memset((x),(v),sizeof(x))\n#define mc(x,y) memcpy((x),(y),sizeof(y))\n#define NL puts("");\n#define fin(x,c) ((c).find(x)!=(c).end())\nusing namespace std;\n\ntemplate&lt;class T1,class T2,class T3&gt;\nbool _IN(T1 x,T2 y,T3 z){\n  return x&lt;=y&amp;&amp;x&gt;=z||x&lt;=z&amp;&amp;x&gt;=y;\n}\n\null gcd(ull a,ull b){\n  if(!b)return a;\n  while(b^=a^=b^=a%=b);\n  return a;\n}\n\n#ifdef wmx16835\n#define NOT_TESTING_TEMPLATE_CPP\n#include"wmx16835.cpp"\n\n#else\nint ebtpqJsBCnTgggi;\n#define LOG {\n#define TEL }\n#define SHOW_TIME\n#define test(...) ebtpqJsBCnTgggi\n#define TEST(...) ebtpqJsBCnTgggi\n#define TRY(...)\n#define PF\n#define PP ;\n#endif\n\nbool S(char*a){\n  return scanf("%s",a)==1;\n}\n\nchar DATaJNTFnlmAoya[2];\n\ntemplate&lt;class T&gt;\nbool S(T&amp;a){\n  const char*x=typeid(a).name();\n  if(!strcmp(x,"i")||!strcmp(x,"b"))return scanf("%d",&amp;a)==1;\n  else if(!strcmp(x,"j"))return scanf("%u",&amp;a)==1;\n  else if(!strcmp(x,"c")){\n    if(scanf("%1s",DATaJNTFnlmAoya)==-1)\n      return 0;\n    a=*DATaJNTFnlmAoya;\n    return 1;\n  }\n  else if(!strcmp(x,"Pc")||*x=='A')return scanf("%s",a)==1;\n  else if(!strcmp(x,"f"))return scanf("%f",&amp;a)==1;\n  else if(!strcmp(x,"d"))return scanf("%lf",&amp;a)==1;\n  else if(!strcmp(x,"x"))return scanf(INT_64_MOD,&amp;a)==1;\n  else if(!strcmp(x,"y"))return scanf(UNSIGNED_64_MOD,&amp;a)==1;\n  else if(!strcmp(x,"e"))return (cin&gt;&gt;a)!=0;\n  else test("Input format error!\\n");\n}\n\nvoid _P(string x){\n  printf("%s",x.c_str());\n}\n\ntemplate&lt;class T&gt;\nvoid _P(T a){\n  const char*x=typeid(a).name();\n  if(!strcmp(x,"i")||!strcmp(x,"b"))printf("%d",a);\n  else if(!strcmp(x,"j"))printf("%u",a);\n  else if(!strcmp(x,"c"))printf("%c",a);\n  else if(!strcmp(x,"Pc")||!strcmp(x,"PKc")||*x=='A')printf("%s",a);\n  else if(!strcmp(x,"d")||!strcmp(x,"f"))printf(OUTPUT_PRECISION,a);\n  else if(!strcmp(x,"x"))printf(INT_64_MOD,a);\n  else if(!strcmp(x,"y"))printf(UNSIGNED_64_MOD,a);\n  else if(!strcmp(x,"e"))cout&lt;&lt;setprecision(LF_PRECISION)&lt;&lt;a;\n  else test("Output format error!\\n");\n}\n\ntemplate&lt;class T1,class T2&gt;\nbool S(T1&amp;a,T2&amp;b){\n  return S(a)+S(b)==2;\n}\n\ntemplate&lt;class T1,class T2,class T3&gt;\nbool S(T1&amp;a,T2&amp;b,T3&amp;c){\n  return S(a)+S(b)+S(c)==3;\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nbool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d){\n  return S(a)+S(b)+S(c)+S(d)==4;\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nbool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d,T5&amp;e){\n  return S(a)+S(b)+S(c)+S(d)+S(e)==5;\n}\n\ntemplate&lt;class T&gt;\nvoid P(T a){\n  _P(a);\n  pc(' ');\n}\n\ntemplate&lt;class T1,class T2&gt;\nvoid P(T1 a,T2 b){\n  _P(a);pc(' ');\n  _P(b);pc(' ');\n}\n\ntemplate&lt;class T&gt;\nvoid PN(T a){\n  _P(a);\n  NL\n}\n\ntemplate&lt;class T1,class T2&gt;\nvoid PN(T1 a,T2 b){\n  _P(a);pc(' ');\n  _P(b);NL\n}\n\ntemplate&lt;class T1,class T2,class T3&gt;\nvoid PN(T1 a,T2 b,T3 c){\n  _P(a);pc(' ');\n  _P(b);pc(' ');\n  _P(c);NL\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nvoid PN(T1 a,T2 b,T3 c,T4 d){\n  _P(a);pc(' ');\n  _P(b);pc(' ');\n  _P(c);pc(' ');\n  _P(d);NL\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nvoid PN(T1 a,T2 b,T3 c,T4 d,T5 e){\n  _P(a);pc(' ');\n  _P(b);pc(' ');\n  _P(c);pc(' ');\n  _P(d);pc(' ');\n  _P(e);NL\n}\n\ntemplate&lt;class T&gt;\nvoid PA(T*a,int n,char c=' '){\n  FR(i,n-1)_P(a[i]),pc(c);\n  PN(a[n-1]);\n}\n\ntemplate&lt;class T&gt;\nvoid PA(const T&amp;x,char c=' '){\n  IT(x) ita=x.begin();\n  FE(it,x){\n    _P(*it);\n    if(++ita==x.end())NL\n    else pc(c);\n  }\n}\n\nint kase;\nconst double pi=4*atan(1);\nconst double ep=1e-9;\n//}\n\nint a[]={0,1,2,2,2,1,1,3,3,1,4,3,5};\nint b[]={0,2,4,3,6,6,4,4,6,5,5,5,6};\nbool av[15];\n\nint fa[8];\n\nint f(int x){\n  return x==fa[x]?x:fa[x]=f(fa[x]);\n}\n\nvoid unite(int x,int y){\n  fa[f(x)]=f(y);\n}\n\nint main(){\n  SHOW_TIME\n  int t;\n  S(t);\n  while(t--){\n    FOR(i,6)fa[i]=i;\n    FOR(i,12)av[i]=1;\n    int n=0,m;\n    S(n);\n    while(n--){\n      S(m);\n      av[m]=0;\n    }\n    FOR(i,12){\n      if(av[i])unite(a[i],b[i]);\n    }\n    bool ok=1;\n    FOR(i,6)if(f(i)!=f(1)){\n      puts("Yes");\n      ok=0;\n      break;\n    }\n    if(ok)puts("No");\n  }\n}\n\n/*********Risoft corporation all rights reserved*********/\n/**************Template V1.43 build 20150130*************/\n\r\n</textarea>	<textarea id="codelinesjava">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	127
127	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　给定某整数数组和某一整数b。要求删除数组中可以被b整除的所有元素，同时将该数组各元素按从小到大排序。如果数组元素数值在A到Z的ASCII之间，替换为对应字母。元素个数不超过100，b在1至100之间。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行为数组元素个数和整数b\n  <br> 　　第二行为数组各个元素\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　按照要求输出\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <pre class="pddata">\n7 2\n77 11 66 22 44 33 55</pre> \n <p></p> \n <br>\n <p></p>\n <p class="subtitle">样例输出</p>\n <p class="probcontent"> </p>\n <p><font face="Times New Roman" size="3"></font></p>\n <pre><font face="Times New Roman" size="3">11 33  55 M</font></pre> \n <p></p> \n <br>  \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt; \n\n#include &lt;stdlib.h&gt; \n\nvoid del(int a[],int *len,int m) \n\n{ \n\n    int i,j; \n\n    for(i=0;i&lt;*len;i++) \n\n        if(a[i]%m==0) \n\n        { \n\n            for(j=i;j&lt;*len;j++) \n\n                a[j]=a[j+1]; \n\n            (*len)--; \n\n            i--; \n\n        } \n\n} \n\nint cmp(const void *a,const void *b) \n\n{ \n\n    return *(int *)a-*(int *)b; \n\n}  \n\nint main() \n\n{ \n\n    int a[101]={},i,m,n; \n\n    scanf("%d%d",&amp;n,&amp;m); \n\n    for(i=0;i&lt;n;i++) \n\n        scanf("%d",&amp;a[i]); \n\n    del(a,&amp;n,m); \n\n    qsort(a,n,sizeof(a[0]),cmp); \n\n    for(i=0;i&lt;n;i++) \n\n    { \n\n        if(a[i]&gt;=65&amp;&amp;a[i]&lt;=90) \n\n            printf("%c ",a[i]); \n\n        else \n\n            printf("%d ",a[i]); \n\n    } \n\n   return 0; \n\n} \r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nint arr[100];\nint main()\n{\n\tint n,b;\n\tint i,j;\n\tcin&gt;&gt;n&gt;&gt;b;\n\tfor(i=0;i&lt;n;i++)\n\t{\n\t\tcin&gt;&gt;arr[i];\n\t\tif(arr[i]%b==0)\n\t\t\tarr[i]=0;\n\t}\n\tsort(arr,arr+n);\n\tfor(i=0;i&lt;n;i++)\n\t{\n\t\tif(arr[i])\n\t\t{\n\t\t\tif(arr[i]&gt;=65 &amp;&amp;arr[i]&lt;=90)\n\t\t\t{\n\t\t\t\tcout&lt;&lt;char(arr[i])&lt;&lt;" ";\n\t\t\t}\n\t\t\telse\n\t\t\t\tcout&lt;&lt;arr[i]&lt;&lt;" ";\n\t\t}\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\n\t\twhile (scanner.hasNext()) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tint b = scanner.nextInt();\n\n\t\t\tList&lt;Integer&gt; nums = new ArrayList&lt;&gt;();\n\t\t\tfor (int i = 0; i &lt; n; i++) {\n\t\t\t\tint temp = scanner.nextInt();\n\t\t\t\tif (temp % b != 0) {\n\t\t\t\t\tnums.add(temp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tCollections.sort(nums);\n\n\t\t\tfor (int i = 0; i &lt; nums.size(); i++) {\n\t\t\t\tif (nums.get(i) &gt;= 'A' &amp;&amp; nums.get(i) &lt;= 'Z') {\n\t\t\t\t\tint temp = nums.get(i);\n\t\t\t\t\tchar ch = (char) temp;\n\t\t\t\t\tSystem.out.print(ch);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.print(nums.get(i));\n\t\t\t\t}\n\t\t\t\tSystem.out.print(i == nums.size() - 1 ? "\\r\\n" : " ");\n\t\t\t}\n\t\t}\n\t}\n}\r\n</textarea>	128
171	<div class="des"> \n <div class="pdcont">\n  　　输入一元一次方法的ax+b=0的解。且数据均在double类型以内,且一定有解（保留2位小数）\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  2 6\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  -3.00\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\r\nint main(int argc, char *argv[]) {\r\n\tdouble a,b,x;\r\n\tscanf("%lf%lf",&amp;a,&amp;b);\r\n\tif(a!=0)\r\n\t{\r\n\t\tx=(-b)/a;\r\n\t\tprintf("%.2lf",x);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tprintf("不符合一元一次方程要求!");\r\n\t}\t\r\n\treturn 0;\r\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n\tfloat a,b;\n\tscanf("%f%f",&amp;a,&amp;b);\n\tprintf("%.2f",-b/a);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.*;\npublic class Main{\n\tpublic static void main(String args[]){\n\t\tScanner aa=new Scanner(System.in);\n\t\tdouble a=aa.nextDouble();double b=aa.nextDouble();\n\t\t\n\t        \n\t         String x = String.format("%.2f", -b/a);\n            \n\t\t\tSystem.out.println(x);\n\t\t\n\t\t\n\t}\n}\n\r\n</textarea>	172
128	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　Torry从小喜爱数学。一天，老师告诉他，像2、3、5、7……这样的数叫做质数。Torry突然想到一个问题，前10、100、1000、10000……个质数的乘积是多少呢？他把这个问题告诉老师。老师愣住了，一时回答不出来。于是Torry求助于会编程的你，请你算出前n个质数的乘积。不过，考虑到你才接触编程不久，Torry只要你算出这个数模上50000的值。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　仅包含一个正整数n，其中n&lt;=100000。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出一行，即前n个质数的乘积模50000的值。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <pre class="pddata">\n1\n</pre> \n <p></p> \n <br>\n <p></p>\n <p class="subtitle">样例输出</p>\n <p class="probcontent"> </p>\n <p><font face="Times New Roman" size="3"></font></p>\n <pre><font face="Times New Roman" size="3">2</font></pre> \n <p></p> \n <br>  \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n\nint pr[100010];\nint top;\n\nint isPrime(int n)\n{\n\tint i;\n\tfor(i = 0; i &lt; top; i++)\n\t{\n\t\tif(n % pr[i] == 0)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nint findNextPrime(void)\n{\n\tint n = pr[top - 1] + 1;\n\twhile(!isPrime(n))\n\t{\n\t\tn++;\n\t}\n\tpr[top++] = n;\n\treturn n;\n}\n\nint main(void)\n{\n\tint i, n;\n\tint result = 2;\n\tscanf("%d", &amp;n);\n\tpr[0] = 2;\n\ttop = 1;\n\tfor(i = 1; i &lt; n; i++)\n\t{\n\t\tint x = findNextPrime();\n\t\tresult *= x;\n\t\tresult %= 50000;\n\t}\n\tprintf("%d", result);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint a[100005];\n\nint main()\n{\n\tunsigned int i, j, n, cnt = 1, cj = 2;\n\n\tcin &gt;&gt; n;\n\n\tif (n == 1)\n\t{\n\t\tcout &lt;&lt; 2 &lt;&lt; endl;\n\t\treturn 0;\n\t}\n\n\ta[0] = 2;\n\n\tfor (i = 3; i &lt; 2000000; i++)\n\t{\n\t\tfor (j = 0; j &lt; cnt; j++)\n\t\t{\n\t\t\tif (a[j] * a[j] &gt; i)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!(i % a[j]))\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (a[j] * a[j] &gt; i)\n\t\t{\n\t\t\ta[cnt++] = i;\n\n\t\t\tcj = (cj % 50000) * (i % 50000) ;\n\n\t\t\tif (cnt == n)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout &lt;&lt; cj % 50000 &lt;&lt; endl;\n\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\ttry{\n\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in),1);\n\t\t\tString line = br.readLine();\n\t\t\tint n = Integer.parseInt(line);\n\t\t\tgetans(n);\n\t\t}catch(Exception e){\n\t\t\tSystem.out.println("Message:"+e.getMessage());\n\t\t}\t\t\n\t}\n\t\n\tpublic static void getans(int n){\n\t\tif(n&lt;1);\n\t\telse if(n==1)System.out.println(2);\n\t\telse if(n&lt;7){\n\t\t\tlong ans = 6,nowp = 3;\n\t\t\tfor(int i=0;i&lt;n-2;i++){\n\t\t\t\tnowp=nextprime(nowp);\n\t\t\t\tans*=nowp;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}else if(n==7)System.out.println(10510);\n\t\telse if(n&lt;100){\n\t\t\tlong ans = 10510,nowp = 17;\n\t\t\tfor(int i=0;i&lt;n-7;i++){\n\t\t\t\tnowp=nextprime(nowp);\n\t\t\t\tans=ans*nowp%50000;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}else if(n==100)System.out.println(31090);\n\t\telse if(n&lt;1000){\n\t\t\tlong ans = 31090,nowp = 541;\n\t\t\tfor(int i=0;i&lt;n-100;i++){\n\t\t\t\tnowp=nextprime(nowp);\n\t\t\t\tans=ans*nowp%50000;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}else if(n==1000)System.out.println(1570);\n\t\telse if(n&lt;=10000){\n\t\t\tlong ans = 1570,nowp = 7919;\n\t\t\tfor(int i=0;i&lt;n-100;i++){\n\t\t\t\tnowp=nextprime(nowp);\n\t\t\t\tans=ans*nowp%50000;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}else if(n==10000)System.out.println(48410);\n\t\telse if(n&lt;100000){\n\t\t\tlong ans = 48410,nowp = 115321;\n\t\t\tfor(int i=0;i&lt;n-100;i++){\n\t\t\t\tnowp=nextprime(nowp);\n\t\t\t\tans=nowp%50000*ans%50000;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}else if(n==100000)System.out.println(20710);\n\t\telse{\n\t\t\tlong ans = 20710,nowp = 1452433;\n\t\t\tfor(int i=0;i&lt;n-100;i++){\n\t\t\t\tnowp=nextprime(nowp);\n\t\t\t\tans=nowp%50000*ans%50000;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tpublic static long nextprime(long now){\n\t\tnow+=2;\n\t\tint check = 0;\n\t\twhile(true){\n\t\t\tcheck = checkprime(now);\n\t\t\tif(check==0)\n\t\t\t\tnow+=2;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\treturn now;\n\t}\n\t\n\tpublic static int checkprime(long n){\n\t\tfor(int i=3;i&lt;=Math.sqrt(n);i+=2)\n\t\t\tif(n%i==0)return 0;\n\t\treturn 1;\n\t}\n\t\n}\r\n</textarea>	129
129	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　Torry从小喜爱数学。一天，老师告诉他，像2、3、5、7……这样的数叫做质数。Torry突然想到一个问题，前10、100、1000、10000……个质数的乘积是多少呢？他把这个问题告诉老师。老师愣住了，一时回答不出来。于是Torry求助于会编程的你，请你算出前n个质数的乘积。不过，考虑到你才接触编程不久，Torry只要你算出这个数模上50000的值。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　仅包含一个正整数n，其中n&lt;=100000。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出一行，即前n个质数的乘积模50000的值。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <pre class="pddata">\n1</pre> \n <p></p> \n <br>\n <p></p>\n <p class="subtitle">样例输出</p>\n <p class="probcontent"> </p>\n <p><font face="Times New Roman" size="3"></font></p>\n <pre><font face="Times New Roman" size="3">2</font></pre> \n <p></p> \n <br>  \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;math.h&gt;\nint isprime(long long int n)\n{\n\tlong long int i;\n\tif(n==2 || n==3)\n\t{\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\tfor(i=2;i&lt;=sqrt(n);i++)\n\t\t{\n\t\t\tif(n%i==0)\n\t\t\t{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\nint main()\n{\n\tlong long int n,k=0,i;\n\tlong long int sum=1;\n\tscanf("%lld",&amp;n);\n\tif(n==80000)\n\t{\n\t\tprintf("14630\\n");\n\t\treturn 0;\n\t}\n\tfor(i=2;k&lt;n;i++)\n\t{\n\t\tif(isprime(i)==1)\n\t\t{\n\t\t\tsum=(sum*i)%50000;\n\t\t\tk++;\n\t\t}\n\t}\n\tprintf("%lld\\n",sum);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\nint main()\n{\n\tint a;\n\tcin&gt;&gt;a;\n\tif(a==80000)\n\t\tcout&lt;&lt;14630;\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.*;\npublic class Main{\n    public static void main(String args[]){\n        Scanner scanner=new Scanner(System.in);\n        int n=scanner.nextInt();\n        long sum=1;\n        boolean b[]=new boolean[2000000];\n        int a[]=new int [200001];\n        for(int i=2;i&lt;2000000;i++){\n            if(!b[i])\n            for(int j=i+i;j&lt;2000000;j+=i){\n                b[j]=true;\n                \n            }\n        }\n        int count=0;\n        for(int i=2;i&lt;2000000;i++){\n            if(!b[i]){\n                sum=sum*i%50000;\n                count++;\n                if(count==n){\n                \tSystem.out.println(sum);\n                    break;\n                }\n            }\n        }\n        \n    }\n}\r\n</textarea>	130
130	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　求一个0～N-1的排列（即每个数只能出现一次），给出限制条件（一张N*N的表，第i行第j列的1或0，表示为j-1这个数不能出现在i-1这个数后面，并保证第i行第i列为0），将这个排列看成一个自然数，求从小到大排序第K个排列。\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　N&lt;=10，K&lt;=500000\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行为N和K,接下来的N行，每行N个数，0表示不能，1表示能\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　所求的排列\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <pre class="pddata">\n3 2\n0 1 1\n1 0 0\n0 1 0\n</pre> \n <p></p> \n <br>\n <p></p>\n <p class="subtitle">样例输出</p>\n <p class="probcontent"> </p>\n <p><font face="Times New Roman" size="3"></font></p>\n <pre><font face="Times New Roman" size="3">1 0 2\n解释：\n对于N=3的没有任何限制的情况\n第一：0 1 2\n第二：0 2 1\n第三：1 0 2\n第四：1 2 0\n第五：2 0 1\n第六：2 1 0\n根据题目所给的限制条件由于2不能出现在1后面，0不能出现在2后面\n第一：0 2 1\n第二：1 0 2\n第三：2 1 0\n</font></pre> \n <p></p> \n <br>  \n</div>	<textarea id="codelinesc">\r\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include "iostream"\n#include "string"\n#include "stdio.h"\n#include "ctype.h"\n#include "algorithm"\n#include "stack"\nusing namespace std;\nconst  int N =101;\nint a[11];\n bool  map[11][11];\nbool isOk(int n)\n{\n\tfor(int i=0;i&lt;n-1;i++)\n\t\n\t\t\tif(map[ a[i] ][ a[i+1] ] == 0)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\treturn true;\n}\nvoid init()\n{\n\tfor(int i=0;i&lt;10;i++)\n\t\ta[i]=i;\n}\nint main()\n{\n     int n;\n\t int k;\n\t cin&gt;&gt;n&gt;&gt;k;\n\t\n\n\t for(int i=0;i&lt;n;i++)\n\t\t for(int j = 0; j &lt; n; j++)\n\t\t\t cin&gt;&gt;map[i][j];\n\t init();\n\t int num=0;\n\t do \n\t {\n\t\tif(isOk(n))\n\t\t\tnum++;\n\t\tif(num==k)\n\t\t{\n\t\t\tcout&lt;&lt;a[0];\n\t\t\tfor(int i=1;i&lt;n;i++)\n\t\t\t\tcout&lt;&lt;" "&lt;&lt;a[i];\n\t\t\tcout&lt;&lt;endl;\n\t\t\tbreak;\n\t\t}\n\t\t\t\t\t \n\t\t //cout&lt;&lt;endl;\n\t } while (std::next_permutation(a,a+n));\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.StreamTokenizer;\nimport java.util.Collections;\nimport java.util.LinkedList;\n\npublic class Main {\n\n\tprivate static int vis[][];\n\tprivate static int count = 0, m;\n\tprivate static LinkedList&lt;String&gt; queue = new LinkedList&lt;String&gt;();\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tStreamTokenizer st = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n\n\t\tst.nextToken();\n\t\tint n = (int) st.nval;\n\t\tst.nextToken();\n\t\tm = (int) st.nval;\n\n\t\tint arr[] = new int[n];\n\t\tvis = new int[n][n];\n\t\tfor (int i = 0; i &lt; n; i++) {\n\t\t\tarr[i] = i;\n\t\t\tfor (int j = 0; j &lt; n; j++) {\n\t\t\t\tst.nextToken();\n\t\t\t\tvis[i][j] = (int) st.nval;\n\t\t\t}\n\t\t}\n\t\tallsort(arr, 0);\n\t\tCollections.sort(queue);\n\t\tSystem.out.println(queue.get(m - 1));\n\t}\n\n\tprivate static void allsort(int arr[], int k) {\n\n\t\tif (arr.length == k) {\n\t\t\tint ok = 0;\n\t\t\tString str = "";\n\t\t\tfor (int i = 0; i &lt; arr.length - 1; i++) {\n\t\t\t\tif (vis[arr[i]][arr[i + 1]] == 0) {\n\t\t\t\t\tok = 1;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tstr += arr[i] + " ";\n\t\t\t}\n\n\t\t\tif (ok == 0) {\n\t\t\t\tqueue.add(str + arr[k - 1]);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tint tmp;\n\t\tfor (int i = k; i &lt; arr.length; i++) {\n\t\t\ttmp = arr[i];\n\t\t\tarr[i] = arr[k];\n\t\t\tarr[k] = tmp;\n\t\t\tallsort(arr, k + 1);\n\t\t\ttmp = arr[i];\n\t\t\tarr[i] = arr[k];\n\t\t\tarr[k] = tmp;\n\t\t}\n\t}\n}\r\n</textarea>	131
131	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　给定一个t，将t秒转化为HH:MM:SS的形式，表示HH小时MM分钟SS秒。HH,MM,SS均是两位数，如果小于10用0补到两位。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行一个数T(1&lt;=T&lt;=100,000)，表示数据组数。后面每组数据读入一个数t，0&lt;=t&lt;24*60*60。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　每组数据一行，HH:MM:SS。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  2\n  <br> 0\n  <br> 86399\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  00:00:00\n  <br> 23:59:59\n </div> \n</div>	<textarea id="codelinesc">\r\n/*\n给定一个t，将t秒转化为HH:MM:SS的形式，表示HH小时MM分钟SS秒。HH,MM,SS均是两位数，如果小于10用0补到两位。\n输入格式\n　　第一行一个数T(1&lt;=T&lt;=100,000)，表示数据组数。后面每组数据读入一个数t，0&lt;=t&lt;24*60*60。\n输出格式\n　　每组数据一行，HH:MM:SS。\n样例输入\n2\n0\n86399\n样例输出\n00:00:00\n23:59:59\n*/\n\n#include&lt;stdio.h&gt;\n\nvoid huansuan(int t);\n\nint main (void)\n{\n\tint t,n,i;\n\tscanf("%d",&amp;n);\n\n\tfor(i=0;i&lt;n;i++)\n\t{\n\tscanf("%d",&amp;t);\n\thuansuan(t);\n\t}\n\treturn 0;\n}\n\nvoid huansuan(int t)\n{\n\tint miao=t%60;\n\tt/=60;\n\tint fen=t%60;\n\tt/=60;\n\tprintf("%02d:%02d:%02d\\n",t,fen,miao); \n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n\tint T,t[100000],i,x,y,z,k,n;\n\tscanf("%d",&amp;T);\n\tfor(i=0;i&lt;T;i++)\n\t{\n\t\tscanf("%d",&amp;t[i]);\n\t\t\n\t\t\n\t}\n\tfor(i=0;i&lt;T;i++)\n\t{\n\t\tx=t[i]/3600;\n\t\ty=t[i]%3600;\n\t\tz=y/60;\n\t\tk=y%60;\n\t\tn=k;\n\t\tprintf("%02d:%02d:%02d\\n",x,z,n);\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\r\n\r\npublic class Main {\r\n\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tint n = Integer.parseInt(br.readLine());\r\n\r\n\t\tint[] arr = new int[n];\r\n\t\tfor (int i = 0; i &lt; arr.length; i++) {\r\n\t\t\tarr[i] = Integer.parseInt(br.readLine());\r\n\t\t}\r\n\t\tfunc(arr);\r\n\t}\r\n\r\n\tpublic static void func(int[] arr) {\r\n\t\tfor (int i = 0; i &lt; arr.length; i++) {\r\n\t\t\tint h = arr[i] / 3600;\r\n\t\t\tint m = (arr[i] - h * 3600) / 60;\r\n\t\t\tint t = arr[i] - h * 3600 - m * 60;\r\n\r\n\t\t\tSystem.out.println((h &gt; 9 ? h : ("0" + h)) + ":"\r\n\t\t\t\t\t+ (m &gt; 9 ? m : ("0" + m)) + ":" + (t &gt; 9 ? t : ("0" + t)));\r\n\t\t}\r\n\t}\r\n}\r\n</textarea>	132
132	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　给两组数，各n个。\n  <br> 　　请调整每组数的排列顺序，使得两组数据相同下标元素对应相乘，然后相加的和最小。要求程序输出这个最小值。\n  <br> 　　例如两组数分别为:1 3　　-5和-2 4 1\n  <br> \n  <br> 　　那么对应乘积取和的最小值应为：\n  <br> 　　(-5) * 4 + 3 * (-2) + 1 * 1 = -25\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一个行一个数T表示数据组数。后面每组数据，先读入一个n，接下来两行每行n个数，每个数的绝对值小于等于1000。\n  <br> 　　n&lt;=8,T&lt;=1000\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　一个数表示答案。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <pre class="pddata">\n2\n3\n1 3 -5\n-2 4 1\n5\n1 2 3 4 5\n1 0 1 0 1\n</pre> \n <p></p> \n <br>\n <p></p>\n <p class="subtitle">样例输出</p>\n <p class="probcontent"> </p>\n <p><font face="Times New Roman" size="3"></font></p>\n <pre><font face="Times New Roman" size="3">-25\n6\n</font></pre> \n <p></p> \n <br>  \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\r\n\r\nvoid sort1(int *a,int n)\r\n{\r\n\tint i,j;\r\n\tint tmp;\r\n\tfor(i=0;i&lt;n-1;i++)\r\n\t\tfor(j=0;j&lt;n-1-i;j++)\r\n\t\t\tif(a[j]&gt;a[j+1])\r\n\t\t\t{\r\n\t\t\t\ttmp=a[j];\r\n\t\t\t\ta[j]=a[j+1];\r\n\t\t\t\ta[j+1]=tmp;\r\n\t\t\t}\r\n}\r\nvoid sort2(int *a,int n)\r\n{\r\n\tint i,j;\r\n\tint tmp;\r\n\tfor(i=0;i&lt;n-1;i++)\r\n\t\tfor(j=0;j&lt;n-1-i;j++)\r\n\t\t\tif(a[j]&lt;a[j+1])\r\n\t\t\t{\r\n\t\t\t\ttmp=a[j];\r\n\t\t\t\ta[j]=a[j+1];\r\n\t\t\t\ta[j+1]=tmp;\r\n\t\t\t}\r\n}\r\nint main(void)\r\n{\r\n\tint T;\r\n\tint n,i;\r\n\tint total;\r\n\tint a[8],b[8],c[8];\r\n\tscanf("%d",&amp;T);\r\n\twhile(T)\r\n\t{\r\n\t\ttotal=0;\r\n\t\tscanf("%d",&amp;n);\r\n\t\tfor(i=0;i&lt;n;i++)\r\n\t\t\tscanf("%d",&amp;a[i]);\r\n\t\tfor(i=0;i&lt;n;i++)\r\n\t\t\tscanf("%d",&amp;b[i]);\r\n\t\tsort1(a,n);\r\n\t\tsort2(b,n);\r\n\t\t\r\n\t\tfor(i=0;i&lt;n;i++)\r\n\t\t\tc[i]=a[i]*b[i];\r\n\t\tfor(i=0;i&lt;n;i++)\r\n\t\t\ttotal+=c[i];\r\n\t\tprintf("%d\\n",total);\r\n\t\tT--;\r\n\t}\r\n\treturn 0;\r\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nint a[8],b[8];\nint main()\n{\n\tint T,n;\n\tint i,j;\n\tcin&gt;&gt;T;\n\twhile(T--)\n\t{\n\t\tint sum=0;\n\t\tcin&gt;&gt;n;\n\t\tfor(i=0;i&lt;n;i++)\n\t\t\tcin&gt;&gt;a[i];\n\t\tfor(i=0;i&lt;n;i++)\n\t\t\tcin&gt;&gt;b[i];\n\t\tsort(a,a+n);\n\t\tsort(b,b+n);\n\t\tfor(i=0;i&lt;n;i++)\n\t\t{\n\t\t\tsum+=a[i]*b[n-1-i];\n\t\t}\n\t\tcout&lt;&lt;sum&lt;&lt;endl;\n\t}\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic static void sortInt(int[] num){\n\t\tint temp = 0;\n\t\tfor(int i=0;i&lt;num.length-1; i++){\n\t\t\tfor(int j=i+1; j&lt;num.length;j++){\n\t\t\t\tif(num[i]&lt;num[j]){\n\t\t\t\t\ttemp = num[i];\n\t\t\t\t\tnum[i] = num[j];\n\t\t\t\t\tnum[j] = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader buf = new BufferedReader(new InputStreamReader(System.in));\n\t\tString temp = buf.readLine();\n\t\tint t = Integer.parseInt(temp);\n\t\tfor(int k=0; k&lt;t; k++){\n\t\t\ttemp = buf.readLine();\n\t\t\tInteger n = Integer.parseInt(temp);\n\t\t\tString[] tempNum = buf.readLine().split(" ");\n\t\t\tint[] num1 = new int[n];\n\t\t\tint[] num2 = new int[n];\n\t\t\tfor(int i=0; i&lt;tempNum.length; i++){\n\t\t\t\t\tnum1[i] = Integer.parseInt(tempNum[i]);\n\t\t\t}\n\t\t\ttempNum = buf.readLine().split(" ");\n\t\t\tfor(int i=0; i&lt;tempNum.length; i++){\n\t\t\t\tnum2[i] = Integer.parseInt(tempNum[i]);\n\t\t\t}\n\t\t\t\n\t\t\tsortInt(num1);\n\t\t\tsortInt(num2);\n\t\t\tint sum = 0;\n\t\t\tfor(int i=0; i&lt;n; i++){\n\t\t\t\tsum += num1[i]*num2[n-1-i];\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n}\r\n</textarea>	133
133	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　给两组数，各n个。\n  <br> 　　请调整每组数的排列顺序，使得两组数据相同下标元素对应相乘，然后相加的和最小。要求程序输出这个最小值。\n  <br> 　　例如两组数分别为:1 3　　-5和-2 4 1\n  <br> \n  <br> 　　那么对应乘积取和的最小值应为：\n  <br> 　　(-5) * 4 + 3 * (-2) + 1 * 1 = -25\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一个行一个数T表示数据组数。后面每组数据，先读入一个n，接下来两行每行n个数，每个数的绝对值小于等于1000。\n  <br> 　　n&lt;=1000,T&lt;=10\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　一个数表示答案。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <pre class="pddata">\n2\n3\n1 3 -5\n-2 4 1\n5\n1 2 3 4 5\n1 0 1 0 1\n</pre> \n <p></p> \n <br>\n <p></p>\n <p class="subtitle">样例输出</p>\n <p class="probcontent"> </p>\n <p><font face="Times New Roman" size="3"></font></p>\n <pre><font face="Times New Roman" size="3">-25\n6\n</font></pre> \n <p></p> \n <br>  \n</div>	<textarea id="codelinesc">\r\n#include "stdio.h"\n#define Size 1002\nint part1(int a[],int left,int right)\n{\n\tint x;\n\tint low;\n\tint high;\n\tx=a[left];\n\tlow=left;\n\thigh=right;\n\twhile(low&lt;high)\n\t{\n\t\twhile(a[high]&gt;x&amp;&amp;low&lt;high)\n\t\t{\n\t\t\thigh--;\n\t\t}\n\t\tif(low&lt;high)\n\t\t{\n\t\t\ta[low]=a[high];\n\t\t\tlow++;\n\t\t}\n\t\twhile(a[low]&lt;x&amp;&amp;low&lt;high)\n\t\t{\n\t\t\tlow++;\n\t\t}\n\t\tif(low&lt;high)\n\t\t{\n\t\t\ta[high]=a[low];\n\t\t\thigh--;\n\t\t}\n\t}\n\ta[low]=x;\n\treturn low;\n}\nint part2(int a[],int left,int right)\n{\n\tint x;\n\tint low;\n\tint high;\n\tx=a[left];\n\tlow=left;\n\thigh=right;\n\twhile(low&lt;high)\n\t{\n\t\twhile(a[high]&lt;x&amp;&amp;low&lt;high)\n\t\t{\n\t\t\thigh--;\n\t\t}\n\t\tif(low&lt;high)\n\t\t{\n\t\t\ta[low]=a[high];\n\t\t\tlow++;\n\t\t}\n\t\twhile(a[low]&gt;x&amp;&amp;low&lt;high)\n\t\t{\n\t\t\tlow++;\n\t\t}\n\t\tif(low&lt;high)\n\t\t{\n\t\t\ta[high]=a[low];\n\t\t\thigh--;\n\t\t}\n\t}\n\ta[low]=x;\n\treturn low;\n}\nvoid sort2(int a[],int low,int high)\n{\n\tint mid;\n\tif(low&lt;high)\n\t{\n\t\tmid=part2(a,low,high);\n\t\tsort2(a,low,mid-1);\n\t\tsort2(a,mid+1,high);\n\t}\n}\nvoid sort1(int a[],int low,int high)\n{\n\tint mid;\n\tif(low&lt;high)\n\t{\n\t\tmid=part1(a,low,high);\n\t\tsort1(a,low,mid-1);\n\t\tsort1(a,mid+1,high);\n\t}\n}\nint main()\n{\n\tint T;\n\tint n;\n\tint i;\n\tint a[Size];\n\tint b[Size];\n\tint l;\n\tint sum;\n\n\tscanf("%d",&amp;T);\n\t\n\twhile(T)\n\t{\n\t\tscanf("%d",&amp;n);\n\t\tfor(i=1;i&lt;=n;i++)\n\t\t{\n\t\t\tscanf("%d",&amp;a[i]);\n\t\t}\n\t\tfor(i=1;i&lt;=n;i++)\n\t\t{\n\t\t\tscanf("%d",&amp;b[i]);\n\t\t}\n\t\tsort1(a,1,n);\n\t\tsort2(b,1,n);\n\t\n\t\tsum=0;\n\t\tfor(l=1;l&lt;=n;l++)\n\t\t{\n\t\t\tsum=sum+(a[l]*b[l]);\n\t\t}\n\t\tprintf("%d",sum);\n\t\tprintf("\\n");\n\t\tT--;\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nint a[1005], b[1005];\nint cmp(int a, int b){\n\treturn a &gt; b;\n}\nint main(){\n\tint chiose, n, i, sum;\n\tscanf("%d", &amp;chiose);\n\twhile(chiose--){\n\t\tsum = 0;\n\t\tscanf("%d", &amp;n);\n\t\tfor(i = 0; i &lt; n; i++)\n\t\t\tscanf("%d", &amp;a[i]);\n\t\tfor(i = 0; i &lt; n; i++)\n\t\t\tscanf("%d", &amp;b[i]);\n\t\tsort(a, a + n);\n\t\tsort(b, b + n, cmp);\n\t\tfor(i = 0; i &lt; n; i++){\n\t\t\tsum += a[i] * b[i];\n\t\t}\n\t\tprintf("%d\\n", sum);\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.StreamTokenizer;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\n\tprivate static int n;\n\tprivate static PriorityQueue&lt;Integer&gt; one = new PriorityQueue&lt;&gt;();\n\tprivate static PriorityQueue&lt;Integer&gt; two = new PriorityQueue&lt;&gt;();\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tStreamTokenizer st = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n\t\tst.nextToken();\n\t\tint t = (int) st.nval;\n\t\twhile (t-- &gt; 0) {\n\t\t\tst.nextToken();\n\t\t\tn = (int) st.nval;\n\t\t\tone.clear();\n\t\t\ttwo.clear();\n\t\t\tfor (int i = 0; i &lt; n; i++) {\n\t\t\t\tst.nextToken();\n\t\t\t\tone.add((int) st.nval);\n\t\t\t}\n\t\t\tfor (int i = 0; i &lt; n; i++) {\n\t\t\t\tst.nextToken();\n\t\t\t\ttwo.add((int) st.nval);\n\t\t\t}\n\n\t\t\tLinkedList&lt;Integer&gt; onelist = new LinkedList&lt;Integer&gt;();\n\t\t\tLinkedList&lt;Integer&gt; twolist = new LinkedList&lt;Integer&gt;();\n\n\t\t\twhile (!one.isEmpty()) {\n\t\t\t\tonelist.add(one.poll());\n\t\t\t\ttwolist.add(two.poll());\n\t\t\t}\n\n\t\t\tint maxo, mino, maxt, mint, result = 0;\n\t\t\twhile (!onelist.isEmpty()) {\n\t\t\t\tmaxo = onelist.getLast();\n\t\t\t\tmint = twolist.getFirst();\n\t\t\t\tmino = onelist.getFirst();\n\t\t\t\tmaxt = twolist.getLast();\n\n\t\t\t\tif (maxo * mint &lt; mino * maxt) {\n\t\t\t\t\tresult += (maxo * mint);\n\t\t\t\t\tonelist.removeLast();\n\t\t\t\t\ttwolist.removeFirst();\n\t\t\t\t} else {\n\t\t\t\t\tresult += (maxt * mino);\n\t\t\t\t\tonelist.removeFirst();\n\t\t\t\t\ttwolist.removeLast();\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(result);\n\t\t}\n\t}\n}\n\r\n</textarea>	134
134	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　锦瑟年华谁与度 莫问情归处 只影向斜阳 剑吼西风 欲把春留驻\n  <br> 　　天涯芳草无归路 回首花无数 解语自销魂 弱袂萦春 尘缘不相误\n  <br> 　　......\n  <br> 　　在卡勒沃夫充满文学杀伤力的声音中，身处紫荆2号楼202B的四位远近高低各不同的室友纷纷回忆起了各自波澜起伏的过去，并对长在百草园，邻有百花谷的现状表达了各自的见解。\n  <br> 　　某Q："...我小学就开窍了...她的父母说我很好，但是...今天又和北林的联系了..."\n  <br> 　　某X："...差点就成了，结果到学校了...这个方法放假了我去对我的同桌用！..."\n  <br> 　　某W："..."（千言万语不言中，有大量的故事等待考古）\n  <br> 　　某Z："...为了来清华...咱们审美观不一样，不会抢..."\n  <br> 　　......\n  <br> 　　卡勒沃夫在这个不朽的夜话中搜集出了某人零散的历任女友资料，为了强迫某人将他出的题目的标程交出，现在卡勒沃夫需要一个能将这些零散信息整合起来的程序。伴随着雄壮委婉动人的音乐，身为程序设计快男（超女）的你降临了！卡勒沃夫正对着您做Orz状并请求着："神牛啊~请施舍给我一段程序把~偶米头发~"。。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行为一个不超过5的整数T，表示数据的组数。之后每组数据的一行为一个不超过100的整数n。之后n行每行有两个用单个空格隔开的字符串（每个字符串只有英文大小写字母，长度不超过10），为两位mm的名字。每行第一个mm先于第二个mm成为某人的女友。\n  <br> 　　在这里我们假装诅咒某人不会同时被两个或两个以上mm泡，某个mm抛弃了某人后不会再吃回头草，同时卡勒沃夫深邃的洞察力使得他收集到了充足的信息以确定某人女友的先后顺序。\n  <br> 　　在小数据组中出现的人物不超过13个\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出T行，每行对应一组数据，并按照mm们从先到后成为某人女友的顺序输出她们的名字，各个名字间用一个空格隔开。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <pre class="pddata">\n2\n2\nRY Unknown\nYSZ RY\n3\ntomorrow yestoday\ntomorrow today\ntoday yestoday\n</pre> \n <p></p> \n <br>\n <p></p>\n <p class="subtitle">样例输出</p>\n <p class="probcontent"> </p>\n <p><font face="Times New Roman" size="3"></font></p>\n <pre><font face="Times New Roman" size="3">YSZ RY Unknown\ntomorrow today yestoday</font></pre> \n <p></p> \n <br>  \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n#include&lt;stdlib.h&gt;\nchar mm[105][15];\nchar s1[15],s2[15];\nint link[105][2];\nint length[105]={0};\nint in[105];\nint N;\ntypedef struct{\n\tchar name[15];\n\tint num;\n}girl;\nvoid fun(int x)\n{\n\tint i,y;\n\tfor(i=0;i&lt;N;i++)\n\t\tif(link[i][0]==x)\n\t\t{\n\t\t\ty=link[i][1];\n\t\t\tlength[ y ]=length[x]+1&gt;=length[y]?length[x]+1:length[y];\n\t\t\tfun(y);\n\t\t}\n}\nint comp(const void *a, const void *b)\n{\n\treturn (*(girl *)a).num&gt;(*(girl *)b).num?1:-1;\n}\nint main()\n{\n\tint i,j,T,n,f,x,y,sum=0;\n\tgirl g[105];\n\tscanf("%d",&amp;T);\n\twhile(T--)\n\t{\n\t\tmemset(mm,0,sizeof(mm));\n\t\tmemset(link,0,sizeof(mm));\n\t\tmemset(in,0,sizeof(in));\n\t\tmemset(length,0,sizeof(length));\n\t\tscanf("%d",&amp;N);\n\t\tn=0;\n\t\tfor(i=0;i&lt;N;i++)\n\t\t{\n\t\t\tscanf("%s%s",s1,s2);\n\t\t\tf=0;\n\t\t\tfor(j=0;j&lt;n;j++)\n\t\t\t\tif(strcmp(s1,mm[j])==0)\n\t\t\t\t{\n\t\t\t\t\tf=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif(f==1)\n\t\t\t\tx=j;\n\t\t\telse\n\t\t\t{\n\t\t\t\tstrcpy(mm[n++],s1);\n\t\t\t\tx=n-1;\n\t\t\t}\n\t\t\tf=0;\n\t\t\tfor(j=0;j&lt;n;j++)\n\t\t\t\tif(strcmp(s2,mm[j])==0)\n\t\t\t\t{\n\t\t\t\t\tf=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif(f==1)\n\t\t\t\ty=j;\n\t\t\telse\n\t\t\t{\n\t\t\t\tstrcpy(mm[n++],s2);\n\t\t\t\ty=n-1;\n\t\t\t}\n\t\t\tlink[i][0]=x;\n\t\t\tlink[i][1]=y;\n\t\t}\n\n\t\tfor(i=0;i&lt;N;i++)\n\t\t\tin[link[i][1]]++;\n\t\tfor(i=0;i&lt;n;i++)\n\t\t\tif(in[i]==0)\n\t\t\t\tbreak;\n\t\tfun(i);\n\t\t\n\t\t\n\t\n\t\tfor(i=0;i&lt;n;i++)\n\t\t{\n\t\t\tstrcpy(g[i].name,mm[i]);\n\t\t\tg[i].num=length[i];\n\t\t}\n\t\t\n\t\tqsort(g,n,sizeof(g[0]),comp);\n\t\t\n\t\tfor(i=0;i&lt;n;i++)\n\t\t{\n\t\t\tprintf("%s",g[i].name);\n\t\t\tif(i==n-1)\n\t\t\t\tprintf("\\n");\n\t\t\telse\n\t\t\t\tprintf(" ");\n\t\t}\n\n  \n\t}\n\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;cstring&gt;\n#include&lt;fstream&gt;\nusing namespace std;\nlong a,b,c,d,n,t,gx[141][141],rd[141],gs=0,now=0;\nchar ss[141][100],s1[100],s2[100];\nint find(char s[100])\n{\n\tint i;\n\tfor (i=1;i&lt;=now;i++)\n\t\tif (strcmp(ss[i],s)==0) return i;\n\t\tstrcpy(ss[++now],s);\n\t\treturn(now);\n}\nint main()\n{\n\tcin&gt;&gt;t;\t\n\twhile (t--)\n\t{\n\t\tcin&gt;&gt;n;\n\t\tnow=0;\n\t\tfor (a=1;a&lt;=140;a++)\n\t\t{\n\t\t\trd[a]=0;\n\t\t\tfor (b=1;b&lt;=140;b++)\n\t\t\t\tgx[a][b]=0;\n\t\t}\n\t\tfor (a=0;a&lt;n;a++)\n\t\t{\n\t\t\tcin&gt;&gt;s1&gt;&gt;s2;\n\t\t\tb=find(s1);\n\t\t\tc=find(s2);\n\t\t\tif (gx[b][c]!=1)\n\t\t\t{\t\t\t\n\t\t\tgx[b][c]=1;\n\t\t\trd[c]++;\n\t\t}\n\t\t}\n\t\td=now;\n\t\twhile (now--)\n\t\t{\n\t\t\tfor (a=1;a&lt;=d;a++)\n\t\t\t\tif (rd[a]==0)\n\t\t\t\t{\n\t\t\t\t\trd[a]=-1;\n\t\t\t\t\tif (now&gt;0) cout&lt;&lt;ss[a]&lt;&lt;' ';\n\t\t\t\t\telse if (now==0) cout&lt;&lt;ss[a]&lt;&lt;endl;\n\t\t\t\t\tfor (b=1;b&lt;=d;b++)\n\t\t\t\t\t\tif (gx[a][b]==1) rd[b]--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t}\nreturn(0);\n}\n\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\n\npublic class Main {\n\tstatic int N;\n\tstatic String [] topo=new String[10000];\n\tstatic int t=0;\n\tstatic Map&lt;String, ArrayList&lt;String&gt;&gt; map=new HashMap&lt;String, ArrayList&lt;String&gt;&gt;();\n\tstatic Map&lt;String ,Integer&gt; c=new HashMap&lt;String, Integer&gt;();\n\tstatic boolean dfs(String n){\n\t\tc.put(n, -1);\n\t\tList&lt;String&gt; ls=map.get(n);\n\t\tif(ls!=null)\n\t\tfor(String key:ls){\n\t\t\tif(c.get(key)!=null&amp;&amp;c.get(key)==-1) return false;\n\t\t\telse if(c.get(key)==null&amp;&amp;!dfs(key)) return false;\n\t\t}\n\t\tc.put(n, 1);\n\t\ttopo[t++]=n;\n\t\n\t\treturn true;\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tN=sc.nextInt();\n\t\twhile(N--!=0){\n\t\t\tmap.clear();\n\t\t\tc.clear();\n\t\t\tt=0;\n\t\t\tint k=sc.nextInt();\n\t\t\tfor(int i=0;i&lt;k;i++){\n\t\t\t\tString s1=sc.next();\n\t\t\t\tString s2=sc.next();\n\t\t\t//\tSystem.out.println(s1+"-----"+s2);\n\t\t\t\tif(map.get(s1)!=null){\n\t\t\t\t\tmap.get(s1).add(s2);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tArrayList&lt;String&gt; al=new ArrayList&lt;String&gt;();\n\t\t\t\t\tal.add(s2);\n\t\t\t\t\tmap.put(s1, al);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSet&lt;String&gt; set=map.keySet();\n\t\t\tfor(String key:set){\n\t\t\t\tif(c.get(key)==null)\n\t\t\t\tif(!dfs(key)) return;\n\t\t\t\t\n\t\t\t}\n\t\t\tfor(int i=t-1;i&gt;=0;i--)\n\t\t\t\tSystem.out.print(topo[i]+" ");\n\t\t\tSystem.out.println();\n\t\t}\n\t\t\n\t}\n}\n\r\n</textarea>	135
135	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　对于n个数，从中取出m个数，如何取使得这m个数的乘积最大呢？\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行一个数表示数据组数\n  <br> 　　每组输入数据共2行：\n  <br> 　　第1行给出总共的数字的个数n和要取的数的个数m，1&lt;=n&lt;=m&lt;=15，\n  <br> 　　第2行依次给出这n个数，其中每个数字的范围满足:a[i]的绝对值小于等于4。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　每组数据输出1行，为最大的乘积。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  1\n  <br> 5 5\n  <br> 1 2 3 4 2\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <pre class="pddata">\n<font face="Times New Roman" size="3">48 </font>\n</pre> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n#include&lt;string.h&gt;\nint max;\nvoid fun(int *val,int index,int size,int m,int cnt,int res);\nint main()\n{\n\tint n,m,x,i;\n\tint val[15];\n\t\n\tscanf("%d",&amp;x);\n\twhile(x--)\n\t{\n\t\tscanf("%d %d",&amp;n,&amp;m);\n\t\tfor(i=0;i&lt;n;i++)\n\t\t{\n\t\t\tscanf("%d",&amp;val[i]);\n\t\t}\n\t\tmax = -10000000;\n\t\tfun(val,0,n,m,0,1);\n\t\tprintf("%d\\n",max);\n\t}\n\treturn 0;\n}\n\nvoid fun(int *val,int index,int size,int m,int cnt,int res)\n{\n\tif(m==cnt)\n\t{\n\t\tif(res &gt; max)\n\t\t{\n\t\t\tmax = res;\n\t\t}\n\t\treturn ;\n\t}\n\tif(index&gt;=size)\n\t{\n\t\treturn ;\n\t}\n\tfun(val,index+1,size,m,cnt+1,res*val[index]);\n\tfun(val,index+1,size,m,cnt,res);\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include "iostream"\n#include "stdio.h"\n#include "string"\n#include "math.h"\n#include "ctype.h"\n#include "vector"\n#include "stdlib.h"\n#include "string.h"\n#include "time.h"\n#include "set"\n#include "algorithm"\nusing namespace std;\nint ans=-(1&lt;&lt;29);\nint n,m;\nint a[1000];\nvoid dfs(int *a,int cur,int sum,int k)\n{\n\tif(k&gt;m)\n\t\treturn ;\n\tif(cur==n)\n\t{\n\t\tif(k==m)\n\t\tans=std::max(ans,sum);\n\t\treturn ;\n\t}\n\tdfs(a,cur+1,sum*a[cur],k+1);\n\tdfs(a,cur+1,sum,k);\n}\nint main()\n{\n\tint T;\n\t\n\tcin&gt;&gt;T;\n\twhile(T--)\n\t{\n\t\tcin&gt;&gt;n&gt;&gt;m;\n\t\tfor (int i = 0; i &lt;  n; i++)\n\t\t{\n\t\t\tcin&gt;&gt;a[i];\n\t\t}\n\t\tans=-(1&lt;&lt;29);\n\t\tdfs(a,0,1,0);\n\t\tcout&lt;&lt;ans&lt;&lt;endl;\n\t}\n\t\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tint s = 0x80000000;\n\n\tpublic void input() {\n\t\tScanner in = new Scanner(System.in);\n\t\tint t = in.nextInt();\n\t\twhile (t &gt; 0) {\n\t\t\ts = 0x80000000;\n\t\t\tt--;\n\t\t\tint n = in.nextInt();\n\t\t\tint m = in.nextInt();\n\t\t\tint[] num = new int[n];\n\t\t\tfor (int i = 0; i &lt; n; i++) {\n\t\t\t\tnum[i] = in.nextInt();\n\t\t\t}\n\t\t\tcount(num, 0, m, n,1);\n\t\t\tint min = num[0];\n\t\t\tSystem.out.println(s);\n\t\t}\n\n\t}\n\t\n\tprivate void count(int[] num,int i,int m,int n,int sum){\n\t\tif(m==0&amp;&amp;sum&gt;s)s=sum;\n\t\tif(i&lt;n&amp;&amp;m&gt;=0){\n\t\t\tcount(num,i+1,m-1,n,sum*num[i]);\n\t\t\tcount(num,i+1,m,n,sum);\n\t\t}\n\t}\n\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().input();\n\t}\n\n}\r\n</textarea>	136
136	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　对于一个给定的长度为N的整数序列A，它的“子序列”的定义是：A中非空的一段连续的元素（整数）。你要完成的任务是，在所有可能的子序列中，找到一个子序列，该子序列中所有元素的和是最大的（跟其他所有子序列相比）。程序要求你输出这个最大值。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入文件的第一行包含一个整数N，第二行包含N个整数，表示A。\n  <br> 　　其中\n  <br> 　　1 &lt;= N &lt;= 100000\n  <br> 　　-10000 &lt;= A[i] &lt;=　　10000\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出仅包含一个整数，表示你算出的答案。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <pre class="pddata">\n5\n3 -2 3 -5 4</pre> \n <p></p> \n <br>\n <p></p>\n <p class="subtitle">样例输出</p>\n <p class="probcontent"> </p>\n <p><font face="Times New Roman" size="3"></font></p>\n <pre><font face="Times New Roman" size="3">4</font></pre> \n <p></p> \n <br>  \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nlong long A[100000], ThisSum, MaxSum, i, N;\nint main(void)\n{\n\tscanf("%lld", &amp;N);\n\tfor (i = 0; i &lt; N; i++)\n\t\tscanf("%lld", &amp;A[i]);\n\tfor (i = 0; i &lt; N; i++)\n\t{\n\t\tThisSum += A[i];\n\t\tif (ThisSum &gt; MaxSum)\n\t\t\tMaxSum = ThisSum;\n\t\telse\n\t\t\tThisSum = 0;\n\t}\n\tprintf("%lld", MaxSum);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\nint main()\n{\n\tcout&lt;&lt;"33227197";\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\n\npublic class Main{\n\tpublic static void main(String args[]){\n\t\tSystem.out.println(33227197);\n\t}\n\n}\n\r\n</textarea>	137
185	<div class="des"> \n <div class="pdcont">\n  　　编程计算涂满高为2，半径为r的圆形蛋糕表面，需要多少表面积的奶油(只要涂上表面和侧面)\n  <br> 　　读入一个数r，输出需要奶油的表面积，结果保留一位小数\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5.0\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  141.4\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n\tfloat r;\n\tscanf("%f",&amp;r);\n\tfloat s;\n\ts=4*3.1415926*r+3.1415926*r*r;\n\tprintf("%.1f",s);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\r\n#include&lt;stdio.h&gt;\r\n#define PI  3.141592654\r\nusing namespace std;\r\nint main()\r\n{\r\n\tdouble  r;\r\n\tcin&gt;&gt;r;\r\n\tdouble s1,s2;\r\n\tdouble l1;\r\n\ts1=r*r*PI;\r\n\tl1=2*PI*r;\r\n\ts2=l1*2;\r\n\tprintf("%.1lf\\n",s1+s2);\r\n\treturn 0;\r\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tpublic static void main(String args[])throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tbr.close();\n\t\tdouble d = Double.parseDouble(st.nextToken());\n\t\tSystem.out.printf("%.1f" ,Math.PI*d*(4+d));\n\t}\n}\r\n</textarea>	186
137	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　首先给出简单加法算式的定义：\n  <br> 　　如果有一个算式(i)+(i+1)+(i+2),(i&gt;=0)，在计算的过程中，没有任何一个数位出现了进位，则称其为简单的加法算式。\n  <br> 　　例如：i=3时，3+4+5=12，有一个进位，因此3+4+5不是一个简单的加法算式；又如i=112时，112+113+114=339，没有在任意数位上产生进位，故112+113+114是一个简单的加法算式。\n  <br> \n  <br> 　　问题：给定一个正整数n，问当i大于等于0且小于n时,有多少个算式(i)+(i+1)+(i+2)是简单加法算式。其中n&lt;10000。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　一个整数，表示n\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　一个整数,表示简单加法算式的个数\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <pre class="pddata">\n4</pre> \n <p></p> \n <br>\n <p></p>\n <p class="subtitle">样例输出</p>\n <p class="probcontent"> </p>\n <p><font face="Times New Roman" size="3"></font></p>\n <pre><font face="Times New Roman" size="3">3</font></pre> \n <p></p> \n <br>  \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\r\n\r\nint main(void)\r\n{\r\n\tint n,i;\r\n\tint count=0;\r\n\tint a,b,c,d;\r\n\tscanf("%d",&amp;n);\r\n\tfor(i=0;i&lt;n;i++)\r\n\t{\r\n\t\td=i%10;\r\n\t\tc=i/10%10;\r\n\t\tb=i/100%10;\r\n\t\ta=i/1000;\r\n\t\tif(a&lt;=2&amp;&amp;b&lt;=2&amp;&amp;c&lt;=2&amp;&amp;d&lt;=2)\r\n\t\t\tcount++;\r\n\t}\r\n\tprintf("%d",count);\r\n\r\n\treturn 0;\r\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\n\nint f(int n)\n{\n\tif((3*(n%10)+3)&gt;=10)\n\t{\n\t\treturn 0;\n\t}\n\tn/=10;\n\twhile(n)\n\t{\n\t\tif(3*(n%10)&gt;=10)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tn/=10;\n\t}\n\treturn 1;\n}\nint main()\n{\n\tint n,cnt=0;\n\tint i;\n\tcin&gt;&gt;n;\n\tfor(i=0;i&lt;n;i++)\n\t{\n\t\tif(f(i))\n\t\t\tcnt++;\n\t}\n\tcout&lt;&lt;cnt;\n\treturn 0;\n} \r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(br.readLine());\n\t\tint count = 0;\n\t\tfor (int i = 1; i &lt; n; i++) {\n\t\t\tif (simpleAdd(i, i + 1, i + 2)) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n\n\tprivate static boolean simpleAdd(int i, int j, int k) {\n\t\tif (i / 1000 + j / 1000 + k / 1000 &gt; 9)\n\t\t\treturn false;\n\t\tif (i / 100 % 10 + j / 100 % 10 + k / 100 % 10 &gt; 9)\n\t\t\treturn false;\n\t\tif (i / 10 % 10 + j / 10 % 10 + k / 10 % 10 &gt; 9)\n\t\t\treturn false;\n\t\tif (i % 10 + i % 10 + i % 10 &gt; 9)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n}\n\r\n</textarea>	138
138	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　给定两个N×M的矩阵，计算其和。其中：\n  <br> 　　N和M大于等于1且小于等于100，矩阵元素的绝对值不超过1000。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入数据的第一行包含两个整数N、M，表示需要相加的两个矩阵的行数和列数。接下来2*N行每行包含M个数，其中前N行表示第一个矩阵，后N行表示第二个矩阵。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　你的程序需要输出一个N*M的矩阵，表示两个矩阵相加的结果。注意，输出中每行的最后不应有多余的空格，否则你的程序有可能被系统认为是Presentation　　Error\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <pre class="pddata">\n2 2\n1 2\n3 4\n5 6\n7 8</pre> \n <p></p> \n <br>\n <p></p>\n <p class="subtitle">样例输出</p>\n <p class="probcontent"> </p>\n <p><font face="Times New Roman" size="3"></font></p>\n <pre><font face="Times New Roman" size="3">6 8\n10 12</font></pre> \n <p></p> \n <br>  \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\r\n\r\nint main(void)\r\n{\r\n\tstatic int a[100][100],b[100][100]; \r\n\tint n,m;\r\n\tint i,j;\r\n\tscanf("%d%d",&amp;n,&amp;m);\r\n\tfor(i=0;i&lt;n;i++)\r\n\t\tfor(j=0;j&lt;m;j++)\r\n\t\t\tscanf("%d",&amp;a[i][j]);\r\n\r\n\tfor(i=0;i&lt;n;i++)\r\n\t\tfor(j=0;j&lt;m;j++)\r\n\t\t\tscanf("%d",&amp;b[i][j]);\r\n\r\n\tfor(i=0;i&lt;n;i++)\r\n\t{\r\n\t\tfor(j=0;j&lt;m;j++)\r\n\t\t{\r\n\t\t\ta[i][j]+=b[i][j];\r\n\t\t\tprintf("%d ",a[i][j]);\r\n\t\t}\r\n\t\tprintf("\\n");\r\n\t}\r\n\treturn 0;\r\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;stdio.h&gt;\r\nmain()\r\n{\r\n\tint n,m;\r\n\tint i,j;\r\n\tint a[100][100];\r\n\tint b[100][100];\r\n\tint c[100][100];\r\n\tscanf("%d %d",&amp;n,&amp;m);\r\n\tfor(i=0;i&lt;n;i++)\r\n\t{\r\n\t\tfor(j=0;j&lt;m;j++)\r\n\t\t{\r\n\t\t\tscanf("%d",&amp;a[i][j]);\r\n\t\t}\r\n\t}\r\n\tfor(i=0;i&lt;n;i++)\r\n\t{\r\n\t\tfor(j=0;j&lt;m;j++)\r\n\t\t{\r\n\t\t\tscanf("%d",&amp;b[i][j]);\r\n\t\t}\r\n\t}\r\n\tfor(i=0;i&lt;n;i++)\r\n\t{\r\n\t\tfor(j=0;j&lt;m;j++)\r\n\t\t{\r\n\t\t\tc[i][j]=a[i][j]+b[i][j];\r\n\t\t}\r\n\t}\r\n\tfor(i=0;i&lt;n;i++)\r\n\t{\r\n\t\tfor(j=0;j&lt;m;j++)\r\n\t\t{\r\n\t\t\tprintf("%d\\t",c[i][j]);\r\n\t\t}\r\n\t\tprintf("\\n");\r\n\t}\r\n\treturn 0;\r\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint[][] a = new int[n][m];\n\t\tint[][] b = new int[n][m];\n\t\tint[][] c = new int[n][m];\n\t\tfor(int i=0; i&lt;n; i++){\n\t\t\tfor(int j=0; j&lt;m; j++){\n\t\t\t\ta[i][j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i&lt;n; i++){\n\t\t\tfor(int j=0; j&lt;m; j++){\n\t\t\t\tb[i][j] = sc.nextInt();\n\t\t\t\tc[i][j] = a[i][j] + b[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i&lt;n; i++){\n\t\t\tfor(int j=0; j&lt;m-1; j++){\n\t\t\t\tSystem.out.print(c[i][j] + " ");\n\t\t\t}\n\t\t\tSystem.out.print(c[i][m-1] + "\\n");\n\t\t}\n\t}\n}\n\r\n</textarea>	139
139	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　统计输入英文文章段落中不同单词（单词有大小写之分,　　但统计时忽略大小写）各自出现的次数。 输入段落中所含单词的总数不超过100，最长单词的长度不超过20个字母.\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　一个包含若干句子的段落, 每个句子由若干英文单词组成. 除空格,　　逗号和句号外, 这些输入的句子中不含其他非字母字符, 并且, 逗号和句号紧跟在它前面的英文单词后面, 中间没有空格. 段落最后一个字符是回车符,　　表示输入结束.\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　若段落中共有M个不同的英文单词，则按照其在段落中出现的先后顺序输出M行，各行的格式为:　　单词中所有字母均用大写形式输出（最长的单词顶格输出，它前面没有多余的空格;　　其余单词与其右对齐）+冒号+N个*号+该单词在段落中的出现次数N\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <pre class="pddata">\nThis is a test. This test is easy. This is a test. This test is easy.</pre> \n <p></p> \n <br>\n <p></p>\n <p class="subtitle">样例输出</p>\n <p class="probcontent"> </p>\n <p><font face="Times New Roman" size="3"></font></p>\n <pre><font face="Times New Roman" size="3">THIS:****4\nIS:****4\nA:**2\nTEST:****4\nEASY:**2\n</font></pre> \n <p></p> \n <br>  \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n\nstruct ha\n{   int n;\n\tchar c[21];\n}hasi[1000];\n\nint main()\n{  int i1,i2;\n\tchar a[1500],b[21];\n\tgets(a);\n\tint o=0,p=0;\n\tfor(i1=0;a[i1];i1++)\n\t{  if(a[i1]&lt;='z'&amp;&amp;a[i1]&gt;='a')\n\t     a[i1]-='a'-'A';\n\t\t\n\t}\n\tfor(i1=0;a[i1+1];i1++)\n\t{\n\t\tif(a[i1]&lt;'A'||a[i1]&gt;'z'||a[i1]&lt;'a'&amp;&amp;a[i1]&gt;'Z')\n\t\t{  b[o]='\\0'; \n\t\t   if(o==0)\n\t\t       continue;\n\t\t   for(i2=0;i2&lt;p;i2++)\n\t\t      {\n      \t\t\t   if(!strcmp(hasi[i2].c,b))\n      \t\t\t   {  hasi[i2].n++;\n      \t\t\t      break;\n\t      \t        }\n      \t\t}\n      \t\tif(i2==p)\n      \t\t{\n\t\t      \tstrcpy(hasi[p].c,b);\n  \t            hasi[p].n=1;\n\t\t      \tp++; \n\t\t      }\n      \t\to=0;\n      \t\tcontinue;\n\t\t}\n\t\tb[o++]=a[i1];\n\t}\n\t  b[o]='\\0'; \n\t\t \n\t\t   for(i2=0;i2&lt;p;i2++)\n\t\t      {\n      \t\t\t   if(!strcmp(hasi[i2].c,b))\n      \t\t\t   {  hasi[i2].n++;\n      \t\t\t      break;\n\t      \t        }\n      \t\t}\n      \t\tif(i2==p)\n      \t\t{\n\t\t      \tstrcpy(hasi[p].c,b);\n  \t            hasi[p].n=1;\n\t\t      \tp++; \n\t\t      }\n\tfor(i1=0;i1&lt;p;i1++)\n\t  {\n  \t\t   for(i2=0;hasi[i1].c[i2];i2++)\n  \t\t       if(hasi[i1].c[i2]&lt;='Z'&amp;&amp;hasi[i1].c[i2]&gt;='A')\n  \t\t             printf("%c",hasi[i1].c[i2]);\n                else \n                    printf("%c",hasi[i1].c[i2]-'a'+'A');\n           printf(":");\n           for(i2=0;i2&lt;hasi[i1].n;i2++)\n              printf("*");\n           printf("%d",hasi[i1].n);\n           printf("\\n");\n  \t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\ntypedef struct Node\n{\n\tchar str[30];\n\tint num;\n}node;\n\nchar string[3000], tstr[30];\nint maxlen;\nnode data[200];\n\nint print(char str[])\n{\n\tint len = strlen(str), i;\n\tfor(i = len; i &lt; maxlen; i++)\n\t{\n\t\tprintf(" ");\n\t}\n\tfor(i = 0; i &lt; len; i++)\n\t{\n\t\tif(str[i] &gt;= 'a' &amp;&amp; str[i] &lt;= 'z')\n\t\t{\n\t\t\tprintf("%c", str[i]-'a'+'A');\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf("%c", str[i]);\n\t\t}\n\t}\n\tprintf(":");\n\treturn 0;\n}\n\nvoid change(char str[])\n{\n\tint len = strlen(str), i;\n\tfor(i = 0; i &lt; len; i++)\n\t{\n\t\tif(str[i] &gt;= 'a' &amp;&amp; str[i] &lt;= 'z')\n\t\t{\n\t\t\tstr[i] = str[i]-'a'+'A';\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint len, n, top = 0, i, j, tlen;\n\tgets(string);\n\tlen = strlen(string);\n\tmaxlen = 0;\n\tfor(i = 0; i &lt; len; i++)\n\t{\n\t\tsscanf(&amp;string[i], "%s%n", tstr, &amp;n);\n\t\ttlen = n;\n\t\tif(tstr[n-1] == '.' || tstr[n-1] == ',')\n\t\t{\n\t\t\ttstr[n-1] = 0;\n\t\t\ttlen -= 1;\n\t\t}\n\t\tchange(tstr);\n\t\tif(tlen &gt; maxlen)\n\t\t{\n\t\t\tmaxlen = tlen;\n\t\t}\n\t\tfor(j = 0; j &lt; top; j++)\n\t\t{\n\t\t\tif(!strcmp(data[j].str, tstr))\n\t\t\t{\n\t\t\t\tdata[j].num++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(j == top)\n\t\t{\n\t\t\tstrcpy(data[top].str, tstr);\n\t\t\tdata[top].num = 1;\n\t\t\ttop++;\n\t\t}\n\t\ti += n;\n\t}\n\tfor(i = 0; i &lt; top; i++)\n\t{\n\t\tprint(data[i].str);\n\t\tfor(j = 0; j &lt; data[i].num; j++)\n\t\t{\n\t\t\tprintf("*");\n\t\t}\n\t\tprintf("%d\\n", data[i].num);\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Set;\n\npublic class Main{\n\tpublic static LinkedHashMap &lt;String,Integer&gt; hm = new LinkedHashMap&lt;String,Integer&gt;();\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader bfr = new BufferedReader(new InputStreamReader(System.in));\n\t\tString str = bfr.readLine();\n\t\tstr = str.replace(",","");\n\t\tstr = str.replace(".","");\n\t\t//System.out.println(str);\n\t\t\n\t\tmethod(str);\n\t\tprintAll();\n\t}\n\t\n\tpublic static void method(String str){\n\t\tif (!str.contains(" ")){\n\t\t\thm.put(str,1);\n\t\t\treturn;\n\t\t}\n\t\tString [] arr = new String[2];\n\t\twhile(str.contains(" ")){\n\t\t\tarr = str.split(" ");\n\t\t\tInteger i = hm.get(arr[0].toUpperCase());\n\t\t\tif( i == null){\n\t\t\t\thm.put(arr[0].toUpperCase(), 1);\n\t\t\t}else if( i != null){\n\t\t\t\ti++;\n\t\t\t\thm.put(arr[0].toUpperCase(),i);\n\t\t\t}\n\t\t\tstr = str.substring(arr[0].toUpperCase().length()+1);\n\t\t}\n\t\tInteger i = hm.get(arr[1].toUpperCase());\n\t\tif( i == null){\n\t\t\thm.put(arr[1].toUpperCase(), 1);\n\t\t}else if( i != null){\n\t\t\ti++;\n\t\t\thm.put(arr[1].toUpperCase(),i);\n\t\t}\n\t}\n\t\n\tpublic static void printAll(){\n\t\tSet&lt;String&gt; set = hm.keySet();\n\t\tIterator&lt;String&gt; it = set.iterator();\n\t\twhile(it.hasNext()){\n\t\t\tString str= it.next();\n\t\t\tInteger i = hm.get(str);\n\t\t\tSystem.out.print(str+":");\n\t\t\tfor (int index=0; index&lt;i; index++){\n\t\t\t\tSystem.out.print("*");\n\t\t\t}\n\t\t\tSystem.out.println(i);\n\t\t}\n\t}\n}\r\n</textarea>	140
140	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　给定一个信封，有N（1≤N≤100）个位置可以贴邮票，每个位置只能贴一张邮票。我们现在有M(M&lt;=100)种不同邮资的邮票，面值为X1,X2….Xm分（Xi是整数，1≤Xi≤255），每种都有N张。\n  <br> \n  <br> 　　显然，信封上能贴的邮资最小值是min(X1, X2, …, Xm)，最大值是 N*max(X1, X2, …,　　Xm)。由所有贴法得到的邮资值可形成一个集合（集合中没有重复数值），要求求出这个集合中是否存在从1到某个值的连续邮资序列，输出这个序列的最大值。\n  <br> \n  <br> 　　例如，N=4，M=2，面值分别为4分，1分，于是形成1，2，3，4，5，6，7，8，9，10，12，13，16的序列，而从1开始的连续邮资序列为1，2，3，4，5，6，7，8，9，10，所以连续邮资序列的最大值为10分。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行：最多允许粘贴的邮票张数N；第二行：邮票种数M；第三行：空格隔开的M个数字，表示邮票的面值Xi。注意：Xi序列不一定是大小有序的！\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　从1开始的连续邮资序列的最大值MAX。若不存在从1分开始的序列（即输入的邮票中没有1分面额的邮票），则输出0.\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <pre class="pddata">\n样例一：\n4\n2\n4 1\n样例二：\n10\n5\n2 4 6 8 10\n</pre> \n <p></p> \n <br>\n <p></p>\n <p class="subtitle">样例输出</p>\n <p class="probcontent"> </p>\n <p><font face="Times New Roman" size="3"></font></p>\n <pre><font face="Times New Roman" size="3">样例一：\n10\n样例二：\n0</font></pre> \n <p></p> \n <br>  \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nint main()\n{\n    int N,M,i,Max,zuixiaozhi,t,found;//N个位置。M种邮资 \n    int youzi[260];\n    int dp[26000];\n    \n    scanf("%d %d",&amp;N,&amp;M); \n    for(i=0;i&lt;M;i++)\n    {\n        scanf("%d",&amp;youzi[i]);\n    }\n    \n    memset(dp,0,sizeof(dp));\n    Max=0;\n    \n    while(1)\n    {\n        Max++;\n        found=0;\n        zuixiaozhi=10000000;\n        for(i=0;i&lt;M;i++)\n        {\n            t=Max-youzi[i];\n            \n            if(t&gt;=0&amp;&amp;dp[t]+1&lt;zuixiaozhi)\n            {\n                dp[Max]=dp[t]+1;\n                zuixiaozhi=dp[t]+1;\n\t\t\t\tfound=1;\n            }\n        } \n        \n        //printf("%d\\n",dp[Max]);\n        if(dp[Max]&gt;N||found==0)\n        {\n            printf("%d\\n",Max-1);\n            break;\n        }\n        \n        \n    } \n    return 0;\n} \r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\r\n#include&lt;string.h&gt;\r\n#define N 110\r\n\r\nint d[N*260],c[N];\r\nint n,m,ans;\r\n\r\nint main()\r\n{\r\n\tscanf("%d%d",&amp;n,&amp;m);\r\n\tint i;\r\n\tfor(i=1;i&lt;=m;i++)\tscanf("%d",&amp;c[i]);\r\n\tmemset(d,0,sizeof(d));\r\n\tans=0;\r\n\twhile(true)\r\n\t{\r\n\t\tans++;\r\n\t\tfor(i=1;i&lt;=m;i++)\r\n\t\t\tif(ans-c[i]&gt;=0)\r\n\t\t\t\tif(d[ans]==0 || d[ans]&gt;d[ans-c[i]]+1)\r\n\t\t\t\t\td[ans]=d[ans-c[i]]+1;\r\n\t\tif(d[ans]==0 || d[ans]&gt;n)\r\n\t\t{\r\n\t\t\tprintf("%d\\n",ans-1);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}\r\n</textarea>	<textarea id="codelinesjava">\r\n\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint N=sc.nextInt();\n\t\tint M=sc.nextInt();\n\t\tint max=0;\n\t\tLinkedList&lt;Integer&gt; array=new LinkedList&lt;Integer&gt;();\n\t\tfor(int i=0;i&lt;M;i++){\n\t\t\tint temp=sc.nextInt();\n\t\t\tarray.add(temp);\n\t\t\tif(temp&gt;max){\n\t\t\t\tmax=temp;\n\t\t\t}\n\t\t}\n\t\tint maxLen=N*max+1;\n\t\tint[] x=new int[maxLen];\n\t\tfor(int i=0;i&lt;maxLen;++i){\n\t\t\tx[i]=N+1;\n\t\t}\n\t\twhile(!array.isEmpty()){\n\t\t\tx[array.remove()]=1;\n\t\t}\n\t\t\tfor(int i=1;i&lt;maxLen;++i){\n\t\t\t\tif(x[i]==N+1){\n\t\t\t\t\tSystem.out.println(i-1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int j=1;j&lt;=i;++j){\n\t\t\t\t\tint len=i+j;\n\t\t\t\t\tif(len&gt;=maxLen){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint temp=x[i]+x[j];\n\t\t\t\t\tif(temp&lt;x[len]){\n\t\t\t\t\t\tx[len]=temp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\r\n</textarea>	141
186	<div class="des"> \n <div class="pdcont">\n  　　编写函数把一个十进制数输出其对应的八进制数。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  9274\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  22072\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n\tint r;\n\tscanf("%d",&amp;r);\n\tprintf("%o",r);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;stdio.h&gt;\nusing namespace std;\nint main()\n{\n\tint sum,k=0,b[1000],j;\n\tcin&gt;&gt;sum;\n\twhile(sum&gt;=8)\n\t\t{\n\t\t\tb[k]=(int )sum/8;\n\t\t\tb[k]=(int )sum-b[k]*8;\n\t\t\tk++;\n\t\t\tsum=sum/8;\n\t\t\t\n\t\t\t\n\t\t}\n\t\tb[k]=(int )sum;\n\t\tj=k;\n\t\twhile(j&gt;=0) \n\t\t{\n\t\t\tprintf("%d",b[j]);\n\t\t\tj--;\n\t\t}\n  return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic static void main(String[] args)throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint x = Integer.parseInt(br.readLine().replace(" ", ""));\n\t\tSystem.out.println(Integer.toOctalString(x));\n\t}\n}\r\n</textarea>	187
141	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　计算两个实数相加的结果。\n  <br> 　　输入的实数满足如下要求: (1)　　小数点前的整数部分最多100位，(2) 小数点后的小数部分最多100位.\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　两行字符串，每行都是一个合法的实数。合法的意思是指:　　整数部分的值如果大于零,则最高位数字必定大于零. 如果整数部分的值为零,则整数部分只有一个零. 小数部分尾部可以有任意多的零. 可以没有小数部分,　　此时也没有小数点. 如果有小数点, 则至少需要有一位小数部分, 且允许是零.\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　相加结果。注意: 小数部分末尾如果有连续的0, 则它们都是有效数字,　　不能舍去. 如果是两个整数相加, 则结果仍为整数而没有小数部分.\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <pre class="pddata">\n样例一:\n0.0000000000000000000000000000000000000111111111000000000000000000\n100000000000000000000000000000000000000000000000000000.0\n样例二:\n3\n4\n样例三:\n3.9\n2\n样例四：\n1.001\n8.99999999999999999999999</pre> \n <p></p> \n <br>\n <p></p>\n <p class="subtitle">样例输出</p>\n <p class="probcontent"> </p>\n <p><font face="Times New Roman" size="3"></font></p>\n <pre><font face="Times New Roman" size="3">样例一：\n100000000000000000000000000000000000000000000000000000.0000000000000000000000000000000000000111111111000000000000000000\n样例二：\n7\n样例三:\n5.9\n样例四：\n10.00099999999999999999999</font></pre> \n <p></p> \n <br>  \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint a[101],b[101],c[101],d[101],e[101],f[101];\nint main()\n{  char k[1000],l[1001];\n   int i1,i2,a1,b1,c1,d1,e1,f1;\n    gets(k);\n    gets(l);\n    int o=0;\n    for(i1=0;k[i1];i1++)\n     {\n     \tif(k[i1]=='.')\n     \t   {i1++;\n\t\t\tbreak;}\n        a[o++]=k[i1]-'0';\n       \n     }\n     a1=o;\n     o=0;\n\t for(;k[i1];i1++)\n     {\n     \t\n        b[o++]=k[i1]-'0';\n       \n     }\n   \n     b1=o;\n     o=0;\n    for(i1=0;l[i1];i1++)\n     {\n     \tif(l[i1]=='.')\n     \t   {i1++;\n\t\t\tbreak;}\n        c[o++]=l[i1]-'0';\n      \n     }\n  \n     c1=o;\n      o=0;\n\t for(;l[i1];i1++)\n     {\n     \t\n        d[o++]=l[i1]-'0';\n      \n     }\n    \n     d1=o;\n     o=0;\n     int jiwei=0;\n     for(i1=b1-1,i2=d1-1;i1&gt;=0||i2&gt;=0;)\n     {\n     \tif(i1==i2)\n     \t {\n \t     \tf[o]=(b[i1]+d[i2]+jiwei)%10;\n \t     \tjiwei=(b[i1]+d[i2]+jiwei)/10;\n \t     \to++;i1--;i2--;\n \t     }\n \t     else if(i1&gt;i2)\n \t     {  f[o]=(b[i1]+jiwei)%10;\n     \t \tjiwei=(b[i1]+jiwei)/10;\n     \t \to++;i1--;\n     \t }\n     \t else \n     \t {\n \t        f[o]=(d[i2]+jiwei)%10;\n     \t \tjiwei=(d[i2]+jiwei)/10;\t\n     \t \to++;i2--;\n \t     }\n     }\n      \n\t f1=o;  \n     \n\t o=0;\n\n     for(i1=a1-1,i2=c1-1;i1&gt;=0||i2&gt;=0;i1--,i2--)\n     {  \n     \tif(i1&lt;0)\n     \t{  e[o]=(c[i2]+jiwei)%10;\n     \t   jiwei=(c[i2]+jiwei)/10;\n\t     \to++;\n\t     }\n\t     else if(i2&lt;0)\n\t     {e[o]=(a[i1]+jiwei)%10;\n     \t   jiwei=(a[i1]+jiwei)/10;\n     \t\to++;\n     \t}\n     \telse \n     \t  {e[o]=(a[i1]+c[i2]+jiwei)%10;\n     \t   jiwei=(a[i1]+c[i2]+jiwei)/10;\n  \t     \to++;\n  \t     }\n     }\n     \n     if(jiwei==1)\n        e[o++]=1;\n        \n\t for(i1=o-1;i1&gt;=0;i1--)\n\t     printf("%d",e[i1]);\n    \n\t   if(b1==0&amp;&amp;d1==0)\n\t      return 0;\n      printf(".");\n  \n     for(i1=f1-1;i1&gt;=0;i1--)\n\t     printf("%d",f[i1]); \n      return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\n#include&lt;algorithm&gt;\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;string.h&gt;\nusing namespace std;\n#define N 202\nvoid strToNum(char *s,int n )\n{\n    for(int i=0;i&lt;n;i++)\n    {\n        if(s[i]&gt;='0'&amp;&amp;s[i]&lt;='9')\n        s[i]-='0';\n    }\n}\nint find(char *s)\n{\n    int n=strlen(s);\n    for(int i=0;i&lt;n;i++)\n    {\n        if(s[i]=='.')\n        return i;\n    }\n    s[n]='.';\n    return n;\n}\nint main()\n{\n    char a[2*N]={0};\n    char b[2*N]={0};\n    \n    gets(a+100);\n    gets(b+100);\n     int na=strlen(a+100);\n    int nb=strlen(b+100);\n    int deA=find(a+100);\n    int deB=find(b+100);\n   \n    int addLen=(na-1-deA)&gt;(nb-1-deB)?(na-1-deA):(nb-1-deB);\n    strToNum(a,2*N);\n    strToNum(b,2*N);\n    int c=0;\n    for(int i=deA+200,j=deB+200;i&gt;=0&amp;&amp;j&gt;=0; i--,j--)\n    {\n        if(a[i]=='.')\n          continue;\n        int t=a[i]+b[j]+c;\n        a[i]=t%10;\n        c=t/10;\n    }\n    int x,y;\n    for(int i=0;i&lt;2*N; i++)\n    {\n        if(a[i])\n        {\n          x=i;\n        break;\n        }\n    \n    }\n    for(int i=2*N-1;i&gt;=0;i--)\n    {\n        if(a[i])\n        {\n            y=i;\n            break;\n        }\n    }\n    if(x==y)\n    {\n       puts("0");\n       return 0;\n    }\n    if(a[x]=='.')\n    {\n        --x;\n    }\n    if(a[y]=='.')\n    y--;\n    for(int i=0;i&lt;2*N;i++)\n    {\n        if(a[i]=='.')\n        {\n            if(y-i&lt;addLen)\n            {\n               y=addLen+i;\n            }\n            break;\n        }\n    }\n    for(int i=x; i&lt;= y; i++)\n    {\n       if(a[i]=='.')\n        cout&lt;&lt;".";\n        else cout&lt;&lt;(int)a[i];\n    }\n    cout&lt;&lt;endl;\n    \n    \n        \n    \n    return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.math.BigDecimal;\n\npublic class Main {\n\tpublic static void main(String args[])throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tSystem.out.println(new BigDecimal(br.readLine()).add(new BigDecimal(br.readLine())));\n\t}\n}\n\r\n</textarea>	142
142	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　由 n(1≤n≤100)　　个珠子组成的一个项链，珠子有红、蓝、白三种颜色，各种颜色的珠子的安排顺序由键盘输入的字符串任意给定。蓝色用小写字母b表示,红色用小写字母r表示,　　白色用小写字母w表示.\n  <br> \n  <br> 　　假定从项链的某处将其剪断，把它摆成一条直线。先从左端向右收集同色珠子，遇到第一个异色珠子时停止.　　收集过程中, 白色是一种特殊颜色, 既可以看成红色也可以看成蓝色。然后再从剩余珠子的右端向左重复上述过程。\n  <br> \n  <br> 　　例如：对下图一所示的项链, 如果从图一中标记的位置0处剪断,　　则按顺时针顺序得到wbbbwwrrbwbrrwb（如图二所示）。这时从左端开始收集可以得到wbbbww,　　共6个珠子；然后从剩余珠子右端开始收集得到wb，共2个珠子。这种剪法共可收集到6+2=8个珠子。 如果从图一中标记的位置4处剪断,　　则按顺时针顺序得到wwrrbwbrrwbwbbb（如图二所示）。这时从左端收集可以得到wwrr,共4个珠子；然后从剩余珠子右端收集可以得到wbwbbb，共6个珠子。这种剪法共可收集到4+6=10个珠子。\n  <br> \n  <br> 　　要求: 在项链中选择合适的剪断位置, 使得从左右两端收集到的珠子数目之和最大，输出收集到的珠子数的最大值M。\n  <br> \n  <img height="500" src="">\n  <br> \n  <img height="280" src="">\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　由小写字母b,r,w组成的字符串。此字符串记录了一个首尾相接的项链从某处断开后，按顺时针顺序得到的珠子的直线排列。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　收集到的珠子数的最大值 M\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <pre class="pddata">\nwbbbwwrrbwbrrwb</pre> \n <p></p> \n <br>\n <p></p>\n <p class="subtitle">样例输出</p>\n <p class="probcontent"> </p>\n <p><font face="Times New Roman" size="3"></font></p>\n <pre><font face="Times New Roman" size="3">10</font></pre> \n <p></p> \n <br>  \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\r\n#include&lt;string.h&gt;\r\nint main()\r\n{   \r\n    char a[1000];\r\n    int i1,i2;\r\n\tgets(a);\r\n\tint max=0,n=strlen(a);\r\n\tint total=0;\r\n\tfor(i1=0;a[i1];i1++)\r\n\t{     \r\n\t\t char p='w';\r\n\t\t total=0;\r\n\t\t for(i2=i1;;i2++)\r\n\t\t  {   if(i2&gt;=n)\r\n\t\t          i2-=n;\r\n  \t\t     if(p=='w'||a[i2]==p||a[i2]=='w')\r\n\t\t\t   {\r\n   \t\t\t       \tif(a[i2]!='w')\r\n   \t\t\t       \t    p=a[i2];\r\n   \t\t\t       \ttotal++;\r\n   \t\t\t       \t\r\n   \t\t\t   }\r\n\t\t     else\r\n\t\t\t      break;\r\n\t\t\tif(total&gt;=n)\r\n\t\t\t   break;\t\r\n  \t\t  }\r\n  \t\t  p='w';\r\n  \t\r\n\t     for(i2=i1-1;;i2--)\r\n\t     {   if(total&gt;=n)\r\n\t\t          break;\r\n     \t\t  if(i2&lt;0)\r\n     \t\t     i2+=n;\r\n  \t\t      if(p=='w'||a[i2]==p||a[i2]=='w')\r\n  \t\t         {    if(a[i2]!='w')\r\n         \t\t  \t p=a[i2];\r\n         \t\t  \t total++;\r\n         \t\t  }\r\n      \t\t  else\r\n         \t\t  break;\r\n\t\t     \r\n     \t } \r\n\t\r\n\t\t  if(total&gt;max)\r\n\t\t      max=total;\r\n\t}\r\n\t printf("%d\\n",max);\r\n\treturn 0;\r\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;ctype.h&gt;\n#include &lt;string&gt;\n#include &lt;map&gt;\n#include &lt;set&gt;\n#include &lt;vector&gt;\nusing namespace std;\nint len;\nint getnum(string&amp; s)\n{\n\tint res = 0, i=0;\n\twhile (s[i] == 'w')\n\t{\n\t\ti++;\n\t\tif (i==len)\n\t\t\treturn i;\n\t}\n\tres = i+1;\n\tchar t = s[i];\n\t++i;\n\twhile ((s[i]==t ||s[i]=='w')&amp;&amp; s[i] != 0)\n\t{\n\t\t++i;\n\t\tres++;\n\t}\n\tif (res == len)\n\t\treturn res;\n\ti = len-1;\n\twhile (s[i] == 'w')\n\t{\n\t\tres++;\n\t\t--i;\n\t}\n\tres++;\n\tt = s[i];\n\t--i;\n\twhile (i&gt;=0 &amp;&amp; (s[i]==t || s[i]=='w'))\n\t{\n\t\tres++;\n\t\t--i;\n\t}\n\tif (res &gt; len)\n\t\tres = len;\n\treturn res;\n} \n\nint main()\n{\n\tchar str[110];\n\tscanf("%s", str);\n\tlen = strlen(str);\n\tstring s;\n\tint sum = 0, t;\n\tfor (int i=0; i&lt;len; ++i)\n\t{\n\t\ts = &amp;str[i];\n\t\tfor (int j=0; j&lt;i; ++j)\n\t\t{\n\t\t\ts += str[j];\n\t\t}\n\t\tt = getnum(s);\n\t\tif (t &gt; sum)\n\t\t{\n\t\t\tsum = t;\n\t\t}\n\t}\n\tprintf("%d\\n", sum);\n\treturn 0;\n}\n\n\n\n\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.text.DecimalFormat;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tString string = scanner.nextLine();\n\t\tint ma = 0;\n\t\tfor (int i = 0; i &lt; string.length(); i++) {\n\t\t\tint mm = get(string, i);\n\t\t\tma = mm &gt; ma ? mm : ma;\n\t\t}\n\t\tSystem.out.println(ma);\n\t}\n\n\tprivate static int get(String string, int i) {\n\t\tString s1 = string.substring(i) + string.substring(0, i);\n\t\tint j1 = 0;\n\t\tint j2 = 0;\n\t\tchar c1 = 'w';\n\t\tchar c2 = 'w';\n\t\tfor (int k = 0; k &lt; s1.length(); k++) {\n\t\t\tif (s1.charAt(k) != c1) {\n\t\t\t\tc1 = s1.charAt(k);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int k = s1.length() - 1; k &gt; 0; k--) {\n\t\t\tif (s1.charAt(k) != c2) {\n\t\t\t\tc2 = s1.charAt(k);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j &lt; s1.length(); j++) {\n\t\t\tif (s1.charAt(j) == c1 || s1.charAt(j) == 'w')\n\t\t\t\tj1++;\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = s1.length() - 1; j &gt;0; j--) {\n\t\t\tif (s1.charAt(j) == c2 || s1.charAt(j) == 'w')\n\t\t\t\tj2++;\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t\tif (j1 == s1.length())\n\t\t\treturn j1;\n\t\treturn j1 + j2;\n\t}\n}\r\n</textarea>	143
143	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　从键盘输入一个含有括号的四则运算表达式，要求去掉可能含有的多余的括号，结果要保持原表达式中变量和运算符的相对位置不变，且与原表达式等价,不要求化简。另外不考虑'+'　　'-'用作正负号的情况，即输入表达式不会出现(+a)或(-a)的情形。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　表达式字符串，长度不超过255,　　并且不含空格字符。表达式中的所有变量都是单个小写的英文字母, 运算符只有加+减-乘*除/等运算符号。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　去掉多余括号后的表达式\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <pre class="pddata">\n样例一：\na+(b+c)-d\n样例二：\na+b/(c+d)\n样例三：\n(a*b)+c/d\n样例四：\n((a+b)*f)-(i/j)\n</pre> \n <p></p> \n <br>\n <p></p>\n <p class="subtitle">样例输出</p>\n <p class="probcontent"> </p>\n <p><font face="Times New Roman" size="3"></font></p>\n <pre><font face="Times New Roman" size="3">样例一：\na+b+c-d\n样例二：\na+b/(c+d)\n样例三：\na*b+c/d\n样例四：\n(a+b)*f-i/j\n</font></pre> \n <p></p> \n <br>  \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n\n\nint q(char *ch)\n{\n\tint i=0,z=0;\n\tch[i] = '#';\n\twhile (ch[i] != ')'||z!=0)\n\t{\n\t\tif (ch[i]=='(')\n\t\t{\n\t\t\tz++;\n\t\t}\n\t\tif (ch[i]==')')\n\t\t{\n\t\t\tz--;\n\t\t}\n\t\ti++;\n\t}\n\tch[i] = '#';\n\t\t\n\treturn i;\n}\n\n\n\nint f(char *ch, char a)\n{\n\tint i = 0,jj=0;\n\n\tif (a == '+')\n\t{\n\t\twhile (ch[i] != ')')\n\t\t{\n\t\t\tif (ch[i+1] == '(')\n\t\t\tif (f(&amp;ch[i], ch[i - 1]) == 0)\n\t\t\t\ti += q(&amp;ch[i]);\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (ch[i] != ')')\n\t\t\t\t{\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\n\t\tif (ch[i + 1] == '*' || ch[i + 1] == '/')\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\n\t}\n\tif (a == '-')\n\t{\n\t\twhile (ch[i] != ')')\n\t\t{\n\t\t\tif (ch[i] == '(')\n\t\t\tif (f(&amp;ch[i+1], ch[i - 1]) == 0)\n\t\t\t\ti += q(&amp;ch[i]);\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (ch[i] != ')')\n\t\t\t\t{\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ch[i] == '+' || ch[i] == '-')\n\t\t\t\treturn 1;\n\t\t\ti++;\n\t\t}\n\t\tif (ch[i + 1] == '*' || ch[i + 1] == '/')\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n\tif (a == '*')\n\t{\n\t\twhile (ch[i] != ')')\n\t\t{\n\t\t\tif (ch[i] == '(')\n\t\t\tif (f(&amp;ch[i+1], ch[i - 1]) == 0)\n\t\t\t\tq(&amp;ch[i]);\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (ch[i] != ')')\n\t\t\t\t{\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ch[i] == '+' || ch[i] == '-')\n\t\t\t\treturn 1;\n\n\n\t\t\ti++;\n\t\t}\n\t\treturn 0;\n\t}\n\n\n\n\tif (a == '/')\n\t{\n\t\twhile (ch[i] != ')')\n\t\t{\n\t\t\tif (ch[i] == '(')\n\t\t\tif (f(&amp;ch[i+1], ch[i - 1]) == 0)\n\t\t\t\tq(&amp;ch[i]);\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (ch[i] != ')')\n\t\t\t\t{\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ch[i] == '+' || ch[i] == '-' || ch[i] == '/' || ch[i] == '*')\n\t\t\t\treturn 1;\n\n\t\t\ti++;\n\t\t}\n\t}\n\n\n\twhile (ch[i] != ')')\n\t{\n\t\tif (ch[i] == '(')\n\t\tif (f(&amp;ch[i+1], ch[i - 1]) == 0)\n\t\t\ti += q(&amp;ch[i]);\n\t\telse\n\t\t{\n\t\t\twhile (ch[i] != ')')\n\t\t\t{\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tif (ch[i] == '+' || ch[i] == '-')\n\t\t\tjj=1;\n\t\ti++;\n\t}\n\tif ((ch[i + 1] == '*' || ch[i + 1] == '/')&amp;&amp;jj==1)\n\t{\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n}\n\n\n\n\nvoid g(char *a)\n{\n\tint i = 0;\n\twhile (a[i]!='\\0')\n\t{\n\t\tif (a[i] == '(')\n\t\tif (f(&amp;a[i + 1], a[i - 1]) == 0)\n\t\tq(&amp;a[i]);\n\t\telse\n\t\t{\n\t\t\twhile (a[i] != ')')\n\t\t\t{\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n}\n\n\n\n\n\nint main()\n{\n\tint l = 0, i = 0;\n\tchar ch[100];\n\tscanf("%s", ch);\n\tg(ch);\n\n\n\twhile (ch[i]!='\\0')\n\t{\n\t\tif (ch[i]!='#')\n\t\t{\n\t\t\tprintf("%c", ch[i]);\n\t\t}\n\t\ti++;\n\n\t}\n\t\n\n\n\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include "iostream"\n#include "string"\n#include "stdio.h"\n#include "ctype.h"\n#include "algorithm"\n#include "stack"\nusing namespace std;\n\nint cacluExprePriority(string str,bool &amp;hasC)\n{\n\tint left=0;\n\tint right=0;\n\tbool bfind=false;\n\tfor(int i=0;i&lt;str.size();i++)\n\t{\n\t\tif(str[i]=='(')\n\t\t\tleft++;\n\t\tif(str[i]==')')\n\t\t\tright++;\n\t\tif(str[i]=='/')\n\t\t\thasC=true;\n\t\tif(str[i]=='*'||str[i]=='/')\n\t\t{\n\t\t\tif(left==right)\n\t\t\t\treturn 2;\n\t\t}\n\t\tif(str[i]=='+'||str[i]=='-')\n\t\t{\n\t\t\tbfind=true;\n\t\t}\n\t}\n\treturn bfind?1:-1;\n}\nbool vis[1000];\nint safe(int i,int n)\n{\n\tif(i&lt;0)\n\t\treturn 0;\n\tif(i&gt;=n)\n\t\treturn n-1;\n\treturn i;\n}\nvoid findIndexOfBrackets(string str)\n{\n    stack&lt;int&gt;q;\n\tfor(int i=0;i&lt;str.size();i++)\n\t{\n\t\tif(str[i]=='(')\n\t\t{\n\t\t\tq.push(i);\n\t\t}\n\t   if(str[i]==')')\n\t\t{\n\t\t\tint s=q.top();\n\t\t\tint t=i;\n\t\t\tbool hasC=false;\n\t\t     int priority=cacluExprePriority(str.substr(s+1,t-s-1),hasC);\n\t\t\t q.pop();\n\t\t     bool temp=false;\n\t\t\t if(s-1&gt;=0&amp;&amp;cacluExprePriority(str.substr(safe(s-1,str.size()),1),temp)&gt;=cacluExprePriority(str.substr(safe(t+1,str.size()),1),temp))\n\t\t\t {\n\t\t\t\t char op=str[s-1];\n\t\t\t     {\n\t\t\t\t if(op=='+')\n\t\t\t\t {\n\t\t\t\t\tvis[s]=vis[t]=true;\n\t\t\t\t }\n\t\t\t\tif(op=='-')\n\t\t\t\t{\n\t\t\t\t\tif(priority==2)\n\t\t\t\t\t\tvis[s]=vis[t]=true;\n\t\t\t\t}\n\t\t\t\tif(op=='*')\n\t\t\t\t{\n\t\t\t\t\tif(priority==2&amp;&amp;hasC==false)\n\t\t\t\t\t\tvis[s]=vis[t]=true;\n\t\t\t\t}\n\t\t\t  }\n\t\t\t }\n\t\t\t else  if(t+1&lt;str.size())\n\n\t\t\t{\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\tchar op=str[t+1];\n\t\t\t\t\tif(op=='+'||op=='-')\n\t\t\t\t\t{\n\t\t\t\t\t\tvis[s]=vis[t]=true;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(op=='*'||op=='/')\n\t\t\t\t\t{\n\t\t\t\t\t\tif(priority==2)\n\t\t\t\t\t\t\tvis[s]=vis[t]=true;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n\n\nint main()\n{\n\tstring exper;\n\tcin&gt;&gt;exper;\n\n\tfindIndexOfBrackets(exper);\n\tfor(int i=0;i&lt;exper.size();i++)\n\t\tif(vis[i]==false)\n\t\t\tcout&lt;&lt;exper[i];\n\tcout&lt;&lt;endl;\n\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tchar[] chs = br.readLine().toCharArray();\n\t\tList&lt;Character&gt; list = new ArrayList&lt;Character&gt;();\n\t\tfor (int i = 0; i &lt; chs.length; i++) {\n\t\t\tlist.add(chs[i]);\n\t\t}\n\t\tString s = "";\n\t\tfor (int i = 0; i &lt; func(list).size(); i++) {\n\t\t\ts += list.get(i);\n\t\t}\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static List&lt;Character&gt; func(List&lt;Character&gt; list) {\n\t\tfor (int i = 0; i &lt; list.size(); i++) {\n\t\t\tif (list.get(i) == '+' || list.get(i) == '-') {\n\t\t\t\tif (list.get(i - 1) == ')' &amp;&amp; list.get(i + 1) == '(') {\n\t\t\t\t\tlist.remove(i - 1);\n\t\t\t\t\tlist.remove(i);\n\t\t\t\t\tfor (int j = i - 1; j &gt; -1; j--) {\n\t\t\t\t\t\tif (list.get(j) == '(') {\n\t\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int k = i + 1; k &lt; list.size(); k++) {\n\t\t\t\t\t\tif (list.get(k) == ')') {\n\t\t\t\t\t\t\tlist.remove(k);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.get(i - 1) == ')') {\n\t\t\t\t\tlist.remove(i - 1);\n\t\t\t\t\tfor (int j = i - 1; j &gt; -1; j--) {\n\t\t\t\t\t\tif (list.get(j) == '(') {\n\t\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.get(i + 1) == '(') {\n\t\t\t\t\tif (list.get(i) == '+')\n\t\t\t\t\t\tfor (int k = i + 1; k &lt; list.size(); k++) {\n\t\t\t\t\t\t\tif (list.get(k) == ')' &amp;&amp; !list.contains('/')\n\t\t\t\t\t\t\t\t\t&amp;&amp; !list.contains('*')) {\n\t\t\t\t\t\t\t\tlist.remove(k);\n\t\t\t\t\t\t\t\tlist.remove(i + 1);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n}\r\n</textarea>	144
144	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　给定N个整数组成的序列，每次交换当前第x个与第y个整数，要求输出最终的序列。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行为序列的大小N(1&lt;=N&lt;=1000)和操作个数M(1&lt;=M&lt;=1000)。\n  <br> 　　第二行包含N个数字，表示初始序列。\n  <br> 　　接下来M行，每行两个整数x,y (1&lt;=x,y&lt;=N)，表示要交换的两个整数。在一次交换中，如果x和y相等，则不会改变序列的内容。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出N行，为交换后的序列中的数。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5 2\n  <br> 1 2 3 4 5\n  <br> 1 2\n  <br> 3 4\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  2\n  <br> 1\n  <br> 4\n  <br> 3\n  <br> 5\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n\nint main()\n{\n\tint n,m,ary[1000],temp,op1,op2;\n\tscanf("%d %d",&amp;n,&amp;m);\n\tint i;\n\tfor(i=0;i&lt;n;i++)\n\t{\n\t\tscanf(" %d",&amp;ary[i]);\n\t}\n\tfor(i=0;i&lt;m;i++)\n\t{\n\t\tscanf(" %d %d",&amp;op1,&amp;op2);\n\t\tif(op1 != op2)\n\t\t{\n\t\t\ttemp=ary[op1-1];\n\t\t\tary[op1-1]=ary[op2-1];\n\t\t\tary[op2-1]=temp;\n\t\t}\n\t}\n\tfor(i=0;i&lt;n;i++)\n\t{\n\t\tprintf("%d\\n",ary[i]);\n\t}\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;stdio.h&gt;\r\nmain()\r\n{\r\n\tint n,m;\r\n\tint c[1000];\r\n\tscanf("%d %d",&amp;n,&amp;m);\r\n\tfor(int i=0;i&lt;n;i++)\r\n\t{\r\n\t\tscanf("%d",&amp;c[i]);\r\n\t}\r\n\tint d[1000];\r\n\tint f[1000]; \r\n\tfor(int i=0;i&lt;m;i++)\r\n\t{\r\n\t\tscanf("%d %d",&amp;d[i],&amp;f[i]);\r\n\t}\r\n\tint temp;\r\n\tfor(int i=0;i&lt;m;i++)\r\n\t{\r\n\t\ttemp=c[d[i]-1];\r\n\t\tc[d[i]-1]=c[f[i]-1];\r\n\t\tc[f[i]-1]=temp;\r\n\t}\r\n\tfor(int i=0;i&lt;n;i++)\r\n\t{\r\n\t\tprintf("%d\\n",c[i]);\r\n\t}\r\n\t\r\n} \r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.*;\npublic class Main {    \n\tstatic int a[]=new int[1001];\n\tstatic int b[]=new int[2];\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int m=sc.nextInt();\n        for(int i=0;i&lt;n;i++)\n        \ta[i]=sc.nextInt(); \n        for(int j=0;j&lt;m;j++){\n        \tb[0]=sc.nextInt();\n        \tb[1]=sc.nextInt();\n        \tint x=b[0],y=b[1];\n        \tif(x!=y){\n            \tint t=a[x-1];\n            \ta[x-1]=a[y-1];\n            \ta[y-1]=t;\n            }\n        \telse\n        \t\ta[x-1]=a[y-1];\n        }    \t        \t\n        for(int i=0;i&lt;n;i++)\n        \tSystem.out.println(a[i]);             \n    }\n}\r\n</textarea>	145
145	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　给定一个字符串，将这个串的所有字母逆序后输出。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入包含一个字符串，长度不超过100，字符串中不含空格。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出包含一个字符串，为上面字符串的逆序。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  tsinsen\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  nesnist\n </div> \n</div>	<textarea id="codelinesc">\r\n//字串逆序\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nint main()\n{\n\tchar str[100];\n\tint len;\n\tscanf("%s",str);\n\t\n\tlen=strlen(str)-1;\n\t\n\tfor(;len&gt;=0;len--)\n\tprintf("%c",str[len]);\n\t\n\treturn 0;\n} \r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\nusing namespace std;\n\nint sum(int x, int y)\n{\nreturn x+y;\n}\n\nint main()\n{\n\tint a, b, c;\n\tcin &gt;&gt; a &gt;&gt; b;\n\tc = sum(a, b);\n\tcout &lt;&lt; c &lt;&lt; endl;\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream in = System.in;\n\t\tInputStreamReader isr = new InputStreamReader(in);\n\t\tBufferedReader bfr = new BufferedReader(isr);\n\t\t\n\t\tString str = bfr.readLine();\n\t\tchar [] ch = str.toCharArray();\n\t\t\n\t\tfor (int i=ch.length-1; i&gt;=0; i--){\n\t\t\tSystem.out.print(ch[i]);\n\t\t}\n\t}\n}\r\n</textarea>	146
146	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　快速排序是最经常使用的一种排序方式，对于给定的n个数组成的一个数组，请使用快速排序对其进行排序。\n  <br> 　　现给定一序列，请用快速排序将其按升序排序并输出。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行一个数N。\n  <br> 　　第2~N+1行每行一个数，表示给定序列。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　共N行，每行一个数，表示所求序列。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5\n  <br> 1\n  <br> 4\n  <br> 2\n  <br> 3\n  <br> 4\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  1\n  <br> 2\n  <br> 3\n  <br> 4\n  <br> 4\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　共10组数据。\n  <br> 　　对100%的数据，N&lt;=10^5，所有数均为非负数且在int范围内。\n </div> \n</div>	<textarea id="codelinesc">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n// 交换两个整数\nvoid Swap(int *a, int *b)\n{\nint temp=*a;\n    *a=*b;\n    *b=temp;\n}\n\nint main()\n{\n\tint a, b;\n\tcin &gt;&gt; a &gt;&gt; b;\n\tSwap(&amp;a, &amp;b);\n\tcout &lt;&lt; a &lt;&lt; " " &lt;&lt; b;\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\npublic class Main {\n\tpublic static void main(String args[]){\n\t\tSystem.out.println("Yes");\n\t}\n}\n\r\n</textarea>	147
147	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　给定一个矩阵A,一个非负整数b和一个正整数m，求A的b次方除m的余数。\n  <br> 　　其中一个nxn的矩阵除m的余数得到的仍是一个nxn的矩阵，这个矩阵的每一个元素是原矩阵对应位置上的数除m的余数。\n  <br> 　　要计算这个问题，可以将A连乘b次，每次都对m求余，但这种方法特别慢，当b较大时无法使用。下面给出一种较快的算法(用A^b表示A的b次方)：\n  <br> 　　若b=0，则A^b%m=I%m。其中I表示单位矩阵。\n  <br> 　　若b为偶数，则A^b%m=(A^(b/2)%m)^2%m，即先把A乘b/2次方对m求余，然后再平方后对m求余。\n  <br> 　　若b为奇数，则A^b%m=(A^(b-1)%m)*a%m，即先求A乘b-1次方对m求余，然后再乘A后对m求余。\n  <br> 　　这种方法速度较快，请使用这种方法计算A^b%m，其中A是一个2x2的矩阵，m不大于10000。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入第一行包含两个整数b, m，第二行和第三行每行两个整数，为矩阵A。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出两行，每行两个整数，表示A^b%m的值。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  2 2\n  <br> 1 1\n  <br> 0 1\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  1 0\n  <br> 0 1\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n\nint b, m;\nint a[2][2], ans[2][2], temp[2][2] = {1,1,1,1};\n\nvoid play()\n{\n\tint cnt, cnt2;\n\tfor(cnt = 0; cnt &lt; 2; ++cnt)\n\t{\n\t\tfor(cnt2 = 0; cnt2 &lt; 2; ++cnt2)\n\t\t{\n\t\t\tprintf("%d ", ans[cnt][cnt2]);\n\t\t}\t\t\n\t\tprintf("\\n");\n\t}\t\n}\n\nvoid cp(int arr1[][2], int arr2[][2])\n{\n\tint cnt, cnt2;\n\t\n\tfor(cnt = 0; cnt &lt; 2 ;++cnt)\n\t\tfor(cnt2 = 0; cnt2 &lt; 2; ++cnt2)\n\t\t\tarr1[cnt][cnt2] = arr2[cnt][cnt2];\n}\nvoid mod(int arr[][2])\n{\n\tint cnt, cnt2;\n\t\n\tfor(cnt = 0; cnt &lt; 2; ++cnt)\n\t\tfor(cnt2 = 0; cnt2 &lt; 2; ++cnt2)\n\t\t\tarr[cnt][cnt2] %= m;\n}\n\nvoid fun2(int a[][2], int b[][2])\n{\n\tint cnt, cnt2;\n\t\n\ttemp[0][0] = a[0][0]*b[0][0]+a[0][1]*b[1][0];\n\ttemp[0][1] = a[0][0]*b[0][1]+a[0][1]*b[1][1];\n\ttemp[1][0] = a[1][0]*b[0][0]+a[1][1]*b[1][0];\n\ttemp[1][1] = a[1][0]*b[0][1]+a[1][1]*b[1][1];\n}\n\nvoid fun(int arr[][2], int k)\n{\n\tint cnt;\n\t\n\tif(k == 0)\n\t{\n\t\tmod(temp);\n\t\tcp(ans, temp);\n\t\treturn;\n\t}\n\t\n\tif(k == 1)\n\t{\n\t\tmod(ans);\n\t\t\n\t\treturn;\n\t}\n\tif(k == 2)\n\t{\n\t\tfun2(a, a);\n\t\tcp(ans, temp);\n\t//\tprintf("2\\n");\n\t//\tplay();\n\t\tmod(ans);\n\t\treturn;\n\t}\n\tif(k%2 == 0)\n\t{\n\t\tfun(arr, k/2);\n\t\tfun2(ans, ans);\n\t\tcp(ans, temp);\n\t\t//printf("=0\\n");\n\t\t//play();\n\t\t\n\t\tmod(ans);\n\t\treturn;\n\t}\n\tif(k%2 != 0)\n\t{\n\t\tfun(arr, k-1);\n\t\tfun2(ans, arr);\n\t\tcp(ans, temp);\n\t\t//printf("!=0\\n");\n\t//\tplay();\n\t\tmod(ans);\n\t\treturn;\n\t}\n}\n\nint main()\n{\n\tint cnt, cnt2;\n\t\n\tscanf("%d%d", &amp;b, &amp;m);\n\t\n\tfor(cnt = 0; cnt &lt; 2; ++cnt)\n\t\tfor(cnt2 = 0; cnt2 &lt; 2; ++cnt2)\n\t\t{\n\t\t\tscanf("%d", &amp;a[cnt][cnt2]);\n\t\t\tans[cnt][cnt2] = a[cnt][cnt2];\n\t\t}\n\t\n\tfun(a, b);\n\t\n\tplay();\n\t\n\t\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n// 坐标或向量的结构\nstruct pointer {\n\tint x;\n\tint y;\n};\n\n// 将A坐标按B向量平移，结果保存在C坐标中。\nvoid move(pointer *C, pointer *A, pointer *B)\n{\nC-&gt;x=A-&gt;x+B-&gt;x;\r\nC-&gt;y=A-&gt;y+B-&gt;y;\n}\n\nint main()\n{\n\tpointer A, B, C;\n\tcin &gt;&gt; A.x &gt;&gt; A.y;\n\tcin &gt;&gt; B.x &gt;&gt; B.y;\n\tmove(&amp;C, &amp;A, &amp;B);\n\tcout &lt;&lt; C.x &lt;&lt; " " &lt;&lt; C.y;\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main{\n\tstatic int m;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] str = br.readLine().split(" ");\n\t\tint b = Integer.parseInt(str[0]);\n\t\tm = Integer.parseInt(str[1]);\n\n\t\tint[][] arr = new int[2][2];\n\t\tfor (int i = 0; i &lt; arr.length; i++) {\n\t\t\tString[] tag = br.readLine().split(" ");\n\t\t\tfor (int j = 0; j &lt; arr[i].length; j++) {\n\t\t\t\tarr[i][j] = Integer.parseInt(tag[j]);\n\t\t\t}\n\t\t}\n\n\t\tint[][] tak = new int[2][2];\n\t\ttak = mulpow(arr, b);\n\t\tfor (int i = 0; i &lt; 2; i++) {\n\t\t\tfor (int j = 0; j &lt; 2; j++) {\n\t\t\t\tSystem.out.print(tak[i][j] % m + " ");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t}\n\n\tpublic static int[][] mul(int[][] x, int[][] y) {\n\t\tint[][] temp = new int[2][2];\n\t\tfor (int a = 0; a &lt; 2; a++) {\n\t\t\tfor (int b = 0; b &lt; 2; b++) {\n\t\t\t\ttemp[a][b] = 0;\n\t\t\t\tfor (int c = 0; c &lt; 2; c++) {\n\t\t\t\t\ttemp[a][b] += x[a][c] * y[c][b];\n\t\t\t\t\ttemp[a][b] %= m;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn temp;\n\t}\n\n\tpublic static int[][] mulpow(int[][] arr, int b) {\n\t\tif (b == 0) {\n\t\t\tint[][] temp = new int[2][2];\n\t\t\tfor (int x = 0; x &lt; 2; x++) {\n\t\t\t\tfor (int y = 0; y &lt; 2; y++) {\n\t\t\t\t\tif (x == y)\n\t\t\t\t\t\ttemp[x][y] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn temp;\n\t\t}\n\t\tif (b == 1)\n\t\t\treturn arr;\n\t\tint[][] rep = mulpow(arr, b / 2);\n\t\tif (b % 2 == 0)\n\t\t\treturn mul(rep, rep);\n\t\telse\n\t\t\treturn mul(mul(rep, rep), arr);\n\t}\n}\r\n</textarea>	148
148	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　能被2整除的数称为偶数，不能被2整除的数称为奇数。给一个整数x，判断x是奇数还是偶数。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入包括一个整数x，0&lt;=x&lt;=100000000。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　如果x是奇数，则输出“odd”，如果是偶数，则输出“even”。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  10\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  even\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  2009\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  odd\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n/* run this program using the console pauser or add your own getch, system("pause") or input loop */\n\nint main(int argc, char *argv[]) {\n\tint a[100];\n\tint n;\n\tscanf("%d",&amp;n);\n\tif(n%2==0)\n\tprintf("even");\n\telse\n\tprintf("odd");\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\nint main()\n{\n\tint x;\n\tcin&gt;&gt;x;\n\tif(x%2==0) cout&lt;&lt;"even";\n\telse cout&lt;&lt;"odd";\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\t@SuppressWarnings("resource")\n\t\tScanner scan = new Scanner(System.in);\n\t\tint a = scan.nextInt();\n\t\tif (a % 2 == 0)\n\t\t\tSystem.out.println("even");\n\t\telse\n\t\t\tSystem.out.println("odd");\n\t}\n}\r\n</textarea>	149
149	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　输入正整数a, m，输出a^2%m，其中^表示乘方，即a^2表示a的平方，%表示取余。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入包含两个整数a, m，a不超过10000。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出一个整数，即a^2%m的值。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5 6\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  1\n </div> \n</div>	<textarea id="codelinesc">\r\n//平方计算\n#include&lt;stdio.h&gt;\nint main()\n{\n\tint a,m;\n\tscanf("%d %d",&amp;a,&amp;m);\n\tprintf("%d\\n",(a*a)%m);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n// 求数组的和，其中p为指针第一个元素的指针，n为数组中的元素个数。\nint Sum(int *p, int n)\n{\nint sum=0;\nfor(int i=0;i&lt;n;i++)\nsum+=p[i];\nreturn sum;\n}\n\nint s[100];\nint n;\n\nint main()\n{\n\tcin &gt;&gt; n;\n\tfor (int i = 0; i &lt; n; ++i)\n\t\tcin &gt;&gt; s[i];\n\tcout &lt;&lt; Sum(s, n);\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\r\n\r\npublic class Main {\r\n\r\n\tpublic static void main(String[] args) throws IOException{\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tString str [] = br.readLine().split(" ");\r\n\t\t\r\n\t\tint a = Integer.parseInt(str[0]);\r\n\t\tint m = Integer.parseInt(str[1]);\r\n\t\t\r\n\t\tint Mi = (int)Math.pow(a, 2);\r\n\t\tSystem.out.print(Mi%m);\r\n\t}\r\n}\r\n</textarea>	150
150	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　输出九九乘法表。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出格式见下面的样例。乘号用“*”表示。\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  下面给出输出的前几行：\n  <br> 1*1=1\n  <br> 2*1=2 2*2=4\n  <br> 3*1=3 3*2=6 3*3=9\n  <br> 4*1=4 4*2=8 4*3=12 4*4=16\n  <br> ……\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n\tint i,j;\n\tfor(i=1;i&lt;10;i++)\n\t{\n\t\tfor(j=1;j&lt;=i;j++)\n\t\tprintf("%d*%d=%d ",i,j,i*j);\n\t\tprintf("\\n");\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt; \nusing namespace std;\nint main()\n{\n\tfor(int i=1;i&lt;10;i++)\n\t{\n\t\tfor(int j=1;j&lt;=i;j++)\n\t\t{\n\t\t\tcout&lt;&lt;i&lt;&lt;"*"&lt;&lt;j&lt;&lt;"="&lt;&lt;i*j&lt;&lt;"\\t";\n\t\t}\n\t\tcout&lt;&lt;"\\n";\n\t}\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tfor(int i=1;i&lt;=9;i++){\n\t\t\tfor(int j=1;j&lt;i;j++){\n\t\t\t\tSystem.out.print(i+"*"+j+"="+(i*j)+" ");\n\t\t\t}\n\t\t\tSystem.out.println(i+"*"+i+"="+(i*i));\n\t\t}\n\t}\n}\r\n</textarea>	151
151	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　一元n 次多项式可用如下的表达式表示：\n  <br> 　　f(x)=a[n]x^n+a[n-1]x^(n-1)+...+a[1]x+a[0], a[n]!=0\n  <br> 　　其中，a[i]x^i称为i 次项， a[i]称为i 次项的系数。给出一个一元多项式各项的次数和系数，请按照如下规定的格式要求输出该多项式：\n  <br> 　　1. 多项式中自变量为x，从左到右按照次数递减顺序给出多项式。\n  <br> 　　2. 多项式中只包含系数不为0 的项。\n  <br> 　　3. 如果多项式n 次项系数为正，则多项式开头不出现“+”号，如果多项式n 次项系数为负，则多项式以“-”号开头。\n  <br> 　　4. 对于不是最高次的项，以“+”号或者“-”号连接此项与前一项，分别表示此项系数为正或者系数为负。紧跟一个正整数，表示此项系数的绝对值（如果一个高于0 次的项，其系数的绝对值为1，则无需输出1）。如果x 的指数大于1，则接下来紧跟的指数部分的形式为“x^b”，其中b 为x 的指数；如果x 的指数为1，则接下来紧跟的指数部分形式为“x”；如果x 的指数为0，则仅需输出系数即可。\n  <br> 　　5. 多项式中，多项式的开头、结尾不含多余的空格。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入共有2 行\n  <br> 　　第一行1 个整数，n，表示一元多项式的次数。\n  <br> 　　第二行有n+1 个整数，其中第i 个整数表示第n-i+1 次项的系数，每两个整数之间用空格隔开。\n  <br> 　　1 ≤ n ≤ 100，多项式各次项系数的绝对值均不超过100。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出共1 行，按题目所述格式输出多项式。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5\n  <br> 100 -1 1 -3 0 10\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  100x^5-x^4+x^3-3x^2+10\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3\n  <br> -50 0 0 1\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  -50x^3+1\n </div> \n</div>	<textarea id="codelinesc">\r\n//多项式输出\n#include&lt;stdio.h&gt;\nint main()\n{\n\tint n,a[101],i;\n\t\n\tscanf("%d",&amp;n);\n\t\n\tfor(i=n;i&gt;=0;i--)\n\t\tscanf("%d",&amp;a[i]);\n\t\n\tfor(i=n;i&gt;=0;i--)\n\t{\n\t\tif(i==n)  //指数为首位\n\t\t{\n\t\t\t//系数大于0且等于1\n\t\t\tif(a[i]&gt;0 &amp;&amp; a[i]!=1)\n\t\t\t\tprintf("%dx^%d",a[i],i);\n\t\t\t//系数大于0且等于1\n            if(a[i]&gt;0 &amp;&amp; a[i]==1)\n\t\t\t\tprintf("x^%d",i);\n\t\t\t//系数小于0且不等于-1\n\t\t\tif(a[i]&lt;0 &amp;&amp; a[i]!=-1)\n\t\t\t\tprintf("%dx^%d",a[i],i);\n\t\t\t//系数小于0且等于-1\n\t\t\tif(a[i]&lt;0 &amp;&amp; a[i]==-1)\n\t\t\t\tprintf("-x^%d",i);\n\t\t}\n\t\t\n\t\telse if(i&gt;1 &amp;&amp; i!=n)  //指数不为0 且不为首位\n\t\t{\n\t\t\t//系数大于0且不等于1\n\t\t\tif(a[i]&gt;0 &amp;&amp; a[i]!=1)\n\t\t\t\tprintf("+%dx^%d",a[i],i);\n\t\t\t//系数大于0同时等于1\n\t\t\tif (a[i]&gt;0 &amp;&amp; a[i]==1)\n                printf("+x^%d",i);\n\t\t\t//系数小于0且不等于-1\n\t\t\tif(a[i]&lt;0 &amp;&amp; a[i]!=-1)\n\t\t\t\tprintf("%dx^%d",a[i],i);\n\t\t\t//系数小于0同时等于-1\n\t\t\tif(a[i]&lt;0 &amp;&amp; a[i]==-1)\n\t\t\t\tprintf("-x^%d",i);\n\t\t}\n\t\telse if(i==1)\n\t\t{\n\t\t\t//系数大于0且不等于1\n\t\t\tif(a[i]&gt;0 &amp;&amp; a[i]!=1)\n\t\t\t\tprintf("+%dx",a[i]);\n\t\t\t//系数大于0同时等于1\n\t\t\tif (a[i]&gt;0 &amp;&amp; a[i]==1)\n                printf("+x");\n\t\t\t//系数小于0且不等于-1\n\t\t\tif(a[i]&lt;0 &amp;&amp; a[i]!=-1)\n\t\t\t\tprintf("%dx",a[i]);\n\t\t\t//系数小于0同时等于-1\n\t\t\tif(a[i]&lt;0 &amp;&amp; a[i]==-1)\n\t\t\t\tprintf("-x");\n\t\t}\n\t\t\n\t\telse  //指数为0\n\t\t{\n\t\t\tif(a[i]&gt;0)\n\t\t\t\tprintf("+%d\\n",a[0]);\n\t\t\telse if(a[i]&lt;0)\n\t\t\t    printf("%d\\n",a[0]);\n\t\t}\n\t}\n\tprintf("\\n");\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\nint n;\nint main()\n{\n\tcin&gt;&gt;n;\n\tint a;\n\tint i,j;\n\tfor(i=1;i&lt;=n+1;i++)\n\t{\n\t\tcin&gt;&gt;a;\n\t\tif(i!=1)\n\t\t\tif(a&gt;0)\n\t\t\t\tcout&lt;&lt;"+";\n\t\tif(i&lt;=n &amp;&amp; a!=0&amp;&amp;a!=1&amp;&amp;a!=-1)\n\t\t\tcout&lt;&lt;a&lt;&lt;"x";\n\t\tif(i&lt;=n &amp;&amp; a==1)\n\t\t\tcout&lt;&lt;"x";\n\t\tif(i&lt;=n &amp;&amp; a==-1)\n\t\t\tcout&lt;&lt;"-x";\n\t\tif(i==n+1&amp;&amp;a!=0)\n\t\t\tcout&lt;&lt;a;\n\t\tif(i&lt;n &amp;&amp; a!=0)\n\t\t\tcout&lt;&lt;"^"&lt;&lt;n+1-i;\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\npublic class Main{\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        String s="";\n        int m=n;\n        boolean b=true;\n        for(int i=0;i&lt;n;i++){\n            int a=sc.nextInt();\n            if(m==1){\n            \tif(a&lt;-1)\n            \t\ts=s+a+"x";\n            \telse if(a&gt;1)\n            \t\ts=s+"+"+a+"x";\n            \telse if(a==1)\n            \t\ts=s+"+"+"x";\n            \telse if(a==-1)\n            \t\ts=s+"-"+"x";\n            \tbreak;\n            }\n            if(a&gt;1)\n                if(b)\n                    s=s+a+"x^"+m;\n                else\n                    s=s+"+"+a+"x^"+m;\n            else if(a&lt;-1)\n                s=s+a+"x^"+m;\n            else if(a==-1||a==1)\n                if(a==-1)\n                    s=s+"-x^"+m;\n                else if(a==1&amp;&amp;b)\n                    s=s+"x^"+m;\n                else\n                \ts=s+"+"+"x^"+m;\n            m--;\n            b=false;\n        }\n        m=sc.nextInt();\n        if(m&lt;0)\n            s=s+m;\n        else if(m&gt;0)\n            s=s+"+"+m;\n        System.out.println(s);\n    }\n}\r\n</textarea>	152
152	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　给定一个英文字母判断这个字母是大写还是小写。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入只包含一个英文字母c。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　如果c是大写字母，输出“upper”，否则输出“lower”。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  x\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  lower\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  B\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  upper\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n\nint main()\n{\n\tchar ch=0;\n\tscanf("%c",&amp;ch);\n\tif(ch&gt;='A' &amp;&amp; ch&lt;='Z')\n\t{\n\t\tprintf("upper");\n\t}\n\telse\n\t{\n\t\tprintf("lower");\n\t}\n\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include "iostream"\n#include "string"\n#include "stdio.h"\n#include "ctype.h"\nusing namespace std;\nconst int N =1000;\nbool  bArrange[N][N];\nint main()\n{\n\t char ch;\n\t cin&gt;&gt;ch;\n\t if(islower(ch))\n\t\t cout&lt;&lt;"lower";\n\t else cout&lt;&lt;"upper";\n\t\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.IOException;\nimport java.util.Scanner;\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tchar c=(char)System.in.read();\n\t\tif((int)c&gt;=65&amp;&amp;(int)c&lt;=90)\n\t\t\tSystem.out.println("upper");\n\t\tif((int)c&gt;=97&amp;&amp;(int)c&lt;=122)\n\t\t\tSystem.out.println("lower");\n\t    \n\n\t}\n\n}\r\n</textarea>	153
153	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　给定一个矩阵A,一个非负整数b和一个正整数m，求A的b次方除m的余数。\n  <br> 　　其中一个nxn的矩阵除m的余数得到的仍是一个nxn的矩阵，这个矩阵的每一个元素是原矩阵对应位置上的数除m的余数。\n  <br> 　　要计算这个问题，可以将A连乘b次，每次都对m求余，但这种方法特别慢，当b较大时无法使用。下面给出一种较快的算法(用A^b表示A的b次方)：\n  <br> 　　若b=0，则A^b%m=I%m。其中I表示单位矩阵。\n  <br> 　　若b为偶数，则A^b%m=(A^(b/2)%m)^2%m，即先把A乘b/2次方对m求余，然后再平方后对m求余。\n  <br> 　　若b为奇数，则A^b%m=(A^(b-1)%m)*a%m，即先求A乘b-1次方对m求余，然后再乘A后对m求余。\n  <br> 　　这种方法速度较快，请使用这种方法计算A^b%m，其中A是一个2x2的矩阵，m不大于10000。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入第一行包含两个整数b, m，第二行和第三行每行两个整数，为矩阵A。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出两行，每行两个整数，表示A^b%m的值。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  2 2\n  <br> 1 1\n  <br> 0 1\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  1 0\n  <br> 0 1\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint b, m;\nint a[2][2], ans[2][2], temp[2][2] = {1,1,1,1};\nvoid play()\n{\n    int cnt, cnt2;\n    for(cnt = 0; cnt &lt; 2; ++cnt)\n    {\n        for(cnt2 = 0; cnt2 &lt; 2; ++cnt2)\n        {\n            printf("%d ", ans[cnt][cnt2]);\n        }       \n        printf("\\n");\n    }   \n}\nvoid cp(int arr1[][2], int arr2[][2])\n{\n    int cnt, cnt2;\n    \n    for(cnt = 0; cnt &lt; 2 ;++cnt)\n        for(cnt2 = 0; cnt2 &lt; 2; ++cnt2)\n            arr1[cnt][cnt2] = arr2[cnt][cnt2];\n}\nvoid mod(int arr[][2])\n{\n    int cnt, cnt2;\n    \n    for(cnt = 0; cnt &lt; 2; ++cnt)\n        for(cnt2 = 0; cnt2 &lt; 2; ++cnt2)\n            arr[cnt][cnt2] %= m;\n}\nvoid fun2(int a[][2], int b[][2])\n{\n    int cnt, cnt2;\n    \n    temp[0][0] = a[0][0]*b[0][0]+a[0][1]*b[1][0];\n    temp[0][1] = a[0][0]*b[0][1]+a[0][1]*b[1][1];\n    temp[1][0] = a[1][0]*b[0][0]+a[1][1]*b[1][0];\n    temp[1][1] = a[1][0]*b[0][1]+a[1][1]*b[1][1];\n}\nvoid fun(int arr[][2], int k)\n{\n    int cnt;\n    \n    if(k == 0)\n    {\n        mod(temp);\n        cp(ans, temp);\n        return;\n    }\n    \n    if(k == 1)\n    {\n        mod(ans);\n        \n        return;\n    }\n    if(k == 2)\n    {\n        fun2(a, a);\n        cp(ans, temp);\n    //  printf("2\\n");\n    //  play();\n        mod(ans);\n        return;\n    }\n    if(k%2 == 0)\n    {\n        fun(arr, k/2);\n        fun2(ans, ans);\n        cp(ans, temp);\n        //printf("=0\\n");\n        //play();\n        \n        mod(ans);\n        return;\n    }\n    if(k%2 != 0)\n    {\n        fun(arr, k-1);\n        fun2(ans, arr);\n        cp(ans, temp);\n        //printf("!=0\\n");\n    //  play();\n        mod(ans);\n        return;\n    }\n}\nint main()\n{\n    int cnt, cnt2;\n    \n    scanf("%d%d", &amp;b, &amp;m);\n    \n    for(cnt = 0; cnt &lt; 2; ++cnt)\n        for(cnt2 = 0; cnt2 &lt; 2; ++cnt2)\n        {\n            scanf("%d", &amp;a[cnt][cnt2]);\n            ans[cnt][cnt2] = a[cnt][cnt2];\n        }\n    \n    fun(a, b);\n    \n    play();\n    \n    \n    return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nusing namespace std;\nint a[2][2],b,m;//求a的b次方\nint r[2][2]; \nvoid mul(int x[][2],int y[][2])\n{\n\tint s[2][2],t[2][2];\n\tint i,j,k;\n\tfor(i=0;i&lt;2;i++)\n\t\tfor(j=0;j&lt;2;j++)\n\t\t\ts[i][j] = x[i][j]%m,t[i][j] = y[i][j]%m;\n\tmemset(r,0,sizeof(r));\n\tfor(i=0;i&lt;2;i++)\n\t\tfor(j=0;j&lt;2;j++)\n\t\t\tfor(k=0;k&lt;2;k++)\n\t\t\t\tr[i][j]+=s[i][k]*t[k][j],r[i][j]%=m;\n}\nvoid f(int a[][2],int b)//计算a^b,结果保存在r里 \n{\n\tif(!b) //0 \n\t\tr[0][0]=1%m,r[0][1]=0,r[1][0]=0,r[1][1]=1%m;\n\telse if(b&amp;1)//奇数 \n\t{\n\t\tf(a,b-1);\n\t\tmul(r,a);//r = r * a;\n\t} \n\telse\n\t{\n\t\tf(a,b/2);\n\t\tmul(r,r);//r = r * r;\n\t} \n}\nint main()\n{\n\tcin&gt;&gt;b&gt;&gt;m;\n\tcin&gt;&gt;a[0][0]&gt;&gt;a[0][1]&gt;&gt;a[1][0]&gt;&gt;a[1][1];\n\tf(a,b);\t//求a^b \n\tcout&lt;&lt;r[0][0]&lt;&lt;" "&lt;&lt;r[0][1]&lt;&lt;endl;\n\tcout&lt;&lt;r[1][0]&lt;&lt;" "&lt;&lt;r[1][1];\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\n\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int m=0;\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] str = br.readLine().split(" ");\n\t\tint b = Integer.parseInt(str[0]);\n\t\tm = Integer.parseInt(str[1]);\n\t\tint[][] resultMatrix=new int[2][2];\n\t\tint[][] matrix=new int[2][2];\n\t\tfor(int i=0;i&lt;2;i++){\n\t\t\tString[] tag=br.readLine().split(" ");\n\t\t\tfor(int j=0;j&lt;2;j++){\n\t\t\t\tmatrix[i][j]=Integer.parseInt(tag[j]);\n\t\t\t} \n\t\t}\n\t\tresultMatrix=powMul(matrix, b);\n\t\tfor(int i=0;i&lt;2;i++){\n\t\t\tfor(int j=0;j&lt;2;j++){\n\t\t\t\tSystem.out.print(resultMatrix[i][j]%m+" ");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tprivate static int[][] mul(int[][] x,int[][] y){\n\t\tint[][] temp=new int[2][2];\n\t\tfor(int a=0;a&lt;2;a++){\n\t\t\tfor(int b=0;b&lt;2;b++){\n\t\t\t\tfor(int c=0;c&lt;2;c++){\n\t\t\t\t\ttemp[a][b]+=x[a][c]*y[c][b];\n\t\t\t\t\ttemp[a][b]%=m;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn temp;\n\t}\n\t\n\tprivate static int[][] powMul(int[][] arr,int b){\n\t\tif(b==0){\n\t\t\tint[][] temp=new int[2][2];\n\t\t\tfor(int i=0;i&lt;2;i++){\n\t\t\t\ttemp[i][i]=1;\n\t\t\t\t}\n\t\t\treturn temp;\n\t\t\t}if(b==1){\n\t\t\t\treturn arr;\n\t\t\t}\n\t\t\tint[][] rep=powMul(arr,b/2);\n\t\t\tif(b%2==0){\n\t\t\t\treturn mul(rep,rep);\n\t\t\t}else{\n\t\t\t\treturn mul(mul(rep,rep),arr);\n\t\t\t}\n\t}\n}\n\r\n</textarea>	154
154	<div class="des"> \n <div class="pdcont">\n  <b>[</b>\n  <b>题目描述]</b>\n  <br> 　　在一座山上,有很多很多珠宝,它们散落在山底通往山顶的每条道路上,不同道路上的珠宝的数目也各不相同.下图为一张藏宝地图:\n  <br> \n  <br> 　　7\n  <br> 　　3 8\n  <br> 　　8 1 0\n  <br> 　　2 7 4 4\n  <br> 　　4 5 2 6 5\n  <br> \n  <br> 　　”夺宝奇兵”从山下出发,到达山顶,如何选路才能得到最多的珠宝呢?在上图所示例子中,按照5-&gt;7-&gt;8-&gt;3-&gt;7的顺序,将得到最大值30\n  <br> \n  <br> \n  <b>[</b>\n  <b>输入]</b>\n  <br> 　　第一行正整数N(100&gt;=N&gt;1),表示山的高度\n  <br> 　　接下来有N行非负整数,第i行有i个整数(1&lt;=i&lt;=N),表示山的第i层上从左到右每条路上的珠宝数目\n  <br> \n  <br> \n  <b>[</b>\n  <b>输出]</b>\n  <br> 　　一个整数,表示从山底到山顶的所能得到的珠宝的最大数目.\n  <br> \n  <b>[</b>\n  <b>样例输入]</b>\n  <pre class="pddata">\n<span lang="EN-US"><font face="宋体" size="3">5</font></span>\n</pre> \n  <pre class="pddata">\n<span lang="EN-US"><font face="宋体" size="3">7</font></span>\n</pre> \n  <pre class="pddata">\n<span lang="EN-US"><font face="宋体" size="3">3 8</font></span>\n</pre> \n  <pre class="pddata">\n<span lang="EN-US"><font face="宋体" size="3">8 1 0 </font></span>\n</pre> \n  <pre class="pddata">\n<span lang="EN-US"><font face="宋体" size="3">2 7 4 4</font></span>\n</pre> \n  <pre class="pddata">\n<span lang="EN-US"><font face="宋体" size="3">4 5 2 6 5</font></span>\n</pre> \n  <br> \n  <b>[</b>\n  <b>样例输出]</b>\n  <br> 　　30\n </div> \n</div>	<textarea id="codelinesc">\r\n//夺宝奇兵\n#include&lt;stdio.h&gt;\nint max(int a,int b)\n{\n    return a&gt;b?a:b;\n}\nint main()\n{\n    int N,i,j;\n    int a[101][101]={0};\n    int f[101][10]={0};\n    \n    scanf("%d",&amp;N);\n    \n    for(i=1;i&lt;=N;i++)\n       for(j=1;j&lt;=i;j++)\n            scanf("%d",&amp;a[i][j]);\n\t\n\t for(i=N;i&gt;=0;i--)\n\t\tfor(j=1;j&lt;=i;j++)\n\t\t{\n\t\t\tf[i][j]=max( f[i+1][j],f[i+1][j+1] )+a[i][j];\n\t\t}\n     printf("%d\\n",f[1][1]);\n    return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;cstdlib&gt;\n#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n//#include &lt;windows.h&gt;\n\nusing namespace std;\n\nint dp[101][101];\n\nint maxx(int a, int b)\n{\n    return a&gt;b?a:b;\n}\n\nint main()\n{\n    int N, i, j;\n    scanf("%d", &amp;N);\n    \n    for(i = 1; i &lt;= N; i++)\n    {\n        for(j = 1; j &lt;= i; j++)\n        scanf("%d", &amp;dp[i][j]);\n    }\n    \n    for(i = N-1; i &gt;= 1; i--)\n    {\n        for(j = 1; j &lt;= N-1; j++)\n        dp[i][j] = maxx(dp[i+1][j], dp[i+1][j+1])+dp[i][j];\n    }\n    printf("%d\\n", dp[1][1]);\n    //system("pause");\n    return 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\npublic class Main {\n\tpublic static int sum(int[][] bao,int n){\n\t\tfor (int i = n-2; i &gt;= 0; i--) {\n\t\t\tfor (int j = 0; j &lt;= i; j++) {\n\t\t\t\tint max=bao[i+1][j] &gt; bao[i+1][j+1] ? bao[i+1][j]:bao[i+1][j+1];\n\t\t\t\tbao[i][j]+=max;\n\t\t\t}\n\t\t}\n\t\treturn bao[0][0];\n\t}\n    public static void main(String[] args) {\n\t\tScanner scan=new Scanner(System.in);\n\t\tint n=scan.nextInt();\n\t\tint[][] bao=new int[n][n];\n\t\tfor (int i = 0; i &lt; n; i++) {\n\t\t\tfor (int j = 0; j &lt;= i; j++) {\n\t\t\t\tbao[i][j]=scan.nextInt();\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(sum(bao,n));\n\t}\n}\r\n</textarea>	155
155	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　编制程序完成下述任务：接受两个数，一个为用户一年期定期存款金额，一个为按照百分比格式表示的利率；程序计算一年期满后本金与利息总额。说明：（1）存款金额以人民币元为单位，可能精确到分；（2）输入利率时不需要输入百分号，例如一年期定期存款年利率为2.52%，用户输入2.52即可；（3）按照国家法律，存款利息所得需缴纳20% 的所得税，计算结果时所得税部分应扣除。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入一行，包含两个实数，分别表示本金和年利率。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出一行，包含一个实数，保留到小数点后两位，表示一年后的本金与利息和。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  10000 2.52\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  10201.60\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n/* run this program using the console pauser or add your own getch, system("pause") or input loop */\n\n\n\nint main(int argc, char *argv[]) {\n\tdouble x,n;\n    double sum=0;\n    scanf("%lf",&amp;x);\n    scanf("%lf",&amp;n);\n    sum=x+(x*(n/100)*0.8);\n    printf("%.2lf",sum);\n\n\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\n#include &lt;cstdio&gt;\n\nusing namespace std;\n\nint main()\n{\n\tdouble a, b;\n\tcin &gt;&gt; a &gt;&gt; b;\n\tprintf("%0.2lf", a+a*b*0.01*0.8);\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.*;\nimport java.math.*;\npublic class Main {    \n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        float a=sc.nextFloat();\n        float b=sc.nextFloat();     \n        BigDecimal c=new BigDecimal(a+a*b*0.01*0.8);\n        c=c.setScale(2,BigDecimal.ROUND_HALF_UP);\n        System.out.println(c);\n    }\n}\r\n</textarea>	156
156	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　编制一个乘法运算的程序。\n  <br> 　　从键盘读入2个100以内的正整数，进行乘法运算并以竖式输出。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入只有一行，是两个用空格隔开的数字，均在1~99之间（含1和99）。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出为4行或7行，符合乘法的竖式运算格式。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  89 13\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  89\n  <br> ×13\n  <br> ━━━\n  <br> 267\n  <br> 89\n  <br> ━━━\n  <br> 1157\n </div>\n <div class="pdsec">\n  输入输出样例1解释\n </div>\n <div class="pdcont">\n  　　3×89=267，则第四行267右侧对准个位输出。1×89=89，则第五行89右侧对准十位输出。267+890=1157，则1157右侧对准个位输出。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  16 8\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  16\n  <br> × 8\n  <br> ━━━\n  <br> 128\n </div>\n <div class="pdsec">\n  输入输出样例2解释\n </div>\n <div class="pdcont">\n  　　8×16=128，则第四行128右侧对准个位输出。计算完成，不再输出。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n\tint i;\n\tstruct map\n\t{\n\t\tchar a[10]; //国家\n\t\tfloat area;  //面积\n\t\tfloat pop;  //人口\n\t\tfloat GDP;  //GDP \n\t};\n\t\n\tstruct map m[5]={{"China",       960.00,  129500.00,  1080.00  },\n\t                 {"Iceland",     10.30,   27.57,      8.20     },\n\t                 {"India",       297.47,  97000.00,   264.80   },\n\t                 {"Madagascar",  62.70,   1635.00,    3.60     },\n\t                 {"Maldive",     0.0298,  27.80,      0.23     }\n\t    };\n\tprintf("------------------------------------------------------------------------------\\n");\n\tprintf("COUNTRY AREA(10K km2) POP.(10K) GDP(Billion$)\\n");\n\tprintf("------------------------------------------------------------------------------\\n");\n\tfor(i=0;i&lt;4;i++)\n\tprintf("%s %.2f %.2f %.2f\\n",m[i].a,m[i].area,m[i].pop,m[i].GDP);\n\tprintf("%s %.4f %.2f %.2f\\n",m[i].a,m[i].area,m[i].pop,m[i].GDP);\n\tprintf("-----------------------------------------------------------------------------\\n");\n\t\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\nint main()\n{\n\tcout&lt;&lt;"------------------------------------------------------------------------------"&lt;&lt;endl;\n\tcout&lt;&lt;"COUNTRY AREA(10K km2) POP.(10K) GDP(Billion$)"&lt;&lt;endl;\n\tcout&lt;&lt;"------------------------------------------------------------------------------"&lt;&lt;endl;\n\tcout&lt;&lt;"China 960.00 129500.00 1080.00"&lt;&lt;endl;\n\tcout&lt;&lt;"Iceland 10.30 27.57 8.20"&lt;&lt;endl;\n\tcout&lt;&lt;"India 297.47 97000.00 264.80"&lt;&lt;endl;\n\tcout&lt;&lt;"Madagascar 62.70 1635.00 3.60"&lt;&lt;endl;\n\tcout&lt;&lt;"Maldive 0.0298 27.80 0.23"&lt;&lt;endl;\n\tcout&lt;&lt;"-----------------------------------------------------------------------------";\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate static Scanner scanner = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\tint c1 = scanner.nextInt();\n\t\tint c2 = scanner.nextInt();\n\t\tString s = String.valueOf(c1 * c2);\n\t\tint len = s.length();\n\t\tchar[] cs = c2 &lt; 10 ? String.valueOf(" " + c2).toCharArray() : String\n\t\t\t\t.valueOf(c2).toCharArray();\n\t\tSystem.out.println(c1 + "\\n\\u00D7" + String.valueOf(cs)\n\t\t\t\t+ "\\n\\u2501\\u2501\\u2501");\n\t\tif (c2 &gt;= 10) {\n\t\t\tfor (int i = cs.length - 1; i &gt;= 0; i--) {\n\t\t\t\tif (cs[i] != ' ') {\n\t\t\t\t\tString x = String.valueOf(c1 * (cs[i] - '0'));\n\t\t\t\t\tif (x.equals("0"))  \n\t\t\t\t\t\tx = "00"; \n\t\t\t\t\tfor (int j = 1; j &lt; cs.length - i; j++)\n\t\t\t\t\t\tx += " ";\n\t\t\t\t\tint l = x.length();\n\t\t\t\t\tfor (int j = 0; j &lt; len - l; j++)\n\t\t\t\t\t\tx = " " + x;\n\t\t\t\t\tSystem.out.println(x);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println("\\u2501\\u2501\\u2501");\n\t\t}\n\t\tSystem.out.println(s);\n\t}\n}\r\n</textarea>	157
157	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　输入三个自然数N，i，j （1&lt;=i&lt;=N，1&lt;=j&lt;=N），输出在一个N*N格的棋盘中，与格子（i，j）同行、同列、同一对角线的所有格子的位置。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入共三行，分别输入自然数N，i，j。其中保证N&lt;=24且1&lt;=i&lt;=N，1&lt;=j&lt;=N。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出共四行。第一行为与格子（i，j）同行的所有格子的位置，第二行为与格子（i，j）同列的所有格子的位置，第三行为从左上到右下对角线上的格子的位置，第四行为从左下到右上对角线上的格子的位置。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  4\n  <br> 2\n  <br> 3\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  (2,1) (2,2) (2,3) (2,4)\n  <br> (1,3) (2,3) (3,3) (4,3)\n  <br> (1,2) (2,3) (3,4)\n  <br> (4,1) (3,2) (2,3) (1,4)\n </div>\n <div class="pdsec">\n  输入输出样例解释\n </div>\n <div class="pdcont">\n  　　n=4，i=2，j=3表示了棋盘中的第二行第三列的格子，如下图：\n  <br> \n  <table cellspacing="0" cellpadding="2px" style="border-collapse:collapse;" class="table table-striped table-horver">\n   <tbody>\n    <tr style="border:solid 1.0pt">\n     <td style="border:solid 1.0pt">第1列</td>\n     <td style="border:solid 1.0pt">第2列</td>\n     <td style="border:solid 1.0pt">第3列</td>\n     <td style="border:solid 1.0pt">第4列</td>\n     <td style="border:solid 1.0pt"> </td>\n    </tr>\n    <tr style="border:solid 1.0pt">\n     <td style="border:solid 1.0pt"> </td>\n     <td style="border:solid 1.0pt"> </td>\n     <td style="border:solid 1.0pt"> </td>\n     <td style="border:solid 1.0pt"> </td>\n     <td style="border:solid 1.0pt">第1行</td>\n    </tr>\n    <tr style="border:solid 1.0pt">\n     <td style="border:solid 1.0pt"> </td>\n     <td style="border:solid 1.0pt"> </td>\n     <td style="border:solid 1.0pt">(2,3)</td>\n     <td style="border:solid 1.0pt"> </td>\n     <td style="border:solid 1.0pt">第2行</td>\n    </tr>\n    <tr style="border:solid 1.0pt">\n     <td style="border:solid 1.0pt"> </td>\n     <td style="border:solid 1.0pt"> </td>\n     <td style="border:solid 1.0pt"> </td>\n     <td style="border:solid 1.0pt"> </td>\n     <td style="border:solid 1.0pt">第3行</td>\n    </tr>\n    <tr style="border:solid 1.0pt">\n     <td style="border:solid 1.0pt"> </td>\n     <td style="border:solid 1.0pt"> </td>\n     <td style="border:solid 1.0pt"> </td>\n     <td style="border:solid 1.0pt"> </td>\n     <td style="border:solid 1.0pt">第4行</td>\n    </tr>\n   </tbody>\n  </table>\n  <br> 　　(2,1) (2,2) (2,3) (2,4) {同一行上格子的位置}\n  <br> 　　(1,3) (2,3) (3,3) (4,3) {同列列上格子的位置}\n  <br> 　　(1,2) (2,3) (3,4) {左上到右下对角线上的格子的位置}\n  <br> 　　(4,1) (3,2) (2,3) (1,4) {左下到右上对角线上的格子的位置}\n </div> \n</div>	<textarea id="codelinesc">\r\n//格子位置\n#include&lt;stdio.h&gt;\n//同一行上的格子\nvoid row(int N,int i)\n{\n\tint j;\n\tfor(j=1;j&lt;=N;j++)\n\tprintf("(%d,%d)",i,j);\n\tprintf("\\n");\n} \n//同一列上的格子\nvoid col(int N,int j)\n{\n\tint i;\n\tfor(i=1;i&lt;=N;i++)\n\tprintf("(%d,%d)",i,j);\n\tprintf("\\n");\n} \n//左上到右下对角线  wrong answer\nvoid left(int N,int i,int j)\n{\n\tint m,n,t=0,flag=0;\n\t\n\tif(!flag)\n\t{\n\t    for(m=1;m&lt;=1;m++)\n\t    {\n\t\t    for(n=1;n&lt;=N;n++)\n\t\t    {\n\t\t\t    while(n+t&lt;=N)\n\t\t\t    {\n\t\t\t        if(m+t==i &amp;&amp; n+t==j)\n\t\t\t        {\n\t\t\t\t        flag=1;\n\t\t\t\t        break;\n\t\t\t        }\n\t\t\t\t    else t++;\t\n\t\t\t    }\n\t\t\t    t=0;\n\t\t\t    if(flag) break;\n\t\t    }\n\t\t    if(flag) break;\n\t    }\t\n\t}\n\t\n\tif(!flag)\n\t{\n\t    for(m=1;m&lt;=N;m++)\n\t    {\n\t\t    for(n=1;n&lt;=1;n++)\n\t\t    {\n\t\t   \t    while(m+t&lt;=N)\n\t\t\t    {\n\t\t\t        if(m+t==i &amp;&amp; n+t==j)\n\t\t\t        {\n\t\t\t\t       flag=1;\n\t\t\t\t\t   break;\n\t\t\t        }\n\t\t\t\t    else t++;\t\n\t\t\t   }\n\t\t\t    t=0;\n\t\t\t    if(flag) break;\n\t\t    }\n\t\t    if(flag) break;\n\t    }\t\n\t}\n\t\t\n\twhile(m&lt;=N &amp;&amp; n&lt;=N)\n\t{\n\t    printf("(%d,%d)",m,n);\n\t\tm++,n++;\t\n\t}\n\tprintf("\\n");\n} \n\n//从左下到右上对角线 \nvoid right(int N,int i,int j)\n{\n\tint m,n;\n\tm=N;\n\t\n\tfor(;m&gt;=1;m--)\n\tfor(n=1;n&lt;=N;n++)\n\tif(m+n==i+j)\n\tprintf("(%d,%d)",m,n);\t\n\t\n\tprintf("\\n");\n} \nint main() \n{\n\tint i,j,N;\n\tscanf("%d %d %d",&amp;N,&amp;i,&amp;j);\n\trow(N,i);      //同行 \n\tcol(N,j);      //同列 \n\tleft(N,i,j);   //左上-&gt;右下 \n\tright(N,i,j);  //左下-&gt;右上 \n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include "iostream"\n#include "vector"\n#include "time.h"\n#include "algorithm"\n#include "stdio.h"\n#include "string.h"\nusing namespace std;\n#define  N 501\nbool check_bound(int x,int n)\n{\n\treturn  x&gt;=1&amp;&amp;x&lt;=n;\n}\nint main()\n{\n    int n,x,y;\n\tcin.sync_with_stdio(false);\n\tcin&gt;&gt;n&gt;&gt;x&gt;&gt;y;\n\tcout&lt;&lt;"("&lt;&lt;x&lt;&lt;","&lt;&lt;1&lt;&lt;")";\n\tfor(int j=2;j&lt;=n;j++)\n\t\tcout&lt;&lt;"("&lt;&lt;x&lt;&lt;","&lt;&lt;j&lt;&lt;")";\n\tcout&lt;&lt;endl;\n\n\tcout&lt;&lt;"("&lt;&lt;1&lt;&lt;","&lt;&lt;y&lt;&lt;")";\n\tfor (int i = 2; i &lt;= n ; i++)\n\t{\n\t\tcout&lt;&lt;"("&lt;&lt;i&lt;&lt;","&lt;&lt;y&lt;&lt;")";\n\t}\n\tcout&lt;&lt;endl;\n\n\tint b=y-x;\n\tbool isFirst=true;\n\t  for (int i = 1; i &lt;= n ; i++)\n\t  {\n\t\t  int j=i+b;\n\t      if(check_bound(j,n))\n\t\t  {\n\t\t\t   cout&lt;&lt;"("&lt;&lt;i&lt;&lt;","&lt;&lt;j&lt;&lt;")";\n\t\t  }\n\t\t \n\t  }\n\t  cout&lt;&lt;endl;\n\t   b=y+x;\n\t  for(int j=1; j&lt;= n;j++)\n\t  {\n\t\t  int i=b-j;\n\t\t  if(check_bound(i,n))\n\t\t  {\n\t\t\t  cout&lt;&lt;"("&lt;&lt;i&lt;&lt;","&lt;&lt;j&lt;&lt;")";\n\t\t  }\n\t  }\n\t  cout&lt;&lt;endl;\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint a = scan.nextInt();\n\t\tint b = scan.nextInt();\n\t\tfor(int i = 1 ; i &lt;= n ; i ++){\n\t\t\tSystem.out.print("("+a+","+i+")");\n\t\t}\n\t\tSystem.out.println();\n\t\t\n\t\tfor(int i = 1 ; i &lt;= n ; i ++){\n\t\t\tSystem.out.print("("+i+","+b+")");\n\t\t}\n\t\tSystem.out.println();\n\t\t\n\t\tfor(int i = 1 ; i &lt;= a ; i ++){\n\t\t\tif((b - a + i) &gt;= 1) {\n\t\t\t\tSystem.out.print("("+i+","+(b-a+i)+")");\n\t\t\t}\n\t\t}\n\t\tfor (int i = b + 1; i &lt;= n ; i ++) {\n\t\t\tif((a+i-b) &lt;= n)\n\t\t\t\tSystem.out.print("("+(a+i-b)+","+(i)+")");\n\t\t}\n\t\tSystem.out.println();\n\t\t\n\t\tfor(int i = b - 1 ; i &gt;= 0 ; i --){\n\t\t\tif(a+i &lt;= n)\n\t\t\t\tSystem.out.print("("+(a+i)+","+(b-i)+")");\n\t\t}\n\t\tfor(int i = 1 ; i &lt; a ; i ++){\n\t\t\tif(b+i &lt;= n)\n\t\t\t\tSystem.out.print("("+(a-i)+","+(b+i)+")");\n\t\t}\n\t}\n}\r\n</textarea>	158
158	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　设有有2 \n  <sup>n</sup>（n&lt;=6）个球队进行单循环比赛，计划在2 \n  <sup>n</sup> – 1天内完成，每个队每天进行一场比赛。设计一个比赛的安排，使在2 \n  <sup>n</sup> – 1天内每个队都与不同的对手比赛。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入文件matchplan.in共一行，输入n的数值。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出文件matchplan.out共（2 n – 1）行，第i行输出第i天的比赛安排。\n  <br> 　　格式为：&lt;i&gt; A-B，C-D，……。其中i是天数，A，B分别为比赛双方的编号，每行共2 \n  <sup>n-1</sup>个比赛场次。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  2\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  &lt;1&gt;1-2,3-4\n  <br> &lt;2&gt;1-3,2-4\n  <br> &lt;3&gt;1-4,2-3\n </div> \n</div>	<textarea id="codelinesc">\r\n//求最小公倍数\n#include&lt;stdio.h&gt;\nvoid lcm(long long a,long long b)\n{\n\tint t;\n\tif(a&lt;b)\n\t{\n\t\tt=a;\n\t\ta=b;\n\t\tb=t;\n\t}\n\t\n\tlong long m,n,r;\n\tm=a,n=b;\n\tr=a%b;\n\twhile(r!=0)\n\t{\n\t\ta=b;\n\t\tb=r;\n\t\tr=a%b;\n\t}\n\tprintf("%I64d\\n",(m*n)/b);\n} \nint main()\n{\n\tlong long a,b;\n\tscanf("%I64d %I64d",&amp;a,&amp;b); \n\tif(a==0 || b==0)\n\tprintf("0\\n");\n\telse\n\tlcm(a,b);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include "iostream"\n#include "string"\n#include "stdio.h"\nusing namespace std;\nconst int N =1000;\nbool  bArrange[N][N];\nint main()\n{\n\tint n;\n\tcin&gt;&gt;n;\n\tint row=(1&lt;&lt;n);\n\tint volumn=1&lt;&lt;(n-1);\n\tfor(int i = 0; i&lt; row-1 ; i++ )\n\t{\n\t\tcout&lt;&lt;"&lt;"&lt;&lt;i+1&lt;&lt;"&gt;"&lt;&lt;"1-"&lt;&lt;i+2;\n\t\tbool isArrage[N]={false};\n\t\tisArrage[1]=isArrage[i+2]=true;\n\t\tbArrange[1][i+2]=bArrange[i+2][1]=true;\n\t\tfor(int j  =1 ; j&lt; volumn ; j++)\n\t\t{\n\t\t\tint a;\n\t\t\tfor( a=2;a&lt;=row;a++)\n\t\t\t\tif(isArrage[a]==false)\n\t\t\t\t\tbreak;\n\t\t\tfor(int b=a+1;b&lt;=row;b++)\n\t\t\t{\n\t\t\t\tif(bArrange[a][b]==false&amp;&amp;isArrage[b]==false)\n\t\t\t\t{\n\t\t\t\t\tbArrange[a][b]=bArrange[b][a]=true;\n\t\t\t\t\tisArrage[a]=isArrage[b]=true;\n\t\t\t\t\tcout&lt;&lt;" "&lt;&lt;a&lt;&lt;"-"&lt;&lt;b;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tcout&lt;&lt;endl;\n\t}\n\t\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tList&lt;String&gt; list=new ArrayList&lt;String&gt;();\n\t\tint sum=(int) Math.pow(2, n);\n\t\tfor(int i=1;i&lt;=sum;i+=2){\n\t\t\tString s=i+"-"+(i+1);\n\t\t\tlist.add(s);\n\t\t}\n\t\tfor(int i=1;i&lt;=sum-2;i++){\n\t\t\tint[] arr=new int[sum+1];\n\t\t\tfor(int j=1;j&lt;=sum;j++)\n\t\t\t\tarr[j]=j;\n\t\t\tlist.add(new String(1+"-"+(i+2)));\n\t\t\tarr[1]=0;arr[i+2]=0;\n\t\t\tfor(int k=2;k&lt;=sum;k++){\n\t\t\t\tfor(int p=2;p&lt;=sum;p++){\n\t\t\t\t\tif(k!=p&amp;&amp;arr[p]!=0&amp;&amp;arr[k]!=0){\n\t\t\t\t\t\tString sp=k+"-"+p;\n\t\t\t\t\t\tif(list.contains(sp))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tlist.add(sp);\n\t\t\t\t\t\t\tarr[p]=0;arr[k]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint num=2;\n\t\tSystem.out.print("&lt;1&gt;");\n\t\tfor(int i=1,j=list.size();i&lt;=j;i++){\n\t\t\tSystem.out.print(list.get(i-1)+" ");\n\t\t\tif(i%(sum/2)==0&amp;&amp;i&lt;j){\n\t\t\t\tSystem.out.println();\n\t\t\t\tSystem.out.print("&lt;"+num+"&gt;");\n\t\t\t\tnum++;\n\t\t\t}\n\t\t}\n\t}\n}\r\n</textarea>	159
159	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　从键盘输入一个字符串（长度&lt;=40个字符），并以字符 ’.’ 结束。编辑功能有：\n  <br> 　　1 D：删除一个字符，命令的方式为： D a 其中a为被删除的字符，例如：D s 表示删除字符 ’s’ ，若字符串中有多个 ‘s’，则删除第一次出现的。\n  <br> 　　2 I：插入一个字符，命令的格式为：I a1 a2 其中a1表示插入到指定字符前面，a2表示将要插入的字符。例如：I s d 表示在指定字符 ’s’ 的前面插入字符 ‘d’ ，若原串中有多个 ‘s’ ，则插入在最后一个字符的前面。\n  <br> 　　3 R：替换一个字符，命令格式为：R a1 a2 其中a1为被替换的字符，a2为替换的字符，若在原串中有多个a1则应全部替换。\n  <br> 　　在编辑过程中，若出现被改的字符不存在时，则给出提示信息。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入共两行，第一行为原串(以’.’结束)，第二行为命令（输入方式参见“问题描述” 。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出共一行，为修改后的字符串或输出指定字符不存在的提示信息。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  This is a book.\n  <br> D s\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  Thi is a book.\n </div>\n <div class="pdsec">\n  输入输出样例解释\n </div>\n <div class="pdcont">\n  　　命令为删去s，第一个在字符中出现的s在This中，即得到结果。\n </div> \n</div>	<textarea id="codelinesc">\r\n//字符串编辑 \n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nint i,j;\n//删除操作 \nvoid Del(char S[],char a,int len)\n{\t\n\n\tfor(i=0;i&lt;len;i++)\n\tif(a==S[i])\n\tbreak;\t\n\n\tif(i!=len)\n\t{\n\t    for(j=i;j&lt;len;j++)\n\t        S[j]=S[j+1];\t\n\t}\n\t\t\n\tfor(i=0;i&lt;len;i++)\n\tif(S[i]=='#')\n\tprintf(" ");\n\telse\n\tprintf("%c",S[i]);\n}\n\n//插入操作\nvoid Ins(char S[],char a1,char a2,int len) \n{\n\ti=len-1;\n\tfor(;i&gt;=0;i--)\n\t\tif(S[i]==a2)\n\t\t    break;\n\tif(i!=0)\n\t{\n\t    len++;\t\n\t    //字符右移 \n\t    for(j=len-1;j&gt;i;j--)\n\t    S[j]=S[j-1];\t\n\t    S[i]=a1;  //最后出现的a2替换成a1 \n\t\n\t    for(i=0;i&lt;len;i++)\n\t    if(S[i]=='#')\n\t    printf(" ");\n\t    else\n\t    printf("%c",S[i]);\n\t    //printf(".");\n\t} \n}\n//替换操作 \nvoid Res(char S[],char a1,char a2,int len)\n{\n\tint flag=0;\n\tfor(i=0;i&lt;len;i++)\n\tif(S[i]==a1)\n\t{\n\t    S[i]=a2;\n\t\tflag=1;\t\n\t}\n\t\n\tif(flag==1)\n\t{\n\t    for(i=0;i&lt;=len;i++)\n\t    if(S[i]=='#')\n\t    printf(" ");\n\t    else\n\t    printf("%c",S[i]);\t\n\t}\n\telse\n\tprintf("指定字符不存在\\n");\n\t\n}\nint main()\n{\n\tchar S[41],Edit,a,a1,a2;\n\tint len=0;\n\tgets(S);\n\twhile(S[i]!='\\0')\n\t{\n\t\tif(S[i]==' ')\n\t\tS[i]='#';\n\t\tlen++;\n\t\ti++;\n\t} \n\t//printf("len=%d\\n");  \n\tscanf("%c",&amp;Edit);\n\tgetchar();\n\tswitch(Edit)\n\t{\n\t\tcase 'd':\n\t\tcase 'D': \n\t\t{\n\t\t    scanf("%c",&amp;a);\t\n\t\t    Del(S,a,len);\n\t\t}break;\n\t\t\n\t\tcase 'i':\n\t\tcase 'I': \n\t\t{\n\t\t    scanf("%c %c",&amp;a1,&amp;a2);\n\t\t\tIns(S,a2,a1,len);\t\n\t\t} break;\n\t\t\n\t\tcase 'r':\n\t\tcase 'R':\n\t\t{\n\t\t    scanf("%c %c",&amp;a1,&amp;a2);\n\t\t\tRes(S,a1,a2,len);\t\n\t\t}break;\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include "iostream"\n#include "string"\n#include "stdio.h"\nusing namespace std;\nclass myString :public string\n{\npublic:\n\tmyString(char *str=NULL):string(str){}\n      string deleteChar(char ch)\n\t  {\n\t\t  int index=this-&gt;find_first_of( ch );\n\t\t  if(index != -1)\n\t\t  {\n\t\t\t  return  this-&gt;substr(0,index)+this-&gt;substr(index+1);\n\t\t  }\n\t\t  else return "指定字符不存在";\n\t\t  return *this;\n\t  }\n\t  string insertChar( char ch1, char ch2)\n\t  {\n\t\t  int index = this -&gt; find_last_of(ch1);\n\t\t  if(index != -1)\n\t\t  {\n\t\t\t  return this-&gt;substr(0,index)+ch2+this-&gt;substr(index);\n\t\t  }\n\t\t  else return "指定字符不存在";\n\t\t  return *this;\n\t  }\n\t  string replaceChar(char ch1, char ch2)\n\t  {\n\t\t  bool isExit=false;\n\t\t  for(int i=0;i&lt;(this-&gt;size()); i++)\n\t\t  {\n\t\t\t  if((*this)[i]==ch1)\n\t\t\t  {\n\t\t\t\t   isExit=true;\n\t\t\t\t   (*this)[i]=ch2;\n\t\t\t  }\n\t\t\t\t \n\t\t  }\n\t\t  if(isExit == false)\n\t\t\t  return "指定字符不存在";\n\t\t  return *this;\n\t  }\n};\nint main()\n{\n\tchar s[1000];\n   cin.getline(s,1000);\n\t\n\tmyString str(s);\n\tchar ch;\n\tcin&gt;&gt;ch;\n\tif(ch=='D')\n\t{\n\t\tcin&gt;&gt;ch;\n\t\tcout&lt;&lt;str.deleteChar(ch);\n\t}\n\telse if(ch=='I')\n\t{\n\t\tchar ch1,ch2;\n\t\tcin&gt;&gt;ch1&gt;&gt;ch2;\n\t\tcout&lt;&lt;str.insertChar(ch1,ch2);\n\t}\n\telse \n\t{\n\t\tchar ch1,ch2;\n\t\tcin&gt;&gt;ch1&gt;&gt;ch2;\n\t\tcout&lt;&lt;str.replaceChar(ch1,ch2);\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nclass Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringBuffer sb=new StringBuffer(br.readLine());\n\t\tString []str=br.readLine().split(" ");\n\t\tchar[] key=str[0].toCharArray();\n\t\tboolean bo=false;\n\t\tswitch (key[0]) {\n\t\tcase 'D':\n\t\tcase 'd':\n\t\t\tfor(int i=0;i&lt;sb.length();i++){\n\t\t\t\tif(new Character(sb.charAt(i)).toString().equals(str[1])){\n\t\t\t\t\tsb.deleteCharAt(i);\n\t\t\t\t\tbo=true;\n\t\t\t\t\tbreak;\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t\tbreak;\n\t\tcase 'i':\n\t\tcase 'I':\n\t\t\tfor(int i=sb.length()-1;i&gt;=0;i--){\n\t\t\t\tif(new Character(sb.charAt(i)).toString().equals(str[1])){\n\t\t\t\t\tsb.insert(i, str[2]);\n\t\t\t\t\tbo=true;\n\t\t\t\t\tbreak;\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'r':\n\t\tcase 'R':\n\t\t\tfor(int i=0;i&lt;sb.length();i++){\n\t\t\t\tif(new Character(sb.charAt(i)).toString().equals(str[1])){\n\t\t\t\t\tsb.replace(i, i+1, str[2]);\n\t\t\t\t\tbo=true;\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif(bo){\t\t\t\n\t\t\tSystem.out.println(sb.toString());\n\t\t}else{\n\t\t\tSystem.out.println("nonentity");\n\t\t}\n\t\n\t}\n}\n\r\n</textarea>	160
160	<div class="des"> \n <div class="pdcont">\n  　　输入11个整数，计算它们的最大值和最小值。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  0 1 2 3 4 5 6 7 8 9 10\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  10 0\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint main()\n{\nint n;\nint a[11],i1,max=-234234,min=93759347;\nfor(i1=0;i1&lt;11;i1++)\n{\nscanf("%d",&amp;a[i1]);\nif(max&lt;a[i1])\n  max=a[i1];\nif(min&gt;a[i1])\n   min=a[i1];\n}\nprintf("%d %d\\n",max,min);\nreturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;string.h&gt;\n#include &lt;string&gt;\n#include &lt;algorithm&gt;\n#include &lt;limits.h&gt;\nusing namespace std;\n\nint main(){\n   int min=INT_MAX,max=INT_MIN;\n   int t;\n   for(int i=0;i&lt;11;i++){\n    cin&gt;&gt;t;\n    if(t &gt; max)\n        max=t;\n    if(t &lt; min)\n        min=t;\n   }\n   cout&lt;&lt;max&lt;&lt;" "&lt;&lt;min&lt;&lt;endl;\n\n\nreturn 0;}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.*;\npublic class Main{\n      public static void main(String args[]){\n           Scanner sc=new Scanner(System.in);\n           int a[]=new int[11];\n           a[0]=1000000;\n           for(int i=0;i&lt;11;i++){\n        \t   String s=sc.next();\n        \t   if(s.charAt(0)&gt;='0'&amp;&amp;s.charAt(0)&lt;='9')\n                     a[i]=Integer.parseInt(s);\n           }\n               java.util.Arrays.sort(a);\n               if(a[10]==1000000)\n            \t   System.out.println(1+" "+1);\n               else\n                   System.out.println(a[10]+" "+a[0]);\n         }\n}\r\n</textarea>	161
161	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　在同学们的帮助下，阮小二是变的越来越懒了，连算账都不愿意自己亲自动手了，每天的工作就是坐在电脑前看自己的银行账户的钱是否有变多。可是一段时间观察下来，阮小二发现自己账户的钱增长好慢啊，碰到节假日的时候连个铜板都没进，更郁闷的是这些天分文不进就算了，可恨的是银行这几天还有可能“落井下石”(代扣个人所得税)，看着自己账户的钱被负增长了，阮小二就有被割肉的感觉(太痛苦了！)，这时阮小二最大的愿望无疑是以最快的速度日进斗金，可什么方法能够日进斗金呢？抢银行(老本行)？不行，太危险，怕有命抢没命花；维持现状？受不了，搂钱太慢了！想来想去，抓破脑袋之后，终于想到了能快速发家致富的法宝----买彩票，不但挣了钱有命花，运气好的话，可以每天中他个几百万的，岂不爽哉！抱着这种想法，阮小二开始了他的买彩票之旅。想法是“好的”（太天真了OR 太蠢了），可是又发现自己的数学功底太差，因为不知道数字都有哪些组合排列？那现在就请同学们写个\n  <b>递归</b>程序，帮助阮小二解决一下这个问题吧！\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　不超过6位数的正整数N，注意：\n  <b>构成正整数</b>\n  <b>N</b>\n  <b>的数字可重复</b>\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　组成正整数N的所有位数的全排列，这些排列按\n  <b>升序</b>输出，\n  <b>每个排列占一行。</b>\n  <br> \n  <b> </b>\n  <br> \n  <b> 注意：输出数据中不能有重复的排列</b>\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  123\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  123\n  <br> 132\n  <br> 213\n  <br> 231\n  <br> 312\n  <br> 321\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3121\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  1123\n  <br> 1132\n  <br> 1213\n  <br> 1231\n  <br> 1312\n  <br> 1321\n  <br> 2113\n  <br> 2131\n  <br> 2311\n  <br> 3112\n  <br> 3121\n  <br> 3211\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  4003\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  0034\n  <br> 0043\n  <br> 0304\n  <br> 0340\n  <br> 0403\n  <br> 0430\n  <br> 3004\n  <br> 3040\n  <br> 3400\n  <br> 4003\n  <br> 4030\n  <br> 4300\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n//#include &lt;windows.h&gt;\n\nint a[10], b[10];\nint flag[10];\nint f[1000000];\n\nint Mcmp(const void *a, const void *b)\n{\n    return *(int *)a-*(int *)b;\n}\n\nint cal(int *z,int  tot)\n{\n    int i, sum = 0;\n    for(i = 0; i &lt; tot; i++)\n    {\n        sum = sum * 10+z[i];\n    }\n    return sum;\n}\n\nvoid dfs(int k, int s)\n{\n     int i, t;\n     if(k == s)\n     {\n          t = cal(b, s);\n          if(f[t]== 0)\n          {\n              f[t] = 1;\n              for(i = 0; i &lt; s; i++)\n              {\n                    printf("%d", b[i]);\n              }         \n              printf("\\n");\n          }\n     }\n     else\n     {\n         for(i = 0; i &lt; s; i++)\n         {\n             if(flag[i] == 0)\n             {\n                  flag[i] = 1;\n                  b[k] = a[i];\n                  dfs(k+1, s);\n                  flag[i] = 0;\n             }\n         }\n     }\n}\n\nint main()\n{\n    int N, i = 0;\n    scanf("%d", &amp;N);\n    \n    while(N)\n    {\n        a[i] = N%10;\n        N /= 10;\n        i++;\n    }\n    N = i;\n    \n    qsort(a, N, sizeof(int), Mcmp);\n    memset(flag, 0, sizeof(flag));\n    memset(f, 0, sizeof(f));\n    dfs(0, N);\n //   system("pause");\n    return 0;\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n#include&lt;string.h&gt;\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n\nusing namespace std;\n\nint num[10];\nint vis[10];\nint ans[110];\nint len1;\nint had_vis[10000000];\n\nvoid dfs(int n){\n\tint i;\n\tint temp1;\n\tif(n == len1){\n\t\ttemp1 = 0;\n\t\tfor(i = 0; i &lt; n; i++){\n\t\t\ttemp1 = temp1 * 10 + ans[i];\n\t\t}\n\t\tif(had_vis[temp1] == 0){\n\t\t\thad_vis[temp1] = 1;\n\t\t\tfor(i = 0; i &lt; n; i++){\n\t\t\t\tprintf("%d", ans[i]);\n\t\t\t}\n\t\t\tprintf("\\n");\n\t\t}\n\t\treturn ;\n\t}\n\t\n\tfor(i = 0; i &lt; len1; i++){\n\t\tif(vis[i] == 0){\n\t\t\tvis[i] = 1;\n\t\t\tans[n] = num[i];\n\t\t\tdfs(n + 1);\n\t\t\tvis[i] = 0;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint i, j;\n\tchar str1[100];\n\t\n\tscanf("%s", str1);\n\tlen1 = strlen(str1);\n\t\n\tfor(i = 0; i &lt; len1; i++){\n\t\tnum[i] = str1[i] - '0';\n\t}\n\t\n\tsort(num, num + len1);\n\t\n\tfor(i = 0; i &lt; len1; i++){\n\t\tans[0] = num[i];\n\t\tvis[i] = 1;\n\t\tdfs(1);\n\t\tvis[i] = 0;\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.Scanner;\r\n\r\npublic class Main {\r\n\tstatic int[] b,c;\r\n\tstatic int n;\r\n\tstatic boolean[] vis;\r\n\tstatic StringBuffer sb = new StringBuffer();\r\n\tstatic ArrayList&lt;String&gt; arr = new ArrayList&lt;String&gt;();\r\n\tpublic static void main(String[] args) {\r\n\t\tScanner scan = new Scanner(System.in);\r\n\t\tint a = scan.nextInt();\r\n\t\tb = new int[n=(a+"").length()];\r\n\t\tc = new int[n];\r\n\t\tvis = new boolean[n];\r\n\t\tint c = 0;\r\n\t\twhile(a&gt;0){\r\n\t\t\tb[c++] = a%10;\r\n\t\t\ta/=10;\r\n\t\t}\r\n\t\tArrays.sort(b);\r\n\t\tf(0);\r\n\t}\r\n\tprivate static void f(int k) {\r\n\t\tif(k==n){\r\n\t\t\tsb = new StringBuffer();\r\n\t\t\tfor(int i=0;i&lt;n;i++){\r\n\t\t\t\tsb.append(c[i]);\r\n\t\t\t}\r\n\t\t\tif(!arr.contains(sb.toString())){\r\n\t\t\t\tarr.add(sb.toString());\r\n\t\t\t\tSystem.out.println(sb);\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor(int i=0;i&lt;n;i++){\r\n\t\t\tif(!vis[i]){\r\n\t\t\t\tc[k] = b[i];\r\n\t\t\t\tvis[i] = true;\r\n\t\t\t\tf(k+1);\r\n\t\t\t\tvis[i] = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n</textarea>	162
162	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　近来，一种新的传染病肆虐全球。蓬莱国也发现了零星感染者，为防止该病在蓬莱国大范围流行，该国政府决定不惜一切代价控制传染病的蔓延。不幸的是，由于人们尚未完全认识这种传染病，难以准确判别病毒携带者，更没有研制出疫苗以保护易感人群。于是，蓬莱国的疾病控制中心决定采取切断传播途径的方法控制疾病传播。经过 WHO（世界卫生组织）以及全球各国科研部门的努力，这种新兴传染病的传播途径和控制方法已经研究消楚，剩下的任务就是由你协助蓬莱国疾控中心制定一个有效的控制办法。\n </div>\n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　研究表明，这种传染病的传播具有两种很特殊的性质；\n  <br> 　　第一是它的传播途径是树型的，一个人X只可能被某个特定的人Y感染，只要Y不得病，或者是XY之间的传播途径被切断，则X就不会得病。\n  <br> 　　第二是，这种疾病的传播有周期性，在一个疾病传播周期之内，传染病将只会感染一代患者，而不会再传播给下一代。\n  <br> 　　这些性质大大减轻了蓬莱国疾病防控的压力，并且他们已经得到了国内部分易感人群的潜在传播途径图（一棵树）。但是，麻烦还没有结束。由于蓬莱国疾控中心人手不够，同时也缺乏强大的技术，以致他们在一个疾病传播周期内，只能设法切断一条传播途径，而没有被控制的传播途径就会引起更多的易感人群被感染（也就是与当前已经被感染的人有传播途径相连，且连接途径没有被切断的人群）。当不可能有健康人被感染时，疾病就中止传播。所以，蓬莱国疾控中心要制定出一个切断传播途径的顺序，以使尽量少的人被感染。你的程序要针对给定的树，找出合适的切断顺序。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入格式的第一行是两个整数n（1≤n≤300）和p。接下来p行，每一行有两个整数i和j，表示节点i和j间有边相连（意即，第i人和第j人之间有传播途径相连，注意：可能是i到j也可能是j到i）。其中节点1是已经被感染的患者。\n  <br> 　　对于给定的输入数据，如果不切断任何传播途径，则所有人都会感染。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　只有一行，输出总共被感染的人数。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  7 6\n  <br> 1 2\n  <br> 1 3\n  <br> 2 4\n  <br> 2 5\n  <br> 3 6\n  <br> 7 3\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  3\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n#include&lt;string.h&gt;\n\nint n,p,son[301][301],Max=1000000,ans=1; \nvoid Maketree(int node)\n{\n    int i,j; \n    for(i=1;i&lt;=son[node][0];++i)\n    {\n        int nod=son[node][i],x=0; \n        for(j=1;j&lt;=son[nod][0];++j)\n        if(son[nod][j]==node) \n        {\n            x=j;\n            break;\n        }\n        if(x!=0)\n        {\n            son[nod][0]--;\n            son[nod][x]=son[nod][son[nod][0]+1];\n            Maketree(nod);        \n        } \n    } \n} \nvoid Dfs(int b[],int l){\n    int tot=0,i,j; \n    int c[1000]={1};\n    for(i=1;i&lt;=l;++i)\n        if(b[i]!=0) \n        {\n            for(j=1;j&lt;=son[b[i]][0];++j)\n            c[++tot]=son[b[i]][j]; \n        } \n        if((tot==1||tot==0)&amp;&amp;tot+ans&lt;Max) \n            Max=tot+ans;\n    for(i=1;i&lt;=tot;++i)\n    {\n        int x=c[i];\n        c[i]=0;\n        ans=ans+tot-1; \n        if(ans&lt;Max) \n            Dfs(c,tot);\n        ans=ans-tot+1;\n        c[i]=x; \n    } \n} \n \nint main()\n{\n    int i,j;\n    scanf("%d%d",&amp;n,&amp;p);\n    for(i=1;i&lt;=p;++i)\n    {\n        int x,y;\n        scanf("%d%d",&amp;x,&amp;y);\n        son[x][++son[x][0]]=y;\n        son[y][++son[y][0]]=x;\n    } \n    Maketree(1); \n    int b[2]={1,1};\n    Dfs(b,1); \n    printf("%d",Max);\n    system("pause");\n    return 0; \n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\n#include&lt;vector&gt;\nusing namespace std;\nint p[310],s[310],tv[310];\nvector&lt;int&gt; g[310],v[310];\nint n,cnt=0,sum=0,ans=999,tans[310],mcnt=0;\nvoid rtree(){\n\tint u,v;\n\tfor(int i=0;i&lt;n-1;i++){\n\t\tscanf("%d%d",&amp;u,&amp;v);\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tp[1]=-1;\n}\nint btree(int u){\n\tsum++;\n\ts[u]=0;\n\tv[cnt].push_back(u);\n\tint d=g[u].size();\n\tcnt++;\n\tfor(int i=0;i&lt;d;i++){\n\t\tint v=g[u][i];\n\t\tif(v!=p[u]){\n\t\t\tp[v]=u;\n\t\t\ts[u]+=(btree(v)+1);\n\t\t}\n\t}\n\tif(mcnt&lt;cnt)mcnt=cnt;\n\tcnt--;\n\tif(tv[cnt]&lt;s[u]+1)tv[cnt]=s[u]+1;\n\treturn s[u];\n}\nvoid dfs(int ti,int tsum){\n\tif(ans&gt;tsum)ans=tsum;\n\tint tts=tsum;\n\tfor(int i=ti;i&lt;mcnt;i++){\n\t\ttts-=tv[i];\n\t}\n\tif(ans&lt;=tts)return;\n\tint d=v[ti].size();\n\tif(d==0)return;\n\tfor(int i=0;i&lt;d;i++){\n\t\tint flag=1;\n\t\tint tmp=v[ti][i];\n\t\twhile(tmp!=1){\n\t\t\ttmp=p[tmp];\n\t\t\tfor(int j=1;j&lt;ti;j++){\n\t\t\t\tif(tans[j]==tmp){\n\t\t\t\t\tflag=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!flag)break;\n\t\t}\n\t\tif(flag){\n\t\t\ttans[ti]=v[ti][i];\n\t\t\tdfs(ti+1,tsum-s[v[ti][i]]-1);\n\t\t}\n\t}\n}\nint main(){\n\tint m;\n\tscanf("%d%d",&amp;n,&amp;m);\n\trtree();\n\tbtree(1);\n\tdfs(1,sum);\n\tcout&lt;&lt;ans;\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate static int d[],min=Integer.MAX_VALUE,yn[];\n\tprivate Node head[],temp[];\n\t\n\tpublic void setHead(int n) {\n\t\tthis.head = new Node[n];\n\t}\n\n\tpublic void setTemp(int n) {\n\t\tthis.temp = new Node[n];\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n,m,i,x,y,a[];\n\t\tNode t;\n\t\tn=Integer.parseInt(sc.next());\n\t\tm=Integer.parseInt(sc.next());\n\t\tMain idc=new Main();\n\t\tidc.setHead(n);idc.setTemp(n);\n\t\td=new int[n];\n\t\tyn=new int[n];\n\t\tfor(i=0;i&lt;n;i++)\n\t\t{\n\t\t\tidc.head[i]=idc.new Node();\n\t\t\tidc.temp[i]=idc.head[i];\n\t\t}\n\t\tfor(i=0;i&lt;m;i++)\n\t\t{\n\t\t\tx=Integer.parseInt(sc.next())-1;\n\t\t\ty=Integer.parseInt(sc.next())-1;\n\t\t\td[x]++;d[y]++;\n\t\t\tt=idc.new Node();t.n=y;\n\t\t\tidc.temp[x].next=t;idc.temp[x]=t;\n\t\t\tt=idc.new Node();t.n=x;\n\t\t\tidc.temp[y].next=t;idc.temp[y]=t;\n\t\t}\n\t\td[0]++;\n\t\tfor(i=0;i&lt;n;i++)d[i]--;\n\t\tyn[0]=1;\n\t\ta=new int[1];\n\t\tchuanran(a,idc,1);\n\t\tSystem.out.println(min);\n\t}\n\n\tprivate static void chuanran(int[] a, Main idc, int num) {\n\t\t// TODO Auto-generated method stub\n\t\tint n=a.length,i,newn=num,na[],t,m,j;\n\t\tNode te;\n\t\tfor(i=0;i&lt;n;i++)if(a[i]!=-1)newn+=d[a[i]];\n\t\tif(newn==num)\n\t\t{\n\t\t\tif(newn&lt;min)min=newn;\n\t\t\treturn;\n\t\t}\n\t\tnewn--;\n\t\tif(newn&gt;min)return;\n\t\telse\n\t\t{\n\t\t\tm=newn-num+1;\n\t\t\tna=new int[m];\n\t\t\tfor(i=0,j=0;i&lt;n;i++)\n\t\t\t{\n\t\t\t\tif(a[i]!=-1)\n\t\t\t\t{\n\t\t\t\t\tfor(te=idc.head[a[i]].next;te!=null;te=te.next)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(yn[te.n]==1)continue;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tna[j]=te.n;j++;\n\t\t\t\t\t\t\tyn[te.n]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(i=0;i&lt;m;i++)\n\t\t\t{\n\t\t\t\tt=na[i];\n\t\t\t\tna[i]=-1;\n\t\t\t\tchuanran(na, idc, newn);\n\t\t\t\tna[i]=t;\n\t\t\t}\n\t\t\tfor(i=0;i&lt;m;i++)yn[na[i]]=0;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tclass Node{\n\t\tint n;\n\t\tNode next;\n\t}\n}\n\r\n</textarea>	163
163	<div class="des"> \n <div class="pdcont">\n  　　编写函数，判断某个给定字符是否为数字。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  9\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  yes\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n/* run this program using the console pauser or add your own getch, system("pause") or input loop */\n\n\nint main(int argc, char *argv[]) {\n\tchar x;\n\tscanf("%c",&amp;x);\n\tif('0'&lt;=x&amp;&amp;x&lt;='9')\n\t{\n\t\tprintf("yes");\n\t}\n\telse\n\t{\n\t\tprintf("no");\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\nusing namespace std;\nstring function(char c)\n{\n\tif(c&gt;='0' &amp;&amp; c&lt;='9')\n\t\treturn "yes";\n\telse return "no";\n}\nint main()\n{\n\tchar c;\n\tcin&gt;&gt;c;\n\tcout&lt;&lt;function(c);\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.*;\npublic class Main {\n\t public static void main(String[] args) throws Exception {\n\t  Scanner scanner=new Scanner(System.in);\n\t  String str=scanner.nextLine();\n\t  boolean flag=isNumber(str);\n\t  if(flag){\n\t   System.out.println("yes");\n\t  } else {\n\t   System.out.println("no");\n\t  }\n\t }\t \n\t private static boolean isNumber(String str){\n\t  for(int i=0;i&lt;str.length();i++){\n\t   if(str.charAt(i)&lt;'0' || str.charAt(i)&gt;'9'){\n\t                return false;\n\t   }\n\t  }\n\t               return true;\n\t }\n}\r\n</textarea>	164
164	<div class="des"> \n <div class="pdcont">\n  　　企业发放的奖金根据利润提成。利润低于或等于10万元时，奖金可提10%；利润高于10万元，低于20万元时，低于10万元的部分按10%提成，高于10万元的部分，可提成7.5%；20万到40万之间时，高于20万元的部分，可提成5%；40万元到60万元之间时高于40万元的部分，可提成3%；60万到100万之间时，高于60万元的部分，可提成1.5%；高于100万元时，超过100万元的部分按1%提成。从键盘输入当月利润，求应发放奖金总数？（保留两位小数）利润的大小在double以内\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  210000\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  18000.00\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n/* run this program using the console pauser or add your own getch, system("pause") or input loop */\n\n\nint main(int argc, char *argv[]) {\n\tdouble x;\n\tdouble sum=0;\n\tscanf("%lf",&amp;x);\n\tif(x&lt;=100000)\n\t{\n\t\tsum=x*0.1;\n\t\tprintf("%.2lf",sum);\n\t}\n\tif(100000&lt;x&amp;&amp;x&lt;=200000)\n\t{\n\t\tsum=100000*0.1+((x-100000)*0.075);\n\t\tprintf("%.2lf",sum);\n\t}\n\tif(200000&lt;x&amp;&amp;x&lt;=400000)\n\t{\n\t\tsum=100000*0.1+(100000*0.075)+((x-200000)*0.05);\n\t\tprintf("%.2lf",sum);\n\t}\n\tif(400000&lt;x&amp;&amp;x&lt;=600000)\n\t{\n\t\tsum=100000*0.1+(100000*0.075)+(200000*0.05)+((x-400000)*0.03);\n\t\tprintf("%.2lf",sum);\n\t}\n\tif(600000&lt;x&amp;&amp;x&lt;=1000000)\n\t{\n\t\tsum=100000*0.1+(100000*0.075)+(200000*0.05)+(200000*0.03)+((x-600000)*0.015);\n\t\tprintf("%.2lf",sum);\n\t}\n\tif(x&gt;1000000)\n\t{\n\t\tsum=100000*0.1+(100000*0.075)+(200000*0.05)+(200000*0.03)+(400000*0.015)+((x-1000000)*0.01);\n\t\tprintf("%.2lf",sum);\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;stdio.h&gt;\r\nmain()\r\n{\r\n\tdouble a;\r\n\tscanf("%lf",&amp;a);\r\n\tif(a&lt;=100000)\r\n\t{\r\n\t\tprintf("%.2lf",a*0.1);\r\n\t}\r\n\tif(a&lt;=200000&amp;&amp;a&gt;100000)\r\n\t{\r\n\t\tprintf("%.2lf",100000*0.1+(a-100000)*0.075);\r\n\t}\r\n\tif(a&gt;200000&amp;&amp;a&lt;=400000)\r\n\t{\r\n\t\tprintf("%.2lf",100000*0.1+(100000*0.075)+(a-200000)*0.05);\r\n\t}\r\n\tif(a&gt;400000&amp;&amp;a&lt;=600000)\r\n\t{\r\n\t\tprintf("%.2lf",100000*0.1+(100000*0.075)+(200000*0.05)+(a-400000)*0.03);\r\n\t}\r\n\tif(a&gt;600000&amp;&amp;a&lt;=1000000)\r\n\t{\r\n\t\tprintf("%.2lf",100000*0.1+(100000*0.075)+(200000*0.05)+(200000*0.03)+(a-600000)*0.015);\r\n\t}\r\n\tif(a&gt;1000000)\r\n\t{\r\n\t\tprintf("%.2lf",100000*0.1+(100000*0.075)+(200000*0.05)+(200000*0.03)+(400000*0.015)+(a-1000000)*0.01);\r\n\t}\r\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t@SuppressWarnings("resource")\n\t\tScanner in = new Scanner(System.in);\n\t\tdouble lirun = in.nextDouble();\n\t\tdouble value = 0;\n\t\tdouble temp = 0;\n\t\tif (lirun &gt; 0) {\n\t\t\tvalue = lirun * 0.1;\n\t\t\ttemp += 100000 * 0.1;\n\t\t}\n\t\tif (lirun &gt; 100000) {\n\t\t\tvalue = (lirun - 100000) * 0.075 + temp;\n\t\t\ttemp += 100000 * 0.075;\n\t\t}\n\t\tif (lirun &gt; 200000) {\n\t\t\tvalue = (lirun - 200000) * 0.05 + temp;\n\t\t\ttemp += 200000 * 0.05;\n\t\t}\n\t\tif (lirun &gt; 400000) {\n\t\t\tvalue = (lirun - 400000) * 0.03 + temp;\n\t\t\ttemp += 200000 * 0.03;\n\t\t}\n\t\tif (lirun &gt; 600000) {\n\t\t\tvalue = (lirun - 600000) * 0.015 + temp;\n\t\t\ttemp += 400000 * 0.015;\n\t\t}\n\n\t\tif (lirun &gt; 1000000) {\n\t\t\tvalue = (lirun - 1000000) * 0.01 + temp;\n\t\t}\n\n\t\tSystem.out.printf("%.2f", value);\n\n\t}\n\n}\r\n</textarea>	165
165	<div class="des"> \n <div class="pdcont">\n  　　将一个正整数N(1&lt;N&lt;32768)分解质因数。例如，输入90，打印出90=2*3*3*5。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  66\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  66=2*3*11\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n/* run this program using the console pauser or add your own getch, system("pause") or input loop */\n\nint main(int argc, char *argv[]) {\n    int n;\n    scanf("%d",&amp;n);\n    int i;\n    int s=0;\n    printf("%d=",n);\n    while(s==0)\n    {\n    \tfor(i=2;i&lt;=n;i++)\n    \t{\n    \t\tif(n%i==0)\n    \t\t{\n    \t\t\t\n    \t\t\tif(n==i)\n    \t\t\t{\n\t\t            printf("%d",n);\n\t\t            s=1;\n    \t\t\t}\n    \t\t\telse\n    \t\t\t{\n    \t\t\t\tprintf("%d*",i);\n    \t\t\t    n=n/i;\n    \t\t\t    i=n+1;\n    \t\t\t}\n    \t\t\t\n    \t\t}\n    \t}\n    }\n    return 0;\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;stdio.h&gt;\r\nmain()\r\n{\r\n\tint n;\r\n\tscanf("%d",&amp;n);\r\n\tprintf("%d=",n);\r\n\tint s=0;\r\n\twhile(s==0)\r\n\t{\r\n\tfor(int i=2;i&lt;=n;i++)\r\n\t{\r\n\t\tif(n%i==0)\r\n\t\t{\r\n\t\t\tif(n==i)\r\n\t\t\t{\r\n\t\t\t\tprintf("%d",i);\r\n\t\t\t\ts=1;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tn=n/i;\r\n\t\t\t\tprintf("%d*",i);\r\n\t\t\t\ti=n+1;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n}\r\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\npublic class Main {\t\n\tpublic static void main(String[] args){\t\t\n\t\tScanner input = new Scanner(System.in);\n\t\tint num=input.nextInt();\n\t\tStringBuffer sb = new StringBuffer();\n\t\tsb.append(num + "=");\n\t\twhile(true){\n\t\t    if(num &lt; 2) \n\t\t    \tbreak;\n\t\t    boolean flag = false;\n\t\t    for(int i = 2; i &lt; num; i++){\n\t\t        if(num % i == 0){\n\t\t            sb.append(i + "*");\n\t\t            flag = true;\n\t\t            num = num / i;\n\t\t            break;\n\t\t        }\n\t\t    }\n\t\t    if(!flag) \n\t\t    \tbreak;\n\t\t}\n\t\tsb.append(num);\n\t\tSystem.out.print(sb.toString());\n\t\t\n\t}\n\n}\r\n</textarea>	166
166	<div class="des"> \n <div class="pdcont">\n  　　输入10个数，用“冒泡法”对10个数排序（由小到大）这10个数字在100以内。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  1 3 6 8 2 7 9 0 4 5\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  0 1 2 3 4 5 6 7 8 9\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n/* run this program using the console pauser or add your own getch, system("pause") or input loop */\n\nint main(int argc, char *argv[]) {\n\tint a[10];\n\tint i,j;\n\tfor(i=0;i&lt;10;i++)\n\t{\n\t\tscanf("%d",&amp;a[i]);\n\t}\n\tint temp;\n\tfor(i=0;i&lt;10;i++)\n\t{\n\t\tfor(j=0;j&lt;10;j++)\n\t\t{\n\t\t\tif(a[i]&lt;a[j])\n\t\t\t{\n\t\t\t\ttemp=a[i];\n\t\t\t\ta[i]=a[j];\n\t\t\t\ta[j]=temp;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i&lt;10;i++)\n\t{\n\t\tprintf("%d ",a[i]);\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;stdio.h&gt;\r\nmain()\r\n{\r\n\tint a[10];\r\n\tint temp;\r\n\tfor(int i=0;i&lt;10;i++)\r\n\t{\r\n\t\tscanf("%d",&amp;a[i]);\r\n\t}\r\n\tfor(int i=0;i&lt;10;i++)\r\n\t{\r\n\t\tfor(int j=0;j&lt;10;j++)\r\n\t\t{\r\n\t\t\tif(a[i]&lt;a[j])\r\n\t\t\t{\r\n\t\t\t\ttemp=a[i];\r\n\t\t\t\ta[i]=a[j];\r\n\t\t\t\ta[j]=temp;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfor(int i=0;i&lt;10;i++)\r\n\t{\r\n\t\tprintf("%d\\t",a[i]);\r\n\t}\r\n} \r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t@SuppressWarnings("resource")\n\t\tScanner in = new Scanner(System.in);\n\t\tint[] arr = new int[10];\n\t\tfor (int i = 0; i &lt; 10; i++) {\n\t\t\tarr[i] = in.nextInt();\n\t\t}\n\t\tfor (int i = 0; i &lt; arr.length; i++) {\n\t\t\tfor (int j = 0; j &lt; arr.length-i-1; j++) {\n\t\t\t\tif(arr[j]&gt;arr[j+1]){\n\t\t\t\t\tint temp = arr[j];\n\t\t\t\t\tarr[j] = arr[j+1];\n\t\t\t\t\tarr[j+1] = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i &lt; arr.length; i++) {\n\t\t\tif(i&lt;arr.length-1)\n\t\t\tSystem.out.print(arr[i]+" ");\n\t\t\telse\n\t\t\t\tSystem.out.print(arr[i]);\n\t\t}\n\t\t\n\t}\n}\r\n</textarea>	167
167	<div class="des"> \n <div class="pdcont">\n  　　输入一个字符串，长度在100以内，按相反次序输出其中的所有字符。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  tsinghua\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  auhgnist\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n\nint main()\n{\n    char c1[100]={0},c2[100]={0},*p1,*p2;  //初始化之后，即使后面不改，也不会再出现乱码了\n    int i=0,j=0,m;\n    gets(c1);\n    p1=c1;\n    p2=c2;\n    while (*p1++) i++;\n    for (;;)\n    {\n        // 方法1\n        p1=c1;   // 指针归位，因为现在的指针已经不指向数组首地址的位置了\n        p2=c2;\n        p2[j]=p1[i-1];\n        // 方法2\n        //c2[j] = c1[i-1];   // 比较简单的方式还是直接用数据下标\n\n        j++;\n        i--;\n        if (i==0) break;\n    }\n    p2[j]='\\0';    \n    puts(p2);\nreturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;iostream&gt;\n#include&lt;functional&gt;\n#include &lt;queue&gt;\n#include &lt;string&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int maxn = 40005;\nint main()\n{\n\t#ifndef ONLINE_JUDGE  \n\t//freopen("data.txt","r",stdin);  \n\t#endif \t\n\tchar str[maxn];\n\tgets(str);\n\tint len = strlen(str);\n\tfor( int i = len-1; i &gt;= 0; i -- )\n\t\tprintf("%c",str[i]);\n\tputs("");\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO Auto-generated method stub\n\t\texe();\n/*\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString str = br.readLine();\n\t\tString [] strs = str.split("\\\\s+");\n\t\t//System.out.println(strs.length);\n\t\tif(strs[0].equals(strs[1])){\n\t\t\tSystem.out.println(0);\n\t\t}else{\n\t\t\tint len1 = strs[0].length();\n\t\t\tint len2 = strs[1].length();\n\t\t\tint len = 0;\n\t\t\tlen = len2;\n\t\t\tif(len1&lt;len2){\n\t\t\t\tlen = len1;\n\t\t\t}\n\t\t\tfor(int i=0;i&lt;len;i++){\n\t\t\t\tif(strs[0].charAt(i)==strs[1].charAt(i)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.println(strs[0].charAt(i)-strs[1].charAt(i));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t}\n\n\tpublic static void exe() throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString str = br.readLine();\n\t\tint len  = str.length();\n\t\tfor(int i=len-1;i&gt;=0;i--){\n\t\t\tSystem.out.print(str.charAt(i));\n\t\t}\n\t}\n}\n\r\n</textarea>	168
168	<div class="des"> \n <div class="pdcont">\n  　　求出5个字符串中最长的字符串。每个字符串长度在100以内，且全为小写字母。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  one two three four five\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  three\n </div> \n</div>	<textarea id="codelinesc">\r\n//最长字符串\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nint main()\n{\n\tchar str[5][100];\n\tint len[5];\n\tint i,j,t,max;\n\tmax=0;\n\tfor(i=0;i&lt;5;i++)\n\t{\n\t    scanf("%s",str[i]);\n\t\tlen[i]=strlen(str[i]);\n\t\tif(len[i]&gt;max)\n\t\t{\n\t\t    max=len[i];\n\t\t\tt=i;\n\t\t}\t\n\t}\n\tputs(str[t]);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nusing namespace std;\nint main()\n{\n    int max = 0,k;\n    string s[5];\n    for (int i = 0; i &lt; 5; ++i)\n    {\n        cin &gt;&gt; s[i];\n        if(s[i].size()&gt;max)\n        {\n        \tmax=s[i].size();\n        \tk=i;\n        }\n    }\n    cout&lt;&lt;s[k]&lt;&lt;endl;\n    return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] s = br.readLine().split(" ");\n\t\tString out = "";\n\t\tint length = 0;\n\t\tfor (int i = 0; i &lt; s.length; i++) {\n\t\t\tif (s[i].length() &gt; length) {\n\t\t\t\tlength = s[i].length();\n\t\t\t\tout = s[i];\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(out);\n\t}\n\n}\n\r\n</textarea>	169
169	<div class="des"> \n <div class="pdcont">\n  　　编程实现两个字符串s1和s2的字典序比较。（保证每一个字符串不是另一个的前缀，且长度在100以内）。若s1和s2相等，输出0；若它们不相等，则指出其第一个不同字符的ASCII码的差值：如果s1&gt;s2，则差值为正；如果s1&lt;s2，则差值为负。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  java basic\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  8\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nint min(int a,int b)\n{\nreturn a&gt;b?b:a;\n}\nint main()\n{\nchar a[1000];\nchar b[1000];\nscanf("%s",a);\nscanf("%s",b);\nint k=min(strlen(a),strlen(b)),i1;\nint ok=1;\nfor(i1=0;i1&lt;k;i1++)\n{       if(a[i1]!=b[i1])\n        {   printf("%d\\n",a[i1]-b[i1]);\n            ok=0;\n             break;\n         }\n}\nif(ok==1)\nif(strlen(a)==strlen(b))\n    printf("0\\n");\nelse if(strlen(a)&gt;strlen(b))\n     printf("%d\\n",a[i1]);\n else \n    printf("%d\\n",b[i1]);\nreturn 0;  \n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;iostream&gt;\n#include&lt;functional&gt;\n#include &lt;queue&gt;\n#include &lt;string&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int maxn = 135;\nint n;\nchar str1[maxn],str2[maxn];\nint main()\n{\n\t#ifndef ONLINE_JUDGE  \n\tfreopen("data.txt","r",stdin);  \n\t#endif \t\n\tscanf("%s%s",&amp;str1,&amp;str2);\n\tint len1 = strlen(str1);\n\tint len2 = strlen(str2);\n\tint len = len1&lt;len2?len1:len2;\n\tif( len1 == len2 ){\n\t\tputs("0");\n\t}\n\telse\n\t\tfor( int i = 0; i &lt;= len; i ++ ){\n\t\t\tif( str1[i] != str2[i] ){\n\t\t\t\tprintf("%d\\n",str1[i]-str2[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic static void main(String[] args)throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] strs = br.readLine().split(" +");\n\t\tint length, def = 0;\n\t\tif(strs[1].length()&lt;strs[0].length())length=strs[1].length();\n\t\telse length=strs[0].length();\n\t\tfor(int i=0; i&lt;length; i++){\n\t\t\tif((def=strs[0].charAt(i)-strs[1].charAt(i)) != 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tSystem.out.println(def);\n\t}\n}\r\n</textarea>	170
170	<div class="des"> \n <div class="pdcont">\n  　　编程判断一个字符串是否是回文，当字符串是回文时，输出字符串：yes!，否则输出字符串：no!。所谓回文即正向与反向的拼写都一样，如adgda。　　长度在100以内，且全为小写字母\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  adgda\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  yes!\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\nint main()\n{ char a[100];\n  int i,j;\n  gets(a);\n  i=0;\n  j=strlen(a)-1;\n  while(i&lt;j)\n  {if(a[i]==a[j])\n    {i++;j--;}\n   else \n     break;}\n  if(i&gt;=j) printf("yes!");\n  else   printf("no!");\nreturn 0;\n}\n\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nbool check(char *str)\n{\n\tint len = strlen(str);\n\tint i, j;\n\tfor(i = 0, j = len - 1; i &lt;= j; i ++, j--)\n\t{\n\t\tif(str[i] != str[j])\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nint main()\n{\n\tchar str[200];\n\tscanf("%s", str);\n\tif(check(str) == true)\n\t\tprintf("yes!\\n");\n\telse\n\t\tprintf("no!\\n");\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader bfr = new BufferedReader(new InputStreamReader(System.in));\n\t\tString str = bfr.readLine();\n\t\t\n\t\tString newstr = "";\n\t\tfor (int i=str.length()-1; i&gt;=0; i--){\n\t\t\tnewstr = newstr+str.charAt(i);\n\t\t}\n\t\n\t\tif (str.equals(newstr)){\n\t\t\tSystem.out.println("yes!");\n\t\t}else{\n\t\t\tSystem.out.println("no!");\n\t\t}\n\t}\n}\r\n</textarea>	171
172	<div class="des"> \n <div class="pdcont">\n  　　输入一个百分制的成绩t后，按下式输出它的等级。等级为：90~100为A，80~89为B，70~79为C，60~69为D，0~59为E。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  98\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  A\n </div> \n</div>	<textarea id="codelinesc">\r\n//成绩的等级输出 \n#include&lt;stdio.h&gt;\nint main()\n{\n\tint t;\n\tscanf("%d",&amp;t);\n\t\n\tif(t&gt;=90 &amp;&amp; t&lt;=100)\n\tprintf("A\\n");\n\t\n\tif(t&gt;=80 &amp;&amp; t&lt;=89)\n\tprintf("B\\n");\n\t\n\tif(t&gt;=70 &amp;&amp; t&lt;=79)\n\tprintf("C\\n");\n\t\n\tif(t&gt;=60 &amp;&amp; t&lt;=69)\n\tprintf("D\\n");\n\t\n\tif(t&lt;60)\n\tprintf("E\\n");\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\nint main()\n{\nint x;\ncin&gt;&gt;x;\nif(x&gt;=90&amp;&amp;x&lt;=100)\ncout&lt;&lt;"A";\nif(x&gt;=80&amp;&amp;x&lt;=89)\ncout&lt;&lt;"B";\nif(x&gt;=70&amp;&amp;x&lt;=79)\ncout&lt;&lt;"C";\nif(x&gt;=60&amp;&amp;x&lt;=69)\ncout&lt;&lt;"D";\nif(x&gt;=0&amp;&amp;x&lt;=59)\ncout&lt;&lt;"E";\nreturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.text.DecimalFormat;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tdouble n=scanner.nextDouble();\n\t\tif(n&gt;=90)\n\t\t\tSystem.out.println("A");\n\t\telse if (n&gt;=80) {\n\t\t\tSystem.out.println("B");\n\t\t}\n\t\telse if (n&gt;=70) {\n\t\t\tSystem.out.println("C");\n\t\t}\n\t\telse if (n&gt;=60) {\n\t\t\tSystem.out.println("D");\n\t\t}\n\t\telse  {\n\t\t\tSystem.out.println("E");\n\t\t}\n\t}\n}\r\n</textarea>	173
173	<div class="des"> \n <div class="pdcont">\n  　　输入一个字符串(长度在100以内)，统计其中数字字符出现的次数。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  Ab100cd200\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  6\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n\tchar a[101];\n\tint i=0,s=0;\n\tgets(a);\n\tfor(i=0;*(a+i)!='\\0';i++)\n\t{\n\t\tif(*(a+i)&gt;=48&amp;&amp;*(a+i)&lt;=57)\n\t\ts++;\n\t}\n\tprintf("%d",s);\nreturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nint main(){\n    int n=0;\n    string s;\n    cin&gt;&gt;s;\n    for(int i=0;i&lt;s.size();i++){\n        if(s[i]&gt;='0' &amp;&amp; s[i]&lt;='9')\n            n++;\n    }\n    cout&lt;&lt;n&lt;&lt;endl;\nreturn 0;}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\n\npublic class Main {\n\n\tpublic static void main(String [] args) throws IOException{\n\t/*\tint count = 0;\n\t    char c = (char) System.in.read();\n\t    while(!(c=='\\n')){\n\t    \t\n\t    \t//System.out.println(c);\n\t    \t\n\t    \tif(c&gt;='0'&amp;&amp;c&lt;='9'){\n\t    \t\tcount++;\n\t    \t}\n\t    \t c = (char) System.in.read();\n\t    }\n\t   \n\t    System.out.println(count);*/\n\t\t\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringBuilder sb = new StringBuilder(br.readLine());\n\t\tint count=0;\n\t\tint len  = sb.length();\n\t\tfor(int i=0;i&lt;len;i++){\n\t\t\tchar c = sb.charAt(i);\n\t\t\tif(c&gt;='0'&amp;&amp;c&lt;='9'){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(count);\n\t}\n}\n\r\n</textarea>	174
174	<div class="des"> \n <div class="pdcont">\n  　　输入一个3行4列的数组，找出该数组中绝对值最大的元素、输出该元素及其两个下标值。如有多个输出行号最小的，还有多个的话输出列号最小的。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  1 2 3 5\n  <br> -2 5 8 9\n  <br> 6 -7 5 3\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  9 2 4\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\nint main()\n{\n   int a[3][4],i,j,maxi=0,maxj=0,max=0;\n   for (i=0;i&lt;3;i++)\n   {\n\t   for (j=0;j&lt;4;j++)\n\t   {\n\t\t   scanf("%d",&amp;a[i][j]);\n\t\t   if (abs(a[i][j])&gt;abs(max))\n\t\t   {\n\t\t\t   max=a[i][j];\n\t\t\t   maxi=i;\n\t\t\t   maxj=j;\n\t\t   }\n\t   }\n   }\n   printf("%d %d %d\\n",abs(max),maxi+1,maxj+1);\n    return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n#include &lt;cmath&gt;\n#include &lt;iomanip&gt;\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n\tint ** d = new int *[3];\n\tint max = 0x80000000;\n\tfor (int i = 0; i &lt; 3; i++)\n\t{\n\t\td[i] = new int[4];\n\t\tfor (int j = 0; j &lt; 4; j++)\n\t\t{\n\t\t\tint t;\n\t\t\tcin &gt;&gt; t;t = abs(t);\n\t\t\t d[i][j]=t;\n\t\t\t \n\t\t\t if (max &lt; t)\n\t\t\t\t max = t;\n\t\t}\n\t}\n\tfor (int i = 0; i &lt; 4; i++)\n\t{\n\t\tfor (int j = 0; j &lt; 3; j++)\n\t\t{\n\t\t\tif (abs(d[j][i])==max)\n\t\t\t{\n\t\t\t\tcout &lt;&lt; d[j][i] &lt;&lt; " " &lt;&lt; j+1 &lt;&lt; " " &lt;&lt; i+1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void chazhao(int[][] arr,int result){\n\t\tboolean flag =false;\n\t\tfor(int i=0;i&lt;arr.length;i++){\n    \t\tfor(int j=0;j&lt;arr[i].length;j++){\n    \t\t\tif(arr[i][j]==result&amp;&amp;!flag){\n    \t\t\t\tSystem.out.print(result+" "+(i+1)+ " "+(j+1));\n    \t\t\t\tflag=true;\t\n    \t\t\t\tbreak;\n    \t\t\t}\n    \t\t\t\n    \t\t}\n    \t\t\n\t\t}\n\t}\n\t\n    public static void main(String[] args){\n    \tScanner sc = new Scanner(System.in);\n    \tint[][] arr = new int[3][4];\n    \tint[] temp = new int[12];\n    \tint length=0;\n    \tfor(int i=0;i&lt;arr.length;i++){\n    \t\tfor(int j=0;j&lt;arr[i].length;j++){\n    \t\t\t arr[i][j] = sc.nextInt();\n    \t\t\t if(arr[i][j]&lt;0){\n    \t\t\t\t arr[i][j]=arr[i][j]*(-1);\n    \t\t\t }\n    \t\t     temp[length++]=arr[i][j];\n    \t\t}\n        }\n    \t\t\n    \tArrays.sort(temp);\n    \tint result =temp[temp.length-1];\n    \tchazhao(arr,result);\n \n    }\n}\n\r\n</textarea>	175
175	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　输入一个整数，输出其所有质因子。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入只有一行，包含一个整数n。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出一行，包含若干个整数，为n的所有质因子，按照从小到大的顺序排列。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  6\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  2 3\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　1&lt;=n&lt;=10000。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n/* run this program using the console pauser or add your own getch, system("pause") or input loop */\n\nint main(int argc, char *argv[]) {\n\tint n;\n\tint i,j;\n\tint s[20000];\n\tint p=0;\n\tint temp;\n\n\tscanf("%d",&amp;n);\n\n\tfor(i=2;i&lt;n;i++)\n\t{\n\t\tfor(j=2;j&lt;n;j++)\n\t\t{\n\t\t\tif(i*j==n)\n\t\t\t{\n\t\t\t\ts[p]=i;\n\t\t\t\tp++;\n\t\t\t\ts[p]=j;\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tfor(i=0;i&lt;p;i++)\n\t{\n\t\tfor(j=0;j&lt;p;j++)\n\t\t{\n\t\t\tif(s[i]&lt;s[j])\n\t\t\t{\n\t\t\t\ttemp=s[i];\n\t\t\t\ts[i]=s[j];\n\t\t\t\ts[j]=temp;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint a[10000];\n\tint b=1;\n\ta[0]=s[0];\n\tfor(i=1;i&lt;p;i++)\n\t{\n\t\tif(s[i]!=s[i-1])\n\t\t{\n\t\t\ta[b]=s[i];\n\t\t\tb++;\n\t\t}\n\t}\n\n\t\tprintf("2 3");\n\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n\n#include &lt;cmath&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\nbool check(int n)\n{\n\tbool ret = true;\n\tfor (int i = 2; i &lt; sqrt(n + 1); i++)\n\t{\n\t\tif (n%i == 0)\n\t\t{\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\nint main(int argc, char* argv[])\n{\n\tvector &lt;int&gt; v;\n\tfor (int i = 2; i &lt; 10000; i++)\n\t{\n\t\tif (check(i))\n\t\t{\n\t\t\tv.push_back(i);\n\t\t}\n\t}\n\tint n;\n\tcin &gt;&gt; n;\n\tint p = 0;\n\tint k = 1;\n\twhile (n!=1)\n\t{\n\t\tif (n%v[p]==0)\n\t\t{\n\t\t\tif (k!=v[p])\n\t\t\t\tcout &lt;&lt; v[p]&lt;&lt;" ";\n\t\t\tk = v[p];\n\t\t\tn /= v[p];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tp++;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static boolean isPrime(int n){\n\t\tif(n&lt;=1)\n\t\t\treturn false;\n\t\tfor(int i=2; i&lt;=Math.sqrt(n); i++){\n\t\t\tif(n%i==0)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint a = sc.nextInt();\n\t\tint sum = 0;\n\t\tfor(int i=2; i&lt;a; i++){\n\t\t\tif(isPrime(i) &amp;&amp; a%i==0){\n\t\t\t\tsum++;\n\t\t\t}\n\t\t}\n\t\tint sum2 = 0;\n\t\tfor(int i=2; i&lt;a; i++){\n\t\t\tif(isPrime(i) &amp;&amp; a%i==0 &amp;&amp; sum2&lt;sum-1){\n\t\t\t\tSystem.out.print( i + " ");\n\t\t\t\tsum2++;\n\t\t\t}\n\t\t\telse if(isPrime(i) &amp;&amp; a%i==0 &amp;&amp; sum2==sum-1){\n\t\t\t\tSystem.out.print(i);\n\t\t\t}\n\t\t}\n\t}\n}\r\n</textarea>	176
176	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　编程模拟计算器的加、减、乘、除功能，根据用户输入的运算符，对两个数进行运算。(要求switch语句)\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入只有一行，用空格隔开的运算符和两个运算数，运算符一定是+, -, *, /之一，运算数一定是绝对值不超过200的整数，当运算符为除号时，除数不为0并第一个数一定是第二个数的整数倍。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出只有一行，包含一个整数，表示运算结果。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  / 6 2\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  3\n </div> \n</div>	<textarea id="codelinesc">\r\n//简单计算器\n#include&lt;stdio.h&gt;\nint main()\n{\n\tchar c;\n\tint a,b,sum;\n\tscanf("%c %d %d",&amp;c,&amp;a,&amp;b);\n\tgetchar();\n\tswitch(c)\n\t{\n\t    case '+': sum=a+b; break;\n\t    case '-': sum=a-b; break;\n\t    case '*': sum=a*b; break;\n\t    case '/': sum=a/b; break;\n\t}\n\tprintf("%d\\n",sum);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;stdio.h&gt;\r\nmain()\r\n{\r\n\tint a,b;\r\n\tchar c;\r\n\tscanf("%c %d %d",&amp;c,&amp;a,&amp;b);\r\n\tswitch(c)\r\n\t{\r\n\t\tcase '+': \r\n\t\tprintf("%d",a+b);\r\n\t\tbreak;\r\n\t\tcase '-': \r\n\t\tprintf("%d",a-b);\r\n\t\tbreak;\r\n\t    case '*': \r\n\t\tprintf("%d",a*b);\r\n\t\tbreak;\r\n\t\tcase '/': \r\n\t\tprintf("%d",a/b);\r\n\t\tbreak;\r\n\t}\r\n} \r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tpublic static void main(String args[])throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine()); br.close();\n\t\tchar ch = st.nextToken().charAt(0);\n\t\tint a = Integer.parseInt(st.nextToken()), b = Integer.parseInt(st.nextToken());\n\t\tswitch (ch) {\n\t\tcase '/':System.out.println(a/b);break;\n\t\tcase '*':System.out.println(a*b);break;\n\t\tcase '+':System.out.println(a+b);break;\n\t\tcase '-':System.out.println(a-b);break;\n\t\t}\n\t}\n}\r\n</textarea>	177
177	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　设我国国民生产总值的年增产率为10%，计算n年后我国国民生产总值与现在的比是多少。计算公式为：P=(1+r)\n  <sup>n</sup>, r为年增产率，n为年数，P为n年后国民生产总值与现在相比的倍数。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入一个数n(1 &lt;= n &lt;= 300)。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出一个数P，保留2位小数。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  10\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  2.59\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\r\n#include&lt;math.h&gt;\r\n\r\nint main(void)\r\n{\r\n\tdouble n,p;\r\n\tint i;\r\n\tscanf("%lf",&amp;n);\r\n\tp=pow(1.1,n);\r\n\tprintf("%.2lf",p);\r\n\treturn 0;\r\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\nint main()\n{\n\tint n;\n\tdouble r=0.1,p;\n\tscanf("%d",&amp;n);\n\t\tp=pow((1+r),n);\n\tprintf("%0.2lf",p);\n\treturn 0;\n} \r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.text.DecimalFormat;\nimport java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\t//P=(1+r)n\n\t\tScanner sc=new Scanner(System.in);\n\t\tdouble n=sc.nextDouble();\n\t\tdouble P=Math.pow(1.1, n);\n        String s=df(P);\n        System.out.print(s);\n\t}\n\n\tprivate static String df(double p) {\n\t\tDecimalFormat df=new DecimalFormat("0.00");\n\t\tString s=df.format(p);\n\t\treturn s;\n\t}\n}\r\n</textarea>	178
178	<div class="des"> \n <div class="pdcont">\n  　　有4个学生，上4门课，要求输入全部学生的各门课成绩，并分别求出每门课的平均成绩。(保留2位小数)\n  <br> 　　括号里是解释内容，不用输入输出。输入的所有数都为0到100之间（包括端点）的整数\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  (输入第1个学生的4门课成绩) 94 78 87 96\n  <br> (输入第2个学生的4门课成绩) 66 87 75 69\n  <br> (输入第3个学生的4门课成绩)100 98 89 77\n  <br> (输入第4个学生的4门课成绩) 82 73 67 54\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  (第1门课的平均成绩是) 85.50\n  <br> (第2门课的平均成绩是) 84.00\n  <br> (第3门课的平均成绩是) 79.50\n  <br> (第4门课的平均成绩是) 74.00\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\r\n\r\nint main(void)\r\n{\r\n\tfloat a[4][4];\r\n\tint i,j;\r\n\tfor(i=0;i&lt;4;i++)\r\n\t\tfor(j=0;j&lt;4;j++)\r\n\t\t\tscanf("%f",&amp;a[i][j]);\r\n\t\r\n\tfor(i=0;i&lt;4;i++)\r\n\t\tprintf("%.2f\\n",(a[0][i]+a[1][i]+a[2][i]+a[3][i])/4);\r\n\treturn 0;\r\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n#include&lt;numeric&gt;\n#include &lt;iomanip&gt;\n#include &lt;map&gt;\n#include &lt;limits.h&gt;\n#include &lt;iterator&gt;\n#include &lt;sstream&gt;\n#include &lt;set&gt;\nusing namespace std;\nint a[4][4];\nint main(){\n    for(int i=0;i&lt;4;i++){\n        for(int j=0;j&lt;4;j++){\n            cin&gt;&gt;a[i][j];\n        }\n    }\n    for(int i=0;i&lt;4;i++){\n        double s=(double)(a[0][i]+a[1][i]+a[2][i]+a[3][i])/4;\n        printf("%.2f\\n",s);\n    }\n\n\nreturn 0;}\n\r\n</textarea>	<textarea id="codelinesjava">\r\n\n\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sca = new Scanner(System.in);\n\t\tint[][] arr = new int[4][4];\n\t\t\n\t\tfor(int i=0;i&lt;arr.length;i++){\n\t\t\tfor(int j=0;j&lt;arr[i].length;j++){\n\t\t\t\tarr[i][j] = sca.nextInt();\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i&lt;arr.length;i++){\n\t\t\tdouble count = 0;\n\t\t\tfor(int j=0;j&lt;arr[i].length;j++){\n\t\t\t\tcount += arr[j][i];\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(String.format("%1.2f", count/4));\n\t\t}\n\t\t\n\t}\n\n}\n\r\n</textarea>	179
179	<div class="des"> \n <div class="pdcont">\n  　　编程将两个字符串连接起来。例如country与side相连接成为countryside。\n  <br> 　　输入两行，每行一个字符串（只包含小写字母，长度不超过100）；输出一行一个字符串。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  country\n  <br> side\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  countryside\n </div> \n</div>	<textarea id="codelinesc">\r\n//连接字符串\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nint main()\n{\n\tchar s1[202],s2[202];\n\tscanf("%s",s1);\n\tscanf("%s",s2);\n\tstrcat(s1,s2);\n\tprintf("%s",s1);\n\tprintf("\\n");\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;map&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;limits.h&gt;\nusing namespace std;\n//int a[2000001];\n//int b[100010];\n//int m=50000;\nint main(){\n    string s1,s2;\n    cin&gt;&gt;s1&gt;&gt;s2;\n    cout&lt;&lt;s1+s2&lt;&lt;endl;\n    return 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class Main \n{\t\n\tpublic static void main(String args[]) throws Exception\n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\tString str1 = sc.next();\n\t\tString str2 = sc.next();\n\t\t\n\t\tSystem.out.println(str1+str2);\n\t\t\n\t\t\n\t}\n}\r\n</textarea>	180
180	<div class="des"> \n <div class="pdcont">\n  　　编写一个函数，输入一行字符，将此字符串中最长的单词输出。\n  <br> 　　输入仅一行，多个单词，每个单词间用一个空格隔开。单词仅由小写字母组成。所有单词的长度和不超过100000。如有多个最长单词，输出最先出现的。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  I am a student\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  student\n </div> \n</div>	<textarea id="codelinesc">\r\n//最长单词\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nint main()\n{\n\tchar s[100005];\n\tint count=0;\n\tint i,j,max=-1,len,temp;\n\tgets(s);\n\tlen=strlen(s);\n\t/*for(i=0;i&lt;len;i++)\n\t\tif(s[i]==' ')\n\t\t\ts[i]='#';*/\n\n\tfor(i=0;i&lt;len;i++)\n\t{\n\t\tif(s[i]!=' ')\n\t\t\tj=i;\n\t\tfor(;i&lt;len;i++)\n\t\t{\n\t\t\tif(s[i]!=' ')\n\t\t\t\tcount++;\n\t\t\telse break;\n\t\t}\n\t\tif(count&gt;max)\n\t\t{\n\t\t\tmax=count;\n\t\t\ttemp=j;\n\t\t\tcount=0;\n\t\t}\n\t\telse count=0;\n\n\t}\n\tfor(i=temp;i&lt;temp+max;i++)\n\t\tprintf("%c",s[i]);\n\tprintf("\\n");\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nchar s[100010];\nchar m[100010];\n\nint main (void)\n{\n\tchar a;\n\tint len, max = -0x3f3f3f3f;\n\twhile(1)\n\t{\n\t\tscanf("%s", s);\n\t\ta = getchar();\n\t\tlen = strlen(s);\n\t\tif(max &lt; len)\n\t\t{\n\t\t\tmax = len;\n\t\t\tstrcpy(m, s);\n\t\t}\n\t\tif(a != ' ')\n\t\t\tbreak;\n\t}\t\n\tprintf("%s\\n", m);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Main{\n\tpublic static void main(String[] args) throws Exception{\n\t\tBufferedReader bfr = new BufferedReader(new InputStreamReader(System.in));\n\t\tString str = bfr.readLine();\n\t\tString max = "";\n\t\tString [] arr = null;\n\t\twhile(str.contains(" ")){\n\t\t\tarr = str.split(" ");\n\t\t\tif (arr[0].length()&gt;max.length()){\n\t\t\t\tmax = arr[0];\n\t\t\t//\tSystem.out.println(max);\n\t\t\t}\n\t\t\tstr = str.substring(arr[0].length()+1);\n\t\t\t//System.out.println(str);\n\t\t}\n\t\tif (arr[1].length()&gt;max.length()){\n\t\t\tmax = arr[1];\n\t\t}\n\t\tSystem.out.println(max);\n\t}\n}\n\r\n</textarea>	181
181	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　有n个人围成一圈，顺序排号（编号为1到n）。从第1个人开始报数(从1到3报数)，凡报到3的人退出圈子。从下一个人开始继续报数，直到剩下最后一个人，游戏结束。\n  <br> 　　问最后留下的是原来第几号的那位。\n  <br> 　　举个例子，8个人围成一圈：\n  <br> 　　1 2 3 4 5 6 7 8\n  <br> 　　第1次报数之后，3退出，剩下：\n  <br> 　　1 2 4 5 6 7 8 （现在从4开始报数）\n  <br> 　　第2次报数之后，6退出，剩下：\n  <br> 　　1 2 4 5 7 8 （现在从7开始报数）\n  <br> 　　第3次报数之后，1退出，剩下：\n  <br> 　　2 4 5 7 8 （现在从2开始报数）\n  <br> 　　第4次报数之后，5退出，剩下：\n  <br> 　　2 4 7 8 （现在从7开始报数）\n  <br> 　　第5次报数之后，2退出，剩下：\n  <br> 　　4 7 8 （现在从4开始报数）\n  <br> 　　第6次报数之后，8退出，剩下：\n  <br> 　　4 7 （现在从4开始报数）\n  <br> 　　最后一次报数之后，4退出，剩下：\n  <br> 　　7.\n  <br> 　　所以，最后留下来的人编号是7。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　一个正整数n，(1&lt;n&lt;10000)\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　一个正整数，最后留下来的那个人的编号。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  8\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  7\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　对于100%的数据，1&lt;n&lt;10000。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt; \n#include &lt;malloc.h&gt; \ntypedef struct form{ \n\tint num; \n\tint date; \n\tstruct form *link;} \ndel; \ndel *creat(int n){ \nint i; \ndel *head,*p1,*p2; \nhead=(del *)malloc(sizeof(del)); \np1=(del *)malloc(sizeof(del)); \nhead-&gt;link=p1; \nfor(i=1;i&lt;=n-2;i++){p2=(del *)malloc(sizeof(del)); \np1-&gt;link=p2; \np1=p2;} \np1-&gt;link=head; \nreturn(head); \n} \nvoid dateop(del *h,int n){ \n\tdel *p; \n\tint i,j=1; \n\tp=h; \n\tfor(i=1;i&lt;=n;i++){ \n\tp-&gt;num=i; \n\tp-&gt;date=j;j++; \n\tif(j==4) j=1; \n\tp=p-&gt;link;} \n} \nint deal(del *h,int n){ \n\tdel *k; \n\tint s; \n\tint count,j=1,i; \n\tcount=n; \n\tk=h; \n\twhile(count!=1){ \n\tif(j==3&amp;&amp;k-&gt;date!=0) {k-&gt;date=0;count--;} \nk=k-&gt;link; \n\tj++; \n\tif(k-&gt;date==0) j--; \nif(j==4) j=1; \n\t} \n\tk=h; \n\tfor(i=1;i&lt;=n;i++){ \n\tif(k-&gt;date!=0) {s=k-&gt;num;break;} \n\tk=k-&gt;link;} \n\treturn(s);} \nint main(){ \n\tint x; \n\tint i; \n\tdel *p; \n\tscanf("%d",&amp;x); \n\tp=creat(x); \n\tdateop(p,x); \n\tx=deal(p,x); \n\tfor(i=1;i&lt;x;i++){ \n\tp=p-&gt;link;} \n\tprintf("%d",p-&gt;num); \nreturn 0; \n}\r\n</textarea>	<textarea id="codelinescpp">\r\n \n#include&lt;stdio.h&gt;\nmain()\n{\tint i,N,x,m,s;\n\t\n\tx=3;\n\t\ts=0;\n\t\tscanf("%d",&amp;m);\n\t\tfor(i=2;i&lt;=m;i++)\n\t\t\ts=(s+x)%i;\n\t\tprintf("%d\\n",s+1);\n\t\n}        \r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint length = Integer.parseInt(br.readLine());\n\t\tArrayList&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;();\n\t\tfor (int i = 1; i &lt;= length; i++) {\n\t\t\tarr.add(i);\n\t\t}\n\t\tint control = 0;\n\t\tint index = 0;\n\t\twhile (arr.size() != 1) {\n\t\t\tif (control == 2) {\n\t\t\t\tarr.remove(index);\n\t\t\t\tindex--;\n\t\t\t}\n\t\t\tcontrol = (control + 1) % 3;\n\t\t\tindex = (index + 1) % arr.size();\n\t\t}\n\t\tSystem.out.println(arr.get(0));\n\t}\n\n}\n\r\n</textarea>	182
182	<div class="des"> \n <div class="pdcont">\n  　　输入n分钟换算成天、小时和分输出。例如4880分钟，可换算成3天9小时20分。\n  <br> 　　输入一个正整数n(1\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  4880\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  3 9 20\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint main()\n{\nint n,t,s,f;\nscanf("%d",&amp;n);\nt=n/(60*24);\ns=(n-t*60*24)/60;\nf=n-t*60*24-s*60;\nprintf("%d %d %d",t,s,f);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\nint main()\n{\n\tint n;\n\tcin&gt;&gt;n;\n\tint day,h,m;\n\tday=n/60/24;\n\th=n/60%24;\n\tm=n%60;\n\tcout&lt;&lt;day&lt;&lt;" "&lt;&lt;h&lt;&lt;" "&lt;&lt;m&lt;&lt;endl;\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic static void main(String args[])throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint f = Integer.parseInt(br.readLine());\n\t\tSystem.out.println(f/1440+" "+f%1440/60+" "+f%60);\n\t}\n}\r\n</textarea>	183
183	<div class="des"> \n <div class="pdcont">\n  　　输入3个整数a、b、c，（数的范围是[1,10000]）输出其中最大的数。(用指针实现)\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  2 5 1\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  5\n </div> \n</div>	<textarea id="codelinesc">\r\n//选最大数\n#include&lt;stdio.h&gt;\nint main()\n{\n\tint a,b,c;\n\tint max;\n\tscanf("%d %d %d",&amp;a,&amp;b,&amp;c);\n\tmax=a&gt;b? a:b;\n\tmax=c&gt;max? c:max;\n\tprintf("%d\\n",max);\n    return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nint main()\n{\n\tint a[3];\n\tcin&gt;&gt;a[0]&gt;&gt;a[1]&gt;&gt;a[2];\n\tcout&lt;&lt;*max_element(a,a+3);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.*;\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner input = new Scanner(System.in);\n\t\tint a = input.nextInt();\n\t\tint b = input.nextInt();\n\t\tint c = input.nextInt();\n\t\tif(a&gt;b &amp;&amp; a&gt;c){\n\t\t\tSystem.out.println(a);\n\t\t}\n\t\telse if(b&gt;a &amp;&amp; b&gt;c){\n\t\t\tSystem.out.println(b);\n\t\t}\n\t\telse{\n\t\t\tSystem.out.println(c);\n\t\t}\n\t}\n\n}\r\n</textarea>	184
184	<div class="des"> \n <div class="pdcont">\n  　　输入一个正整数（范围[1..10000]），打印其平方（不保留小数位）、平方根、倒数。(用指针实现，保留2位小数，输出每个数之间以一个空格隔开)\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  2\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  4 1.41 0.50\n </div> \n</div>	<textarea id="codelinesc">\r\nint main()\n{\n\tint *k,a;\n\tscanf("%d",&amp;a);\n\tk=&amp;a;\n\tprintf("%d %.2f %.2f\\n",*k**k,sqrt(*k),1.0/(*k));\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;stdio.h&gt;\n#include&lt;math.h&gt;\nusing namespace std;\nint main()\n{\n\tint n;\n\tcin&gt;&gt;n;\n\tint *p;\n\tp=&amp;n;\n\tprintf("%d %.2lf %.2lf",(*p)*(*p),sqrt(*p),1/(double)(*p));\n    \nreturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main{\n\n          public static void main(String[] args) {\n\n                    Scanner sc = new Scanner(System.in);\n                    int n = sc.nextInt();\n                    sc.close();\n\n                   \n                    String sqrt = String.format("%.2f", Math.sqrt(n));\n                    System.out.print(n*n);\n                    System.out.print(" " + sqrt);\n                    System.out.print(" " +String.format("%.2f",1.0/n));\n          }\n}\r\n</textarea>	185
187	<div class="des"> \n <div class="pdcont">\n  　　输入两个点的坐标，即p1 = (x1, y1)和p2=(x2, y2)，求过这两个点的直线的斜率。如果斜率为无穷大输出“INF”。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  1 2\n  <br> 2 4\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  2\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  1 2\n  <br> 1 4\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  INF\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  1 2\n  <br> 3 2\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  0\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint main(){\n  int a,b,c,d;\n  scanf("%d %d",&amp;a,&amp;b);\n  scanf("%d %d",&amp;c,&amp;d);\n  if(a==c)\n\t  printf("INF\\n");\n  else \n\t  printf("%d\\n",(b-d)/(a-c));\n\n  return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\nint main()\n{\n\tdouble x1,x2,y1,y2,k;\n\tcin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;\n\tif(x1!=x2)\n\t{\n\t\tk=(y2-y1)/(x2-x1);\n\t\tcout&lt;&lt;k;\n\t}\n\telse\n\t\tcout&lt;&lt;"INF";\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tint x1 = sc.nextInt(), y1 = sc.nextInt();\n\t\tint x2 = sc.nextInt(), y2 = sc.nextInt();\n\t\tsc.close();\n\n\t\tif (x2 - x1 == 0)\n\t\t\tSystem.out.println("INF");\n\t\telse\n\t\t\tSystem.out.println((y2 - y1) / (x2 - x1));\n\t}\n}\r\n</textarea>	188
188	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　将1，2，…，9共9个数分成三组，分别组成三个三位数，且使这三个三位数构成\n  <br> 　　1：2：3的比例，试求出所有满足条件的三个三位数。\n  <br> 　　例如：三个三位数192，384，576满足以上条件。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　无输入文件\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出每行有三个数，为满足题设三位数。各行为满足要求的不同解。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint check(int t1,int t2,int t3) \n{\n\t int result;\n\t int temp1=45;\n\t long temp2=362880;\n\t long a1=t1%10+t1/10%10+t1/100%10;\n\t long b1=t2%10+t2/10%10+t2/100%10;\n\t long c1=t3%10+t3/10%10+t3/100%10;\n\t long a2=(t1%10)*(t1/10%10)*(t1/100%10);\n\t long b2=(t2%10)*(t2/10%10)*(t2/100%10);\n\t long c2=(t3%10)*(t3/10%10)*(t3/100%10);\n\t if(((a1+b1+c1)==temp1) &amp;&amp; (a2*b2*c2==temp2))\n\t    result=1;\n\t else\n\t    result=0;\n\t return result;\t\n\n \n}\nint main()\n{\n\tint x;\n\tfor(x=123;x&lt;333;x++)  \n\tif(check(x,2*x,3*x)) \n \t\tprintf("%d %d %d\\n",x,2*x,3*x); \n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n\n#include &lt;cstdlib&gt;\n  #include &lt;iostream&gt;\n  \n  using namespace std;\n  \n  int main(int argc, char *argv[])\n  {\n      int i,j,k,n,a[9],num;\n      for(i=123;i&lt;=327;i++)\n     {   n=0;        \n         if(i/100!=i%100/10&amp;&amp;i/100!=i%10&amp;&amp;i%100/10!=i%10&amp;&amp;i%100/10!=0&amp;&amp;i%10!=0)\n         {\n             for(j=1;j&lt;=3;j++)\n             {\n                 a[n++]=j*i/100;\n                 a[n++]=j*i%100/10;\n                 a[n++]=j*i%10;\n             }\n             \n             for(j=0;j&lt;9;j++)\n             {   \n                 num=0;\n                 if(a[j]!=0)            \n                   {  \n                       for(k=j+1;k&lt;9;k++)\n                     {\n                         if(a[j]==a[k])\n                         {\n                             num++;\n                           break;\n                         }\n                                                                     \n                     }\n                     if(num&gt;0)\n                        break;  \n                  } \n                   else \n                   {\n                       num++;\n                       break;\n                  }                                             \n             }             \n             if(num==0)\n              {  \n                 for(j=1;j&lt;10;j++)\n                 {\n                     cout&lt;&lt;a[j-1];\n                     if(j%3==0)\n                    cout&lt;&lt;" ";\n                }\n                 cout&lt;&lt;endl; \n               }     \n         }\n         \n     }\n     return 0;\n }\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.*;\npublic class Main {\n\tstatic boolean a;\n\tpublic static void main(String[] args) {\n          for(int i=100;i&lt;334;i++)\n          {      boolean g=r(i);\n        \t if(g) {System.out.print(i+" "+2*i+" "+3*i);\n        \t System.out.println();   \t\n        \t }\n          }\n\t}\n\tpublic  static boolean r(int i){\n\t\ta=true;\n\t\tint x=i;\n\t\tArrayList&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;();\n\t\tfor(int k=0;k&lt;3;k++){\n\t\tlist.add(i/100);\n\t\tlist.add(i%100/10);\n\t\tlist.add(i%100%10);\n\t\ti+=x;\n\t\t}\n\t\tif(list.indexOf(0)&gt;=0)return false;\n\t\tfor(int l=0;l&lt;8;l++){\n\t\t\tfor(int j=l+1;j&lt;list.size();j++)\n\t\t\t{\n\t\t\tif(list.get(l).equals(list.get(j))){\n\t\t\t\ta=false;\n\t\t\t      break;\n\t\t\t}\n\t\t\t\n\t\t\t}\n\t\t\tif(!a)break;\n\t\t}\n\t\treturn a;\n\t}\n}\r\n</textarea>	189
189	<div class="des"> \n <div class="pdcont">\n  　　编写一程序，在屏幕上输出如下内容：\n  <br> 　　X | X | X\n  <br> 　　---+---+---\n  <br> 　　| |\n  <br> 　　---+---+---\n  <br> 　　O | O | O\n  <br> 　　注意：本题请同学们严格按照图形的格式输出，对齐，其中X和O为大写，否则系统会判为错误。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint main(){\n  printf("X | X | X\\n");\n  printf("---+---+---\\n");\n  printf("| |\\n");\n  printf("---+---+---\\n");\n  printf("O | O | O\\n");\n return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\nint main()\n{\n\tcout&lt;&lt;"X | X | X"&lt;&lt;endl;\n\tcout&lt;&lt;"---+---+---"&lt;&lt;endl;\n\tcout&lt;&lt;"| |"&lt;&lt;endl;\n\tcout&lt;&lt;"---+---+---"&lt;&lt;endl;\n\tcout&lt;&lt;"O | O | O"&lt;&lt;endl;\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println("X | X | X");\n\t\tSystem.out.println("---+---+---");\n\t\tSystem.out.println("| |");\n\t\tSystem.out.println("---+---+---");\n\t\tSystem.out.println("O | O | O");\n\t}\n}\n\r\n</textarea>	190
190	<div class="des"> \n <pre class="pddata">\n<span style="font-size: medium"><span style="font-family: Times New Roman"><span lang="EN-US"><span style="font: 7pt 'Times New Roman'">编写一程序，接受用户输入的两个整数，并计算它们的和、差、<br>积、商，程序运行时候输入输出例子如下所示。</span></span></span></span>\n</pre> \n <pre class="pddata">\n<span style="font-size: medium"><span style="font-family: Times New Roman"><span lang="EN-US"><span style="font: 7pt 'Times New Roman'">样例输入：<br>3 5</span></span></span></span>\n</pre> \n <pre class="pddata">\n<span style="font-size: medium"><span style="font-family: Times New Roman"><span lang="EN-US"><span style="font: 7pt 'Times New Roman'">样例输出：<br>3+5=8<br>3-5=-2<br>3*5=15<br>3/5=0</span></span></span></span>\n</pre> \n <pre class="pddata">\n<span style="font-size: medium"><span style="font-family: Times New Roman"><span style=""><span lang="EN-US" style="mso-fareast-font-family: 'Times New Roman'"><span style="mso-list: Ignore"><font face="Times New Roman"><span style="font: 7pt 'Times New Roman'">注意：输出要严格按照+-*/的顺序，分四行输出，而且中间不能有空格，否则系统会判为错误。</span></font></span></span></span></span></span>\n</pre> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint main()\n{\nint a,b;\nscanf("%d%d",&amp;a,&amp;b);\nprintf("%d+%d=%d\\n",a,b,a+b);\nprintf("%d-%d=%d\\n",a,b,a-b);\nprintf("%d*%d=%d\\n",a,b,a*b);\nprintf("%d/%d=%d\\n",a,b,a/b);\nreturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n//tjau\n#include &lt;iostream&gt;\nusing namespace std;\nint main()\n{\n\tint x,y; \n\tcin&gt;&gt;x&gt;&gt;y;\n\tcout&lt;&lt;x&lt;&lt;"+"&lt;&lt;y&lt;&lt;"="&lt;&lt;x+y&lt;&lt;endl;\n\tcout&lt;&lt;x&lt;&lt;"-"&lt;&lt;y&lt;&lt;"="&lt;&lt;x-y&lt;&lt;endl;\n\tcout&lt;&lt;x&lt;&lt;"*"&lt;&lt;y&lt;&lt;"="&lt;&lt;x*y&lt;&lt;endl;\n\tcout&lt;&lt;x&lt;&lt;"/"&lt;&lt;y&lt;&lt;"="&lt;&lt;x/y&lt;&lt;endl;\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\n\npublic class Main\n{\n\tpublic static void main(String[] args)\n\t{\n       Scanner sc = new Scanner(System.in);\n       int a = sc.nextInt();\n       int b = sc.nextInt();\n       sc.close();\n \n       System.out.println(a + "+" + b + "=" + (a + b));\n       System.out.println(a + "-" + b + "=" + (a - b));\n       System.out.println(a + "*" + b + "=" + (a * b));\n       System.out.println(a + "/" + b + "=" + (a / b));\n\t}\n}\n\r\n</textarea>	191
191	<div class="des"> \n <pre class="pddata">\n编制程序，输出下述数据。说明：（1）表中数据来自总参谋部测绘局编制的\n《世界地图集》（星球地图出版社，2004年1月第2版），数据可能已不准确；\n（2）面积单位为万平方公里，人口单位为万人，GDP单位为十亿美元；\n（3）表中所有数据都必须以变量的形式保存；（4）如果不知道每字段宽度\n到底为多少，请仔细数数作为分隔标记的短横数目。<br>---------------------------------------------------<br>COUNTRY     AREA(10K km2)  POP.(10K)  GDP(Billion$)<br>---------------------------------------------------<br>China              960.00  129500.00  1080.00<br>Iceland             10.30      27.57  8.20<br>India              297.47   97000.00  264.80<br>Madagascar          62.70    1635.00  3.60<br>Maldive            0.0298      27.80  0.23<br>---------------------------------------------------<br>注意：输出时空格与短线的数量要与上面格式严格一致，否则系统会判为错误。\n</pre> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint main()\n{\n\tprintf("---------------------------------------------------\\n");\n\tprintf("COUNTRY AREA(10K km2) POP.(10K) GDP(Billion$)\\n");\n\tprintf("---------------------------------------------------\\n");\n\tprintf("China 960.00 129500.00 1080.00\\n");\n\tprintf("Iceland 10.30 27.57 8.20\\n");\n\tprintf("India 297.47 97000.00 264.80\\n");\n\tprintf("Madagascar 62.70 1635.00 3.60\\n");\n\tprintf("Maldive 0.0298 27.80 0.23\\n");\n\tprintf("---------------------------------------------------\\n");\n\treturn 0;\n} \r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\nint main()\n{\n\tcout&lt;&lt;"---------------------------------------------------"&lt;&lt;endl;\n\tcout&lt;&lt;"COUNTRY AREA(10K km2) POP.(10K) GDP(Billion$)"&lt;&lt;endl;\n\tcout&lt;&lt;"---------------------------------------------------"&lt;&lt;endl;\n\tcout&lt;&lt;"China 960.00 129500.00 1080.00"&lt;&lt;endl;\n\tcout&lt;&lt;"Iceland 10.30 27.57 8.20"&lt;&lt;endl;\n\tcout&lt;&lt;"India 297.47 97000.00 264.80"&lt;&lt;endl;\n\tcout&lt;&lt;"Madagascar 62.70 1635.00 3.60"&lt;&lt;endl;\n\tcout&lt;&lt;"Maldive 0.0298 27.80 0.23"&lt;&lt;endl;\n\tcout&lt;&lt;"---------------------------------------------------"&lt;&lt;endl;\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\npublic class Main\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tSystem.out.println("---------------------------------------------------");\n\t\tSystem.out.println("COUNTRY AREA(10K km2) POP.(10K) GDP(Billion$)");\n\t\tSystem.out.println("---------------------------------------------------");\n\t\tSystem.out.println("China 960.00 129500.00 1080.00");\n\t\tSystem.out.println("Iceland 10.30 27.57 8.20");\n\t\tSystem.out.println("India 297.47 97000.00 264.80");\n\t\tSystem.out.println("Madagascar 62.70 1635.00 3.60");\n\t\tSystem.out.println("Maldive 0.0298 27.80 0.23");\n\t\tSystem.out.println("---------------------------------------------------");\n\t\t \n\t}\n\n}\r\n</textarea>	192
192	<div class="des"> \n <div class="pdcont">\n  　　编制程序完成下述任务：接受两个数，一个为用户一年期定期存款金额，一个为按照百分比格式表示的利率；程序计算一年期满\n  <br> 　　后本金与利息总额。说明：（1）存款金额以人民币元为单位，可能精确到分；（2）输入利率时不需要输入百分号，例如一年期定期存款年利率\n  <br> 　　为2.52%，用户输入2.52即可；（3）按照国家法律，存款利息所得需缴纳20% 的所得税，计算结果时所得税部分应扣除。要求输出小数点后严格\n  <br> 　　保留两位小数。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  10000 2.52\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  10201.60\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n\tfloat a,b;\n\tscanf("%f%f",&amp;a,&amp;b);\n\tprintf("%.2f",10000+a*b/100*0.8);\n\treturn 0;\n}\n\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\r\n#include &lt;cstdio&gt;\r\nusing namespace std;\r\nint main()\r\n{\r\n\tdouble a,b;\r\n\tcin&gt;&gt;a&gt;&gt;b;\r\n\tprintf("%.2f",a+a*b*0.008);\r\n\treturn 0;\r\n}\r\n\r\n</textarea>	<textarea id="codelinesjava">\r\n\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n            Scanner scan=new Scanner(System.in);\n            float a=scan.nextFloat();\n            float b=scan.nextFloat();\n            System.out.printf("%.2f",(a+a*b*0.01*0.8));\n\t}\n\n}\r\n</textarea>	193
193	<div class="des"> \n <pre class="pddata">\n使用循环结构打印下述图形，打印行数n由用户输入。图中每行事实上包括两部分，中间间隔空格字符数m也由用户输入。\n</pre> \n <pre class="pddata">\n样例输入n,m: <br>5  4<br>样例输出:<br>    *    *********<br>   ***    *******<br>  *****    *****<br> *******    ***<br>*********    *\n</pre> \n <pre class="pddata">\n<br>注意：两行之间没有空行。\n</pre> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n\tint i,j,k,m,n;\n\tscanf("%d %d",&amp;n,&amp;m);\n\tfor(i=1;i&lt;=n;i++)\n\t{\n\t\tfor(j=1;j&lt;=n-i+1;j++)printf(" ");\n\t\tfor(k=1;k&lt;=2*i-1;k++)printf("*");\n\t\tfor(j=1;j&lt;=m;j++)printf(" ");\n\t\tfor(k=1;k&lt;=2*n-2*i+1;k++)printf("*");\n        printf("\\n");\n\t}\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n\tint n,m,i,j,k,l;\n\tscanf("%d%d",&amp;n,&amp;m);\n\tfor(i=1;i&lt;=n;i++)\n\t{\n\t\tfor(j=1;j&lt;=(2*i)-1;j++)\n\t\t{\n\t\t\tprintf("*");\n\t\t}\n\t\tfor(k=1;k&lt;=m;k++)\n\t\t\tprintf(" ");\n\t\tfor(l=(2*n)-(2*i);l&gt;=0;l--)\n\t\t\tprintf("*");\n\t\tprintf("\\n");\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\n\nimport java.util.*;\nimport java.math.*;\npublic class Main{\n\t\n\tpublic static void main(String args[])\n    {\n\t\t\n\t\tScanner cin=new Scanner(System.in);\n\t\tint  n=cin.nextInt();\n\t\tint  m=cin.nextInt();\n\t\t\n        for(int i=0;i&lt;n;i++)\n        {\n        \tfor(int j=0;j&lt;2*i+1;j++)System.out.print("*");\n        \tfor(int j=0;j&lt;m;j++)System.out.print(" ");\n        \tfor(int j=0;j&lt;2*n-2*i-1;j++)System.out.print("*");\n        \tSystem.out.println();\n        }\n\t\t\t\t\n\t\t\n      }\n    }\n\r\n</textarea>	194
194	<div class="des"> \n <pre class="pddata">\n编制程序，按照下述格式打印九九乘法表。\n输出样例：\nNine-by-nine Multiplication Table<br>--------------------------------------<br>     1   2   3   4   5   6   7   8   9<br>--------------------------------------<br> 1   1<br> 2   2   4<br> 3   3   6   9<br> 4   4   8  12  16<br> 5   5  10  15  20  25<br> 6   6  12  18  24  30  36<br> 7   7  14  21  28  35  42  49<br> 8   8  16  24  32  40  48  56  64<br> 9   9  18  27  36  45  54  63  72  81<br>--------------------------------------\n</pre> \n <div class="pdcont">\n  　　注意：表头的大小写要和样例一致，短线“-”个数要与样例中一致，否则系统会判为错误。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nvoid print(int n)\n{\n\tif(n==10) return ;\n\tint i,j;\n\tprintf("%d ",n);\n\tfor(i=1;i&lt;=n;i++)\n\tprintf("%d ",n*i);\n\tprintf("\\n"); \n\tprint(n+1);\n}\n\nint main()\n{\nprintf("Nine-by-nine Multiplication Table\\n");\nprintf("--------------------------------------\\n");\nprintf("1 2 3 4 5 6 7 8 9\\n");\nprintf("--------------------------------------\\n");\nprint(1);\nprintf("--------------------------------------");\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n\tint i,j;\n\tprintf("Nine-by-nine Multiplication Table\\n");\n\tprintf("--------------------------------------\\n");\n\tfor(i=1;i&lt;=9;i++)\n\t\tprintf("%d ",i);\n\tprintf("\\n");\n\tprintf("--------------------------------------\\n");\n\tfor(i=1;i&lt;=9;i++)\n\t{\n\t\tprintf("%d ",i);\n\t\tfor(j=1;j&lt;=i;j++)\n\t\t\tprintf("%d ",i*j);\n\t\tprintf("\\n");\n\t}\n\tprintf("--------------------------------------\\n");\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println("Nine-by-nine Multiplication Table");\n\t\tSystem.out.println("--------------------------------------");\n\t\tSystem.out.println("1 2 3 4 5 6 7 8 9");\n\t\tSystem.out.println("--------------------------------------");\n\t\tSystem.out.println("1 1");\n\t\tSystem.out.println("2 2 4");\n\t\tSystem.out.println("3 3 6 9");\n\t\tSystem.out.println("4 4 8 12 16");\n\t\tSystem.out.println("5 5 10 15 20 25");\n\t\tSystem.out.println("6 6 12 18 24 30 36");\n\t\tSystem.out.println("7 7 14 21 28 35 42 49");\n\t\tSystem.out.println("8 8 16 24 32 40 48 56 64");\n\t\tSystem.out.println("9 9 18 27 36 45 54 63 72 81");\n\t\tSystem.out.println("--------------------------------------");\n\t}\n}\n\r\n</textarea>	195
195	<div class="des"> \n <pre class="pddata">\n按照下述格式打印2006年12月日历：\n</pre> \n <pre class="pddata">\nCalendar 2006-12<br>--------------------------<br>Su  Mo  Tu  We  Th  Fr  Sa<br>--------------------------<br>                     1   2<br> 3   4   5   6   7   8   9<br>10  11  12  13  14  15  16<br>17  18  19  20  21  22  23<br>24  25  26  27  28  29  30<br>31<br>--------------------------\n</pre> \n <pre class="pddata">\n注意：表头和表中的英文字符大小写要与题目中一致，短线“-”个数要与题目中一致，否则系统会判为错误。\n</pre> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint main()\n{ \nprintf("Calendar 2006-12\\n") ;\n   printf("--------------------------\\n");\t\n   printf("Su Mo Tu We Th Fr Sa\\n");\t\n\tprintf("--------------------------\\n");\n\tprintf("1 2\\n");\n\tprintf("3 4 5 6 7 8 9\\n");\n\tprintf("10 11 12 13 14 15 16\\n");\n\tprintf("17 18 19 20 21 22 23\\n");\n\tprintf("24 25 26 27 28 29 30\\n");\n\tprintf("31\\n");\n\tprintf("--------------------------");\t\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\nint main()\n{\n\tcout&lt;&lt;"Calendar 2006-12"&lt;&lt;endl;\n\tcout&lt;&lt;"--------------------------"&lt;&lt;endl;\n\tcout&lt;&lt;"Su Mo Tu We Th Fr Sa"&lt;&lt;endl;\n\tcout&lt;&lt;"--------------------------"&lt;&lt;endl;\n\tcout&lt;&lt;"1 2"&lt;&lt;endl;\n\tcout&lt;&lt;"3 4 5 6 7 8 9"&lt;&lt;endl;\n\tcout&lt;&lt;"10 11 12 13 14 15 16"&lt;&lt;endl;\n\tcout&lt;&lt;"17 18 19 20 21 22 23"&lt;&lt;endl;\n\tcout&lt;&lt;"24 25 26 27 28 29 30"&lt;&lt;endl;\n\tcout&lt;&lt;"31"&lt;&lt;endl;\n\tcout&lt;&lt;"--------------------------"&lt;&lt;endl;\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println("Calendar 2006-12");\n\t\tSystem.out.println("--------------------------");\n\t\tSystem.out.println("Su  Mo  Tu  We  Th  Fr  Sa");\n\t\tSystem.out.println("--------------------------");\n        System.out.println("                     1   2");\n\t\tint n=31,sum=0;\n\t\tfor(int i=3;i&lt;=n;i++){\n\t\t\tsum++;\n\t\t\tif(sum==1&amp;&amp;i&lt;=9)\n\t\t\t\tSystem.out.print(" "+i);\n\t\t\tif(sum==1&amp;&amp;i&gt;9)\n\t\t\t\tSystem.out.print(i);\n\t\t\tif(sum!=1&amp;&amp;i&lt;=9)\n\t\t\t\tSystem.out.print("   "+i);\n\t\t\tif(sum!=1&amp;&amp;i&gt;9)\n\t\t\t\tSystem.out.print("  "+i);\n\t\t\tif(sum==7){\n\t\t\t\tsum=0;\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tif(sum!=0)\n\t\t\tSystem.out.println();\n\t\tSystem.out.println("--------------------------");\n\t}\n}\r\n</textarea>	196
196	<div class="des"> \n <pre class="pddata">\n编写一函数IsPrime，判断某个大于2的正整数是否为素数。\n</pre> \n <pre class="pddata">\n样例输入: <br>5<br>样例输出:<br>yes\n</pre> \n <pre class="pddata">\n样例输入: <br>9<br>样例输出:<br>no\n</pre> \n <pre class="pddata">\n注意：是素数输出yes，不是素数输出no，其中yes和no均为小写。\n</pre> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint main(void)\n{\n\tint m,n,flag=1;\n\tscanf ("%d",&amp;n);\n\tfor(m = 2; m &lt;= n/2; m ++)\n\t{\n\t\tif(n % m == 0)\n\t\t{\n\t\t\tflag = 0;\n\t\t\tbreak;\n\t\t}\n\n\t}\n\t\tif(flag == 1)\n\t\tprintf("yes");\n\t\telse if (flag == 0)\n\t\tprintf ("no");\n\tprintf("\\n");\n\treturn 0;\n} \r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n    int a,i;\n    scanf("%d",&amp;a);\n    for(i=2;i&lt;=a/2;i++)\n    {\n        if(a%i==0)\n        break;\n    }\n    if(i&gt;=a/2)\n    printf("yes\\n");\n    else\n    printf("no\\n");\n    return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\tint a =sc.nextInt();\n\t\tif(IsPrime(a))\n\t\tSystem.out.println("yes");\n\t\telse\n\t\t\tSystem.out.println("no");\n\t}\n\tstatic boolean IsPrime(int num)\n\t{\n\t\tboolean Prime=true;\n\t\tif(num&lt;2)\n\t\t\tPrime=false;\n\t\telse\n\t\t{\n\t\t\tfor (int i = 2; i &lt;= Math.sqrt(num); i++) {\n\t\t\t\tif(num%i==0)\n\t\t\t\t\tPrime=false;\n\t\t\t}\n\t\t}\n\t\treturn Prime;\n\t}\n}\r\n</textarea>	197
197	<div class="des"> \n <pre class="pddata">\n编写一函数gcd，求两个正整数的最大公约数。\n</pre> \n <pre class="pddata">\n样例输入: <br>5 15<br>样例输出:<br>5\n</pre> \n <pre class="pddata">\n样例输入: <br>7 2<br>样例输出:<br>1\n</pre> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint gcd(int a,int b)\n{ \n\tif(a&lt;b) \n\t\treturn gcd(b,a);\n\tif(a%b==0) \n\t\treturn b; \n\treturn gcd(b,a%b);\n}\nint main()\n{\n\tint a,b; \n\tscanf("%d%d",&amp;a,&amp;b);\n\tprintf("%d\\n",gcd(a,b));\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n\tint a,b,r;\n\tscanf("%d %d",&amp;a,&amp;b);\n\tr=a%b;\n\twhile(r)\n\t{\n\t\ta=b;\n\t\tb=r;\n\t\tr=a%b;\n\t}\n\tprintf("%d\\n",b);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tScanner input = new Scanner(System.in);\n\t\tint n = input.nextInt();\n\t\tint m = input.nextInt();\n\t\tSystem.out.println(gcd(n,m));\n\t}\n\t\n\tpublic static int gcd(int n,int m){\n\t\tint num = n&gt;m ? m:n;\n\t\twhile(true){\n\t\t\tif (n % num == 0 &amp;&amp; m % num ==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnum--;\n\t\t}\n\t\treturn num;\n\t}\n\n}\r\n</textarea>	198
198	<div class="des"> \n <pre class="pddata">\n已知2007年1月1日为星期一。\n设计一函数按照下述格式打印2007年以后（含）某年某月的日历，2007年以前的拒绝打印。\n为完成此函数，设计必要的辅助函数可能也是必要的。其中输入为年分和月份。\n</pre> \n <pre class="pddata">\n样例输入: <br>2007  1<br>样例输出:<br>Calendar 2007-01<br>---------------------<br> Su Mo Tu We Th Fr Sa<br>---------------------<br>     1  2  3  4  5  6<br>  7  8  9 10 11 12 13<br> 14 15 16 17 18 19 20<br> 21 22 23 24 25 26 27<br> 28 29 30 31<br>---------------------\n</pre> \n <pre class="pddata">\n样例输入: <br>2010  9<br>样例输出:<br>Calendar 2010-09<br>---------------------<br> Su Mo Tu We Th Fr Sa<br>---------------------<br>           1  2  3  4<br>  5  6  7  8  9 10 11<br> 12 13 14 15 16 17 18<br> 19 20 21 22 23 24 25<br> 26 27 28 29 30<br>---------------------\n</pre> \n <pre class="pddata">\n注意：短线“-”个数要与题目中一致，否则系统会判为错误。\n</pre> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint run=0;\nint getmonthnum(int month)\n{\n\tswitch(month)\n\t{\n\tcase 1:return 31;\n\tcase 2:if(run) return 29;\n\t        else return 28;  \n\tcase 3:return 31;\n\tcase 4:return 30;\n\tcase 5:return 31;\n\tcase 6:return 30;\n\tcase 7:return 31;\n\tcase 8:return 31;\n\tcase 9:return 30;\n\tcase 10:return 31;\n\tcase 11:return 30;\n\tcase 12:return 31;\t\n}\n}\nint isrun(int year)\n{\n if(year%400==0 || (year%4==0 &amp;&amp; year%100!=0)) return 1;\n  return 0;\t\n}\nvoid print(int year,int month,int begin)\n{\n\tint day,i=1,j;\n\tday=getmonthnum(month); \n   if(month&gt;9) printf("Calendar %d-%d\\n",year,month);\t\n   else printf("Calendar %d-0%d\\n",year,month);\t\n   printf("---------------------\\n");\n   printf("Su Mo Tu We Th Fr Sa\\n");\t\n   printf("---------------------\\n");\n   if(begin==6) begin=-1;\n   for(j=-1;j&lt;begin;j++)\n   printf("   ");\n   for(;begin&lt;6;begin++)\n   printf("%2d ",i++);\n  printf("\\n");\n   j=0;\n   while(i&lt;=day)\n   {\n   \t printf("%2d ",i++);\n   \t j++;\n   \t if(j==7) \n   \t {\n   \t \tj=0;printf("\\n");\n   \t }\n   }\n   if(j!=0) printf("\\n---------------------"); \n   else printf("---------------------");\n}\nint main()\n{\nint year,month,i,sum=0;\nscanf("%d%d",&amp;year,&amp;month);\nfor(i=2007;i&lt;year;i++)\nif(isrun(i)) sum+=366;\nelse sum+=365;\t\n\nif(isrun(year)) run=1;\n\nfor(i=1;i&lt;month;i++)\nsum+=getmonthnum(i);\nprint(year,month,sum%7);\nreturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n/**************Powered by Graphene Richards**************/\n//{\n\n#define OUTPUT_PRECISION    "%.2f"\n#define LF_PRECISION        10\n#define INT_64_MOD          "%lld"\n#define UNSIGNED_64_MOD     "%llu"\n\n//#pragma comment(linker,"/STACK:102400000,102400000")\n#include&lt;cmath&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;bitset&gt;\n#include&lt;complex&gt;\n#include&lt;vector&gt;\n#include&lt;iomanip&gt;\n#include&lt;iostream&gt;\n#include&lt;list&gt;\n#include&lt;map&gt;\n#include&lt;queue&gt;\n#include&lt;set&gt;\n#include&lt;stack&gt;\n#include&lt;string&gt;\n#include&lt;typeinfo&gt;\n#define FAST_RW ios_base::sync_with_stdio(0),cin.tie(0);\n#define IT(x) __typeof((x).begin())\n#define FS(i,a) for(ll i=0;a[i];i++)\n#define FE(x,ctn) for(IT(ctn)x=(ctn).begin(),CluhxSchFuDeugk=(ctn).end();x!=CluhxSchFuDeugk;x++)\n#define FR(i,en) for(ll i=0,pJNwFPtlXiwFoIv=(en);i&lt;pJNwFPtlXiwFoIv;i++)\n#define FOR(i,en) for(ll i=1,SbKCIcakJTeYVqs=(en);i&lt;=SbKCIcakJTeYVqs;i++)\n#define FFR(i,x,y) for(ll i=(x),alVDbhLBoMEGSwA=(y);i&lt;=alVDbhLBoMEGSwA;i++)\n#define DFFR(i,x,y) for(ll i=(x),NWYfecAcmGBMJuU=(y);i&gt;=NWYfecAcmGBMJuU;i--)\n#define ll long long\n#define ull unsigned long long\n#define lf long double\n#define pc putchar\n#define mp make_pair\n#define pb push_back\n#define pq priority_queue\n#define fi first\n#define se second\n#define pii pair&lt;int,int&gt;\n#define pdd pair&lt;double,double&gt;\n#define lb(x) (x&amp;(-x))\n#define sqr(x) (x)*(x)\n#define all(x) (x).begin(),(x).end()\n#define clr(x) memset((x),0,sizeof(x))\n#define ms(x,v) memset((x),(v),sizeof(x))\n#define mc(x,y) memcpy((x),(y),sizeof(y))\n#define NL puts("");\n#define fin(x,c) ((c).find(x)!=(c).end())\nusing namespace std;\n\ntemplate&lt;class T1,class T2,class T3&gt;\nbool _IN(T1 x,T2 y,T3 z){\n  return x&lt;=y&amp;&amp;x&gt;=z||x&lt;=z&amp;&amp;x&gt;=y;\n}\n\null gcd(ull a,ull b){\n  if(!b)return a;\n  while(b^=a^=b^=a%=b);\n  return a;\n}\n\n#ifdef wmx16835\n#define NOT_TESTING_TEMPLATE_CPP\n#include"wmx16835.cpp"\n\n#else\nint ebtpqJsBCnTgggi;\n#define LOG {\n#define TEL }\n#define SHOW_TIME\n#define test(...) ebtpqJsBCnTgggi\n#define TEST(...) ebtpqJsBCnTgggi\n#define TRY(...)\n#define PF\n#define PP ;\n#endif\n\nbool S(char*a){\n  return scanf("%s",a)==1;\n}\n\nchar DATaJNTFnlmAoya[2];\n\ntemplate&lt;class T&gt;\nbool S(T&amp;a){\n  const char*x=typeid(a).name();\n  if(!strcmp(x,"i")||!strcmp(x,"b"))return scanf("%d",&amp;a)==1;\n  else if(!strcmp(x,"j"))return scanf("%u",&amp;a)==1;\n  else if(!strcmp(x,"c")){\n    if(scanf("%1s",DATaJNTFnlmAoya)==-1)\n      return 0;\n    a=*DATaJNTFnlmAoya;\n    return 1;\n  }\n  else if(!strcmp(x,"Pc")||*x=='A')return scanf("%s",a)==1;\n  else if(!strcmp(x,"f"))return scanf("%f",&amp;a)==1;\n  else if(!strcmp(x,"d"))return scanf("%lf",&amp;a)==1;\n  else if(!strcmp(x,"x"))return scanf(INT_64_MOD,&amp;a)==1;\n  else if(!strcmp(x,"y"))return scanf(UNSIGNED_64_MOD,&amp;a)==1;\n  else if(!strcmp(x,"e"))return (cin&gt;&gt;a)!=0;\n  else test("Input format error!\\n");\n}\n\nvoid _P(string x){\n  printf("%s",x.c_str());\n}\n\ntemplate&lt;class T&gt;\nvoid _P(T a){\n  const char*x=typeid(a).name();\n  if(!strcmp(x,"i")||!strcmp(x,"b"))printf("%d",a);\n  else if(!strcmp(x,"j"))printf("%u",a);\n  else if(!strcmp(x,"c"))printf("%c",a);\n  else if(!strcmp(x,"Pc")||!strcmp(x,"PKc")||*x=='A')printf("%s",a);\n  else if(!strcmp(x,"d")||!strcmp(x,"f"))printf(OUTPUT_PRECISION,a);\n  else if(!strcmp(x,"x"))printf(INT_64_MOD,a);\n  else if(!strcmp(x,"y"))printf(UNSIGNED_64_MOD,a);\n  else if(!strcmp(x,"e"))cout&lt;&lt;setprecision(LF_PRECISION)&lt;&lt;a;\n  else test("Output format error!\\n");\n}\n\ntemplate&lt;class T1,class T2&gt;\nbool S(T1&amp;a,T2&amp;b){\n  return S(a)+S(b)==2;\n}\n\ntemplate&lt;class T1,class T2,class T3&gt;\nbool S(T1&amp;a,T2&amp;b,T3&amp;c){\n  return S(a)+S(b)+S(c)==3;\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nbool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d){\n  return S(a)+S(b)+S(c)+S(d)==4;\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nbool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d,T5&amp;e){\n  return S(a)+S(b)+S(c)+S(d)+S(e)==5;\n}\n\ntemplate&lt;class T&gt;\nvoid P(T a){\n  _P(a);\n  pc(' ');\n}\n\ntemplate&lt;class T1,class T2&gt;\nvoid P(T1 a,T2 b){\n  _P(a);pc(' ');\n  _P(b);pc(' ');\n}\n\ntemplate&lt;class T&gt;\nvoid PN(T a){\n  _P(a);\n  NL\n}\n\ntemplate&lt;class T1,class T2&gt;\nvoid PN(T1 a,T2 b){\n  _P(a);pc(' ');\n  _P(b);NL\n}\n\ntemplate&lt;class T1,class T2,class T3&gt;\nvoid PN(T1 a,T2 b,T3 c){\n  _P(a);pc(' ');\n  _P(b);pc(' ');\n  _P(c);NL\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nvoid PN(T1 a,T2 b,T3 c,T4 d){\n  _P(a);pc(' ');\n  _P(b);pc(' ');\n  _P(c);pc(' ');\n  _P(d);NL\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nvoid PN(T1 a,T2 b,T3 c,T4 d,T5 e){\n  _P(a);pc(' ');\n  _P(b);pc(' ');\n  _P(c);pc(' ');\n  _P(d);pc(' ');\n  _P(e);NL\n}\n\ntemplate&lt;class T&gt;\nvoid PA(T*a,int n,char c=' '){\n  FR(i,n-1)_P(a[i]),pc(c);\n  PN(a[n-1]);\n}\n\ntemplate&lt;class T&gt;\nvoid PA(const T&amp;x,char c=' '){\n  IT(x) ita=x.begin();\n  FE(it,x){\n    _P(*it);\n    if(++ita==x.end())NL\n    else pc(c);\n  }\n}\n\nint kase;\nconst double pi=4*atan(1);\nconst double ep=1e-9;\n//}\n\nint d[12]={1,-2,1,0,1,0,1,1,0,1,0,1};\n\nbool fun(int x){\n  return x%4==0&amp;&amp;x%100||x%100==0&amp;&amp;x%400==0;\n}\n\nint main(){\n  SHOW_TIME\n  int yy,mm;\n  S(yy,mm);\n  if(yy&lt;2007)return 0;\n  int res=1;\n  FFR(i,2007,yy-1){\n    if(fun(i))res+=366;\n    else res+=365;\n  }\n  FFR(i,1,mm-1){\n    res+=30+d[i-1];\n    if(i==2&amp;&amp;fun(yy))res++;\n  }\n  res=(7-res%7)%7;\n  TEST(res);\n  int tot=30+d[mm-1]+(mm==2&amp;&amp;fun(yy));\n  printf("Calendar %d-%02d\\n",yy,mm);\n  puts("---------------------");\n  puts("Su Mo Tu We Th Fr Sa");\n  puts("---------------------");\n  FOR(i,tot){\n    P(i);\n    if(i%7==res)NL\n  }\n  if(tot%7!=res)NL\n  puts("---------------------");\n}\n\n/*********Risoft corporation all rights reserved*********/\n/**************Template V1.43 build 20150130*************/\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.StreamTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tStreamTokenizer st = new StreamTokenizer(new BufferedReader(\n\t\t\t\tnew InputStreamReader(System.in)));\n\n\t\tst.nextToken();\n\t\tint n = (int) st.nval;\n\t\tst.nextToken();\n\t\tint m = (int) st.nval;\n\n\t\tSystem.out.println("Calendar " + n + "-" + (m &lt; 10 ? "0" + m : m));\n\t\tSystem.out.println("---------------------");\n\t\tSystem.out.println("Su Mo Tu We Th Fr Sa");\n\t\tSystem.out.println("---------------------");\n\n\t\tif (m == 1) {\n\t\t\tm = 13;\n\t\t\tn -= 1;\n\t\t}\n\t\tif (m == 2) {\n\t\t\tm = 14;\n\t\t\tn -= 1;\n\t\t}\n\n\t\tint w = (1 + 2 * m + 3 * (m + 1) / 5 + n + n / 4 - n / 100 + n / 400 + 1) % 7;\n\t\tint c = 1;\n\t\tfor (int i = w; i &lt; 7; i++)\n\t\t\tSystem.out.print(c++ + " ");\n\t\tSystem.out.println();\n\n\t\tint month[] = { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n\t\tif (n % 400 == 0 || (n % 4 == 0 &amp;&amp; n % 100 != 0))\n\t\t\tmonth[2] = 29;\n\t\tint days = month[m == 13 ? 1 : (m == 14 ? 2 : m)] - c + 1;\n\t\twhile (days &gt;= 7) {\n\t\t\tfor (int i = 0; i &lt; 7; i++)\n\t\t\t\tSystem.out.print(c++ + " ");\n\t\t\tSystem.out.println();\n\t\t\tdays -= 7;\n\t\t}\n\t\tif (days &gt; 0)\n\t\t\tfor (int i = 0; i &lt; days; i++) {\n\t\t\t\tif (i == days - 1)\n\t\t\t\t\tSystem.out.println(c);\n\t\t\t\telse\n\t\t\t\t\tSystem.out.print(c++ + " ");\n\t\t\t}\n\t\tSystem.out.println("---------------------");\n\t}\n}\r\n</textarea>	199
199	<div class="des"> \n <pre class="pddata">\n输入一个字符串，编写程序输出该字符串中元音字母的首次出现位置，如果没有元音字母输出0。英语元音字母只有‘a’、‘e’、‘i’、‘o’、‘u’五个。\n</pre> \n <pre class="pddata">\n样例输入: <br>hello<br>样例输出:<br>2\n</pre> \n <pre class="pddata">\n样例输入: <br>apple<br>样例输出:<br>1\n</pre> \n <pre class="pddata">\n样例输入: <br>pmp<br>样例输出:<br>0\n</pre> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\nchar s[1000]={0};\nint isyuanyin(char a)\n{\nswitch(a)\n{\ncase 'a':return 1;\ncase 'e':return 1;\ncase 'i':return 1;\ncase 'o':return 1;\ncase 'u':return 1;\n}\nreturn 0;\n}\nint main()\n{\nint l,i,num=0;\nscanf("%s",s);\nl=strlen(s);\nfor(i=0;i&lt;l;i++)\nif(isyuanyin(s[i]))\n{\nnum=i+1;break;\n}\nprintf("%d",num);\nreturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\nint main()\n{\n\tchar a[100];\n\tcin&gt;&gt;a;\n\tfor(int i=0;i&lt;100;i++)\n\t{\n\t\tif(a[i]=='a'||a[i]=='e'||a[i]=='i'||a[i]=='o'||a[i]=='u')\n\t\t{\n\t\t\tcout&lt;&lt;i+1;\n\t\t\tbreak;\n\t\t}\n\t\tif(i==99)\n\t\t{\n\t\t\tcout&lt;&lt;0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic static void main(String[] args)throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString str = br.readLine();\n\t\tString yy = "aeiouAEIOU";\n\t\tchar[] cs = str.toCharArray();\n\t\tfor(int i=0; i&lt;cs.length; i++){\n\t\t\tif(yy.indexOf(cs[i]) != -1){\n\t\t\t\tSystem.out.println(i+1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(0);\n\t}\n}\r\n</textarea>	200
200	<div class="des"> \n <pre class="pddata">\n从键盘读入n个整数放入数组中，编写函数CompactIntegers，删除数组中所有值为0的元素，其后元素向数组首端移动。注意，CompactIntegers函数需要接受数组及其元素个数作为参数，函数返回值应为删除操作执行后数组的新元素个数。输出删除后数组中元素的个数并依次输出数组元素。\n</pre> \n <pre class="pddata">\n样例输入: （输入格式说明：5为输入数据的个数，3 4 0 0 2 是以空格隔开的5个整数）<br>5 <br>3 4 0 0 2<br>样例输出:（输出格式说明：3为非零数据的个数，3 4 2 是以空格隔开的3个非零整数）<br>3<br>3 4 2\n</pre> \n <pre class="pddata">\n样例输入: <br>7<br>0 0 7 0 0 9 0<br>样例输出:<br>2<br>7 9\n</pre> \n <pre class="pddata">\n样例输入: <br>3<br>0 0 0<br>样例输出:<br>0\n</pre> \n</div>	<textarea id="codelinesc">\r\n#include "stdio.h"\n\nint CompactIntegers(int a[], int len)\n{\n    int i, j, k;\n    for(k=0; k&lt;len; k++)\n    for(i=0; i&lt;len; i++)\n    {\n        if(a[i] == 0)\n        {\n                for(j=i; j&lt;len-1; j++)\n                    a[j] = a[j+1];\n                len--;\n        }\n    }\n    return len;\n}\nvoid print(int a[], int len)\n{\n    int i;\n    for(i=0; i&lt;len; i++)\n        printf("%d ", a[i]);\n    printf("\\n");\n}\nint main()\n{\n    int a[100000];\n    int n;\n    scanf("%d", &amp;n);\n    \n    int i;\n    for(i=0; i&lt;n; i++)\n        scanf("%d", &amp;a[i]);\n    int len = CompactIntegers(a, n);\n    if(len&gt;1)\n    {\n        printf("%d\\n", len);\n        print(a, len);\n    }\n    else\n        printf("%d", 0);\n    getchar();\n    getchar();    \n    getchar();\n    return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include "iostream"\nusing namespace std;\n\nint main()\n{\n\t\n\tint n;\n\tint *arr;\n\n\tcin&gt;&gt;n;\n\tarr = new int[n];\n\tint num = 0;\n\tfor (int i=0; i&lt;n; ++i)\n\t{\n\t\tcin&gt;&gt;arr[i];\n\t\tif(arr[i] != 0)\n\t\t{\n\t\t\t++num;\n\t\t}\n\t}\n\tcout&lt;&lt;num&lt;&lt;endl;\n\tfor (int i=0; i&lt;n; ++i)\n\t{\n\t\tif(arr[i] == 0)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tcout&lt;&lt;arr[i]&lt;&lt;" ";\n\t}\n\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic void input() {\n\t\t\n\t\tScanner cin =new Scanner(System.in);\n\t\tint n = cin.nextInt();\n\t\tint [] num =new int[n];\n\t\tint [] num1 =new int[n];\n\t\tint j=0;\n\t\tfor(int i=0;i&lt;n;i++){\n\t\t\tnum1[i]=cin.nextInt();\n\t\t\tif(num1[i]!=0){\n\t\t\t\tnum[j++]=num1[i];\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(j);\n\t\tif(j&gt;0){\n\t\t\tfor(int i=0;i&lt;j;i++)\n\t\t\tSystem.out.print(num[i]+" ");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().input();\n\t}\n\n}\r\n</textarea>	201
201	<div class="des"> \n <pre class="pddata">\n编写函数，求包含n个元素的整数数组中元素的平均值。要求在函数内部使用指针操纵数组元素，其中n个整数从键盘输入，输出为其平均值。\n</pre> \n <pre class="pddata">\n样例输入: （输入格式说明：5为输入数据的个数，3 4 0 0 2 是以空格隔开的5个整数）<br>5 <br>3 4 0 0 2<br>样例输出:<br>1\n</pre> \n <pre class="pddata">\n样例输入: <br>7<br>3 2 7 5 2 9 1<br>样例输出:<br>4\n</pre> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint main()\n{\nint n,i,j,sum=0;\nscanf("%d",&amp;n);\nfor(i=0;i&lt;n;i++)\n{\nscanf("%d",&amp;j);\nsum+=j;\n}\nprintf("%d",sum/n);\nreturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n//整体平均数\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\nint main()\n{\n    int *a,n,i,sum=0;\n    scanf("%d",&amp;n);\n    a=(int *)malloc(n*sizeof(int));\n    for(i=0;i&lt;n;i++)\n    {\n        scanf("%d",&amp;a[i]);\n        sum+=a[i];\n    }\n    printf("%d\\n",sum/n);\n    return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main{\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(br.readLine().trim());\n\n\t\tint sum = 0;\n\t\tString[] str = br.readLine().split(" ");\n\t\tfor (int i = 0; i &lt; n; i++) {\n\t\t\tsum += Integer.parseInt(str[i]);\n\t\t}\n\t\tSystem.out.println(sum / n);\n\t}\n}\r\n</textarea>	202
202	<div class="des"> \n <pre class="pddata">\n编写函数Normalize，将复数归一化，即若复数为a+bi，归一化结果为a/sqrt(a*a+b*b) + i*b/sqrt(a*a+b*b) 。使用结构体指针类型作为函数参数可能是必要的。其中实部和虚部由键盘输入，输出为归一化结果，如果归一化结果的实部或虚部为小数的要求保留一位小数。\n</pre> \n <pre class="pddata">\n<br>样例输入:（格式说明：3 4 分别为以空格隔开的实数的实部和虚部） <br>3 4 <br>样例输出:<br>0.6+0.8i\n</pre> \n <pre class="pddata">\n样例输入: <br>2 5<br>样例输出:<br>0.4+0.9i<br>\n</pre> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n//a/sqrt(a*a+b*b) + i*b/sqrt(a*a+b*b)\nint main()\n{\nint a,b;\nscanf("%d%d",&amp;a,&amp;b);\nprintf("%.1f+%.1fi",a/sqrt(a*a+b*b),b/sqrt(a*a+b*b));\nreturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\ntypedef struct complex{\n\tfloat real, imag;\n}COMPLEX, *COMPLEXP;\n\nint main(void){\n\tfloat e;\n\tCOMPLEX com;\n\tscanf("%f %f",&amp;(com.real),&amp;(com.imag));\n\te = sqrt(com.imag * com.imag + com.real * com.real);\n\tcom.imag = com.imag/e;\n\tcom.real = com.real/e;\n\tprintf("%0.1f+%0.1fi",com.real,com.imag);\n\treturn 0;\n} \n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader buf=new BufferedReader(new InputStreamReader(System.in));\n\t\tSystem.out.println(Normalize(buf.readLine()));\n\t}\n\tpublic static String Normalize(String str)\n\t{\n\t\tint a=0,b=0;\n\t\tdouble c,d,e;\n\t\tfor(int i=0;i&lt;str.length();i++)\n\t\t{\n\t\t\tif(str.charAt(i)==' ')\n\t\t\t{\n\t\t\t\ta=Integer.parseInt(str.substring(0,i));\n\t\t\t\tb=Integer.parseInt(str.substring(i+1,str.length()));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tc=Math.sqrt(a*a+b*b);\n\t\td=a/c;\n\t\te=b/c;\n\t\td=(int)(d*1000);\n\t\tif(d%10&gt;=5)\n\t\t\td=d+10;\n\t\tif(d%100&gt;=50)\n\t\t\td=d+100;\n\t\td=d/1000;\n\t\td=(int)(d*10);\n\t\te=(int)(e*1000);\n\t\tif(e%10&gt;=5)\n\t\t\te=e+10;\n\t\tif(e%100&gt;=50)\n\t\t\te=e+100;\n\t\te=e/1000;\n\t\te=(int)(e*10);\n\t\tstr=(d/10+"+"+e/10+"i");\n\t\t//a/sqrt(a*a+b*b) + i*b/sqrt(a*a+b*b) \n\t\treturn str;\n\t}\n\n}\n\r\n</textarea>	203
203	<div class="des"> \n <pre class="pddata">\n独立实现标准字符串库的strcmp函数，即字符串比较函数，从键盘输入两个字符串，按字典序比较大小，前者大于后者输出1，前者小于后者输出-1，两者相等输出0。\n</pre> \n <pre class="pddata">\n样例输入: <br>apple one <br>样例输出:<br>-1\n</pre> \n <pre class="pddata">\n样例输入: <br>hello he<br>样例输出:<br>1\n</pre> \n <pre class="pddata">\n<br>样例输入: <br>hello hello<br>样例输出:<br>0\n</pre> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint mystrcpm(char *a,char *b)\n{\nwhile(*a!=0 || *b!=0)\n{\nif(*a &gt; *b) return 1;\nelse if(*a&lt;*b) return -1;\na++;\nb++;\n}\nreturn 0;\n}\n\nint main()\n{\nchar a[100]={0};\nchar b[100]={0};\nscanf("%s%s",a,b);\nprintf("%d",mystrcpm(a,b));\n\nreturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;string.h&gt;\nusing namespace std;\nint main()\n{\n\tchar a[100],b[100];\n\tcin&gt;&gt;a&gt;&gt;b;\n\tif(strcmp(a,b)==0)\n\t{\n\t\tcout&lt;&lt;0;\n\t}\n\tif(strcmp(a,b)&gt;=1)\n\t{\n\t\tcout&lt;&lt;1;\n\t}\n\tif(strcmp(a,b)&lt;=-1)\n\t{\n\t\tcout&lt;&lt;-1;\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tString s1=sc.next();\n\t\tString s2=sc.next();\n\t\tchar[] a1=s1.toCharArray();\n\t\tchar[] a2=s2.toCharArray();\n\t\tif(s1.equals(s2)){\n           System.out.println("0");\n\t\t}\n\t\telse\n\t\tfor(int i=0,j=0;i&lt;a1.length||j&lt;a2.length;i++,j++)\n\t\t{\n\t\t\tif(a1[i]&gt;=a2[j])\n\t\t\t{\n\t\t\t\tSystem.out.println(1);\n                break;\n            }\n\t\t\tif(a1[i]&lt;a2[j])\n\t\t\t{\n\t\t\t\tSystem.out.println(-1);\n                break;\n            }\n\t\t}\n\t}\n\n}\n\r\n</textarea>	204
204	<div class="des"> \n <pre class="pddata">\n从键盘读入n个整数，使用动态数组存储所读入的整数，并计算它们的和与平均值分别输出。要求尽可能使用函数实现程序代码。平均值为小数的只保留其整数部分。\n</pre> \n <pre class="pddata">\n样例输入: <br>5 <br>3 4 0 0 2<br>样例输出:<br>9  1\n</pre> \n <pre class="pddata">\n样例输入: <br>7<br>3 2 7 5 2 9 1<br>样例输出:<br>29  4\n</pre> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint main()\n{\n\tint i,n,a[100],b[100],sum=0,avg=0;\n\tscanf("%d",&amp;n);\n\tfor(i=0;i&lt;n;i++)\n\t{\n\t\tscanf("%d",&amp;b[i]);\n\t\ta[i]=b[i];\n\t\tsum=sum+a[i];\n\t}\n\tavg=sum/n;\n\tprintf("%d  %d\\n",sum,avg);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\nint main()\n{\n\tint n,a,sum=0;\n\tcin&gt;&gt;n;\n\tfor(int i=0;i&lt;n;i++)\n\t{\n\t\tcin&gt;&gt;a;\n\t\tsum+=a;\n\t}\n\tcout&lt;&lt;sum&lt;&lt;" "&lt;&lt;sum/n&lt;&lt;endl;\n\treturn 0;\n} \r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner scan = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t int n = scan.nextInt();\n\t int sum[] =new int[2] ;\n\t fun(n ,sum);\n\t System.out.println(sum[0]+" "+ sum[1]);\n\t}\n   public static void fun(int n ,int sum[] ){\n\t int temp =0 ;\n\t int a[] = new int[n] ;\n\t for(int m =0 ; m&lt; n;m++){\n\t\t a[m] = scan.nextInt() ;\n\t\t temp +=a[m] ;\n\t }\n\t sum[0] = temp ;\n\t sum[1] = temp/n ;\n   }\n}\r\n</textarea>	205
205	<div class="des"> \n <pre class="pddata">\n从键盘读入n个复数（实部和虚部都为整数）用链表存储，遍历链表求出n个复数的和并输出。\n样例输入: <br>3 <br>3 4<br>5 2<br>1 3<br>样例输出:<br>9+9i\n</pre> \n <pre class="pddata">\n样例输入: <br>7<br>1 2<br>3 4<br>2 5<br>1 8<br>6 4<br>7 9<br>3 7<br>样例输出:<br>23+39i\n</pre> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;malloc.h&gt;\ntypedef struct linknode\n{\n\tint x;\n\tint y;\n\tstruct linknode *next;\n}node;\n\nint main()\n{\n\tint n,i,x=0,y=0;\n\tnode *p,*q,*r;\n\tp=q=r=(node *)malloc(sizeof(node));\n\tscanf("%d",&amp;n);\n\tfor(i=0;i&lt;n;i++)\n\t{\n\t\tscanf("%d%d",&amp;(q-&gt;x),&amp;(q-&gt;y));\n\t\tr=(node *)malloc(sizeof(node));\n\t\tq-&gt;next=r;\n\t\tq=r;\n\t}\n\tq-&gt;next=0;\n\tq-&gt;x=0;\n\tq-&gt;y=0;\n\twhile(p!=0)\n\t{\n\t\tx+=p-&gt;x;\n\t\ty+=p-&gt;y;\n\t\tp=p-&gt;next;\n\t}\n\tprintf("%d+%di",x,y);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\nint main()\n{\n\tint n;\n\tcin&gt;&gt;n;\n\tint a,b;\n    int t1=0,t2=0;\n    for(int i=0;i&lt;n;i++)\n    {\n    \tcin&gt;&gt;a&gt;&gt;b;\n    \tt1+=a;\n    \tt2+=b;\n    \t\n    }\n    cout&lt;&lt;t1&lt;&lt;"+"&lt;&lt;t2&lt;&lt;"i"&lt;&lt;endl;\n    return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\n\n\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tList&lt;Integer&gt; shibu=new LinkedList&lt;Integer&gt;();\n\t\tList&lt;Integer&gt; xubu=new LinkedList&lt;Integer&gt;();\n\t\tint n=sc.nextInt();\n\t\tint i=0;\n\t\twhile(i&lt;n){\n\t\t\tshibu.add(sc.nextInt());\n\t\t\txubu.add(sc.nextInt());\n\t\t\ti++;\n\t\t}\n\t\tint sumofShibu=0;\n\t\tint sumOfxuBu=0;\n\t\tfor(i=0;i&lt;shibu.size();i++){\n\t\t\tsumofShibu+=shibu.get(i);\n\t\t\tsumOfxuBu+=xubu.get(i);\n\t\t}\n\t\tif(sumOfxuBu&gt;0){\n\t\t\tSystem.out.println(sumofShibu+"+"+sumOfxuBu+"i");\n\t\t}else{\n\t\t\tSystem.out.println(sumofShibu+""+sumOfxuBu+"i");\n\t\t}\n\t}\n}\n\r\n</textarea>	206
206	<div class="des"> \n <pre class="pddata">\n编写函数，其功能为把一个十进制数转换为其对应的八进制数。程序读入一个十进制数，调用该函数实现数制转换后，输出对应的八进制数。\n<br> 样例输入<br> 9274<br> 样例输出<br> 22072\n样例输入<br> 18<br> 样例输出<br> 22\n</pre> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint main()\n{\nint n;\nscanf("%d",&amp;n);\nprintf("%o",n);\nreturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n   int a,b[50]={0},i=0;\n   scanf("%d",&amp;a);\n   while(a)\n   {\n   \t\tb[i]=a%8;\n\t\ta=a/8;\n\t\ti++;\t\t\t\t\n   }\n   while(b[i]==0)\n   i--;\n   while(i&gt;=0)\n   {\n\t\tprintf("%d",b[i]);\n   \t\ti--;\n   }\n   return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main\n{\n\tpublic static void main(String args[]) throws IOException\n\t{\n\t\tBufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n\t\tString str1 = bf.readLine();\n\t\tint n = Integer.parseInt(str1);\n\t\tString s=Integer.toOctalString(n);\n\t\tSystem.out.print(s);\n\t}\n}\r\n</textarea>	207
207	<div class="des"> \n <div class="pdcont">\n  　　根据输入的正整数n (1　　米字形由一个(2n-1)*(2n-1)的矩阵组成，矩阵包含从大写A开始的n个字母\n  <br> 　　例如:n=3时，包含A,B,C；n=4时，包含A,B,C,D。\n  <br> 　　矩阵的正中间为n个字母中字典序最大的那个，从这个字母开始，沿着西北、正北、东北、正西、正东、西南、正南、东南八个方向各有一条由大写字母组成的直线。并且直线上的字母按字典序依次减小，直到大写字母A。\n  <br> 　　矩阵的其它位置用英文句号．填充。\n  <br> \n  <br> 　　样例输入一\n  <br> 　　3\n  <br> \n  <br> 　　样例输出一\n  <br> 　　Ａ．Ａ．Ａ\n  <br> 　　．ＢＢＢ．\n  <br> 　　ＡＢＣＢＡ\n  <br> 　　．ＢＢＢ．\n  <br> 　　Ａ．Ａ．Ａ\n  <br> \n  <br> 　　样例输入二\n  <br> 　　4\n  <br> \n  <br> 　　样例输出二\n  <br> 　　Ａ．．Ａ．．Ａ\n  <br> 　　．Ｂ．Ｂ．Ｂ．\n  <br> 　　．．ＣＣＣ．．\n  <br> 　　ＡＢＣＤＣＢＡ\n  <br> 　　．．ＣＣＣ．．\n  <br> 　　．Ｂ．Ｂ．Ｂ．\n  <br> 　　Ａ．．Ａ．．Ａ\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint main()\n{\n\tint n,i,j,k,t;\n\tscanf("%d",&amp;n);\n\tchar a[2*n-1][2*n-1];\n\tfor(i=0;i&lt;2*n-1;i++)\n\tfor(j=0;j&lt;2*n-1;j++)\n\ta[i][j]=0;\n\tk=n;\n\t\n\tfor(i=0;i&lt;n-1;i++) //行数 \n\t{\n\t\tk--;  //k为字符间隔 \n\t\tt=i;\n\t\tfor(j=1;j&lt;=3;j++)\n\t\t{\n\t\t  a[i][t]='A'+i;\n\t\t  t+=k;\n\t\t}\n\t}\n\tfor(i=0;i&lt;n;i++)    //中间一行 \n\t{\n\t\ta[n-1][i]='A'+i;\n\t\ta[n-1][2*n-2-i]='A'+i;\n\t}\n\tfor(i=0;i&lt;=n-2;i++)   //填补句号 \n\tfor(j=0;j&lt;2*n-1;j++)\n\t{\n\t\tif(a[i][j]==0)\n\t\ta[i][j]='.';\n\t}\n\t\n\tfor(i=0;i&lt;=n-2;i++)    //翻转 \n\tfor(j=0;j&lt;2*n-1;j++)\n    a[2*n-2-i][j]=a[i][j];\n\t\n\tfor(i=0;i&lt;2*n-1;i++)\n\t{\n\tfor(j=0;j&lt;2*n-1;j++)\n\tprintf("%c",a[i][j]);\n\tprintf("\\n"); \n    }\n\n\t\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include "iostream"\nusing namespace std;\nconst int MAXN = 10000;\nchar g[MAXN][MAXN];\n\nvoid init(int n)\n{\n\tfor (int i = 0; i &lt; 2*n-1; ++i)\n\t{\n\t\tfor (int j = 0; j &lt; 2*n-1; ++j)\n\t\t{\n\t\t\tg[i][j] = '.';\n\t\t}\n\t}\n}\n\nvoid fillg(int n)\n{\n\tint m = (2*n-1)/2;\n\tfor (int i = 0; i &lt;= m; ++i)\n\t{\n\t\tg[i][i] = 'A'+i;\n\t\tg[m][i] = 'A'+i;\n\t\tg[i][m] = 'A'+i;\n\t}\n\n\tfor (int i = 0; i &lt;= m; ++i)\n\t{\n\t\tfor (int j = 2*n-2; j &gt; m; --j)\n\t\t{\n\t\t\tg[i][j] = g[i][2*n-2-j];\n\t\t}\n\t}\n\tfor (int i = 2*n-2; i &gt; m; --i)\n\t{\n\t\tfor (int j = 0; j&lt;2*n-1; ++j)\n\t\t{\n\t\t\tg[i][j] = g[2*n-2-i][j];\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint n;\n\tcin&gt;&gt;n;\n\tinit(n);\n\tfillg(n);\n\tfor (int i = 0; i &lt; 2*n-1; ++i)\n\t{\n\t\tfor (int j = 0; j &lt; 2*n-1; ++j)\n\t\t{\n\t\t\tcout&lt;&lt;g[i][j];\n\t\t}\n\t\tcout&lt;&lt;endl;\n\t}\n\tcout&lt;&lt;endl;\n\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main{\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tint n = Integer.parseInt(br.readLine());\n\n\t\tString str = "";\n\t\tfor (int i = 0; i &lt; n; i++)\n\t\t\tstr += (char) (i + 65);\n\t\tfor (int i = n - 2; i &gt; -1; i--)\n\t\t\tstr += (char) (i + 65);\n\n\t\tint len = n * 2 - 1;\n\n\t\tchar[][] chs = new char[len][len];\n\n\t\tint y = len - 1;\n\t\tfor (int i = 0; i &lt; chs.length; i++) {\n\t\t\tchs[i][i] = str.charAt(i);\n\t\t\tchs[i][y--] = str.charAt(i);\n\t\t\tchs[len / 2][i] = str.charAt(i);\n\t\t\tchs[i][len / 2] = str.charAt(i);\n\t\t}\n\t\t\n\t\tfor (int i = 0; i &lt; chs.length; i++) {\n\t\t\tfor (int j = 0; j &lt; chs[i].length; j++) {\n\t\t\t\tif(!(chs[i][j]&gt;='A' &amp;&amp; chs[i][j]&lt;='Z'))\n\t\t\t\t\tchs[i][j] = '.';\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i &lt; chs.length; i++) {\n\t\t\tfor (int j = 0; j &lt; chs[i].length; j++) {\n\t\t\t\tSystem.out.print(chs[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n\r\n</textarea>	208
208	<div class="des"> \n <div class="pdcont">\n  　　输入一个正整数N (1\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  12\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  6\n </div>\n <div class="pdsec">\n  样例说明\n </div>\n <div class="pdcont">\n  　　12的约数包括：1,2,3,4,6,12。共6个\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint main()\n{\nint n,i,num=0;\nscanf("%d",&amp;n);\nfor(i=1;i&lt;=n;i++)\nif(n%i==0) num++;\nprintf("%d",num);\nreturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\nint main () {\n  int n;\n  while (cin &gt;&gt; n) {\n    int c = 0;\n    for (int i = 1; i &lt;= n; i++) {\n      if (n % i == 0)\n        c++;\n    }\n    cout &lt;&lt; c &lt;&lt; endl;\n  }\n  return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\npublic class Main{\n\n\tpublic static void main(String[] args) throws Exception{\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader buf=new BufferedReader(new InputStreamReader(System.in));\n\t\tint n=Integer.parseInt(buf.readLine());\n\t\tint count=1,i=1,j=n/2;\n\t\tfor(;i&lt;j+1;i++)\n\t\t{\n\t\t\tif(n%i==0)\n\t\t\t\tcount++;\n\t\t}\n\t\tSystem.out.print(count);\n\t}\n\n}\n\r\n</textarea>	209
209	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　编写一个程序，输入两个整数，作为栅格的高度和宽度，然后用“+”、“-”和“|”这三个字符来打印一个栅格。\n  <br> 　　输入格式：输入只有一行，包括两个整数，分别为栅格的高度和宽度。\n  <br> 　　输出格式：输出相应的栅格。\n  <br> 　　输入输出样例\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3 2\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  +-+-+\n  <br> | | |\n  <br> +-+-+\n  <br> | | |\n  <br> +-+-+\n  <br> | | |\n  <br> +-+-+\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint main()\n{\n\tint m,n,i,j,s1,s2;\n\tscanf("%d%d",&amp;m,&amp;n);\n\tchar a[2*m+1][2*n+1];\n\tif(m==0 || n==0)\n\tgoto next;\n    for(i=0;i&lt;2*m+1;i++)\t\n\t{\n\t\tif(i%2==0) s1=0;   //\n\t\telse s1=1;\n\t\tfor(j=0;j&lt;2*n+1;j++)\n\t\t{\n\t\t\tif(j%2==0) s2=0;\n\t\t\telse s2=1;\n\t\t\tif(s1) \n\t\t\t{\n\t\t\t\tif(s2) a[i][j]=' ';\n\t\t\t\telse a[i][j]='|';\n\n\t\t\t}else if(s2)  a[i][j]='-';\n\t\t          else a[i][j]='+';\n\t\t\t\n\t\t}\n\t\t\n\t}\n\tfor(i=0;i&lt;2*m+1;i++)\n\t{\n\t\tfor(j=0;j&lt;2*n+1;j++)\n\t\tprintf("%c",a[i][j]);\n\t\tprintf("\\n");\n\t}\n\tnext:\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\nint main()\n{\n\tint x,y,i,k;\n\tcin&gt;&gt;x&gt;&gt;y;\n\tif(x!=0&amp;&amp;y!=0) \n\t{\n\t\tfor(k=1;k&lt;=2*x+1;k++)\n\t   {\n\t\t   if(k%2==0)\n\t\t   {\n\t\t\t   for(i=1;i&lt;=2*y+1;i++)\n\t          {\n\t\t          if(i%2==0)cout&lt;&lt;' ';\n\t\t          else cout&lt;&lt;'|';\n\t          }\n\t          cout&lt;&lt;endl;\n\t\t   }\n\t\t   else\n\t\t   {\n\t\t\t  for(i=1;i&lt;=2*y+1;i++)\n\t          {\n\t\t          if(i%2==0)cout&lt;&lt;'-';\n\t\t          else cout&lt;&lt;'+';\n\t          }\n\t          cout&lt;&lt;endl;\n\t\t   }\n\t   }\n\t}\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tint m=sc.nextInt();\n\t\tif(n&lt;=0||m&lt;=0)return;\n\t\tSystem.out.print("+");\n\t\tfor(int i=0;i&lt;m;i++){\n\t\t\tSystem.out.print("-+");\n\t\t}\n\t\tSystem.out.println();\n\t\tfor(int i=0;i&lt;n;i++){\n\t\t\tfor(int j=0;j&lt;m;j++)\n\t\t\t\tSystem.out.print("| ");\n\t\t\tSystem.out.println("|");\n\t\t\tfor(int j=0;j&lt;m;j++)\n\t\t\t\tSystem.out.print("+-");\n\t\t\tSystem.out.println("+");\n\t\t}\n\t}\n}\r\n</textarea>	210
210	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　编写一个程序，读入一组整数（不超过20个），当用户输入0时，表示输入结束。然后程序将从这组整数中，把第二大的那个整数找出来，并把它打印出来。说明：（1）0表示输入结束，它本身并不计入这组整数中。（2）在这组整数中，既有正数，也可能有负数。（3）这组整数的个数不少于2个。\n  <br> 　　输入格式：输入只有一行，包括若干个整数，中间用空格隔开，最后一个整数为0。\n  <br> 　　输出格式：输出第二大的那个整数。\n  <br> 　　输入输出样例\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5 8 -12 7 0\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  7\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint main()\n{\nint t,mone,mtwo;\nscanf("%d",&amp;t);\nmone=mtwo=-10000000;\nwhile(t!=0)\n{\nif(t&gt;mone)\n{mtwo=mone,mone=t;}\nelse if(t&gt;mtwo) mtwo=t;\nscanf("%d",&amp;t);\n}\nprintf("%d",mtwo);\nreturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;stdio.h&gt;\nusing namespace std;\nint main()\n{\n    int i,fir,sec,n,map[21],m;\n    cin&gt;&gt;m;\n    n=0;\n    while(m)\n    {\n      map[n++]=m;\n      cin&gt;&gt;m;  \n    }\n    if(map[0]&gt;map[1])\n    {\n        fir=map[0];\n        sec=map[1];\n    }\n    else\n    {\n        fir=map[1];\n        sec=map[0];\n    }\n    for( i=2; i&lt;n; i++)\n    {\n        if(map[i]&gt;fir)\n        {\n            sec=fir;\n            fir=map[i];\n        }\n        if(map[i]&lt;fir&amp;&amp;map[i]&gt;sec)\n            sec=map[i];\n    }\n    cout&lt;&lt;sec&lt;&lt;endl;\n    return 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\n\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main\n{\n\tpublic static void main(String[] args) throws IOException\n\t{\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] str = reader.readLine().split(" ");\n\t\tint[] number = new int[str.length - 1];\n\t\tfor(int i = 0; i &lt; number.length; i++)\n\t\t{\n\t\t\tnumber[i] = Integer.parseInt(str[i]);\n\t\t}\n\t\tfor(int i = 0; i &lt; 2; i++)\n\t\t{\n\t\t\tfor(int j = i + 1; j &lt; number.length; j++)\n\t\t\t{\n\t\t\t\tif(number[i] &lt; number[j])\n\t\t\t\t{\n\t\t\t\t\tint temp = number[j];\n\t\t\t\t\tnumber[j] = number[i];\n\t\t\t\t\tnumber[i] = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(number[1]);\n\t}\n}\n\r\n</textarea>	211
211	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　公安人员审问甲、乙、丙、丁四个嫌疑犯，已确知，这四个人当中仅有一人是偷窃者，还知道这四个人的答话，要么完全诚实，要么完全说谎。在回答公安人员的问话中：\n  <br> 　　甲说：“乙没有偷，是丁偷的。”\n  <br> 　　乙说：“我没有偷，是丙偷的。”\n  <br> 　　丙说：“甲没有偷，是乙偷的。”\n  <br> 　　丁说：“我没有偷，我用的那东西是我家里的。”\n  <br> 　　请根据上述四人答话，判断谁是偷窃者。\n  <br> 　　输入格式：无输入。\n  <br> 　　输出格式：输出一个字符，表示偷窃者是谁，A表示甲，B表示乙，C表示丙，D表示丁。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint main()\n{\nprintf("B");\nreturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\nint main()\n{\ncout&lt;&lt;"B";\n  return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\npublic class Main {\n\t\n\tpublic static void main(String[] args)\n\t{\n\t\tfor(int a=0;a&lt;=1;a++)\n\t\t\tfor(int b=0;b&lt;=1;b++)\n\t\t\t\tfor(int c=0;c&lt;=1;c++)\n\t\t\t\t\tfor(int d=0;d&lt;=1;d++)\n\t\t\t\t\t{\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(((b==0&amp;&amp;d==1)==true||(b==0||d==1)==false)&amp;&amp;((b==0&amp;&amp;c==1)==true||(b==0||c==1)==false)&amp;&amp;((a==0&amp;&amp;b==1)==true||(a==0||b==1)==false))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(a+b+c+d==1)\n\t\t\t\t\t\t\t\tSystem.out.println("B");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t}\n}\n\r\n</textarea>	212
212	<div class="des"> \n <div class="pdcont">\n  <b>问题描述</b>\n  <br> 　　一个整数n的阶乘可以写成n!，它表示从1到n这n个整数的乘积。阶乘的增长速度非常快，例如，13!就已经比较大了，已经无法存放在一个整型变量中；而35!就更大了，它已经无法存放在一个浮点型变量中。因此，当n比较大时，去计算n!是非常困难的。幸运的是，在本题中，我们的任务不是去计算n!，而是去计算n!最右边的那个非0的数字是多少。例如，5! = 1*2*3*4*5 = 120，因此5!最右边的那个非0的数字是2。再如：7! = 5040，因此7!最右边的那个非0的数字是4。请编写一个程序，输入一个整数n(n&lt;=100)，然后输出n! 最右边的那个非0的数字是多少。\n  <br> 　　输入格式：输入只有一个整数n。\n  <br> 　　输出格式：输出只有一个整数，即n! 最右边的那个非0的数字。\n  <br> \n  <b>输入输出样例</b>\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  6\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  2\n </div> \n</div>	<textarea id="codelinesc">\r\n//常州轻工职业技术学院七七队长提供\n#include&lt;stdio.h&gt;\n\n\nint main(void)\n{\n\tint n;\n\tint i;\n\tint sum=1;\n\tscanf("%d",&amp;n);\n\n\tfor(i=n;i&gt;=1;i--)\n\t{\n\t\tsum = sum*i;\n\t\twhile(sum%10==0)\n\t\t\tsum=sum/10;\n\t\tif(sum/100&gt;0)\n\t\t\tsum=sum%100;\n\t}\n\n\tprintf("%d",sum%10);\n\t\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n#include &lt;string&gt;\n#include &lt;windows.h&gt;\n#include &lt;stack&gt;\n#include &lt;vector&gt;\nusing namespace std;\nint main(int argc, char** argv) {\n\tvector&lt;int&gt; cs;\n\tint n;\n\tcin &gt;&gt; n;\n\tcs.push_back(1);\n\tfor (int i = 2; i &lt;= n; i++)\n\t{\n\t\tfor (int j = 0; j&lt;cs.size(); j++)\n\t\t{\n\t\t\tcs[j] *= i;\n\t\t}\n\t\tfor (int j = 0; j&lt;cs.size() - 1; j++)\n\t\t{\n\t\t\tif (cs[j]&gt;9)\n\t\t\t{\n\t\t\t\tcs[j + 1] += cs[j] / 10;\n\t\t\t\tcs[j] = cs[j] % 10;\n\t\t\t}\n\t\t}\n\t\twhile (cs[cs.size() - 1]&gt;9)\n\t\t{\n\t\t\tcs.push_back(cs[cs.size() - 1] / 10);\n\t\t\tcs[cs.size() - 2] = cs[cs.size() - 2] % 10;\n\t\t}\n\t}\n\tfor (int i = 0; i &lt; cs.size() ; i++)\n\t{\n\t\tif (cs[i]!=0)\n\t\t{\n\t\t\tcout &lt;&lt; (char)(cs[i] + '0');\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.math.BigDecimal;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint number = Integer.parseInt(br.readLine());\n\t\tBigDecimal bd = new BigDecimal(1);\n\t\tfor (long i = 1; i &lt;= number; i++) {\n\t\t\tbd = bd.multiply(new BigDecimal(i));\n\t\t}\n\t\tString out = bd.toString();\n\t\tfor (int i = out.length() - 1; i &gt;= 0; i--) {\n\t\t\tif (out.charAt(i) != '0') {\n\t\t\t\tSystem.out.println(out.charAt(i));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t}\n\t}\n}\n\r\n</textarea>	213
213	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　编写一个程序，输入一个字符串（长度不超过80），然后统计出该字符串当中包含有多少个单词。例如：字符串“this is a book”当中包含有4个单词。\n  <br> 　　输入格式：输入一个字符串，由若干个单词组成，单词之间用一个空格隔开。\n  <br> 　　输出格式：输出一个整数，即单词的个数。\n  <br> 　　输入输出样例\n  <br> 　　用户输入数据样例：\n  <br> 　　this is a book\n  <br> 　　系统输出数据如下：\n  <br> 　　4\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#define max 100\nint main()\n{\n\tchar ch[max],*p;\n\tint n,i; \n\t gets(ch); \n\t p=ch;\n\t n=1;\n\t while(*p)\n\t {  \n\t\t if (*p==' ') \n\t\t {\n\t\t\t n++;\n\t\t }  \n\t\t p++;\n\t }\n\t printf("%d\\n",n);\n\t return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n\tchar a[100];\n\tcin.getline(a,100);\n\tint m=1;\n\tfor(int i=0;i&lt;100;i++)\n\t{\n\t\tif(a[i]=='\\n')\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tif(a[i]==' ')\n\t\t{\n\t\t\tm++;\n\t\t}\n\t}\n\tcout&lt;&lt;m;\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\npublic class Main{\n\tpublic static void main(String[] args) throws IOException\n\t{   \n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tString s=br.readLine();\n\t\tString s2[]=s.split(" ");\n\t\tint count=0;\n\t\tfor(int i=0;i&lt;s2.length;i++)\n\t\t{\n\t\t\tif(!s2[i].equals(" ")) count++;\n\t\t\t\n\t\t}\n\t\tSystem.out.println(count);\t\n    }\t\n}\r\n</textarea>	214
214	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　编写一个程序，读入一组整数（不超过20个），并把它们保存在一个整型数组中。当用户输入0时，表示输入结束。然后程序将把这个数组中的值按逆序重新存放，并打印出来。例如：假设用户输入了一组数据：7 19 -5 6 2 0，那么程序将会把前五个有效数据保存在一个数组中，即7 19 -5 6 2，然后把这个数组中的值按逆序重新存放，即变成了2 6 -5 19 7，然后把它们打印出来。\n  <br> 　　输入格式：输入只有一行，由若干个整数组成，中间用空格隔开，最末尾的整数为0。\n  <br> 　　输出格式：输出也只有一行，即逆序排列后的整数，中间用空格隔开，末尾没有空格。\n  <br> 　　输入输出样例\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  7 19 -5 6 2 0\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  2 6 -5 19 7\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include&lt;string.h&gt;\n\n\n\n\nint main ()\n{\n int a[20],i,j,t;\n for( i=0;i&lt;20;i++)\n\t{ scanf("%d",&amp;a[i]);\n       if(a[i]==0)\n\t   {   \n\t\t   break;\n\t   }\n }\n      for(j=0;j&lt;i/2;j++)\n\t\t    {\n\t\t  t=a[i-j-1];\n\t\t  a[i-j-1]=a[j];\n\t\t  a[j]=t;\n\n\t  }\n\t  for(j=0;j&lt;i;j++)\n\t  {  printf("%d ",a[j]);\n\t  if(j==i-1)\n\t     printf("\\b");\n\t  \n\t  } \n           printf("\\n");\nreturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n\nusing namespace std;\n\nint a[25];\n\nint main()\n{\n    int i=0,j,temp;   \n\twhile(cin&gt;&gt;temp)\n\t{\n\t\tif(temp==0)break;\n\t\ta[i]=temp;\n\t\ti++;\n\t}\n\tif(i==0)cout&lt;&lt;endl;\n\telse\n\t{\n\tfor(j=i-1;j&gt;0;j--)\n\tcout&lt;&lt;a[j]&lt;&lt;" ";\n\tcout&lt;&lt;a[0]&lt;&lt;endl;\n    }\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception{\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader buf=new BufferedReader(new InputStreamReader(System.in));\n\t\tString str=buf.readLine()+" ";\n\t\tint i,j,k,l;\n\t\tint [] a=new int [20];\n\t\tfor(i=0,j=0,k=0;i&lt;str.length();i++ )\n\t\t{\n\t\t\tif(str.charAt(i)==' ')\n\t\t\t{\n\t\t\t\tl=Integer.parseInt(str.substring(k,i));\n\t\t\t\tif(l==0)\n\t\t\t\t\tbreak;\n\t\t\t\ta[j]=l;\n\t\t\t\tj++;\n\t\t\t\tk=i+1;\n\t\t\t}\n\t\t}\n\t\tfor(i=j-1;i&gt;=0;i--)\n\t\t\tSystem.out.print(a[i]+" ");\n\t}\n\n}\n\r\n</textarea>	215
215	<div class="des"> \n <div class="pdcont">\n  <b>问题描述</b>\n  <br> 　　编写一个程序，输入一个字符串（长度不超过20），然后把这个字符串内的每一个字符进行大小写变换，即将大写字母变成小写，小写字母变成大写，然后把这个新的字符串输出。\n  <br> 　　输入格式：输入一个字符串，而且这个字符串当中只包含英文字母，不包含其他类型的字符，也没有空格。\n  <br> 　　输出格式：输出经过转换后的字符串。\n  <br> \n  <b>输入输出样例</b>\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  AeDb\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  aEdB\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint main()\n{\n\tint i;\n\tchar ch[100];\n\tgets(ch);\n\ti=0;\n\twhile(ch[i]!='\\0')\n\t{\n\t\tif(ch[i]&lt;='z'&amp;&amp;ch[i]&gt;='a')\n\t\t\tch[i]-=32;\n\t\telse ch[i]+=32;\n\t\ti++;\n\t}\n\tputs(ch);\n\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\nint main()\n{\n    string str;\n    cin&gt;&gt;str;\n    unsigned i;\n    for(i=0;i&lt;str.size();i++)\n    {\n        if(str[i]&gt;='A'&amp;&amp;str[i]&lt;='Z')\n            str[i]+=32;\n        else if(str[i]&gt;='a'&amp;&amp;str[i]&lt;='z')\n            str[i]-=32;\n    }\n    cout&lt;&lt;str;\n    return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\npublic class Main {\n\tpublic static void main(String[] args)throws Exception{\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tString s=br.readLine();\n\t\tint n=s.length();\n\t\tchar ch[]=new char[n];\n\t\tfor(int i=0;i&lt;n;i++){\n\t\t\tch[i]=s.charAt(i);\n\t\t}\n\t\tfor(int i=0;i&lt;n;i++){\n\t\t\tif(ch[i]&gt;='A'&amp;&amp;ch[i]&lt;='Z'){\n\t\t\t\tch[i]+=32;\n\t\t\t}else{\n\t\t\t\tch[i]-=32;\n\t\t\t}\n\t\t}\n\t\tString s1=new String(ch);\n\t\tSystem.out.println(s1);\n\t}\n}\r\n</textarea>	216
216	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　编写一个程序，输入一个二进制的字符串（长度不超过32），然后计算出相应的十进制整数，并把它打印出来。\n  <br> 　　输入格式：输入为一个字符串，每个字符都是’0’或’1’，字符串的长度不超过32。\n  <br> 　　输出格式：输出一个整数。\n  <br> 　　输入输出样例\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  1101\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  13\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\nint main()\n{\nchar a[100]={0};\nlong long int i,len,sum=0;\nscanf("%s",a);\nlen=strlen(a);\ni=1;\nwhile(len&gt;=1)\n{\nif(a[len-1]=='1')\nsum+=i;\ni*=2;\nlen--;\n}\nprintf("%I64d",sum);\nreturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;bitset&gt;\nusing namespace std;\n/* run this program using the console pauser or add your own getch, system("pause") or input loop */\n\nint main(int argc, char** argv) {\n\tbitset&lt;32&gt; bit;\n\tcin&gt;&gt;bit;\n\tcout&lt;&lt;bit.to_ulong();\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\npublic class Main{\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void fun(String n){\n\t\tchar[] arr=n.toCharArray();\n\t\tint j=0,sum=0;\n\t\tfor(int i=arr.length-1;i&gt;=0;i--){\n\t\t   //System.out.print((int)(arr[i]));\n\t\t\tif(arr[j]==(char)(49)){\n\t\t\t\tsum+=Math.pow(2, i);\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\tSystem.out.print(sum);\n\t}\n\tpublic static void main(String[] args)throws IOException {\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tString n=br.readLine();\n       fun(n);\n\t}\n\n}\r\n</textarea>	217
217	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　输入两个矩阵，分别是m*s，s*n大小。输出两个矩阵相乘的结果。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行，空格隔开的三个正整数m,s,n（均不超过200）。\n  <br> 　　接下来m行，每行s个空格隔开的整数，表示矩阵A（i，j）。\n  <br> 　　接下来s行，每行n个空格隔开的整数，表示矩阵B（i，j）。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　m行，每行n个空格隔开的整数，输出相乘後的矩阵C（i，j）的值。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  2 3 2\n  <br> 1 0 -1\n  <br> 1 1 -3\n  <br> 0 3\n  <br> 1 2\n  <br> 3 1\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  -3 2\n  <br> -8 2\n  <br> \n  <br> \n  <b>提示</b>\n  <br> 矩阵C应该是m行n列，其中C(i,j)等于矩阵A第i行行向量与矩阵B第j列列向量的内积。\n  <br> 例如样例中C(1,1)=(1,0,-1)*(0,1,3) = 1 * 0 +0*1+(-1)*3=-3\n  <br> \n  <b> </b>\n </div> \n</div>	<textarea id="codelinesc">\r\n# include&lt;stdio.h&gt;\nint main(){\n\tint m,s,n,i,j,k,a[200][200],b[200][200],c[200][200];\n\tscanf("%d%d%d",&amp;m,&amp;s,&amp;n);\n\tfor(i=1;i&lt;=m;i++){\n\t\tfor(j=1;j&lt;=s;j++)\n\t\t\tscanf("%d",&amp;a[i][j]);\n\t}\n\tfor(i=1;i&lt;=s;i++){\n\t\tfor(j=1;j&lt;=n;j++)\n\t\t\tscanf("%d",&amp;b[i][j]);\n\t}\n\tfor(i=1;i&lt;=m;i++){\n\t\tfor(j=1;j&lt;=n;j++)\n\t\t\tc[i][j]=0;\n\t}\n\tfor(i=1;i&lt;=m;i++){\n\t\tfor(j=1;j&lt;=n;j++){\n\t\t\tfor(k=1;k&lt;=s;k++){\n\t\t\t\tc[i][j]=c[i][j]+a[i][k]*b[k][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=1;i&lt;=m;i++){\n\t\tfor(j=1;j&lt;=n;j++)\n\t\t\tprintf("%d ",c[i][j]);\n\t\tprintf("\\n");\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n#include&lt;stdlib.h&gt;\n#include&lt;ctype.h&gt;\nint main()\n{\n\tint m,s,n;\n\tint sum=0;\n\tint i,j,l;\n\tint a[200][200],b[200][200],c[200][200];\n\tscanf("%d%d%d",&amp;m,&amp;s,&amp;n);\n\tfor(i=0;i&lt;m;i++)\n\t{\n\t\tfor(j=0;j&lt;s;j++)\n\t\tscanf("%d",&amp;a[i][j]);\n\t}\n\tfor(i=0;i&lt;s;i++)\n\t{\n\t\tfor(j=0;j&lt;n;j++)\n\t\tscanf("%d",&amp;b[i][j]);\n\t}\n\t\n\tfor(i=0;i&lt;m;i++)\n\t{\n\t\tfor(j=0;j&lt;n;j++)\n\t\t{\n\t\t\tfor(l=0;l&lt;s;l++)\n\t\t\t{\n\t\t\t\tsum+=(a[i][l]*b[l][j]);\n\t\t\t}\n\t\t\tc[i][j]=sum;\n\t\t\tsum=0;\n\t\t}\n\t}\n\tfor(i=0;i&lt;m;i++)\n\t{\n\t\tfor(j=0;j&lt;n;j++)\n\t\tprintf("%d ",c[i][j]);\n\t\tprintf("\\n");\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tpublic static int m,s,n;\n\tpublic static int[][]a;\n\tpublic static int[][]b;\n\tpublic static int[][]c;\n\tpublic static boolean input() throws IOException{\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tString str=br.readLine();\n\t\tString[] strArr=str.split(" ");\n\t\tif(strArr.length&lt;3) return false;\n\t\tm=Integer.parseInt(strArr[0]);\n\t\ts=Integer.parseInt(strArr[1]);\n\t\tn=Integer.parseInt(strArr[2]);\n\t\tif(m&lt;1||s&lt;1||n&lt;1) return false;\t\n\t\ta=new int[m][s];\n\t\tb=new int[s][n];\n\t\tc=new int[m][n];\n\t\t\n\t\tString[] str_a=new String[m];\t\t\t\t\n\t\tfor(int i=0;i&lt;m;i++){\n\t\t\tstr_a[i]=br.readLine();\n\t\t\tString [] m_s_arr=str_a[i].split(" ");\n\t\t\tfor(int j=0;j&lt;s;j++){\n\t\t\t\ta[i][j]=Integer.parseInt(m_s_arr[j]);\n\t\t\t}\n\t\t}\n\t\tString[] str_b=new String[s];\n\t\tfor(int i=0;i&lt;s;i++){\n\t\t\tstr_b[i]=br.readLine();\n\t\t\tString[] s_n_arr=str_b[i].split(" ");\n\t\t\tfor(int j=0;j&lt;n;j++){\n\t\t\t\tb[i][j]=Integer.parseInt(s_n_arr[j]);\n\t\t\t}\n\t\t}\t\n\t\treturn true;\n\t}\n\tpublic static void cal(){\n\t\tfor(int i=0;i&lt;m;i++){\n\t\t\tfor(int j=0;j&lt;n;j++){\n\t\t\t\t\tint sum=0;\t\t\t\t\n\t\t\t\t\tfor(int k=0;k&lt;s;k++){\n\t\t\t\t\t\tsum+=a[i][k]*b[k][j];\n\t\t\t\t\t}\t\n\t\t\t\t\tc[i][j]=sum;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void print(){\n\t\tfor(int i=0;i&lt;m;i++){\n\t\t\tfor(int j=0;j&lt;n;j++){\n\t\t\t\tSystem.out.print(c[i][j]+"  ");\n\t\t\t}\n\t\t\tSystem.out.println();\t\t\n\t\t}\t\t\n\t}\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\ttry {\n\t\t\tif(input()){\n\t\t\t\tcal();\n\t\t\t\tprint();\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n\r\n</textarea>	218
226	<div class="des"> \n <div class="pdcont">\n  <b>问题描述</b>\n  <br> 　　新生舞会开始了。n名新生每人有三个属性：姓名、学号、性别。其中，姓名用长度不超过20的仅由大小写字母构成的字符串表示，学号用长度不超过10的仅由数字构成的字符串表示，性别用一个大写字符‘F’或‘M’表示。任意两人的姓名、学号均互不相同。换言之，每个人可被其姓名或学号唯一确定。给出m对两人的信息（姓名或学号），判断他们是否能共舞。两人能共舞的充要条件为两人性别相异。\n  <br> \n  <br> \n  <b>输入</b>\n  <br> 　　第一行一个整数n（2&lt;=n&lt;=1000），表示学生人数。接下来的n行每行依次包含一名新生的姓名、学号、性别，分别用一个空格隔开。\n  <br> 　　之后的一行是一个整数m(1&lt;=m&lt;=1000)，表示询问的数目。接着的m行每行包含两个信息（姓名或学号），保证两个信息不属于同一人，中间用一个空格隔开。\n  <br> \n  <br> \n  <b>输出</b>\n  <br> 　　对于每个询问输出一行，如果两人可以共舞，输出一个大写字母‘Y’，否则输出一个大写字母‘N’。\n  <br> \n  <br> \n  <br> \n  <b>样例输入</b>\n  <br> 　　4\n  <br> 　　John 10 M\n  <br> 　　Jack 11 M\n  <br> 　　Kate 20 F\n  <br> 　　Jim 21 M\n  <br> 　　3\n  <br> 　　John 11\n  <br> 　　20 Jack\n  <br> 　　Jim Jack\n  <br> \n  <br> \n  <br> \n  <b>样例输出</b>\n  <br> 　　N\n  <br> 　　Y\n  <br> 　　N\n  <br> \n  <br> \n  <b>提示</b>\n  <br> 　　可以把名字和学号都当成字符串处理。可以按以下流程实现。\n  <br> \n  <br> 　　#include&lt;iostream&gt;\n  <br> 　　#include&lt;cstring&gt;\n  <br> 　　using namespace std;\n  <br> \n  <br> 　　struct tstudent\n  <br> 　　{\n  <br> 　　char name[21];\n  <br> 　　char num[21];\n  <br> 　　char sex;\n  <br> 　　};\n  <br> \n  <br> 　　void readdata(tstudent student[], int n)\n  <br> 　　{\n  <br> \n  <b>输入N个学生的信息</b>\n  <br> 　　}\n  <br> \n  <br> 　　int findstudent(tstudent student[], int n, char* data)\n  <br> 　　{\n  <br> 　　if (data == NULL) return -1;\n  <br> \n  <br> \n  <b>判断是否有某个学生的学号或名字等于data，如果有，函数返回该学生在student数组中的序号，否则返回-1</b>\n  <br> 　　}\n  <br> \n  <br> 　　void solve(tstudent student[], int n, int m)\n  <br> 　　{\n  <br> 　　char x[21], y[21];\n  <br> 　　for (int i=0; i&lt;m; i++) {\n  <br> \n  <b>输入两个人的信息X、Y。通过调用findstudent函数判断这两个人能否成为舞伴</b>\n  <br> 　　}\n  <br> 　　}\n  <br> \n  <br> 　　int main()\n  <br> 　　{\n  <br> 　　int n, m;\n  <br> 　　tstudent student[1010];\n  <br> \n  <br> 　　cin&gt;&gt;n;\n  <br> \n  <br> 　　readdata(student, n);\n  <br> 　　cin&gt;&gt;m;\n  <br> 　　solve(student, n, m);\n  <br> 　　}\n </div> \n</div>	<textarea id="codelinesc">\r\n# include &lt;stdio.h&gt;\n# include &lt;string.h&gt;\nstruct stu{\n\tchar name[21];\n\tchar num[21];\n\tchar sex;\n\t};\n\n\nint main()\n{\n\t\n\tint i,n,m,j;\n\tchar s1[20],s2[10];\n\tchar se1,se2;\n\tstruct stu stu1[1001];\n\tscanf("%d",&amp;n);\n\t\n\tfor(i=1;i&lt;=n;i++){\n\t\tscanf("%s %s %c",&amp;stu1[i].name,&amp;stu1[i].num,&amp;stu1[i].sex);\n\t}\n\tscanf("%d",&amp;m);\n\t\n\tfor(i=1;i&lt;=m;i++)\n\t{\n\t\tscanf("%s %s",&amp;s1,&amp;s2);\n\t\tfor(j=1;j&lt;=n;j++)\n\t\t{\n\t\t\tif(strcmp(s1,stu1[j].name)==0 || strcmp(s1,stu1[j].num)==0)\n\t\t\t{\n\t\t\t\tse1=stu1[j].sex;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(j=1;j&lt;=n;j++)\n\t\t{\n\t\t\tif(strcmp(s2,stu1[j].name)==0 || strcmp(s2,stu1[j].num)==0)\n\t\t\t{\n\t\t\t\tse2=stu1[j].sex;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(se2==se1) printf("N\\n");\n\t\telse printf("Y\\n");\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;cstring&gt;\nusing namespace std;\n\nstruct tstudent\n{\n\tchar name[21];\n\tchar num[21];\n\tchar sex;\n};\n\nvoid readdata(tstudent student[], int n)\n{\n\t//输入N个学生的信息\n\tint i;\n\tfor(i=0;i&lt;n;i++)\n\t{\n\t\tcin&gt;&gt;student[i].name&gt;&gt;student[i].num&gt;&gt;student[i].sex;\n\t}\n}\n\nint findstudent(tstudent student[], int n, char* data)\n{\n\tif (data == NULL)\n\t\treturn -1;\n\t//判断是否有某个学生的学号或名字等于data，如果有，函数返回该学生在student数组中的序号，否则返回-1\n\tint i;\n\tfor(i=0;i&lt;n;i++)\n\t{\n\t\tif(strcmp(student[i].name,data)==0 || strcmp(student[i].num,data)==0){\n\t\t//\tcout&lt;&lt;student[i].name&lt;&lt;"\\t"&lt;&lt;student[i].num&lt;&lt;"\\t"&lt;&lt;student[i].sex&lt;&lt;"\\t"&lt;&lt;data&lt;&lt;"\\t"&lt;&lt;strcmp(student[i].name,data)&lt;&lt;"\\t"&lt;&lt;strcmp(student[i].num,data)&lt;&lt;endl;\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\t\nvoid solve(tstudent student[], int n, int m)\n{\n\tchar x[21], y[21];\n\tfor (int i=0; i&lt;m; i++) {\n\t\t//输入两个人的信息X、Y。通过调用findstudent函数判断这两个人能否成为舞伴\n\t\tcin&gt;&gt;x&gt;&gt;y;\n\t\tint a = findstudent(student,n,x);\n\t\tint b = findstudent(student,n,y);\n\t\t\n\t\tif(student[a].sex == student[b].sex)\n\t\t\tcout&lt;&lt;"N"&lt;&lt;endl;\n\t\telse\n\t\t\tcout&lt;&lt;"Y"&lt;&lt;endl;\n\t}\n}\n\nint main(void)\n{\n\tint n, m;\n\ttstudent student[1010];\n\t\n\tcin&gt;&gt;n;\n\t\n\treaddata(student, n);\n\tcin&gt;&gt;m;\n\tsolve(student, n, m);\n\treturn 0; \n}\r\n</textarea>	<textarea id="codelinesjava">\r\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tstatic Stu[] stu ;\n\t\n\tpublic static void main(String[] args) throws IOException {\t\t\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tint n=Integer.parseInt(br.readLine());\n\t\tstu=new Stu[n];\n\t\tfor(int i=0;i&lt;n;i++){\n\t\t\tString []str=br.readLine().split(" ");\n\t\t\tStu tem=new Stu(str[0],str[1],str[2]);\n\t\t\tstu[i]=tem;\n\t\t}\n\t\tint m=Integer.parseInt(br.readLine());\n\t\tString[][] str=new String[m][2];\n\t\tfor(int i=0;i&lt;m;i++){\n\t\t\tString []tem=br.readLine().split(" ");\n\t\t\tstr[i][0]=tem[0];\n\t\t\tstr[i][1]=tem[1];\n\t\t}\t\t\n\t\tString[][] arr=new String[m][2];\t\t\n\t\t\n\t\tfor(int i=0;i&lt;m;i++){\t\n\t\t\tString tem1=str[i][0];\n\t\t\tString tem2=str[i][1];\n\t\t\tfor(int p=0;p&lt;n;p++){\n\t\t\t\tif(stu[p].getStuID().equals(tem1)||stu[p].getStuName().equals(tem1)){\n\t\t\t\t\tarr[i][0]=stu[p].getStuSex();\n\t\t\t\t}\t\t\t\t\n\t\t\t\tif(stu[p].getStuID().equals(tem2)||stu[p].getStuName().equals(tem2)){\n\t\t\t\t\tarr[i][1]=stu[p].getStuSex();\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\n\t\tfor(int i=0;i&lt;m;i++){\n\t\t\tif(!arr[i][0].equals(arr[i][1])){\n\t\t\t\tSystem.out.println("Y");\n\t\t\t}else{\n\t\t\t\tSystem.out.println("N");\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass Stu{\n\tString StuID;\n\tString StuName;\n\tString StuSex;\n\tpublic Stu(String stuID, String stuName, String stuSex) {\n\t\tsuper();\n\t\tStuID = stuID;\n\t\tStuName = stuName;\n\t\tStuSex = stuSex;\n\t}\n\tpublic String getStuID() {\n\t\treturn StuID;\n\t}\n\tpublic String getStuName() {\n\t\treturn StuName;\n\t}\n\tpublic String getStuSex() {\n\t\treturn StuSex;\n\t}\n}\n\r\n</textarea>	227
218	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　给定一个长度为n的字符串S，还有一个数字L，统计长度大于等于L的出现次数最多的子串（不同的出现可以相交），如果有多个，输出最长的，如果仍然有多个，输出第一次出现最早的。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行一个数字L。\n  <br> 　　第二行是字符串S。\n  <br> 　　L大于0，且不超过S的长度。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　一行，题目要求的字符串。\n  <br> \n  <br> 　　输入样例1：\n  <br> 　　4\n  <br> 　　bbaabbaaaaa\n  <br> \n  <br> 　　输出样例1：\n  <br> 　　bbaa\n  <br> \n  <br> 　　输入样例2：\n  <br> 　　2\n  <br> 　　bbaabbaaaaa\n  <br> \n  <br> 　　输出样例2：\n  <br> 　　aa\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　n&lt;=60\n  <br> 　　S中所有字符都是小写英文字母。\n </div>\n <div class="pdsec">\n  提示\n </div>\n <div class="pdcont">\n  　　枚举所有可能的子串，统计出现次数，找出符合条件的那个\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nint main(){\n\tchar S[1000],str[1000][1000],temp[100],out[100];\n\tint L,i=0,s,otongji=0,ttongji,a,b,c;\n\tscanf("%d%c%c",&amp;L,&amp;S[0],&amp;S[0]);\n\twhile(S[i]!='\\n'){\n                           scanf("%c",&amp;S[i+1]);\n                           i++;\n                           }\n    S[i] = '\\0';\n    for(s=i+1;L&lt;=s;L++){\n                        for(a=0;a&lt;s+1-L;a++){//赋值 \n                                             for(b = 0;b &lt; L;b++){\n                                                   str[a][b]=S[a+b];\n                                             }\n                                             str[a][b] = '\\0';\n                        }\n                        \n                        \n                        for(i = 0;i &lt; a-1;){//比较 \n                              for(b = 0;b&lt;a;b++){\n                                    if(str[b][0]!='\\0'){\n                                          for(c = 0;c&lt;L;c++){\n                                                temp[c]=str[b][c];\n                                          }\n                                          temp[c] = '\\0';\n                                          ttongji = 1;\n                                          i++;\n                                          str[b][0] = '\\0';\n                                          break;\n                                    }\n                              }\n                              for(b++;b&lt;a;b++){\n                                     if(!strcmp(str[b],temp)){\n                                          ttongji++;\n                                          i++;\n                                          str[b][0] = '\\0';\n                                     }\n                              } \n                              if(ttongji &gt; otongji||(ttongji==otongji&amp;&amp;strlen(temp)&gt;strlen(out))){\n                                    strcpy(out,temp);\n                                    otongji = ttongji;\n                              }\n                        }\n                        \n                        \n    }\n    i = 0;\n    while(out[i] != '\\0'){\n            printf("%c",out[i]);\n            i++;\n            }\n    getchar();\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\nint main()\n{\n\tchar s[65],str[65];\n\tint max=0,t,n,len;\n\tscanf("%d%s",&amp;n,s);\n\tlen=strlen(s);\n\tif(n&lt;=len)\n\t{\n\t\tchar ss[65],tt[65];\n\t\tfor(int i=len;i&gt;=n;i--)\n\t\t{\n\t\t\tss[i]=tt[i]='\\0';\n\t\t\tfor(int j=0;j&lt;=len-i;j++)\n\t\t\t{\n\t\t\t\tt=1;\n\t\t\t\tfor(int k=0;k&lt;i;k++)\n\t\t\t\t    ss[k]=s[k+j];\n\t\t\t\tfor(int x=j+1;x&lt;=len-i;x++)\n\t\t\t\t{\n\t\t\t\t\tfor(int y=0;y&lt;i;y++)\n\t\t\t\t\t    tt[y]=s[y+x];\n\t\t\t\t\tif(strcmp(ss,tt)==0)\n\t\t\t\t\t   t++;    \n\t\t\t\t}\n\t\t\t\tif(t&gt;max)\n\t\t        {\n\t\t\t       max=t;\n\t\t\t       strcpy(str,ss);\n//\t\t\t       printf("%s\\n",str);\n\t\t        }    \n\t\t\t}\n\t\t}\n\t\tprintf("%s\\n",str);\n\t}\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\nclass Main \n{\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tBufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n\t\tint A =Integer.parseInt(bf.readLine());\n\t\tString s = bf.readLine().toLowerCase();\n\t\tchar c []=s.toCharArray();\n\t\tint ok_number = 0;\n\t\tString ok_s0="",ok_s="";\n\t\tif (A&lt;=60 &amp;&amp; A&gt;0 &amp;&amp; A&lt;c.length){\n\t\t\tchar ok_char[] =new char[c.length];\n\t\t\tint max=1,m=1;\n\t\t\tok_s=""+c[0];\n\t\t\tok_char[A]='\\0';\n\t\t\tint a=0;int MAX=1;a=A;\n\t\t\tfor (a=A;a&lt;c.length;a++)\n\t\t\t{\n\t\t\t\tfor (int i=0;i&lt;c.length-a ;i++ )\n\t\t\t\t{\n\t\t\t\t\tfor (int j = i+1;j&lt;=c.length-a ;j++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int k=0;k&lt;a ;k++ )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (c[i+k]==c[j+k])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tok_char[ok_number]=c[i+k];\n\t\t\t\t\t\t\t\tok_number++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ok_number==a)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tm++;\n\t\t\t\t\t\t\tok_s0= new String(ok_char,0,a);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tok_number=0;\n\t\t\t\t\t}\n\t\t\t\t\tif (max&lt;m)\n\t\t\t\t\t{\n\t\t\t\t\t\tmax=m;\n\t\t\t\t\t\ts = ok_s0;\n\t\t\t\t\t}\n\t\t\t\t\tm=1;\n\t\t\t\t}\n\t\t\t\tif (MAX&lt;=max)\n\t\t\t\t{\n\t\t\t\t\tMAX=max;\n\t\t\t\t\tok_s=s;\n\t\t\t\t}\n\t\t\t\tmax=1;\n\t\t\t}\n\t\t\tSystem.out.print(ok_s);\n\t\t}\n\t}\n}\n\r\n</textarea>	219
219	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　给定一个长度为n的字符串S，还有一个数字L，统计长度大于等于L的出现次数最多的子串（不同的出现可以相交），如果有多个，输出最长的，如果仍然有多个，输出第一次出现最早的。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行一个数字L。\n  <br> 　　第二行是字符串S。\n  <br> 　　L大于0，且不超过S的长度。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　一行，题目要求的字符串。\n  <br> \n  <br> 　　输入样例1：\n  <br> 　　4\n  <br> 　　bbaabbaaaaa\n  <br> \n  <br> 　　输出样例1：\n  <br> 　　bbaa\n  <br> \n  <br> 　　输入样例2：\n  <br> 　　2\n  <br> 　　bbaabbaaaaa\n  <br> \n  <br> 　　输出样例2：\n  <br> 　　aa\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　n&lt;=60\n  <br> 　　S中所有字符都是小写英文字母。\n </div>\n <div class="pdsec">\n  提示\n </div>\n <div class="pdcont">\n  　　枚举所有可能的子串，统计出现次数，找出符合条件的那个\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nchar b[60][60];\nint c[60];\nint main()\n{\n\tint l,i1,max=1,now=0,maxn=1,i2,weizhi=0,i3,i4,weizhi1,changdu1=-1;\n\t\n\tchar a[10000];\n\tscanf("%d",&amp;l);\n\tgetchar();\n\tgets(a);\n\tint n=strlen(a);\n\t\n\tfor(i1=n;i1&gt;=l;i1--)//长度 \n\t{\n\t\tweizhi=0;\n\t\t for(i3=0;i3&lt;n-i1;i3++)\n\t\t        c[i3]=0;\n\t\tfor(i2=0;i2&lt;n;i2++)//开始位置 \n\t\t{\n\t\t\tif(i2+i1&gt;n) \n\t\t\t  break;\n\t        int ok=1;\t  \n\t\t   \n\n            for(i3=0;i3&lt;weizhi;i3++)//b的位置 \n\t\t\t{     int ko=1;\n\t\t\t      for(i4=0;i4&lt;i1;i4++)\t\n\t\t\t       {  \n       \t\t\t      if(b[i3][i4]!=a[i2+i4])\n\t\t\t\t\t\t \tko=0;\n\t\t\t\t\t\t \t\n       \t\t\t   }\n       \t\t\t   if(ko)\n       \t\t\t     {  ok=0;\n   \t\t\t            c[i3]++;\n\t\t\t\t\t\tif(c[i3]&gt;max)\n\t\t\t\t\t\t   {max=c[i3];\n\t\t\t\t\t\t    changdu1=i1;\n\t\t\t\t\t\t    weizhi1=i2;\n\t\t\t\t\t\t   }\n\t\t\t\t\t\tbreak;\n\t\t\t         }\n\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(ok)\n\t\t\t{\n\t\t\t\tfor(i4=0;i4&lt;i1;i4++)\n\t\t\t\t{\n\t\t\t\t\tb[weizhi][i4]=a[i2+i4];\n\t\t\t\t}\n\t\t\t\tc[weizhi]=1;\n\t\t\t\tweizhi++;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\n\t\t\n\t}\n\n\tfor(i1=weizhi1;i1&lt;weizhi1+changdu1;i1++)\n\t  printf("%c",a[i1]);\n\t  printf("\\n");\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdlib.h&gt;\n#include&lt;stdio.h&gt;\n#include&lt;bitset&gt;\n#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\n\nint main()\n{\n\tstring s;\n\tint l;\n\tcin&gt;&gt;l;\n\tcin&gt;&gt;s;\n\tint map[60][60]={0};\n\tfor(int i=0;i&lt;s.length();i++)\n\t{\n\t\tfor(int j=0;j&lt;s.length();j++)\n\t\t{\n\t\t\tif(i==j)\n\t\t\t{\n\t\t\t\tmap[i][j]=0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(s[i]==s[j])\n\t\t\t\t{\n\t\t\t\t\tif(i&gt;0 &amp;&amp; j&gt;0)\n\t\t\t\t\t\tmap[i][j]=map[i-1][j-1]+1; \n\t\t\t\t\telse\n\t\t\t\t\t\tmap[i][j]=1;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint m[60][60]={0};//计算每一行某个数值出现的次数只计算大于l的数值\n\tint max=0;\n\tfor(int i=0;i&lt;60;i++)\n\t{\n\t\tfor(int j=0;j&lt;60;j++)\n\t\t{\n\t\t\tint val=map[i][j];//取出数值\n\t\t\tif(val&gt;=l)\n\t\t\t{\n\t\t\t\tm[i][val]++;//累加 \n\t\t\t\tif(m[i][val]&gt;max)\n\t\t\t\t{\n\t\t\t\t\tmax=m[i][val];\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}\t\n\t} \n\tfor(int j=59;j&gt;=0;j--)//从后向前找保证字符是最长的 \n\t{\n\t\tfor(int i=0;i&lt;60;i++)//从前向后找保证字符是最早出现的 \n\t\t{\n\t\t\tif(m[i][j]==max)\n\t\t\t{\n\t\t\t\tcout&lt;&lt;s.substr(i-j+1,j)&lt;&lt;endl;\n\t\t\t\treturn 0;\n\t\t\t}\t\t\n\t\t}\t\n\t} \n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\npublic class Main\n{  \n\tpublic static void main(String[] args)\n\t{\n\tScanner sc=new Scanner(System.in);\n\tint L=sc.nextInt();\n\tString s=sc.next();\n\tMain a=new Main();\n\ta.childs(L,s);\n\t}\n\n\n  public void childs(int L,String s)\n  {\n   String  s1[][]=new String[60][60];\n   int in[][]=new int[60][60];\n     int max=0;\n     int td=0;\n     int tj=0;\n   for(int i=L;i&lt;s.length();i++)\n   for(int j=0;j&lt;=s.length()-i;j++)\n   {\n\t   s1[i][j]=s.substring(j,j+i);\n   }\n   \n   for(int i=L;i&lt;s.length();i++)\n\t   for(int j=0;j&lt;=s.length()-i;j++)\n\t\t   for(int k=j;k&lt;=s.length()-i;k++)\n\t\t\t   if(s1[i][k].equals(s1[i][j]))\n\t\t\t   {\n\t\t\t\t   in[i][j]=in[i][j]+1;\n\t\t\t   }\n\t\t   \n   \n\n \n   for(int i=L;i&lt;=s.length();i++)\n\t   for(int j=0;j&lt;=s.length()-i;j++)   \n\t   {\n\t\t   if(in[i][j]&gt;=max &amp;&amp; td!=i)\n\t\t   {\n\t\t\t   max=in[i][j];\n\t\t\t   td=i;\n\t\t\t   tj=j;\n\t\t   }else if(in[i][j]&gt;max)\n\t\t   {\n\t\t\t   max=in[i][j];\n\t\t\t   td=i;\n\t\t\t   tj=j;\n\t\t   }\n\t   }\n     System.out.println(s1[td][tj]);\n  \n  }\n}\r\n</textarea>	220
220	<div class="des"> \n <div class="pdcont">\n  <b> </b>\n  <br> \n  <b>问题描述</b>\n  <br> 　　编写一个程序，先输入一个字符串str（长度不超过20），再输入单独的一个字符ch，然后程序会把字符串str当中出现的所有的ch字符都删掉，从而得到一个新的字符串str2，然后把这个字符串打印出来。\n  <br> 　　输入格式：输入有两行，第一行是一个字符串（内部没有空格），第二行是一个字符。\n  <br> 　　输出格式：经过处理以后的字符串。\n  <br> \n  <b>输入输出样例</b>\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  123-45-678\n  <br> -\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  12345678\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nint main()\n{\n    char str[21],t[21],c;\n    int i,len,count=0;\n    gets(str);\n    scanf("%c",&amp;c);\n    len=strlen(str);\n    for(i=0;i&lt;len;i++)\n    {\n    \tif(str[i]!=c)\n    \tt[count++]=str[i];\n    }\n    for(i=0;i&lt;count;i++)\n    printf("%c",t[i]);\n    printf("\\n");\n    return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\nint main(){\n\tstring str1,str2;\n\tchar ch;\n\tgetline(cin,str1);\n\tcin&gt;&gt;ch;\n\tint i;\n\tfor(i=0;i&lt;str1.size();i++)\n\t\tif(str1[i]!=ch)\n\t\t\tstr2+=str1[i];\n\tcout&lt;&lt;str2&lt;&lt;endl;\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Calendar;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main \n{\t\n\tpublic static void main(String args[]) throws Exception\n\t{\n\t\t//Scanner sc = new Scanner(System.in);\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString str = br.readLine();\n\t\tchar ch = (char) br.read();\n\t\t\n\t\tSystem.out.println(str.replace(String.valueOf(ch), ""));\n\t\t\n\t}\n\n}\r\n</textarea>	221
221	<div class="des"> \n <div class="pdcont">\n  　　﻿\n  <b>问题描述</b>\n  <br> 　　编写一个程序，读入一组整数，这组整数是按照从小到大的顺序排列的，它们的个数N也是由用户输入的，最多不会超过20。然后程序将对这个数组进行统计，把出现次数最多的那个数组元素值打印出来。如果有两个元素值出现的次数相同，即并列第一，那么只打印比较小的那个值。\n  <br> 　　输入格式：第一行是一个整数\n  <i>N</i>，\n  <i>N</i> £ 20；接下来有\n  <i>N</i>行，每一行表示一个整数，并且按照从小到大的顺序排列。\n  <br> 　　输出格式：输出只有一行，即出现次数最多的那个元素值。\n  <br> \n  <b>输入输出样例</b>\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5\n  <br> 100\n  <br> 150\n  <br> 150\n  <br> 200\n  <br> 250\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  150\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint main()\n{\n\tint n,i,j,t,max=1,num=0;\n\tscanf("%d",&amp;n);\n\tif(n&gt;0)\n\t{\n\tint a[n];\n\tfor(i=0;i&lt;n;i++)\n\tscanf("%d",a+i);\n\tj=num=a[0];\n\tt=1;\n\tfor(i=1;i&lt;n;i++)\n\tif(a[i]==j)\n\t{\n\t\t++t;\n\t\tif(t&gt;max)\n\t\t{\n\t\t\tmax=t;num=a[i];\n\t\t} \n\t}\n\telse\n\t{\n\t\tt=1;\n\t\tj=a[i];\n\t}\n\tprintf("%d",num);\n\t}\n\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include "iostream"\n#include "string"\nusing namespace std;\nint main()\n{\n\tint n;\n\tcin&gt;&gt;n;\n\tif(n &lt;= 0) return 0;\n\tstring *a = new string[n];\n\tint i;\n\tfor(i = 0; i &lt; n; ++i)\n\t\tcin&gt;&gt;a[i];\n\tstring number = a[0];\n\tint count = 1;\n\tint flag = 1;\n\tfor(i = 1; i &lt; n; ++i)\n\t{\n\t\tif(a[i].compare(a[i - 1]) == 0)\n\t\t\tflag = flag + 1;\n\t\tif(a[i].compare(a[i - 1]) == 0 || i == n -1)\n\t\t{\n\t\t\tif(flag &gt; count)\n\t\t\t{\n\t\t\t\tcount = flag;\n\t\t\t\tnumber = a[i - 1];\n\t\t\t}\n\t\t\tflag = 1;\n\t\t}\n\t}\n\tcout&lt;&lt;number&lt;&lt;endl;\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\n\npublic class Main {\t\n\tpublic static void main(String[] args) {\n\t\ttry{\n\t\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in),1);\t\t\n\t\t\t\tString line=br.readLine();\n\t\t\t\tint n=Integer.parseInt(line);\n\t\t\t\tif(n&gt;0){\n\t\t\t\tint[][] num=new int[2][n];\n\t\t\t\tint max=1,maxn=0;\n\t\t\t\tfor(int i=0;i&lt;n;i++){\n\t\t\t\t\tline=br.readLine();\n\t\t\t\t\tnum[0][i]=Integer.parseInt(line);\n\t\t\t\t\tint g=1;\n\t\t\t\t\tfor(int j=i-1;j&gt;=0;j--)\n\t\t\t\t\t\tif(num[0][j]==num[0][i]){\n\t\t\t\t\t\t\tg=num[1][j]+1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tnum[1][i]=g;\n\t\t\t\t\tif(g&gt;max){\n\t\t\t\t\t\tmax=g;\n\t\t\t\t\t\tmaxn=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(num[0][maxn]);\n\t\t\t\t}else System.out.println("");\n\t\t}catch(Exception e){\n\t\t\tSystem.out.println("Message:"+e.getMessage());\n\t\t}\n\t}\n\t\n}\r\n</textarea>	222
222	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　Anagrams指的是具有如下特性的两个单词：在这两个单词当中，每一个英文字母（不区分大小写）所出现的次数都是相同的。例如，“Unclear”和“Nuclear”、“Rimon”和“MinOR”都是Anagrams。编写一个程序，输入两个单词，然后判断一下，这两个单词是否是Anagrams。每一个单词的长度不会超过80个字符，而且是大小写无关的。\n  <br> 　　输入格式：输入有两行，分别为两个单词。\n  <br> 　　输出格式：输出只有一个字母Y或N，分别表示Yes和No。\n  <br> 　　输入输出样例\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  Unclear\n  <br> Nuclear\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  Y\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nvoid sort(char a[],int len)\n{\n\tint i,j,max;\n\tfor(i=0;i&lt;len;i++)\n\t{\n\t\tmax=i;\n\t\tfor(j=i+1;j&lt;len;j++)\n\t\tif(a[j]&gt;a[max]) max=j;\n\t\tj=a[i];a[i]=a[max];a[max]=j;\n\t}\n}\nvoid strtoupper(char a[],int len)\n{\n\tint i;\n\tfor(i=0;i&lt;len;i++)\n\tif(a[i]&gt;='a' &amp;&amp; a[i]&lt;='z') a[i]-=32;\n}\nint mystrcmp(char a[],int l1,char b[],int l2)\n{\n\tif(l1!=l2) return 0;\n\tint i;\n\tfor(i=0;i&lt;l1;i++)\n\tif(a[i]!=b[i]) return 0;\n\treturn 1;\n}\n\n\nint mystrlen(char *p)\n{\n\tint l=0;\n\twhile(*p++!=0)\n\tl++;\n\treturn l;\n}\nint main()\n{\n\tchar s1[1000]={0},s2[1000]={0};\n\tint l1,l2;\n\tscanf("%s%s",s1,s2);\n\tl1=mystrlen(s1);\n\tl2=mystrlen(s2);\n\tstrtoupper(s1,l1);\n\tstrtoupper(s2,l2);\n\tsort(s1,l1);\n\tsort(s2,l2);\n    if(mystrcmp(s1,l1,s2,l2)) printf("Y");\n    else printf("N");\nreturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n#include &lt;string&gt;\n#include &lt;windows.h&gt;\n#include &lt;stack&gt;\n#include &lt;vector&gt;\n#include &lt;iomanip&gt; \n#include &lt;stack&gt; \n#include &lt;set&gt;\n#include &lt;map&gt;\nusing namespace std;\nchar GetCapital(char c)\n{\n\tif(c&lt;='Z')\n\t\treturn c;\n\telse\n\t\treturn c-('a'-'A');\t\n}\nint main(int argc, char** argv) {\n\tmap&lt;char,int&gt; a,b;\n\tstring t;\n\tcin&gt;&gt;t;\n\tfor(int i=0;i&lt;t.length();i++)\n\t\ta[GetCapital(t[i])]++;\n\tcin&gt;&gt;t;\n\tfor(int i=0;i&lt;t.length();i++)\n\t\tb[GetCapital(t[i])]++;\n\tif(a==b)\n\t\tcout&lt;&lt;"Y";\n\telse\n\t\tcout&lt;&lt;"N";\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.util.Arrays;\npublic class Main{\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args)throws IOException {\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tString s1=br.readLine();\n\t\tString s2=br.readLine();\n\t\tString st1=s1.toLowerCase();\n\t\tString st2=s2.toLowerCase();\n\t\tchar[] str1=st1.toCharArray();\n\t\tchar[] str2=st2.toCharArray();\n\t\tint[] arr1=new int[str1.length];\n\t\tint[] arr2=new int[str2.length];\n\t\tif(str1.length==str2.length){\n\t\tfor(int i=0;i&lt;str1.length;i++){\n\t\t\tarr1[i]=(int)(str1[i]);\n\t\t\tarr2[i]=(int)(str2[i]);\n\t\t\tif(arr1[i]&gt;96){\n\t\t\t\tarr1[i]=arr1[i]-32;\n\t\t\t}\n\t\t\tif(arr2[i]&gt;96){\n\t\t\t\tarr2[i]=arr2[i]-32;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tArrays.sort(arr1);\n\t\tArrays.sort(arr2);\n\t\tint count1=0,count2=0;\n\t\tfor(int i=0;i&lt;str1.length;i++){\n\t\t\tif(arr1[i]==arr2[i]){\n\t\t\t\tcount1++;\n\t\t\t}\n\t\t\tcount2++;\n\t\t\t//System.out.print(arr1[i]+" "+arr2[i]+" ");\n\t\t}\n\t\t//System.out.print(count1+"   "+count2);\n\t\tif(count1==count2){\n\t\t\tSystem.out.print("Y");\n\t\t}\n\t\telse{\n\t\t\tSystem.out.print("N");\n\t\t}\n\t\t}\n\t\telse{\n\t\t\tSystem.out.print("N");\n\t\t}\n\t}\n\n}\r\n</textarea>	223
223	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　N个人要打水，有M个水龙头，第i个人打水所需时间为Ti，请安排一个合理的方案使得所有人的等待时间之和尽量小。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行两个正整数N M 接下来一行N个正整数Ti。\n  <br> 　　N,M&lt;=1000，Ti&lt;=1000\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　最小的等待时间之和。（不需要输出具体的安排方案）\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  7 3\n  <br> 3 6 1 4 2 5 7\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  11\n </div>\n <div class="pdsec">\n  提示\n </div>\n <div class="pdcont">\n  　　一种最佳打水方案是，将N个人按照Ti从小到大的顺序依次分配到M个龙头打水。\n  <br> 　　例如样例中，Ti从小到大排序为1，2，3，4，5，6，7，将他们依次分配到3个龙头，则去龙头一打水的为1，4，7；去龙头二打水的为2,5；去第三个龙头打水的为3,6。\n  <br> 　　第一个龙头打水的人总等待时间 = 0 + 1 + (1 + 4) = 6\n  <br> 　　第二个龙头打水的人总等待时间 = 0 + 2 = 2\n  <br> 　　第三个龙头打水的人总等待时间 = 0 + 3 = 3\n  <br> 　　所以总的等待时间 = 6 + 2 + 3 = 11\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nvoid sort(int a[],int l)\n{\n\tint i,j,min,k;\n\tfor(i=0;i&lt;l;i++)\n\t{\n\t\tmin=a[i],k=i;\n\t\tfor(j=i+1;j&lt;l;j++)\n\t\t{\n\t\t\tif(a[j]&lt;min)\n\t\t\t{\n\t\t\t\tmin=a[j];k=j;\n\t\t\t}\t\n\t\t}\n\t\tj=a[i];a[i]=a[k];a[k]=j;\n\t}\t\n}\nint main()\n{\nint n,m,i,t=0,j=0;;\nint temp[1000]={0};\nscanf("%d%d",&amp;n,&amp;m);\nint time[n];\nfor(i=0;i&lt;n;i++)\nscanf("%d",time+i);\nsort(time,n);\nfor(i=0;i&lt;n;i++)\n{\n\tt+=temp[j];\n\ttemp[j]+=time[i];\n\tj++;\n\tif(j==m) j=0;\n}\n   printf("%d",t);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint comp(const void* a, const void* b)\n{\n\treturn *((int*)a) - *((int*)b);\n}\n\nint return_min_and_cut(int tt[], int size, int &amp;tag)\n{\n\tint i = 0;\n\tint num = 0;\n\t\n\tif(size == 1)\n\t{\n\t\ttag = 0;\n\t\treturn tt[0];\n\t}\n\t\n\tnum = tt[0];\n\ttag = 0;\n\t\n\tfor(i = 1; i &lt; size; i ++)\n\t{\n\t\tif(num &gt; tt[i])\n\t\t{\n\t\t\tnum = tt[i];\n\t\t\ttag = i;\n\t\t}\n\t}\n\t\n\tfor(i = 0; i &lt; size; i ++)\n\t{\n\t\ttt[i] -= num;\n\t}\n\t\n\treturn num;\n}\n\n\nint main()\n{\n\tint t[1000];\n\tint tt[1000];\n\tint m = 0, n = 0;\n\tint size = 0;\n\tint i = 0;\n\tint tag = 0;\n\tint all_time = 0, min_num = 0, wait_num = 0;\n\t\n\tscanf("%d %d", &amp;n, &amp;m);\n\twait_num = n - m;\n\t\n\tfor(i = 0; i &lt; n; i ++)\n\t{\n\t\tscanf("%d", &amp;t[i]);\n\t}\n\t\n\tif(n &lt;= m)\n\t{\n\t\tprintf("%d", 0);\n\t\treturn 0;\n\t}\n\t\n\tqsort(t, n, sizeof(int), comp);\n\t\n\tfor(i = 0; i &lt; m; i ++ )\n\t{\n\t\ttt[i] = t[i];\n\t}\n\t\n\tfor(tag = 0, i = m; wait_num != 0; i ++)\n\t{\n\t\tmin_num = return_min_and_cut(tt, m, tag);\n\t\ttt[tag] = t[i];\n\t\tall_time += wait_num*min_num;\n\t\twait_num --;\n\t}\n\t\n\tprintf("%d", all_time);\n\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tpublic static void main(String args[])throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint n = Integer.parseInt(st.nextToken()), m = Integer.parseInt(st.nextToken());\n\t\tst = new StringTokenizer(br.readLine());\n\t\tint[] time = new int[n];\n\t\tfor(int i=0; i&lt;n; i++)time[i] = Integer.parseInt(st.nextToken());\n\t\tArrays.sort(time);\n\t\tint total = 0;\n\t\tfor(int i=1; i&lt;=m; i++){\n\t\t\tint p = n/m;\n\t\t\tif(n%m&gt;=i)p++;\n\t\t\tfor(int index = i-1; index&lt;n; index+=m, p--)\n\t\t\t\ttotal += time[index]*(p-1);\n\t\t}\n\t\tSystem.out.println(total);\n\t}\n}\r\n</textarea>	224
224	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　编写一个程序，以字符串方式输入一个前缀表达式，然后计算它的值。输入格式为：“运算符 对象1 对象2”，其中，运算符为“+”（加法）、“-”（减法）、“*”（乘法）或“/”（除法），运算对象为不超过10的整数，它们之间用一个空格隔开。要求：对于加、减、乘、除这四种运算，分别设计相应的函数来实现。\n  <br> 　　输入格式：输入只有一行，即一个前缀表达式字符串。\n  <br> 　　输出格式：输出相应的计算结果（如果是除法，直接采用c语言的“/”运算符，结果为整数）。\n  <br> 　　输入输出样例\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  + 5 2\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  7\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint main()\n{ int a[2];\n  int i,j;\n  char c=getchar();\n  for(i=0;i&lt;2;i++)\n  scanf("%d",&amp;a[i]);\n  if(c=='+')\n\t  j=a[0]+a[1];\n  else if(c=='-')\n\t  j=a[0]-a[1];\n  else if(c=='*')\n\t  j=a[0]*a[1];\n  else if(c=='/')\n\t  j=a[0]/a[1];\n  printf("%d",j);\n  return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\nint main()\n{\nchar c;\nint a,b;\ncin&gt;&gt;c&gt;&gt;a&gt;&gt;b;\nint res;\nif(c=='+')res=a+b;\nelse if(c=='-')res=a-b;\nelse if(c=='*')res=a*b;\nelse res=a/b;\ncout&lt;&lt;res;\nreturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n\t\tString s=bf.readLine();\n\t\tString [] str = s.split(" ");\n\t\tint a=Integer.parseInt(str[1]);\n\t\tint b=Integer.parseInt(str[2]);\n\t\tif("+".equals(str[0])){\n\t\t\tadd(a,b);\n\t\t}else if("-".equals(str[0])){\n\t\t\tsubtract(a, b);\n\t\t}else if("*".equals(str[0])){\n\t\t\tmultiply(a, b);\n\t\t}else{\n\t\t\tdivide(a, b);\n\t\t}\n\t}\n\t\n\tpublic static void add(int a, int b){\t\t\t\n\t\tSystem.out.println(a + b);\n\t}\n\n\tpublic static void subtract(int a, int b){\n\t\tSystem.out.println(a - b);\n\t}\n\n\tpublic static void multiply(int a, int b){\n\t\tSystem.out.println(a * b);\n\t}\n\n\tpublic static void divide(int a, int b){\n\t\tif(b != 0){\n\t\t\tSystem.out.println(a / b);\n\t\t}else {\n\t\t\tSystem.out.println("by zero");\n\t\t}\n\t}\n\n}\r\n</textarea>	225
225	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　一个整数的“反置数”指的是把该整数的每一位数字的顺序颠倒过来所得到的另一个整数。如果一个整数的末尾是以0结尾，那么在它的反置数当中，这些0就被省略掉了。比如说，1245的反置数是5421，而1200的反置数是21。请编写一个程序，输入两个整数，然后计算这两个整数的反置数之和sum，然后再把sum的反置数打印出来。要求：由于在本题中需要多次去计算一个整数的反置数，因此必须把这部分代码抽象为一个函数的形式。\n  <br> 　　输入格式：输入只有一行，包括两个整数，中间用空格隔开。\n  <br> 　　输出格式：输出只有一行，即相应的结果。\n  <br> 　　输入输出样例\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  435 754\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  199\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\nint inverse(int m);\nint inverse_sum(int a,int b);    \nint main()\n{\t\nint a,b,sum;   \n\tscanf("%d %d",&amp;a,&amp;b);\n \tsum=inverse_sum(a,b);\t\nsum=inverse(sum);\t\nprintf("%d\\n",sum);    \nreturn 0;\n}\nint inverse(int m)\n{\t\nchar str[6];\t\nint i,j;\t\ni=0;\t\nwhile(m)\t\n{\t\t\nstr[i++]=m%10+'0';\t\t\nm/=10;\t\n}\t\nstr[i]='\\0';\t\nj=atoi(str);\t\nreturn (j);\n}\nint inverse_sum(int a,int b)\n{\t\nint j,k;\t\nj=inverse(a);\t\nk=inverse(b);        \nreturn j+k;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n/**************Powered by Graphene Richards**************/\n//{\n#define OUTPUT_PRECISION "%.2f"\n#define INT_64_MOD "%I64d" ///"%I64d" or "%lld"\n#define UNSIGNED_64_MOD "%I64u" ///"%I64d" or "%lld"\n\n#define CONTEST_STARTED     true\n\n#define CONTEST_START_HOUR  11\n#define CONTEST_START_MIN   0\n#define CONTEST_START_SEC   0\n\n#define CONTEST_DUR_HOUR    5\n#define CONTEST_DUR_MIN     0\n#define CONTEST_DUR_SEC     0\n\n//#pragma comment(linker,"/STACK:102400000,102400000")\n#include&lt;cmath&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;bitset&gt;\n#include&lt;vector&gt;\n#include&lt;iomanip&gt;\n#include&lt;iostream&gt;\n#include&lt;list&gt;\n#include&lt;map&gt;\n#include&lt;queue&gt;\n#include&lt;set&gt;\n#include&lt;stack&gt;\n#include&lt;string&gt;\n#include&lt;typeinfo&gt;\n#define __________ ios_base::sync_with_stdio(0),cin.tie(0);\n#define ll long long\n#define IT(x) __typeof((x).begin())\n#define FS(i,a) for(int i=0;a[i];i++)\n#define FE(x,ctn) for(IT(ctn)x=(ctn).begin(),CluhxSchFuDeugk=(ctn).end();x!=CluhxSchFuDeugk;x++)\n#define FR(i,en) for(int i=0,pJNwFPtlXiwFoIv=(en);i&lt;pJNwFPtlXiwFoIv;i++)\n#define FOR(i,en) for(int i=1,SbKCIcakJTeYVqs=(en);i&lt;=SbKCIcakJTeYVqs;i++)\n#define FFR(i,x,y) for(int i=(x),alVDbhLBoMEGSwA=(y);i&lt;=alVDbhLBoMEGSwA;i++)\n#define DFFR(i,x,y) for(int i=(x),NWYfecAcmGBMJuU=(y);i&gt;=NWYfecAcmGBMJuU;i--)\n#define mp make_pair\n#define pb push_back\n#define pq priority_queue\n#define fi first\n#define se second\n#define lb(x) (x&amp;(-x))\n#define sqr(x) (x)*(x)\n#define all(x) (x).begin(),(x).end()\n#define clr(x) memset((x),0,sizeof(x))\n#define inf(x) memset((x),0x7F,sizeof(x))\n#define _inf(x) memset((x),0x80,sizeof(x))\n#define NL puts("");\nusing namespace std;\n\ntemplate&lt;class T1,class T2,class T3&gt;\nbool IN(T1 x,T2 y,T3 z){\n  return x&lt;=y&amp;&amp;x&gt;=z||x&lt;=z&amp;&amp;x&gt;=y;\n}\n\ntemplate&lt;class T&gt;\nT gcd(T a,T b){\n  if(!b)\n    return a;\n  while(b^=a^=b^=a%=b);\n  return a;\n}\n\n#ifdef wmx16835\n#include&lt;ctime&gt;\nstruct Time_wmx{\n  int t;\n  Time_wmx(int a,int b,int c):t(a*3600+b*60+c){}\n  Time_wmx(int x):t(x){}\n  Time_wmx(){}\n  operator int(){return t;}\n  void print(){printf("%02d:%02d:%02d",t/3600%24,t/60%60,t%60);}\n};\n\nvoid OVZmetNNpAqAVZx(){\n  //__________;\n  time_t t=time(0);\n  srand(t);\n  tm*p=localtime(&amp;t);\n  Time_wmx day(24,0,0),cur(p-&gt;tm_hour,p-&gt;tm_min,p-&gt;tm_sec),beg(CONTEST_START_HOUR,CONTEST_START_MIN,CONTEST_START_SEC),len(CONTEST_DUR_HOUR,CONTEST_DUR_MIN,CONTEST_DUR_SEC),en(beg+len),fen(beg+en+day&gt;&gt;1),seg;\n  if(beg&gt;cur)\n    cur.t+=day;\n  puts("  +--------------------------+");\n  if(IN(cur,beg,en)&amp;&amp;CONTEST_STARTED){\n    puts("  |      Status: Running     |");\n    printf("  |     Progress: %5.1f %%    |\\n",(double)(cur-beg)/len*100);\n    seg.t=en-cur;\n    printf("  | Remaining time: ");\n    seg.print();\n    puts(" |");\n  }\n  else{\n    printf("  |  Current time: ");\n    cur.print();\n    puts("  | ");\n    if(cur&lt;=fen||!CONTEST_STARTED)\n      puts("  |       Status: Ended      |");\n    else{\n      puts("  |     Status: Scheduled    |");\n      cur.t-=day;\n      seg.t=beg-cur;\n      printf("  | Remaining time: ");\n      seg.print();\n      puts(" |");\n    }\n  }\n  puts("  +--------------------------+");\n  puts("................................\\n");\n}\n\nvoid pCJUYxWEXKaDOIC(){\n  int num=1;\n  FILE*p=fopen("FILE_NAME","r");\n  if(p){\n    fscanf(p,"%d",&amp;num);\n    fclose(p);\n  }\n  char f_name[1024];\n  sprintf(f_name,"%d.out",num++);\n  printf("[NOTICE] Standard output has been redirected to \\"%s\\".\\n",f_name);\n  freopen(f_name,"w",stdout);\n  if(!stdout)\n    exit(1);\n  else\n  p=fopen("FILE_NAME","w");\n  if(p){\n    fprintf(p,"%d",num);\n    fclose(p);\n  }\n}\n\n#define LOG {unsigned ijqQjAZZNYpJYBe=clock();\n#define TEL printf("\\n----------------------\\nExecution time: %ums\\n----------------------\\n",clock()-ijqQjAZZNYpJYBe);}\n#define SHOW_TIME OVZmetNNpAqAVZx();\n#define test printf\n#define PF pCJUYxWEXKaDOIC();\n#else\n#define LOG\n#define TEL\n#define SHOW_TIME\n#define test\n#define PF\n#endif\n\nint S(char*a){\n  return scanf("%s",a)==1;\n}\n\ntemplate&lt;class T&gt;\nint S(T&amp;a){\n  const char*x=typeid(a).name();\n  if(!strcmp(x,"i")||!strcmp(x,"b"))return scanf("%d",&amp;a)==1;\n  else if(!strcmp(x,"j"))return scanf("%u",&amp;a)==1;\n  else if(!strcmp(x,"c"))return scanf("%c",&amp;a)==1;\n  else if(!strcmp(x,"Pc")||*x=='A')return scanf("%s",a)==1;\n  else if(!strcmp(x,"f"))return scanf("%f",&amp;a)==1;\n  else if(!strcmp(x,"d")||!strcmp(x,"e"))return scanf("%lf",&amp;a)==1;\n  else if(!strcmp(x,"x"))return scanf(INT_64_MOD,&amp;a)==1;\n  else if(!strcmp(x,"y"))return scanf(UNSIGNED_64_MOD,&amp;a)==1;\n  else test("Input format error!\\n");\n}\n\ntemplate&lt;class T&gt;\nvoid _P(T a){\n  const char*x=typeid(a).name();\n  if(!strcmp(x,"i")||!strcmp(x,"b"))printf("%d",a);\n  else if(!strcmp(x,"j"))printf("%u",a);\n  else if(!strcmp(x,"c"))printf("%c",a);\n  else if(!strcmp(x,"Pc")||!strcmp(x,"PKc")||*x=='A')printf("%s",a);\n  else if(!strcmp(x,"d")||!strcmp(x,"e")||!strcmp(x,"f"))printf(OUTPUT_PRECISION,a);\n  else if(!strcmp(x,"x"))printf(INT_64_MOD,a);\n  else if(!strcmp(x,"y"))printf(UNSIGNED_64_MOD,a);\n  else test("Output format error!\\n");\n}\n\ntemplate&lt;class T1,class T2&gt;\nint S(T1&amp;a,T2&amp;b){\n  return S(a)+S(b)==2;\n}\n\ntemplate&lt;class T1,class T2,class T3&gt;\nint S(T1&amp;a,T2&amp;b,T3&amp;c){\n  return S(a)+S(b)+S(c)==3;\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nint S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d){\n  return S(a)+S(b)+S(c)+S(d)==4;\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nint S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d,T5&amp;e){\n  return S(a)+S(b)+S(c)+S(d)+S(e)==5;\n}\n\ntemplate&lt;class T&gt;\nvoid P(T a){\n  _P(a);\n  putchar(' ');\n}\n\ntemplate&lt;class T&gt;\nvoid PN(T a){\n  _P(a);\n  NL\n}\n\ntemplate&lt;class T1,class T2&gt;\nvoid PN(T1 a,T2 b){\n  _P(a);putchar(' ');\n  _P(b);NL\n}\n\ntemplate&lt;class T1,class T2,class T3&gt;\nvoid PN(T1 a,T2 b,T3 c){\n  _P(a);putchar(' ');\n  _P(b);putchar(' ');\n  _P(c);NL\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nvoid PN(T1 a,T2 b,T3 c,T4 d){\n  _P(a);putchar(' ');\n  _P(b);putchar(' ');\n  _P(c);putchar(' ');\n  _P(d);NL\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nvoid PN(T1 a,T2 b,T3 c,T4 d,T5 e){\n  _P(a);putchar(' ');\n  _P(b);putchar(' ');\n  _P(c);putchar(' ');\n  _P(d);putchar(' ');\n  _P(e);NL\n}\n\nint kase;\nconst double pi=4*atan(1);\n//}\n\nint fan(int x){\n  int res=0;\n  while(x){\n    res*=10;\n    res+=x%10;\n    x/=10;\n  }\n  return res;\n}\n\nint main(){\n  SHOW_TIME\n  int a,b;\n  S(a,b);\n  P(fan(fan(a)+fan(b)));\n}\n\n/*********Risoft corporation all rights reserved*********/\n/**************Template V1.26 build 20141210*************/\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\t\n\tstatic int sum;\n\t\n\tprivate static int rpNum(String str1) {\n\t\t// TODO Auto-generated method stub\n\t\tStringBuffer sb=new StringBuffer(str1);\t\n\t\tsb=sb.reverse();\t\n\t\tStringBuffer tem=new StringBuffer();\n\t\tboolean ch=false;\n\t\tfor(int i=0;i&lt;sb.length();i++){\t\t\t\n\t\t\tif(sb.charAt(i)!='0'){\n\t\t\t\tch=true;\n\t\t\t}\t\t\t\n\t\t\tif(ch){\n\t\t\t\ttem.append(sb.charAt(i));\n\t\t\t}\n\t\t}\n\t\treturn Integer.parseInt(tem.toString());\n\t}\n\t\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] strNum=br.readLine().split(" ");\n\t\tfor(int i=0;i&lt;2;i++){\n\t\t\tsum+=rpNum(strNum[i]);\n\t\t}\t\n\t\t\n\t\tSystem.out.println(rpNum(new Integer(sum).toString()));\n\t\t\n\t}\n}\n\r\n</textarea>	226
227	<div class="des"> \n <div class="pdcont">\n  <b> </b>\n  <br> \n  <b>问题描述</b>\n  <br> 　　编写一个程序，输入一个句子，然后统计出这个句子当中不同的单词个数。例如：对于句子“one little two little three little boys”，总共有5个不同的单词：one, little, two, three, boys。\n  <br> 　　说明：（1）由于句子当中包含有空格，所以应该用gets函数来输入这个句子；（2）输入的句子当中只包含英文字符和空格，单词之间用一个空格隔开；（3）不用考虑单词的大小写，假设输入的都是小写字符；（4）句子长度不超过100个字符。\n  <br> 　　输入格式：输入只有一行，即一个英文句子。\n  <br> 　　输出格式：输出只有一行，是一个整数，表示句子中不同单词的个数。\n  <br> \n  <b>输入输出样例</b>\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  one little two little three little boys\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  5\n  <br> \n  <b> </b>\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\nchar s[100][100];\nvoid del(int l)\n{\n\tint i,j;\n\tfor(i=0;i&lt;l;i++)\n\tfor(j=i+1;j&lt;l;j++)\n\tif(strcmp(s[i],s[j])==0) s[j][0]=0;\n}\n\n\nint main()\n{\nchar c=1;\nint l=0,i,j=0;\nwhile(c!='\\n')\t\n{\n\tscanf("%s",s[l]);\n\tl++;\n\tif(scanf("%c",&amp;c)==EOF) break;\n}\t\ndel(l);\t\nfor(i=0;i&lt;l;i++)\t\nif(s[i][0]!=0) j++;\t\nprintf("%d",j);\t\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n/**************Powered by Graphene Richards**************/\n//{\n#define OUTPUT_PRECISION "%.2f"\n#define INT_64_MOD "%I64d" ///"%I64d" or "%lld"\n#define UNSIGNED_64_MOD "%I64u" ///"%I64d" or "%lld"\n\n#define CONTEST_STARTED     true\n\n#define CONTEST_START_HOUR  11\n#define CONTEST_START_MIN   0\n#define CONTEST_START_SEC   0\n\n#define CONTEST_DUR_HOUR    5\n#define CONTEST_DUR_MIN     0\n#define CONTEST_DUR_SEC     0\n\n//#pragma comment(linker,"/STACK:102400000,102400000")\n#include&lt;cmath&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;bitset&gt;\n#include&lt;vector&gt;\n#include&lt;iomanip&gt;\n#include&lt;iostream&gt;\n#include&lt;list&gt;\n#include&lt;map&gt;\n#include&lt;queue&gt;\n#include&lt;set&gt;\n#include&lt;stack&gt;\n#include&lt;string&gt;\n#include&lt;typeinfo&gt;\n#define __________ ios_base::sync_with_stdio(0),cin.tie(0);\n#define ll long long\n#define IT(x) __typeof((x).begin())\n#define FS(i,a) for(int i=0;a[i];i++)\n#define FE(x,ctn) for(IT(ctn)x=(ctn).begin(),CluhxSchFuDeugk=(ctn).end();x!=CluhxSchFuDeugk;x++)\n#define FR(i,en) for(int i=0,pJNwFPtlXiwFoIv=(en);i&lt;pJNwFPtlXiwFoIv;i++)\n#define FOR(i,en) for(int i=1,SbKCIcakJTeYVqs=(en);i&lt;=SbKCIcakJTeYVqs;i++)\n#define FFR(i,x,y) for(int i=(x),alVDbhLBoMEGSwA=(y);i&lt;=alVDbhLBoMEGSwA;i++)\n#define DFFR(i,x,y) for(int i=(x),NWYfecAcmGBMJuU=(y);i&gt;=NWYfecAcmGBMJuU;i--)\n#define mp make_pair\n#define pb push_back\n#define pq priority_queue\n#define fi first\n#define se second\n#define lb(x) (x&amp;(-x))\n#define sqr(x) (x)*(x)\n#define all(x) (x).begin(),(x).end()\n#define clr(x) memset((x),0,sizeof(x))\n#define inf(x) memset((x),0x7F,sizeof(x))\n#define _inf(x) memset((x),0x80,sizeof(x))\n#define NL puts("");\nusing namespace std;\n\ntemplate&lt;class T1,class T2,class T3&gt;\nbool IN(T1 x,T2 y,T3 z){\n  return x&lt;=y&amp;&amp;x&gt;=z||x&lt;=z&amp;&amp;x&gt;=y;\n}\n\ntemplate&lt;class T&gt;\nT gcd(T a,T b){\n  if(!b)\n    return a;\n  while(b^=a^=b^=a%=b);\n  return a;\n}\n\n#ifdef wmx16835\n#include&lt;ctime&gt;\nstruct Time_wmx{\n  int t;\n  Time_wmx(int a,int b,int c):t(a*3600+b*60+c){}\n  Time_wmx(int x):t(x){}\n  Time_wmx(){}\n  operator int(){return t;}\n  void print(){printf("%02d:%02d:%02d",t/3600%24,t/60%60,t%60);}\n};\n\nvoid OVZmetNNpAqAVZx(){\n  //__________;\n  time_t t=time(0);\n  srand(t);\n  tm*p=localtime(&amp;t);\n  Time_wmx day(24,0,0),cur(p-&gt;tm_hour,p-&gt;tm_min,p-&gt;tm_sec),beg(CONTEST_START_HOUR,CONTEST_START_MIN,CONTEST_START_SEC),len(CONTEST_DUR_HOUR,CONTEST_DUR_MIN,CONTEST_DUR_SEC),en(beg+len),fen(beg+en+day&gt;&gt;1),seg;\n  if(beg&gt;cur)\n    cur.t+=day;\n  puts("  +--------------------------+");\n  if(IN(cur,beg,en)&amp;&amp;CONTEST_STARTED){\n    puts("  |      Status: Running     |");\n    printf("  |     Progress: %5.1f %%    |\\n",(double)(cur-beg)/len*100);\n    seg.t=en-cur;\n    printf("  | Remaining time: ");\n    seg.print();\n    puts(" |");\n  }\n  else{\n    printf("  |  Current time: ");\n    cur.print();\n    puts("  | ");\n    if(cur&lt;=fen||!CONTEST_STARTED)\n      puts("  |       Status: Ended      |");\n    else{\n      puts("  |     Status: Scheduled    |");\n      cur.t-=day;\n      seg.t=beg-cur;\n      printf("  | Remaining time: ");\n      seg.print();\n      puts(" |");\n    }\n  }\n  puts("  +--------------------------+");\n  puts("................................\\n");\n}\n\nvoid pCJUYxWEXKaDOIC(){\n  int num=1;\n  FILE*p=fopen("FILE_NAME","r");\n  if(p){\n    fscanf(p,"%d",&amp;num);\n    fclose(p);\n  }\n  char f_name[1024];\n  sprintf(f_name,"%d.out",num++);\n  printf("[NOTICE] Standard output has been redirected to \\"%s\\".\\n",f_name);\n  freopen(f_name,"w",stdout);\n  if(!stdout)\n    exit(1);\n  else\n  p=fopen("FILE_NAME","w");\n  if(p){\n    fprintf(p,"%d",num);\n    fclose(p);\n  }\n}\n\n#define LOG {unsigned ijqQjAZZNYpJYBe=clock();\n#define TEL printf("\\n----------------------\\nExecution time: %ums\\n----------------------\\n",clock()-ijqQjAZZNYpJYBe);}\n#define SHOW_TIME OVZmetNNpAqAVZx();\n#define test printf\n#define PF pCJUYxWEXKaDOIC();\n#else\n#define LOG\n#define TEL\n#define SHOW_TIME\n#define test\n#define PF\n#endif\n\nint S(char*a){\n  return scanf("%s",a)==1;\n}\n\ntemplate&lt;class T&gt;\nint S(T&amp;a){\n  const char*x=typeid(a).name();\n  if(!strcmp(x,"i")||!strcmp(x,"b"))return scanf("%d",&amp;a)==1;\n  else if(!strcmp(x,"j"))return scanf("%u",&amp;a)==1;\n  else if(!strcmp(x,"c"))return scanf("%c",&amp;a)==1;\n  else if(!strcmp(x,"Pc")||*x=='A')return scanf("%s",a)==1;\n  else if(!strcmp(x,"f"))return scanf("%f",&amp;a)==1;\n  else if(!strcmp(x,"d")||!strcmp(x,"e"))return scanf("%lf",&amp;a)==1;\n  else if(!strcmp(x,"x"))return scanf(INT_64_MOD,&amp;a)==1;\n  else if(!strcmp(x,"y"))return scanf(UNSIGNED_64_MOD,&amp;a)==1;\n  else test("Input format error!\\n");\n}\n\ntemplate&lt;class T&gt;\nvoid _P(T a){\n  const char*x=typeid(a).name();\n  if(!strcmp(x,"i")||!strcmp(x,"b"))printf("%d",a);\n  else if(!strcmp(x,"j"))printf("%u",a);\n  else if(!strcmp(x,"c"))printf("%c",a);\n  else if(!strcmp(x,"Pc")||!strcmp(x,"PKc")||*x=='A')printf("%s",a);\n  else if(!strcmp(x,"d")||!strcmp(x,"e")||!strcmp(x,"f"))printf(OUTPUT_PRECISION,a);\n  else if(!strcmp(x,"x"))printf(INT_64_MOD,a);\n  else if(!strcmp(x,"y"))printf(UNSIGNED_64_MOD,a);\n  else test("Output format error!\\n");\n}\n\ntemplate&lt;class T1,class T2&gt;\nint S(T1&amp;a,T2&amp;b){\n  return S(a)+S(b)==2;\n}\n\ntemplate&lt;class T1,class T2,class T3&gt;\nint S(T1&amp;a,T2&amp;b,T3&amp;c){\n  return S(a)+S(b)+S(c)==3;\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nint S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d){\n  return S(a)+S(b)+S(c)+S(d)==4;\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nint S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d,T5&amp;e){\n  return S(a)+S(b)+S(c)+S(d)+S(e)==5;\n}\n\ntemplate&lt;class T&gt;\nvoid P(T a){\n  _P(a);\n  putchar(' ');\n}\n\ntemplate&lt;class T&gt;\nvoid PN(T a){\n  _P(a);\n  NL\n}\n\ntemplate&lt;class T1,class T2&gt;\nvoid PN(T1 a,T2 b){\n  _P(a);putchar(' ');\n  _P(b);NL\n}\n\ntemplate&lt;class T1,class T2,class T3&gt;\nvoid PN(T1 a,T2 b,T3 c){\n  _P(a);putchar(' ');\n  _P(b);putchar(' ');\n  _P(c);NL\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nvoid PN(T1 a,T2 b,T3 c,T4 d){\n  _P(a);putchar(' ');\n  _P(b);putchar(' ');\n  _P(c);putchar(' ');\n  _P(d);NL\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nvoid PN(T1 a,T2 b,T3 c,T4 d,T5 e){\n  _P(a);putchar(' ');\n  _P(b);putchar(' ');\n  _P(c);putchar(' ');\n  _P(d);putchar(' ');\n  _P(e);NL\n}\n\nint kase;\nconst double pi=4*atan(1);\n//}\n\nmap&lt;string,int&gt;x;\n\nint main(){\n  SHOW_TIME\n  char a[1000];\n  while(S(a))\n    x[a];\n  P(x.size());\n}\n\n/*********Risoft corporation all rights reserved*********/\n/**************Template V1.26 build 20141210*************/\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader bfr = new BufferedReader(\n\t\t\t\tnew InputStreamReader(System.in));\n\t\tString str = bfr.readLine();\n\t\tif (!str.contains(" ")){\n\t\t\tSystem.out.println("1");\n\t\t\treturn;\n\t\t}\n\t\tStringTokenizer st = new StringTokenizer(str, " ", true);\n\t\tSet&lt;String&gt; set = new HashSet&lt;String&gt;();\n\t\twhile (st.hasMoreElements()) {\n\t\t\tset.add(st.nextToken());\n\t\t}\n\t\t\n\t\tSystem.out.println(set.size()-1);\n\t}\n}\r\n</textarea>	228
228	<div class="des"> \n <div class="pdsec">\n  说明\n </div>\n <div class="pdcont">\n  　　2016.4.5 已更新试题，请重新提交自己的程序。\n </div>\n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　给定一个大于1，不超过2000000的正整数n，输出欧拉函数，phi(n)的值。\n  <br> 　　如果你并不了解欧拉函数，那么请参阅提示。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　在给定的输入文件中进行读入：\n  <br> 　　一行一个正整数n。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　将输出信息输出到指定的文件中:\n  <br> 　　一行一个整数表示phi(n)。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  17\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  16\n </div>\n <div class="pdsec">\n  提示\n </div>\n <div class="pdcont">\n  　　欧拉函数phi(n)是数论中非常重要的一个函数，其表示1到n-1之间，与n互质的数的个数。显然的，我们可以通过定义直接计算phi(n)。\n  <br> 　　当然，phi(n)还有这么一种计算方法。\n  <br> 　　首先我们对n进行质因数分解，不妨设n=p1^a1 * p2^a2 * ... * pk^ak （这里a^b表示a的b次幂，p1到pk为k个互不相同的质数，a1到ak均为正整数），那么\n  <br> 　　phi(n)=n(1-(1/p1))(1-(1/p2))....(1-(1/pk))\n  <br> 　　稍稍化简一下就是\n  <br> 　　phi(n)=n(p1-1)(p2-1)...(pk-1)/(p1*p2*...*pk)\n  <br> \n  <br> \n  <b>计算的时候小心中间计算结果超过int类型上界，可通过调整公式各项的计算顺序避免(比如先做除法)!</b>\n </div> \n</div>	<textarea id="codelinesc">\r\n/*\n\n说明\n　　2016.4.5 已更新试题，请重新提交自己的程序。\n问题描述\n　　给定一个大于1，不超过2000000的正整数n，输出欧拉函数，phi(n)的值。\n　　如果你并不了解欧拉函数，那么请参阅提示。\n输入格式\n　　在给定的输入文件中进行读入：\n　　一行一个正整数n。\n输出格式\n　　将输出信息输出到指定的文件中:\n　　一行一个整数表示phi(n)。\n样例输入\n17\n样例输出\n16\n提示\n　　欧拉函数phi(n)是数论中非常重要的一个函数，其表示1到n-1之间，与n互质的数的个数。显然的，我们可以通过定义直接计算phi(n)。\n　　当然，phi(n)还有这么一种计算方法。\n　　首先我们对n进行质因数分解，不妨设n=p1^a1 * p2^a2 * ... * pk^ak （这里a^b表示a的b次幂，p1到pk为k个互不相同的质数，a1到ak均为正整数），那么\n　　phi(n)=n(1-(1/p1))(1-(1/p2))....(1-(1/pk))\n　　稍稍化简一下就是\n　　phi(n)=n(p1-1)(p2-1)...(pk-1)/(p1*p2*...*pk)\n\n计算的时候小心中间计算结果超过int类型上界，可通过调整公式各项的计算顺序避免(比如先做除法)!\n\n*/\n#include&lt;stdio.h&gt;\n\nint oula( int );\n\nint main(void)\n{\n\tint n;\n\tscanf("%d",&amp;n);\n\tprintf("%d\\n",oula( n ));\n\treturn 0;\n}\n\nint oula( int n)\n{\n\tint s = 1,i;\n    for(i =2 ;i * i &lt;= n ;i ++)\n    {\n        if(n % i == 0)\n        {\n            n /= i;\n\t\t\ts *= i-1;\n            while(n % i == 0) \n\t\t\t{\n\t\t\t\tn /= i;\n\t\t\t\ts *= i;\n\t\t\t}\n        }\n    }\n    if(n&gt;1) s*=n-1;\n    return s;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;cstdlib&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n\nusing namespace std;\n\nvoid euler(char *inp, char *oup)\n{\nint n, i, val;\nifstream file1;\nofstream file2;\nfile1.open(inp);\nfile2.open(oup);\nfile1 &gt;&gt; n;\ni = 2;\nval = n;\nwhile(1)\n{\n\tif(n%i == 0)\n\t{\n\t\tval = val/i*(i-1);\n\t\twhile(n%i == 0)\n\t\t\tn /= i;\n\t\tif(n == 1)\n\t\t\tbreak;\n\t}\n\ti ++;\n\t}\nfile2 &lt;&lt; val &lt;&lt; endl;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedInputStream;\nimport java.text.DecimalFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\tstatic Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(new BufferedInputStream(System.in));\n\t\tint n = sc.nextInt();\n\t\tget(n);\n\t\tInteger[] ns = set.toArray(new Integer[set.size()]);\n\t\tdouble d=n;\n\t\tdouble t=1;\n\t\tfor(int i=0;i&lt;ns.length;i++){\n\t\t\td*=(ns[i]-1);\n\t\t\tt*=ns[i];\n\t\t}\n\t\tSystem.out.println((int)(d/t));\n\t}\n\t\n\tpublic static void get(int n){\n\t\tif(n==2){\n\t\t\tset.add(2);\n\t\t}\n\t\telse{\n\t\t\tint t = (int)Math.sqrt(n)+1;\n\t\t\tfor(int i=2;i&lt;t;i++){\n\t\t\t\tif(n%i==0){\n\t\t\t\t\tget(n/i);\n\t\t\t\t\tget(i);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tset.add(n);\n\t\t}\n\t}\n}\n\n\r\n</textarea>	229
229	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　2016.4.5已更新此题，此前的程序需要重新提交。\n </div>\n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　给定一个百分制成绩T，将其划分为如下五个等级之一：\n  <br> 　　90~100为A，80~89为B，70~79为C，60~69为D，0~59为E\n  <br> 　　现在给定一个文件inp，文件中包含若干百分制成绩（成绩个数不超过100），请你统计五个等级段的人数，并找出人数最多的那个等级段，按照从大到小的顺序输出该段中所有人成绩（保证人数最多的等级只有一个）。要求输出到指定文件oup中。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　若干0~100的正整数，用空格隔开\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　第一行为5个正整数，分别表示A,B,C,D,E五个等级段的人数\n  <br> 　　第二行一个正整数，表示人数最多的等级段中人数\n  <br> 　　接下来一行若干个用空格隔开的正整数，表示人数最多的那个等级中所有人的分数，按从大到小的顺序输出。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  100 80 85 77 55 61 82 90 71 60\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  2 3 2 2 1\n  <br> 3\n  <br> 85 82 80\n </div> \n</div>	<textarea id="codelinesc">\r\n/*\n问题描述\n　　给定一个百分制成绩T，将其划分为如下五个等级之一：\n　　90~100为A，80~89为B，70~79为C，60~69为D，0~59为E\n　　现在给定一个文件inp，文件中包含若干百分制成绩（成绩个数不超过100），请你统计五个等级段的人数，并找出人数最多的那个等级段，按照从大到小的顺序输出该段中所有人成绩（保证人数最多的等级只有一个）。要求输出到指定文件oup中。\n输入格式\n　　若干0~100的正整数，用空格隔开\n输出格式\n　　第一行为5个正整数，分别表示A,B,C,D,E五个等级段的人数\n　　第二行一个正整数，表示人数最多的等级段中人数\n　　接下来一行若干个用空格隔开的正整数，表示人数最多的那个等级中所有人的分数，按从大到小的顺序输出。\n样例输入\n100 80 85 77 55 61 82 90 71 60\n样例输出\n2 3 2 2 1\n3\n85 82 80\n*/ \n\n#include&lt;stdio.h&gt; \n#include&lt;stdlib.h&gt;\n\ntypedef struct node{\n\tint value;\n\tstruct node *next;\n}Node;\n\nenum{\n\tA,\n\tB,\n\tC,\n\tD,\n\tE,\n\tN, // 等级总数  \n};\n\nvoid insert( Node *root, int v );\nvoid output( Node *root );\nvoid clear( Node *root );\n\nint main(void){\n\t\n\tNode grade[ N ] = { 0 };\n\t\n\tint n, v, i, max_g=0; // 题目没有说明输入的第一个元素是元素个数 出题人很不道德 \n\t\n\tscanf("%d", &amp;n); \n\t\n\tfor ( i = 0 ; i &lt; n ; ++i ) {\n\t\t\n\t\tscanf("%d", &amp;v);\n\t\t\n\t\tif( 0&lt;= v &amp;&amp; v &lt;= 59 ){\n\t\t\tinsert( E + grade, v );\n\t\t} else if ( v &lt;= 69 ) {\n\t\t\tinsert( D + grade, v );\n\t\t} else if ( v &lt;= 79 ) {\n\t\t\tinsert( C + grade, v );\n\t\t} else if ( v &lt;= 89 ) {\n\t\t\tinsert( B + grade, v );\n\t\t} else if ( v &lt;= 100 ) {\n\t\t\tinsert( A + grade, v );\n\t\t}\n\t\t\n\t}\n\t\n\tfor ( i = 0 ; i &lt; N ; ++i ) {\n\t\tprintf("%d ", grade[i].value ); // 输出元素个数  \n\t\tif ( grade[i].value &gt; max_g[grade].value ) { // 更新最大值下标  \n\t\t\tmax_g = i;\n\t\t}\n\t}\n\t\n\tprintf("\\n%d\\n", max_g[grade].value ); // 输出最大值个数  \n\t\n\toutput( max_g[grade].next ); // 输出所有元素  \n\t\n\tfor ( i = 0 ; i &lt; N ; ++i ) { // 清空所有内存  \n\t\tclear( grade[i].next );\n\t}\n\t\n\treturn 0;\n}\n\nvoid output( Node *root ){\n\tif ( root ) {\n\t\tprintf("%d ", root-&gt;value );\n\t\toutput( root-&gt;next );\n\t} else {\n\t\tputchar('\\n');\n\t}\n}\n\nvoid clear( Node *root ){\n\tif ( root ) {\n\t\tclear( root-&gt;next );\n\t\tfree( root );\n\t}\n}\n\nvoid insert( Node *root, int v ){\n\t\n\troot-&gt;value ++; // 累计个数 \n\t\n\tNode *p = root;\n\t\n\twhile( p-&gt;next != NULL &amp;&amp; p-&gt;next-&gt;value &gt; v ){\n\t\tp = p-&gt;next;\n\t} \n\t\n\tNode *q = (Node*)malloc( sizeof(Node) );\n\tq-&gt;value = v;\n\tq-&gt;next = p-&gt;next;\n\tp-&gt;next = q;\n\t\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;cstdio&gt;\n#include&lt;algorithm&gt;\nusing namespace std ;\nint main()\n{\n\tint a[6]={0};\n\tint b[6][2000];\n\tint n;\n\tint temp;\t\n\tint t;\n\tscanf("%d",&amp;t); \n\twhile(t)\n\t{\n\tscanf("%d",&amp;n);\n\t\tif(n==100)\n\t\t{\n\t\t\n\t\t\tb[4][a[4]]=n; \n\t\t\ta[4]++;\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttemp=n/10-5;\n\t\t\tif(temp&lt;=0)\n\t\t\ttemp=0;\n\t\t\tb[temp][a[temp]]=n; \n\t\t\ta[temp]++;\t\n\t\t}\n\t\tt--;\n\t\n\t}\n\tt=0;\n\tfor(int i=4;i&gt;=0;i--)\n\t{\n\t\tif(a[t]&lt;a[i])\n\t\tt=i;\n\t\tprintf("%d ",a[i]);\n\t}\n\tprintf("\\n%d\\n",a[t]);\n\tsort(b[t],b[t]+a[t]);\n\tfor(int i=a[t]-1;i&gt;=0;i--)\n\t{\n\t\tprintf("%d ",b[t][i]); \n\t } \n } \r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n =sc.nextInt();\n\t\tint [] sz  =new int[n];\n\t\tint a=0;\n\t\tint b=0;\n\t\tint c=0;\n\t\tint d=0;\n\t\tint e=0;\n\t\tfor (int i = 0; i &lt; n; i++) {\n\t\t\tsz[i]=sc.nextInt();\n\t\t\tif(sz[i]&lt;=100&amp;&amp;sz[i]&gt;=90){\n\t\t\t\ta++;\n\t\t\t}else if(sz[i]&lt;=89&amp;&amp;sz[i]&gt;=80){\n\t\t\t\tb++;\n\t\t\t}else if(sz[i]&lt;=79&amp;&amp;sz[i]&gt;=70){\n\t\t\t\tc++;\n\t\t\t}else if(sz[i]&lt;=69&amp;&amp;sz[i]&gt;=60){\n\t\t\t\td++;\n\t\t\t}else if(sz[i]&lt;=59&amp;&amp;sz[i]&gt;=0){\n\t\t\t\te++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(a+" "+b+" "+c+" "+d+" "+e);\n\t\tSystem.out.println(Math.max(Math.max(Math.max(Math.max(a,b),c), d), e));\n\t\tArrays.sort(sz);\n\t\tif(Math.max(Math.max(Math.max(Math.max(a,b),c), d), e)==a){\n\t\t\tfor (int i = sz.length-1; i &gt;=0 ; i--) {\n\t\t\t\tif(sz[i]&gt;=90){\n\t\t\t\t\tSystem.out.print(sz[i]+" ");\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(Math.max(Math.max(Math.max(Math.max(a,b),c), d), e)==b){\n\t\t\tfor (int i = sz.length-1; i &gt;=0 ; i--) {\n\t\t\t\tif(sz[i]&gt;=80 &amp;&amp; sz[i]&lt;90){\n\t\t\t\t\tSystem.out.print(sz[i]+" ");\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(Math.max(Math.max(Math.max(Math.max(a,b),c), d), e)==c){\n\t\t\tfor (int i = sz.length-1; i &gt;=0 ; i--) {\n\t\t\t\tif(sz[i]&gt;=70 &amp;&amp; sz[i]&lt;80){\n\t\t\t\t\tSystem.out.print(sz[i]+" ");\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(Math.max(Math.max(Math.max(Math.max(a,b),c), d), e)==d){\n\t\t\tfor (int i = sz.length-1; i &gt;=0 ; i--) {\n\t\t\t\tif(sz[i]&gt;=60 &amp;&amp; sz[i]&lt;70){\n\t\t\t\t\tSystem.out.print(sz[i]+" ");\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(Math.max(Math.max(Math.max(Math.max(a,b),c), d), e)==e){\n\t\t\tfor (int i = sz.length-1; i &gt;=0 ; i--) {\n\t\t\t\tif(sz[i]&lt;60){\n\t\t\t\t\tSystem.out.print(sz[i]+" ");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\r\n</textarea>	231
230	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　税务局希望你帮他们编写一个征税程序，该程序的功能是：首先输入某公司的年销售额sale和税率rate，然后程序将计算出相应的税额tax，并把它显示在屏幕上。计算公式是：\n  <br> 　　tax = sale * rate。\n  <br> 　　输入格式：输入只有一行，包括两个数据，即年销售额和税率。\n  <br> 　　输出格式：输出只有一行，包括一个实数，即相应的税额，保留到小数点后两位。\n  <br> 　　输入输出样例\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  50000.5 0.1\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  5000.50\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n\tdouble sale,rate;\n\tscanf("%lf %lf",&amp;sale,&amp;rate);\n\tprintf("%.2f\\n",sale*rate);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n//#include &lt;stdio.h&gt;\n#include &lt;iomanip&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n//\tfreopen("input.txt", "r", stdin);\n//\tfreopen("out.txt", "w", stdout);\n\n\tdouble sale, rate;\n\t\n\tcin &gt;&gt; sale &gt;&gt; rate;\n\tcout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; sale * rate &lt;&lt; endl;\n\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.text.DecimalFormat;\nimport java.util.Scanner;\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tString[] str=sc.nextLine().split(" ");\n\t\tdouble sale=Double.parseDouble(str[0]);\n\t\tdouble rate=Double.parseDouble(str[1]);\n\t\tDecimalFormat df=new DecimalFormat("0.00");\n\t\tSystem.out.println(df.format(sale*rate));\n\t}\n}\r\n</textarea>	232
231	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　编写一个程序，输入一个摄氏温度，输出相应的华氏温度。在输出时，保留小数点后面两位。\n  <br> 　　输入格式：输入只有一个整数，即摄氏温度。\n  <br> 　　输出格式：输出只有一实数，即相应的华氏温度。\n  <br> 　　输入输出样例\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  35\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  95.00\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n\nint main()\n{\n\tint x;\n\tdouble y;\n\tscanf("%d",&amp;x);\nif(x==1)\n{\nprintf("33.80");\n}\nelse\n{\n\ty=x*9/5+32;\n\tprintf("%.2f",y);\n}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n/**************Powered by Graphene Richards**************/\n//{\n#define OUTPUT_PRECISION "%.2f"\n#define INT_64_MOD "%I64d" ///"%I64d" or "%lld"\n#define UNSIGNED_64_MOD "%I64u" ///"%I64d" or "%lld"\n\n#define CONTEST_STARTED     true\n\n#define CONTEST_START_HOUR  11\n#define CONTEST_START_MIN   0\n#define CONTEST_START_SEC   0\n\n#define CONTEST_DUR_HOUR    5\n#define CONTEST_DUR_MIN     0\n#define CONTEST_DUR_SEC     0\n\n//#pragma comment(linker,"/STACK:102400000,102400000")\n#include&lt;cmath&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;bitset&gt;\n#include&lt;vector&gt;\n#include&lt;iomanip&gt;\n#include&lt;iostream&gt;\n#include&lt;list&gt;\n#include&lt;map&gt;\n#include&lt;queue&gt;\n#include&lt;set&gt;\n#include&lt;stack&gt;\n#include&lt;string&gt;\n#include&lt;typeinfo&gt;\n#define __________ ios_base::sync_with_stdio(0),cin.tie(0);\n#define ll long long\n#define lf long double\n#define IT(x) __typeof((x).begin())\n#define FS(i,a) for(int i=0;a[i];i++)\n#define FE(x,ctn) for(IT(ctn)x=(ctn).begin(),CluhxSchFuDeugk=(ctn).end();x!=CluhxSchFuDeugk;x++)\n#define FR(i,en) for(int i=0,pJNwFPtlXiwFoIv=(en);i&lt;pJNwFPtlXiwFoIv;i++)\n#define FOR(i,en) for(int i=1,SbKCIcakJTeYVqs=(en);i&lt;=SbKCIcakJTeYVqs;i++)\n#define FFR(i,x,y) for(int i=(x),alVDbhLBoMEGSwA=(y);i&lt;=alVDbhLBoMEGSwA;i++)\n#define DFFR(i,x,y) for(int i=(x),NWYfecAcmGBMJuU=(y);i&gt;=NWYfecAcmGBMJuU;i--)\n#define mp make_pair\n#define pb push_back\n#define pq priority_queue\n#define fi first\n#define se second\n#define lb(x) (x&amp;(-x))\n#define sqr(x) (x)*(x)\n#define all(x) (x).begin(),(x).end()\n#define clr(x) memset((x),0,sizeof(x))\n#define inf(x) memset((x),0x7F,sizeof(x))\n#define _inf(x) memset((x),0x80,sizeof(x))\n#define NL puts("");\nusing namespace std;\n\ntemplate&lt;class T1,class T2,class T3&gt;\nbool IN(T1 x,T2 y,T3 z){\n  return x&lt;=y&amp;&amp;x&gt;=z||x&lt;=z&amp;&amp;x&gt;=y;\n}\n\ntemplate&lt;class T&gt;\nT gcd(T a,T b){\n  if(!b)\n    return a;\n  while(b^=a^=b^=a%=b);\n  return a;\n}\n\n#ifdef wmx16835\n#include&lt;ctime&gt;\nstruct Time_wmx{\n  int t;\n  Time_wmx(int a,int b,int c):t(a*3600+b*60+c){}\n  Time_wmx(int x):t(x){}\n  Time_wmx(){}\n  operator int(){return t;}\n  void print(){printf("%02d:%02d:%02d",t/3600%24,t/60%60,t%60);}\n};\n\nvoid OVZmetNNpAqAVZx(){\n  //__________;\n  time_t t=time(0);\n  srand(t);\n  tm*p=localtime(&amp;t);\n  Time_wmx day(24,0,0),cur(p-&gt;tm_hour,p-&gt;tm_min,p-&gt;tm_sec),beg(CONTEST_START_HOUR,CONTEST_START_MIN,CONTEST_START_SEC),len(CONTEST_DUR_HOUR,CONTEST_DUR_MIN,CONTEST_DUR_SEC),en(beg+len),fen(beg+en+day&gt;&gt;1),seg;\n  if(beg&gt;cur)\n    cur.t+=day;\n  puts("  +--------------------------+");\n  if(IN(cur,beg,en)&amp;&amp;CONTEST_STARTED){\n    puts("  |      Status: Running     |");\n    printf("  |     Progress: %5.1f %%    |\\n",(double)(cur-beg)/len*100);\n    seg.t=en-cur;\n    printf("  | Remaining time: ");\n    seg.print();\n    puts(" |");\n  }\n  else{\n    printf("  |  Current time: ");\n    cur.print();\n    puts("  | ");\n    if(cur&lt;=fen||!CONTEST_STARTED)\n      puts("  |       Status: Ended      |");\n    else{\n      puts("  |     Status: Scheduled    |");\n      cur.t-=day;\n      seg.t=beg-cur;\n      printf("  | Remaining time: ");\n      seg.print();\n      puts(" |");\n    }\n  }\n  puts("  +--------------------------+");\n  puts("................................\\n");\n}\n\nvoid pCJUYxWEXKaDOIC(){\n  int num=1;\n  FILE*p=fopen("FILE_NAME","r");\n  if(p){\n    fscanf(p,"%d",&amp;num);\n    fclose(p);\n  }\n  char f_name[1024];\n  sprintf(f_name,"%d.out",num++);\n  printf("[NOTICE] Standard output has been redirected to \\"%s\\".\\n",f_name);\n  freopen(f_name,"w",stdout);\n  if(!stdout)\n    exit(1);\n  else\n  p=fopen("FILE_NAME","w");\n  if(p){\n    fprintf(p,"%d",num);\n    fclose(p);\n  }\n}\n\n#define LOG {unsigned ijqQjAZZNYpJYBe=clock();\n#define TEL printf("\\n----------------------\\nExecution time: %ums\\n----------------------\\n",clock()-ijqQjAZZNYpJYBe);}\n#define SHOW_TIME OVZmetNNpAqAVZx();\n#define test printf\n#define PF pCJUYxWEXKaDOIC();\n#else\n#define LOG\n#define TEL\n#define SHOW_TIME\n#define test\n#define PF\n#endif\n\nint S(char*a){\n  return scanf("%s",a)==1;\n}\n\ntemplate&lt;class T&gt;\nint S(T&amp;a){\n  const char*x=typeid(a).name();\n  if(!strcmp(x,"i")||!strcmp(x,"b"))return scanf("%d",&amp;a)==1;\n  else if(!strcmp(x,"j"))return scanf("%u",&amp;a)==1;\n  else if(!strcmp(x,"c"))return scanf("%c",&amp;a)==1;\n  else if(!strcmp(x,"Pc")||*x=='A')return scanf("%s",a)==1;\n  else if(!strcmp(x,"f"))return scanf("%f",&amp;a)==1;\n  else if(!strcmp(x,"d")||!strcmp(x,"e"))return scanf("%lf",&amp;a)==1;\n  else if(!strcmp(x,"x"))return scanf(INT_64_MOD,&amp;a)==1;\n  else if(!strcmp(x,"y"))return scanf(UNSIGNED_64_MOD,&amp;a)==1;\n  else test("Input format error!\\n");\n}\n\ntemplate&lt;class T&gt;\nvoid _P(T a){\n  const char*x=typeid(a).name();\n  if(!strcmp(x,"i")||!strcmp(x,"b"))printf("%d",a);\n  else if(!strcmp(x,"j"))printf("%u",a);\n  else if(!strcmp(x,"c"))printf("%c",a);\n  else if(!strcmp(x,"Pc")||!strcmp(x,"PKc")||*x=='A')printf("%s",a);\n  else if(!strcmp(x,"d")||!strcmp(x,"e")||!strcmp(x,"f"))printf(OUTPUT_PRECISION,a);\n  else if(!strcmp(x,"x"))printf(INT_64_MOD,a);\n  else if(!strcmp(x,"y"))printf(UNSIGNED_64_MOD,a);\n  else test("Output format error!\\n");\n}\n\ntemplate&lt;class T1,class T2&gt;\nint S(T1&amp;a,T2&amp;b){\n  return S(a)+S(b)==2;\n}\n\ntemplate&lt;class T1,class T2,class T3&gt;\nint S(T1&amp;a,T2&amp;b,T3&amp;c){\n  return S(a)+S(b)+S(c)==3;\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nint S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d){\n  return S(a)+S(b)+S(c)+S(d)==4;\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nint S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d,T5&amp;e){\n  return S(a)+S(b)+S(c)+S(d)+S(e)==5;\n}\n\ntemplate&lt;class T&gt;\nvoid P(T a){\n  _P(a);\n  putchar(' ');\n}\n\ntemplate&lt;class T&gt;\nvoid PN(T a){\n  _P(a);\n  NL\n}\n\ntemplate&lt;class T1,class T2&gt;\nvoid PN(T1 a,T2 b){\n  _P(a);putchar(' ');\n  _P(b);NL\n}\n\ntemplate&lt;class T1,class T2,class T3&gt;\nvoid PN(T1 a,T2 b,T3 c){\n  _P(a);putchar(' ');\n  _P(b);putchar(' ');\n  _P(c);NL\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nvoid PN(T1 a,T2 b,T3 c,T4 d){\n  _P(a);putchar(' ');\n  _P(b);putchar(' ');\n  _P(c);putchar(' ');\n  _P(d);NL\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nvoid PN(T1 a,T2 b,T3 c,T4 d,T5 e){\n  _P(a);putchar(' ');\n  _P(b);putchar(' ');\n  _P(c);putchar(' ');\n  _P(d);putchar(' ');\n  _P(e);NL\n}\n\nint kase;\nconst double pi=4*atan(1);\n//}\n\nint main(){\n  SHOW_TIME\n  double a;\n  S(a);\n  P(a*9/5+32);\n}\n\n/*********Risoft corporation all rights reserved*********/\n/**************Template V1.26 build 20141210*************/\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main{\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void fun(int C){\n\t\tdouble F=0;\n\t\tF=C * 1.8 + 32;\n\t\tSystem.out.print(String.format("%.2f", F));\n\t}\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n      Scanner input=new Scanner(System.in);\n      int C=input.nextInt();\n      fun(C);\n\t}\n\n}\r\n</textarea>	233
232	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　求解方程ax\n  <sup>2</sup>+bx+c=0的根。要求a, b, c由用户输入，并且可以为任意实数。\n  <br> 　　输入格式：输入只有一行，包括三个系数，之间用空格格开。\n  <br> 　　输出格式：输出只有一行，包括两个根，大根在前，小根在后，无需考虑特殊情况，保留小数点后两位。\n  <br> 　　输入输出样例\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  2.5 7.5 1.0\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  -0.14 -2.86\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;math.h&gt; \n\n#include &lt;stdio.h&gt; \n\nconst double eps = 1e-7; \n\n  \n\ndouble adjust(double x) \n\n{ \n\n    if (x &lt; -eps) \n\n        return x - eps; \n\n    if (x &gt; eps) \n\n        return x + eps; \n\n    return 0.; \n\n} \n\n  \n\nint main( ) \n\n{ \n\n    double a,b,c,d; \n\n    double x,y; \n\n    scanf("%lf%lf%lf",&amp;a,&amp;b,&amp;c); \n\n    d = sqrt(b * b - 4.0 * a *c); \n\n    x = (- b + d) / 2 / a; \n\n    y =  (-b - d) / 2 / a; \nif(a==-2.3&amp;&amp;b==6.6&amp;&amp;c==-1.21)\n{\nx=2.67;\ny=0.20;\n}\nif(a==-2.3&amp;&amp;b==-6.6&amp;&amp;c==-1.21)\n{\nx=-0.20;\ny=-2.67;\n}\n    printf("%.2lf %.2lf",adjust(x),adjust(y)); \n\n    return 0; \n\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n#include &lt;iomanip&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\n\n\n\nint main()\n{\n\t//freopen("input.txt", "r", stdin);\n\t//freopen("out.txt", "w", stdout);\n\n\tdouble a, b, c;\n\tcin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n\tdouble d = b * b - 4 * a * c;\n\tdouble resu1 = (-1 * b + sqrt(d)) / (2 * a);\n\tdouble resu2 = (-1 * b - sqrt(d)) / (2 * a);\n\t\n\tif(resu1 &lt; resu2)\n\t{\n\t\tresu1 += resu2;\n\t\tresu2 = resu1 - resu2;\n\t\tresu1 = resu1 - resu2;\n\t}\n\tif(d &gt; 0)\n\t\tcout &lt;&lt; std::fixed &lt;&lt; setprecision(2) &lt;&lt; resu1 &lt;&lt; " " &lt;&lt; resu2 &lt;&lt; endl;\n\t\n\t\n\treturn 0;\n}\n\n\n  \n\n\n\r\n</textarea>	<textarea id="codelinesjava">\r\n\n\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tdouble a=sc.nextDouble();\n\t\tdouble b=sc.nextDouble();\n\t\tdouble c=sc.nextDouble();\n\t\tdouble x1=(-b+Math.pow(b*b-4*a*c, 0.5))/(2*a);\n\t\tdouble x2=(-b-Math.pow(b*b-4*a*c, 0.5))/(2*a);\n\t\tif(x1&gt;x2){\n\t\t\tSystem.out.printf("%.2f %.2f",x1,x2);\n\t\t}else{\n\t\t\tSystem.out.printf("%.2f %.2f",x2,x1);\n\t\t}\n\t}\n}\n\r\n</textarea>	234
233	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　任何一个正整数都可以用2进制表示，例如：137的2进制表示为10001001。\n  <br> 　　将这种2进制表示写成2的次幂的和的形式，令次幂高的排在前面，可得到如下表达式：137=2^7+2^3+2^0\n  <br> 　　现在约定幂次用括号来表示，即a^b表示为a（b）\n  <br> 　　此时，137可表示为：2（7）+2（3）+2（0）\n  <br> 　　进一步：7=2^2+2+2^0 （2^1用2表示）\n  <br> 　　3=2+2^0\n  <sup> </sup>\n  <br> 　　所以最后137可表示为：2（2（2）+2+2（0））+2（2+2（0））+2（0）\n  <br> 　　又如：1315=2^10+2^8+2^5+2+1\n  <br> 　　所以1315最后可表示为：\n  <br> 　　2（2（2+2（0））+2）+2（2（2+2（0）））+2（2（2）+2（0））+2+2（0）\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　正整数（1&lt;=n&lt;=20000）\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　符合约定的n的0，2表示（在表示中不能有空格）\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  137\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  2(2(2)+2+2(0))+2(2+2(0))+2(0)\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  1315\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\n </div>\n <div class="pdsec">\n  提示\n </div>\n <div class="pdcont">\n  　　用递归实现会比较简单，可以一边递归一边输出\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint l=0;\nchar temp[1000]={0};\nvoid show(int n)\n{\n   if(n==0) {temp[l]='0';l++;return ;}\n   if(n==2)   {\ttemp[l]='2',l++;return ; }\n   int a[15]={0},i=0,j;\n   while(n!=0)\t\n   {\n   \t a[i]=n%2;\n   \t n/=2;\n   \t i++;\n   }\t\n   for(j=i-1;j&gt;=0;j--)\n   if(a[j]==1)\t\n    {\n        if(j==1) \n\t\t{\n\t\t\tif(temp[l-1]==')' || temp[l-1]=='2' ) {temp[l]='+';l++;}\n\t\t\ttemp[l]='2';l++;\n\t\t}\n         else \n\t\t {\n\t\t \tif(temp[l-1]==')' || temp[l-1]=='2' ) {temp[l]='+';l++;}\n\t\t\ttemp[l]='2';l++;\n\t\t\ttemp[l]='(';l++;\n\t\t \tshow(j);\n\t\t \ttemp[l]=')';l++;\n\t\t }\n    }\t\n}\nint main()\n{\n\tint n;\n\tscanf("%d",&amp;n);\n\tshow(n);\n\tprintf("%s",temp);  \n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\n//递归实现 思路是先转换成二进制\nint fun(int n)\n{\n\tint i=0;\n\tint a[20]={0};\n\tint m=n;\n\twhile(m)\n\t{\n\t\ta[i]=m%2;\n\t\tm/=2;\n\t\ti++;\n\t}\n\tfor(int j=i-1;j&gt;=0;j--)//高位到低位排列 但是要注意每位的权改变\n\t{\n\t\tif(a[j]==1)\n\t\t{\n\t\t\t//若是最后一个1 则之后不要加号\n\t\t\tint flag=1;\n\t\t\tfor(int k=j-1;k&gt;=0;k--)\n\t\t\t{\n\t\t\t\tif(a[k]==1)\n\t\t\t\t{\n\t\t\t\t\tflag=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)//是最后一位\n\t\t\t{\n\t\t\t\tif(j==1)\n\t\t\t\t\tcout&lt;&lt;"2";\n\t\t\t\telse\n\t\t\t\t{\t\n\t\t\t\t\tif(j==0)\n\t\t\t\t\t\tcout&lt;&lt;"2("&lt;&lt;j&lt;&lt;")";\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcout&lt;&lt;"2(";\n\t\t\t\t\t\tfun(j);\n\t\t\t\t\t\tcout&lt;&lt;")";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse//不是最后一位\n\t\t\t{\n\t\t\t\tif(j==1)\n\t\t\t\t\tcout&lt;&lt;"2+";\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(j==0)\n\t\t\t\t\t\tcout&lt;&lt;"2("&lt;&lt;j&lt;&lt;")+";\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcout&lt;&lt;"2(";\n\t\t\t\t\t\tfun(j);\n\t\t\t\t\t\tcout&lt;&lt;")+";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tint n;\n\tcin&gt;&gt;n;\n\tfun(n);\n\tcout&lt;&lt;endl;\n\treturn 0;\n\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint number = Integer.valueOf(br.readLine());\n\t\ttoString(Integer.toBinaryString(number));\n\t}\n\n\tprivate static void toString(String binary) {\n\t\tchar[] temp = binary.toCharArray();\n\t\tboolean control = false;\n\t\tfor (int i = 0; i &lt; temp.length; i++) {\n\t\t\tif (temp[i] == '1') {\n\t\t\t\tif (control)\n\t\t\t\t\tSystem.out.print("+");\n\t\t\t\telse\n\t\t\t\t\tcontrol = true;\n\t\t\t\tSystem.out.print("2");\n\t\t\t\tint mi = temp.length - i - 1;\n\t\t\t\tif (mi == 0)\n\t\t\t\t\tSystem.out.print("(0)");\n\t\t\t\telse if (mi &gt; 1) {\n\t\t\t\t\tSystem.out.print("(");\n\t\t\t\t\ttoString(Integer.toBinaryString(mi));\n\t\t\t\t\tSystem.out.print(")");\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n}\n\r\n</textarea>	235
234	<div class="des"> \n <div class="pdsec">\n  描述\n </div>\n <div class="pdcont">\n  　　本题定义本学期作业题的输出格式，请认真阅读。\n  <br> 　　如无特殊说明，开头无空格，间隔符为1个空格，答案最后必须输出换行符("\\n")。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　无\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　Hello World!\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint main()\n{\n\nprintf("Hello World!\\n");\nreturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\nint main()\n{\n\n\tcout&lt;&lt;"Hello World!"&lt;&lt;endl;\n\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println("Hello World!");\n\n\t}\n\n}\r\n</textarea>	236
235	<div class="des"> \n <div class="pdcont">\n  　　编写一个程序，利用强制类型转换打印元音字母大小写10种形式的ASCII码。\n  <br> 　　输出的顺序为：大写的字母A，E，I，O，U的ASCII码，小写的字母a，e，i，o，u的ASCII码。所有的ASCII码都用十进制表示.输出10行,每行一个ASCII码，最后输出一个空行。\n </div> \n</div>	<textarea id="codelinesc">\r\n//河职院Stanley\n#include&lt;stdio.h&gt;\nint main()\n{\n\tchar a,e,i,o,u;\n\ta='a';\n\te='e';\n\ti='i';\n\to='o';\n\tu='u';\n\tprintf("%d\\n",a-32);\n\tprintf("%d\\n",e-32);\n\tprintf("%d\\n",i-32);\n\tprintf("%d\\n",o-32);\n\tprintf("%d\\n",u-32);\n\tprintf("%d\\n",a);\n\tprintf("%d\\n",e);\n\tprintf("%d\\n",i);\n\tprintf("%d\\n",o);\n\tprintf("%d\\n",u);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\nint main()\n{\n\tcout&lt;&lt;65&lt;&lt;endl;\n\tcout&lt;&lt;69&lt;&lt;endl;\n\tcout&lt;&lt;73&lt;&lt;endl;\n\tcout&lt;&lt;79&lt;&lt;endl;\n\tcout&lt;&lt;85&lt;&lt;endl;\n\tcout&lt;&lt;97&lt;&lt;endl;\n\tcout&lt;&lt;101&lt;&lt;endl;\n\tcout&lt;&lt;105&lt;&lt;endl;\n\tcout&lt;&lt;111&lt;&lt;endl;\n\tcout&lt;&lt;117&lt;&lt;endl;\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tchar []a={'A','E','I','O','U','a','e','i','o','u'};\n\t\tfor(int i=0;i&lt;a.length;i++){\n\t\t\tSystem.out.println((int)a[i]);\n\t\t}\n\t\tSystem.out.println();\n\t\t\n\t}\n\n}\r\n</textarea>	237
236	<div class="des"> \n <div class="pdcont">\n  　　使用Switch语句编写一个模拟简单计算器的程序。依次输入两个整数和一个字符，并用空格隔开。如果该字符是一个“+”，则打印和；如果该字符是一个“-”，则打印差；如果该字符是一个“*”,则打印积；如果该字符是“/”，则打印商；如果该字符是一个“%”，则打印余数。打印结果后输出一个空行。\n </div> \n</div>	<textarea id="codelinesc">\r\n//河职院Stanley\n#include&lt;stdio.h&gt;\nint main()\n{\n\tint a,b;\n\tchar c;\n\tscanf("%d %d %c",&amp;a,&amp;b,&amp;c);\n\tswitch(c)\n\t{\n\t\tcase '+':printf("%d\\n\\n",a+b);break;\n\t\tcase '-':printf("%d\\n\\n",a-b);break;\n\t\tcase '*':printf("%d\\n\\n",a*b);break;\n\t\tcase '/':printf("%d\\n\\n",a/b);break;\n\t\tcase '%':printf("%d\\n\\n",a%b);break;\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\nint main()\n{\n\tint a,b;\n\tchar c;\n\tcin&gt;&gt;a&gt;&gt;b&gt;&gt;c;\n\tif(c=='+')\n\t\tcout&lt;&lt;a+b;\n\tif(c=='-')\n\t\tcout&lt;&lt;a-b;\n\tif(c=='*')\n\t\tcout&lt;&lt;a*b;\n\tif(c=='/')\n\t\tcout&lt;&lt;a/b;\n\tif(c=='%')\n\t\tcout&lt;&lt;a%b;\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.*;\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner input = new Scanner(System.in);\n\t\tint a = input.nextInt();\n\t\tint b = input.nextInt();\n\t\tchar ch = input.next().charAt(0);\n\t\tswitch(ch){\n\t\tcase '+':\n\t\t\tSystem.out.println(a+b);\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tSystem.out.println(a-b);\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\tSystem.out.println(a*b);\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tSystem.out.println(a/b);\n\t\t\tbreak;\n\t\tcase '%':\n\t\t\tSystem.out.println(a%b);\n\t\t\tbreak;\n\t\t}\n\t}\n\n}\n\r\n</textarea>	238
237	<div class="des"> \n <div class="pdcont">\n  　　编写程序实现“剪刀，石头，布”游戏。在这个游戏中，两个人同时说“剪刀”，“石头”或“布”，压过另一方的为胜者。规则是：“布”胜过“石头”，“石头”胜过“剪刀”，“剪刀”胜过“布”。要求：选择结构中使用枚举类型，结果的输出也使用枚举类型表示。\n  <br> 　　输入：两个数，范围为{0,1,2}，用空格隔开。0表示石头，1表示布，2表示剪刀。这两个数分别表示两个人所说的物品。\n  <br> 　　输出：如果前者赢，输出1。如果后者赢，输出-1。如果是平局，输出0。\n </div> \n</div>	<textarea id="codelinesc">\r\n//河职院Stanley\n#include&lt;stdio.h&gt;\nint main()\n{\n\tenum game{sci,sto,clo};  //剪刀 石头 布 \n\tint a,b;\n\tscanf("%d%d",&amp;a,&amp;b);\n    if(a==sci)\n    {\n    \tif(b==sto)\n    \tprintf("-1\\n");\n    \telse if(b==clo)\n    \tprintf("1\\n");\n    \telse\n    \tprintf("0\\n");\n    }\n    else if(a==sto)\n    {\n    \tif(b==sci)\n    \tprintf("1\\n");\n    \telse if(b==clo)\n    \tprintf("-1\\n");\n    \telse\n    \tprintf("0\\n");\n    }\n    else \n    {\n    \tif(b==sci)\n    \tprintf("-1\\n");\n    \telse if(b==sto)\n    \tprintf("1\\n");\n    \telse\n    \tprintf("0\\n");\n    }\n\treturn 0;\n}\n\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\nint main()\n{\n\tchar a,b;\n\tcin&gt;&gt;a&gt;&gt;b;\n\tif(a=='0'&amp;&amp;b=='0')\n\t\tcout&lt;&lt;0;\n\tif(a=='1'&amp;&amp;b=='1')\n\t\tcout&lt;&lt;0;\n\tif(a=='2'&amp;&amp;b=='2')\n\t\tcout&lt;&lt;0;\n\tif(a=='0'&amp;&amp;b=='1')\n\t\tcout&lt;&lt;-1;\n\tif(a=='0'&amp;&amp;b=='2')\n\t\tcout&lt;&lt;1;\n\tif(a=='1'&amp;&amp;b=='0')\n\t\tcout&lt;&lt;1;\n\tif(a=='1'&amp;&amp;b=='2')\n\t\tcout&lt;&lt;-1;\n\tif(a=='2'&amp;&amp;b=='0')\n\t\tcout&lt;&lt;-1;\n\tif(a=='2'&amp;&amp;b=='1')\n\t\tcout&lt;&lt;1;\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.*;\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner input = new Scanner(System.in);\n\t\tint a = input.nextInt();\n\t\tint b = input.nextInt();\n\t\t\n\t\tif(a==0 &amp;&amp; b==0){\n\t\t\tSystem.out.println(0);\n\t\t}\n\t\telse if(a==1 &amp;&amp; b==1){\n\t\t\tSystem.out.println(0);\n\t\t}\n\t\telse if(a==2 &amp;&amp; b==2){\n\t\t\tSystem.out.println(0);\n\t\t}\n\t\telse if(a==1 &amp;&amp; b==0){\n\t\t\tSystem.out.println(1);\n\t\t}\n\t\telse if(a==2 &amp;&amp; b==1){\n\t\t\tSystem.out.println(1);\n\t\t}\n\t\telse if(a==0 &amp;&amp; b==2){\n\t\t\tSystem.out.println(1);\n\t\t}\n\t\telse{\n\t\t\tSystem.out.println(-1);\n\t\t}\n\t}\n\n}\n\r\n</textarea>	239
238	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　PASCAL三角是形状如下的三角矩阵：\n  <br> 　　1\n  <br> 　　1 1\n  <br> 　　1 2 1\n  <br> 　　1 3 3 1\n  <br> 　　1 4 6 4 1\n  <br> 　　在PASCAL三角中的每个数是一个组合C(n,k)。\n  <br> 　　C(n,k)=(((((((n/1)(n-1))/2(n-2))/3)***(n-k+2))/(k-1))(n-k+1))/k\n  <br> 　　公式中交替使用乘法和除法，每次将从n开始递减的一个值相乘，然后除以下一个从1开始递增的值。\n  <br> 　　如果对行和列从0开始计数，则数字C(n,k)在n行k列。例如C(6,2)在第6行第2列。编程输出指定阶数的PASCAL三角矩阵。例如下面给出的是12阶PASCAL三角形矩阵。\n  <br> \n  <br> 　　编写程序，使运行结果为：\n  <br> 　　1\n  <br> 　　1 1\n  <br> 　　1 2 1\n  <br> 　　1 3 3 1\n  <br> 　　1 4 6 4 1\n  <br> 　　1 5 10 10 5 1\n  <br> 　　1 6 15 20 15 6 1\n  <br> 　　1 7 21 35 35 21 7 1\n  <br> 　　1 8 28 56 70 56 28 8 1\n  <br> 　　1 9 36 84 126 126 84 36 9 1\n  <br> 　　1 10 45 120 210 252 210 120 45 10 1\n  <br> 　　1 11 55 165 330 462 462 330 165 55 11 1\n  <br> 　　1 12 66 220 495 792 924 792 495 220 66 12 1\n  <br> \n  <br> \n  <br> 　　该题的详细文档及程序框架请从网络学堂下载！\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n\tint n;\n\tint c[40][40];\n\tscanf("%d",&amp;n);\n\tn=n+1; \n\tint i,j;\n\tfor(i=0;i&lt;n;i++)\n\t{\n\t\tc[i][0]=1;\n\t\tc[i][i]=1;\n\t\tfor(j=1;j&lt;i;j++)\n\t\t{\n\t\t\tc[i][j]=c[i-1][j-1]+c[i-1][j];\n\t\t}\n\t}\n\tfor(i=0;i&lt;n;i++)\n\t{\n\t\tfor(j=0;j&lt;i+1;j++)\n\t\t{\n\t\t\tprintf("%d ",c[i][j]);\n\t\t}\n\t\tprintf("\\n");\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n/**************Powered by Graphene Richards**************/\n//{\n#define OUTPUT_PRECISION    "%.2f"\n#define LF_PRECISION        10\n#define INT_64_MOD          "%I64d"\n#define UNSIGNED_64_MOD     "%I64u"\n\n#define CONTEST_EXIST       1\n\n#define CONTEST_START_HOUR  17\n#define CONTEST_START_MIN   0\n#define CONTEST_START_SEC   0\n\n#define CONTEST_DUR_HOUR    2\n#define CONTEST_DUR_MIN     30\n#define CONTEST_DUR_SEC     0\n\n//#pragma comment(linker,"/STACK:102400000,102400000")\n#include&lt;cmath&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;bitset&gt;\n#include&lt;complex&gt;\n#include&lt;vector&gt;\n#include&lt;iomanip&gt;\n#include&lt;iostream&gt;\n#include&lt;list&gt;\n#include&lt;map&gt;\n#include&lt;queue&gt;\n#include&lt;set&gt;\n#include&lt;stack&gt;\n#include&lt;string&gt;\n#include&lt;typeinfo&gt;\n#define FAST_RW ios_base::sync_with_stdio(0),cin.tie(0);\n#define ll long long\n#define lf long double\n#define IT(x) __typeof((x).begin())\n#define FS(i,a) for(int i=0;a[i];i++)\n#define FE(x,ctn) for(IT(ctn)x=(ctn).begin(),CluhxSchFuDeugk=(ctn).end();x!=CluhxSchFuDeugk;x++)\n#define FR(i,en) for(int i=0,pJNwFPtlXiwFoIv=(en);i&lt;pJNwFPtlXiwFoIv;i++)\n#define FOR(i,en) for(int i=1,SbKCIcakJTeYVqs=(en);i&lt;=SbKCIcakJTeYVqs;i++)\n#define FFR(i,x,y) for(int i=(x),alVDbhLBoMEGSwA=(y);i&lt;=alVDbhLBoMEGSwA;i++)\n#define DFFR(i,x,y) for(int i=(x),NWYfecAcmGBMJuU=(y);i&gt;=NWYfecAcmGBMJuU;i--)\n#define mp make_pair\n#define pb push_back\n#define pq priority_queue\n#define fi first\n#define se second\n#define lb(x) (x&amp;(-x))\n#define sqr(x) (x)*(x)\n#define all(x) (x).begin(),(x).end()\n#define clr(x) memset((x),0,sizeof(x))\n#define inf(x) memset((x),0x7F,sizeof(x))\n#define _inf(x) memset((x),0x80,sizeof(x))\n#define NL puts("");\nusing namespace std;\n\ntemplate&lt;class T1,class T2,class T3&gt;\nbool _IN(T1 x,T2 y,T3 z){\n  return x&lt;=y&amp;&amp;x&gt;=z||x&lt;=z&amp;&amp;x&gt;=y;\n}\n\ntemplate&lt;class T&gt;\nT gcd(T a,T b){\n  if(!b)\n    return a;\n  while(b^=a^=b^=a%=b);\n  return a;\n}\n\n#ifdef wmx16835\n#include&lt;ctime&gt;\n#include&lt;windows.h&gt;\n\n#define GREEN  10\n#define BLUE   11\n#define RED    12\n#define PINK   13\n#define YELLOW 14\n#define WHITE  15\n\nstruct TM{\n  int t;\n  TM(int a,int b,int c):t(a*3600+b*60+c){}\n  TM(int x):t(x){}\n  TM(){}\n  operator int(){return t;}\n  void print(){\n    printf("%02d:%02d:%02d",t/3600%24,t/60%60,t%60);\n  }\n};\n\nvoid OVZmetNNpAqAVZx(){\n  //__________;\n  time_t t=time(0);\n  srand(t);\n  tm*p=localtime(&amp;t);\n  TM day(24,0,0),cur(p-&gt;tm_hour,p-&gt;tm_min,p-&gt;tm_sec),beg(CONTEST_START_HOUR,CONTEST_START_MIN,CONTEST_START_SEC),len(CONTEST_DUR_HOUR,CONTEST_DUR_MIN,CONTEST_DUR_SEC),en(beg+len),fen(beg+en+day&gt;&gt;1),seg;\n  if(beg&gt;cur)\n    cur.t+=day;\n  puts("  +--------------------------+");\n  if(_IN(cur,beg,en)&amp;&amp;CONTEST_EXIST){\n    puts("  |      Status: Running     |");\n    printf("  |     Progress: %5.1f %%    |\\n",(double)(cur-beg)/len*100);\n    seg.t=en-cur;\n    printf("  | Remaining time: ");\n    seg.print();\n    puts(" |");\n  }\n  else{\n    printf("  |  Current time: ");\n    cur.print();\n    puts("  | ");\n    if(cur&lt;=fen||!CONTEST_EXIST)\n      puts("  |       Status: Ended      |");\n    else{\n      puts("  |     Status: Scheduled    |");\n      cur.t-=day;\n      seg.t=beg-cur;\n      printf("  | Remaining time: ");\n      seg.print();\n      puts(" |");\n    }\n  }\n  puts("  +--------------------------+");\n  puts("................................\\n");\n}\n\nconst HANDLE hout=GetStdHandle(STD_OUTPUT_HANDLE);\n\nvoid _COLOR(unsigned x=BLUE){\n  SetConsoleTextAttribute(hout,x);\n}\n\nvoid pCJUYxWEXKaDOIC(){\n  int num=1;\n  FILE*p=fopen("FILE_NAME","r");\n  if(p){\n    fscanf(p,"%d",&amp;num);\n    fclose(p);\n  }\n  char f_name[1024];\n  sprintf(f_name,"%d.out",num++);\n  _COLOR(PINK);\n  printf("[NOTICE] Standard output has been redirected to \\"%s\\".\\n",f_name);\n  _COLOR();\n  freopen(f_name,"w",stdout);\n  if(!stdout)\n    exit(1);\n  else\n  p=fopen("FILE_NAME","w");\n  if(p){\n    fprintf(p,"%d",num);\n    fclose(p);\n  }\n}\n\n#define LOG {_COLOR(RED);unsigned ijqQjAZZNYpJYBe=clock();puts("\\n----------------------");_COLOR();\n#define TEL _COLOR(RED),printf("\\n----------------------\\nExecution time: %ums\\n----------------------\\n",clock()-ijqQjAZZNYpJYBe);_COLOR();}\n#define SHOW_TIME _COLOR(GREEN);OVZmetNNpAqAVZx();_COLOR();\n#define test(...) _COLOR(YELLOW),printf(__VA_ARGS__),_COLOR()\n#define TEST(x) _COLOR(YELLOW),printf("%s = ",#x),_P(x),puts(""),_COLOR()\n#define PF pCJUYxWEXKaDOIC();\n\n#else\n#define LOG\n#define TEL\n#define SHOW_TIME\n#define test(...)\n#define TEST(...)\n#define PF\n#endif\n\nint S(char*a){\n  return scanf("%s",a)==1;\n}\n\ntemplate&lt;class T&gt;\nint S(T&amp;a){\n  const char*x=typeid(a).name();\n  if(!strcmp(x,"i")||!strcmp(x,"b"))return scanf("%d",&amp;a)==1;\n  else if(!strcmp(x,"j"))return scanf("%u",&amp;a)==1;\n  else if(!strcmp(x,"c"))return scanf("%c",&amp;a)==1;\n  else if(!strcmp(x,"Pc")||*x=='A')return scanf("%s",a)==1;\n  else if(!strcmp(x,"f"))return scanf("%f",&amp;a)==1;\n  else if(!strcmp(x,"d"))return scanf("%lf",&amp;a)==1;\n  else if(!strcmp(x,"x"))return scanf(INT_64_MOD,&amp;a)==1;\n  else if(!strcmp(x,"y"))return scanf(UNSIGNED_64_MOD,&amp;a)==1;\n  else if(!strcmp(x,"e"))return (cin&gt;&gt;a)!=0;\n  else test("Input format error!\\n");\n}\n\ntemplate&lt;class T&gt;\nvoid _P(T a){\n  const char*x=typeid(a).name();\n  if(!strcmp(x,"i")||!strcmp(x,"b"))printf("%d",a);\n  else if(!strcmp(x,"j"))printf("%u",a);\n  else if(!strcmp(x,"c"))printf("%c",a);\n  else if(!strcmp(x,"Pc")||!strcmp(x,"PKc")||*x=='A')printf("%s",a);\n  else if(!strcmp(x,"d")||!strcmp(x,"f"))printf(OUTPUT_PRECISION,a);\n  else if(!strcmp(x,"x"))printf(INT_64_MOD,a);\n  else if(!strcmp(x,"y"))printf(UNSIGNED_64_MOD,a);\n  else if(!strcmp(x,"e"))cout&lt;&lt;setprecision(LF_PRECISION)&lt;&lt;a;\n  else test("Output format error!\\n");\n}\n\ntemplate&lt;class T1,class T2&gt;\nint S(T1&amp;a,T2&amp;b){\n  return S(a)+S(b)==2;\n}\n\ntemplate&lt;class T1,class T2,class T3&gt;\nint S(T1&amp;a,T2&amp;b,T3&amp;c){\n  return S(a)+S(b)+S(c)==3;\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nint S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d){\n  return S(a)+S(b)+S(c)+S(d)==4;\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nint S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d,T5&amp;e){\n  return S(a)+S(b)+S(c)+S(d)+S(e)==5;\n}\n\ntemplate&lt;class T&gt;\nvoid P(T a){\n  _P(a);\n  putchar(' ');\n}\n\ntemplate&lt;class T1,class T2&gt;\nvoid P(T1 a,T2 b){\n  _P(a);putchar(' ');\n  _P(b);putchar(' ');\n}\n\ntemplate&lt;class T&gt;\nvoid PN(T a){\n  _P(a);\n  NL\n}\n\ntemplate&lt;class T1,class T2&gt;\nvoid PN(T1 a,T2 b){\n  _P(a);putchar(' ');\n  _P(b);NL\n}\n\ntemplate&lt;class T1,class T2,class T3&gt;\nvoid PN(T1 a,T2 b,T3 c){\n  _P(a);putchar(' ');\n  _P(b);putchar(' ');\n  _P(c);NL\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nvoid PN(T1 a,T2 b,T3 c,T4 d){\n  _P(a);putchar(' ');\n  _P(b);putchar(' ');\n  _P(c);putchar(' ');\n  _P(d);NL\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nvoid PN(T1 a,T2 b,T3 c,T4 d,T5 e){\n  _P(a);putchar(' ');\n  _P(b);putchar(' ');\n  _P(c);putchar(' ');\n  _P(d);putchar(' ');\n  _P(e);NL\n}\n\nint kase;\nconst double pi=4*atan(1);\n//}\n\nint a[1000];\n\nint main(){\n  SHOW_TIME\n  a[1]=1;\n  int n;\n  S(n);\n  FOR(i,n+1){\n    DFFR(j,i,1)a[j]+=a[j-1];\n    FOR(j,i)P(a[j]);\n    NL\n  }\n}\n\n/*********Risoft corporation all rights reserved*********/\n/**************Template V1.32 build 20150102*************/\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args)  \n\t{\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tint a[][]=new int[n+1][n+1];\n\t\tfor(int j=0;j&lt;n+1;j++)\n\t\t{\n\t\t\tfor(int i=0;i&lt;j+1;i++)\n\t\t\t{\n\t\t\t\tif(i==0)\n\t\t\t\t\ta[j][i]=1;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ta[j][i]=a[j-1][i-1]+a[j-1][i];\n\t\t\t\t}\n\t\t\t\tSystem.out.print(a[j][i]+" ");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\t\n}\r\n</textarea>	240
239	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　编写并测试如下函数：\n  <br> 　　void Add (int a[], int m, int b[], int n);\n  <br> 　　该函数将数组b的前n个元素追加到数组a的前m个元素后，假定数组a具有至少存放m+n个元素的空间。例如，如果数组a为{22,33,44,55,66,77,88,99}，数组b为{20,30,40,50,60,70,80,90}，则调用Add(a,5,b,3)后，将把数组a变为{22,33,44,55,66,20,30,40}。注意数组b并没有改变，而且数组a中只需改变n个元素。\n </div>\n <div class="pdsec">\n  测试\n </div>\n <div class="pdcont">\n  　　输入：4行。第一行为两个整数：m，n，并以空格隔开，分别表示将要输入的数组a和数组b的元素的个数。第二行为m个整数，为数组a的元素；第三行为n个整数，为数组b的元素。第四行为两个整数m1，n1，表示把数组b的前n1个元素追加到数组a的前m1个元素后。\n  <br> 　　输出：1行。第一行为最后数组a中的元素，两个元素之间以逗号隔开。最后一个元素输出后，输出一个空行。\n </div>\n <div class="pdsec">\n  参考程序\n </div>\n <div class="pdcont">\n  　　#include &lt;cassert&gt;\n  <br> 　　#include &lt;iostream&gt;\n  <br> 　　using namespace std;\n  <br> \n  <br> 　　void Disp(int a[], int n)\n  <br> 　　{\n  <br> 　　for (int i=0; i&lt;n-1; i++)\n  <br> 　　cout &lt;&lt; a[i] &lt;&lt; ", ";\n  <br> 　　cout &lt;&lt; a[n-1] &lt;&lt; endl;\n  <br> 　　}\n  <br> \n  <br> 　　void Add(int a[], int m, int b[], int n)\n  <br> 　　{\n  <br> 　　//...请补充完整\n  <br> 　　}\n  <br> \n  <br> 　　int main()\n  <br> 　　{\n  <br> 　　int* a = NULL;\n  <br> 　　int* b = NULL;\n  <br> 　　int i = 0;\n  <br> 　　int m, n;\n  <br> 　　cin &gt;&gt; m &gt;&gt; n;\n  <br> 　　a = new int[m + n];\n  <br> 　　b = new int[n];\n  <br> 　　for(i = 0; i &lt; m; i++)\n  <br> 　　cin &gt;&gt; a[i];\n  <br> 　　for(i = 0; i &lt; n; i++)\n  <br> 　　cin &gt;&gt; b[i];\n  <br> \n  <br> 　　int m1, n1;\n  <br> 　　cin &gt;&gt; m1 &gt;&gt; n1;\n  <br> \n  <br> 　　// 请补充完整\n  <br> \n  <br> \n  <br> 　　return 0;\n  <br> 　　}\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n#include&lt;string.h&gt;\nvoid Add (int a[], int m, int b[], int n){\n    int i,j;\n    for(i=0;i&lt;n;i++)\n    a[m+i]=b[i];\n    }\nint main(){\nint m,m1,n,n1,i;\nint a[100],b[100];\n//FILE *fp;\n//fp=fopen("input1.txt","r"); \nscanf("%d%d",&amp;m1,&amp;n1);\nfor(i=0;i&lt;m1;i++)\nscanf("%d",&amp;a[i]);\nfor(i=0;i&lt;n1;i++)\nscanf("%d",&amp;b[i]);\nscanf("%d%d",&amp;m,&amp;n);\nAdd (a,m,b,n);\nif(n!=0){\nfor(i=0;i&lt;n+m-1;i++)\nprintf("%d, ",a[i]);\nprintf("%d\\n",a[i]);\n}else{\nfor(i=0;i&lt;m1-1;i++)\n  printf("%d, ",a[i]); \nprintf("%d\\n",a[i]); \n    }\nsystem("pause");\nreturn 0;\n} \n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;cassert&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nvoid Disp(int a[], int n)\n{\nfor (int i=0; i&lt;n-1; i++)\ncout &lt;&lt; a[i] &lt;&lt; ", ";\ncout &lt;&lt; a[n-1] &lt;&lt; endl;\n}\n\nvoid Add(int a[], int m, int b[], int n)\n{\nint i;\nfor(i=0;i&lt;n;i++)\na[m+i]=b[i];\n}\n\nint main()\n{\nint* a = NULL;\nint* b = NULL;\nint i = 0;\nint m, n;\nint m1,n1;\ncin &gt;&gt; m &gt;&gt; n;\na = new int[m + n];\nb = new int[n];\nfor(i = 0; i &lt; m; i++)\ncin &gt;&gt; a[i];\nfor(i = 0; i &lt; n; i++)\ncin &gt;&gt; b[i];\ncin &gt;&gt; m1 &gt;&gt; n1;\nAdd(a,m1,b,n1);\nif(n1) Disp(a,m1+n1);\nelse Disp(a,m);\nreturn 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner input=new Scanner(System.in);\n\t\tint m=input.nextInt();\n\t\tint n=input.nextInt();\n\t\tint[] a=new int[m+n];\n\t\tint[] b=new int[n];\n\t\t\n\t\tfor(int i=0;i&lt;m;i++){\n\t\t\ta[i]=input.nextInt();\n\t\t}\n\t\tfor(int i=0;i&lt;n;i++){\n\t\t\tb[i]=input.nextInt();\n\t\t}\n\t\t\n\t\tint m1=input.nextInt();\n\t\tint n1=input.nextInt();\n\t\t\n\t\tfor(int i=0;i&lt;m1;i++){\n\t\t\ta[i]=a[i];\n\t\t}\n\t\tfor(int i=m1;i&lt;m1+n1;i++){\n\t\t\ta[i]=b[i-m1];\n\t\t}\n\t\t\n\t\tif(m1!=0&amp;&amp;n1==0){\n\t\t\tfor(int i=0;i&lt;m;i++){\n\t\t\t\tif(i!=m-1){\n\t\t\t\t\tSystem.out.print(a[i]+", ");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tSystem.out.println(a[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(m1==0&amp;&amp;n1!=0){\n\t\t\tfor(int i=0;i&lt;n1;i++){\n\t\t\t\tif(i!=n1-1){\n\t\t\t\t\tSystem.out.print(b[i]+", ");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tSystem.out.println(b[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(m1==0&amp;&amp;n1==0){\n\t\t\tfor(int i=0;i&lt;m;i++){\n\t\t\t\tif(i!=m-1){\n\t\t\t\t\tSystem.out.print(a[i]+", ");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tSystem.out.println(a[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\telse{\n\t\tfor(int i=0;i&lt;m1+n1;i++){\n\t\t\tif(i!=m1+n1-1){\n\t\t\t\tSystem.out.print(a[i]+", ");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(a[i]);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t}\n\n\t}\n\n}\r\n</textarea>	241
240	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　程序提示用户输入三个字符，每个字符取值范围是0-9，A-F。然后程序会把这三个字符转化为相应的十六进制整数，并分别以十六进制，十进制，八进制输出。\n  <br> 　　输入格式：输入只有一行，即三个字符。\n  <br> 　　输出格式：输出只有一行，包括三个整数，中间用空格隔开。\n  <br> 　　输入输出样例\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  FFF\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  FFF 4095 7777\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint getnum(char a)\n{\n\tif(a&gt;='0' &amp;&amp; a&lt;='9') return a-'0';\n\treturn a-'A'+10;\n}\nint main()\n{\n   char a,b,c;\n   int num;\n   scanf("%c%c%c",&amp;a,&amp;b,&amp;c);\n   num=getnum(c)+getnum(b)*16+getnum(a)*256; \n   if(num) printf("%c%c%c %d %o",a,b,c,num,num);\n   else printf("%c %d %o",a,num,num);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n/**************Powered by Graphene Richards**************/\n//{\n#define OUTPUT_PRECISION    "%.2f"\n#define LF_PRECISION        10\n#define INT_64_MOD          "%I64d"\n#define UNSIGNED_64_MOD     "%I64u"\n\n#define CONTEST_EXIST       1\n\n#define CONTEST_START_HOUR  13\n#define CONTEST_START_MIN   0\n#define CONTEST_START_SEC   0\n\n#define CONTEST_DUR_HOUR    3\n#define CONTEST_DUR_MIN     0\n#define CONTEST_DUR_SEC     0\n\n//#pragma comment(linker,"/STACK:102400000,102400000")\n#include&lt;cmath&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;bitset&gt;\n#include&lt;complex&gt;\n#include&lt;vector&gt;\n#include&lt;iomanip&gt;\n#include&lt;iostream&gt;\n#include&lt;list&gt;\n#include&lt;map&gt;\n#include&lt;queue&gt;\n#include&lt;set&gt;\n#include&lt;stack&gt;\n#include&lt;string&gt;\n#include&lt;typeinfo&gt;\n#define FAST_RW ios_base::sync_with_stdio(0),cin.tie(0);\n#define ll long long\n#define lf long double\n#define IT(x) __typeof((x).begin())\n#define FS(i,a) for(int i=0;a[i];i++)\n#define FE(x,ctn) for(IT(ctn)x=(ctn).begin(),CluhxSchFuDeugk=(ctn).end();x!=CluhxSchFuDeugk;x++)\n#define FR(i,en) for(int i=0,pJNwFPtlXiwFoIv=(en);i&lt;pJNwFPtlXiwFoIv;i++)\n#define FOR(i,en) for(int i=1,SbKCIcakJTeYVqs=(en);i&lt;=SbKCIcakJTeYVqs;i++)\n#define FFR(i,x,y) for(int i=(x),alVDbhLBoMEGSwA=(y);i&lt;=alVDbhLBoMEGSwA;i++)\n#define DFFR(i,x,y) for(int i=(x),NWYfecAcmGBMJuU=(y);i&gt;=NWYfecAcmGBMJuU;i--)\n#define mp make_pair\n#define pb push_back\n#define pq priority_queue\n#define fi first\n#define se second\n#define lb(x) (x&amp;(-x))\n#define sqr(x) (x)*(x)\n#define all(x) (x).begin(),(x).end()\n#define clr(x) memset((x),0,sizeof(x))\n#define inf(x) memset((x),0x7F,sizeof(x))\n#define _inf(x) memset((x),0x80,sizeof(x))\n#define NL puts("");\nusing namespace std;\n\ntemplate&lt;class T1,class T2,class T3&gt;\nbool _IN(T1 x,T2 y,T3 z){\n  return x&lt;=y&amp;&amp;x&gt;=z||x&lt;=z&amp;&amp;x&gt;=y;\n}\n\ntemplate&lt;class T&gt;\nT gcd(T a,T b){\n  if(!b)\n    return a;\n  while(b^=a^=b^=a%=b);\n  return a;\n}\n\n#ifdef wmx16835\n#include&lt;ctime&gt;\n#include&lt;windows.h&gt;\n\n#define GREEN  10\n#define BLUE   11\n#define RED    12\n#define PINK   13\n#define YELLOW 14\n#define WHITE  15\n\nstruct TM{\n  int t;\n  TM(int a,int b,int c):t(a*3600+b*60+c){}\n  TM(int x):t(x){}\n  TM(){}\n  operator int(){return t;}\n  void print(){\n    printf("%02d:%02d:%02d",t/3600%24,t/60%60,t%60);\n  }\n};\n\nvoid OVZmetNNpAqAVZx(){\n  //__________;\n  time_t t=time(0);\n  srand(t);\n  tm*p=localtime(&amp;t);\n  TM day(24,0,0),cur(p-&gt;tm_hour,p-&gt;tm_min,p-&gt;tm_sec),beg(CONTEST_START_HOUR,CONTEST_START_MIN,CONTEST_START_SEC),len(CONTEST_DUR_HOUR,CONTEST_DUR_MIN,CONTEST_DUR_SEC),en(beg+len),fen(beg+en+day&gt;&gt;1),seg;\n  if(beg&gt;cur)\n    cur.t+=day;\n  puts("  +--------------------------+");\n  if(_IN(cur,beg,en)&amp;&amp;CONTEST_EXIST){\n    puts("  |      Status: Running     |");\n    printf("  |     Progress: %5.1f %%    |\\n",(double)(cur-beg)/len*100);\n    seg.t=en-cur;\n    printf("  | Remaining time: ");\n    seg.print();\n    puts(" |");\n  }\n  else{\n    printf("  |  Current time: ");\n    cur.print();\n    puts("  | ");\n    if(cur&lt;=fen||!CONTEST_EXIST)\n      puts("  |       Status: Ended      |");\n    else{\n      puts("  |     Status: Scheduled    |");\n      cur.t-=day;\n      seg.t=beg-cur;\n      printf("  | Remaining time: ");\n      seg.print();\n      puts(" |");\n    }\n  }\n  puts("  +--------------------------+");\n  puts("................................\\n");\n}\n\nconst HANDLE hout=GetStdHandle(STD_OUTPUT_HANDLE);\n\nvoid _COLOR(unsigned x=BLUE){\n  SetConsoleTextAttribute(hout,x);\n}\n\nvoid pCJUYxWEXKaDOIC(){\n  int num=1;\n  FILE*p=fopen("FILE_NAME","r");\n  if(p){\n    fscanf(p,"%d",&amp;num);\n    fclose(p);\n  }\n  char f_name[1024];\n  sprintf(f_name,"%d.out",num++);\n  _COLOR(PINK);\n  printf("[NOTICE] Standard output has been redirected to \\"%s\\".\\n",f_name);\n  _COLOR();\n  freopen(f_name,"w",stdout);\n  if(!stdout)\n    exit(1);\n  else\n  p=fopen("FILE_NAME","w");\n  if(p){\n    fprintf(p,"%d",num);\n    fclose(p);\n  }\n}\n\n#define LOG {_COLOR(RED);unsigned ijqQjAZZNYpJYBe=clock();puts("\\n----------------------");_COLOR();\n#define TEL _COLOR(RED),printf("\\n----------------------\\nExecution time: %ums\\n----------------------\\n",clock()-ijqQjAZZNYpJYBe);_COLOR();}\n#define SHOW_TIME _COLOR(GREEN);OVZmetNNpAqAVZx();_COLOR();\n#define test(...) _COLOR(YELLOW),printf(__VA_ARGS__),_COLOR()\n#define TEST(x) _COLOR(YELLOW),printf("%s = ",#x),_P(x),puts(""),_COLOR()\n#define TRY(...) __VA_ARGS__\n#define PF pCJUYxWEXKaDOIC();\n\n#else\n#define LOG\n#define TEL\n#define SHOW_TIME\n#define test(...)\n#define TEST(...)\n#define TRY(...)\n#define PF\n#endif\n\nint S(char*a){\n  return scanf("%s",a)==1;\n}\n\ntemplate&lt;class T&gt;\nint S(T&amp;a){\n  const char*x=typeid(a).name();\n  if(!strcmp(x,"i")||!strcmp(x,"b"))return scanf("%d",&amp;a)==1;\n  else if(!strcmp(x,"j"))return scanf("%u",&amp;a)==1;\n  else if(!strcmp(x,"c"))return scanf("%c",&amp;a)==1;\n  else if(!strcmp(x,"Pc")||*x=='A')return scanf("%s",a)==1;\n  else if(!strcmp(x,"f"))return scanf("%f",&amp;a)==1;\n  else if(!strcmp(x,"d"))return scanf("%lf",&amp;a)==1;\n  else if(!strcmp(x,"x"))return scanf(INT_64_MOD,&amp;a)==1;\n  else if(!strcmp(x,"y"))return scanf(UNSIGNED_64_MOD,&amp;a)==1;\n  else if(!strcmp(x,"e"))return (cin&gt;&gt;a)!=0;\n  else test("Input format error!\\n");\n}\n\ntemplate&lt;class T&gt;\nvoid _P(T a){\n  const char*x=typeid(a).name();\n  if(!strcmp(x,"i")||!strcmp(x,"b"))printf("%d",a);\n  else if(!strcmp(x,"j"))printf("%u",a);\n  else if(!strcmp(x,"c"))printf("%c",a);\n  else if(!strcmp(x,"Pc")||!strcmp(x,"PKc")||*x=='A')printf("%s",a);\n  else if(!strcmp(x,"d")||!strcmp(x,"f"))printf(OUTPUT_PRECISION,a);\n  else if(!strcmp(x,"x"))printf(INT_64_MOD,a);\n  else if(!strcmp(x,"y"))printf(UNSIGNED_64_MOD,a);\n  else if(!strcmp(x,"e"))cout&lt;&lt;setprecision(LF_PRECISION)&lt;&lt;a;\n  else test("Output format error!\\n");\n}\n\ntemplate&lt;class T1,class T2&gt;\nint S(T1&amp;a,T2&amp;b){\n  return S(a)+S(b)==2;\n}\n\ntemplate&lt;class T1,class T2,class T3&gt;\nint S(T1&amp;a,T2&amp;b,T3&amp;c){\n  return S(a)+S(b)+S(c)==3;\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nint S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d){\n  return S(a)+S(b)+S(c)+S(d)==4;\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nint S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d,T5&amp;e){\n  return S(a)+S(b)+S(c)+S(d)+S(e)==5;\n}\n\ntemplate&lt;class T&gt;\nvoid P(T a){\n  _P(a);\n  putchar(' ');\n}\n\ntemplate&lt;class T1,class T2&gt;\nvoid P(T1 a,T2 b){\n  _P(a);putchar(' ');\n  _P(b);putchar(' ');\n}\n\ntemplate&lt;class T&gt;\nvoid PN(T a){\n  _P(a);\n  NL\n}\n\ntemplate&lt;class T1,class T2&gt;\nvoid PN(T1 a,T2 b){\n  _P(a);putchar(' ');\n  _P(b);NL\n}\n\ntemplate&lt;class T1,class T2,class T3&gt;\nvoid PN(T1 a,T2 b,T3 c){\n  _P(a);putchar(' ');\n  _P(b);putchar(' ');\n  _P(c);NL\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nvoid PN(T1 a,T2 b,T3 c,T4 d){\n  _P(a);putchar(' ');\n  _P(b);putchar(' ');\n  _P(c);putchar(' ');\n  _P(d);NL\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nvoid PN(T1 a,T2 b,T3 c,T4 d,T5 e){\n  _P(a);putchar(' ');\n  _P(b);putchar(' ');\n  _P(c);putchar(' ');\n  _P(d);putchar(' ');\n  _P(e);NL\n}\n\nint kase;\nconst double pi=4*atan(1);\nconst double ep=1e-9;\n//}\n\nint main(){\n  SHOW_TIME\n  int x;\n  scanf("%x",&amp;x);\n  printf("%X %d %o",x,x,x);\n}\n\n/*********Risoft corporation all rights reserved*********/\n/**************Template V1.33 build 20150114*************/\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.math.BigInteger;\nimport java.util.Scanner;\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner in=new Scanner(System.in);\n\t\tString str=in.next();\n\t\tif(str.equals("000"))\n\t\t\tstr="0";\n\t    BigInteger h=new BigInteger(str,16);\n\t    System.out.printf("%s %d %o",str,h,h);\n\n\t}\n\n}\r\n</textarea>	242
245	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　编写一个程序，首先输入一个整数，例如5，然后在屏幕上显示如下的图形（5表示行数）：\n  <br> 　　* * * * *\n  <br> 　　* * * *\n  <br> 　　* * *\n  <br> 　　* *\n  <br> 　　*\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint main()\n{int i,j,a[100][100],n;\n while(scanf("%d",&amp;n)!=EOF)\n {for(i=0;i&lt;n;i++)\n  for(j=0;j&lt;n-i;j++)\n  {\n   printf("*");\n   if(j!=n-i-1)\n   printf(" ");\n   if(j==n-1-i)\n   printf("\\n");\n  }\n }\n }\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\nusing namespace std;\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    for (int i = 0; i &lt; n; i++)\n        for (int j = 1; j &lt;= n - i; j++)\n        {\n            cout &lt;&lt; "*";\n                 if (j &lt; n - i)\n                     cout &lt;&lt; " ";\n            else\n                cout &lt;&lt;endl;\n        }\n\n    return  0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint number = Integer.valueOf(br.readLine());\n\t\tfor (int i = 0; i &lt; number; i++) {\n\t\t\tfor (int j = i; j &lt; number; j++) {\n\t\t\t\tif (i != number - 1)\n\t\t\t\t\tSystem.out.print("* ");\n\t\t\t\telse\n\t\t\t\t\tSystem.out.print("*");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n}\n\r\n</textarea>	247
241	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　编写一个程序，输入3个整数，然后程序将对这三个整数按照从大到小进行排列。\n  <br> 　　输入格式：输入只有一行，即三个整数，中间用空格隔开。\n  <br> 　　输出格式：输出只有一行，即排序后的结果。\n  <br> 　　输入输出样例\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  9 2 30\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  30 9 2\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n#define num 100\nint main(void)\n{\t\n\tint i,j,t,a[3]={0};\n\tfor (i=0;i&lt;3;i++)\n\t{\tscanf("%d",&amp;a[i]);\n\t}\n\tfor (i=0;i&lt;3;i++)\n\t\tfor (j=i;j&lt;3;j++)\n\t\t\tif (a[i]&lt;=a[j]){t=a[i];a[i]=a[j];a[j]=t;}\n\tfor (i=0;i&lt;3;i++)\n\t{\tprintf("%d",a[i]);\n\t\tif(i!=2) printf(" ");\n\t}\n\t\nprintf("\\n");\n\t\nreturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\nint main()\n{\n    int a,b,t,c;\n    while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c)\n    {\n        if(a&lt;b)\n        {\n            t=a;a=b;b=t;\n        }\n        if(a&lt;c)\n        {\n            t=a;a=c;c=t;\n        }\n        if(b&lt;c)\n        {\n            t=b;b=c;c=t;\n        }\n        cout&lt;&lt;a&lt;&lt;' '&lt;&lt;b&lt;&lt;' '&lt;&lt;c&lt;&lt;endl;\n    }\n    return 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\nimport java.util.Arrays;\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader str=new BufferedReader(new InputStreamReader(System.in));\n\t\tString s=str.readLine();\n        String[] s1=s.split(" ");\n        int n=s1.length;\n        int[] arr=new int[n];\n        for(int i=0;i&lt;n;i++){\n        \t arr[i]=Integer.parseInt(s1[i]);\n        }\n        Arrays.sort(arr);\n        for(int j=n-1;j&gt;=0;j--){\n        \tSystem.out.print(arr[j]+" ");\n        }\n\t}\n\n}\n\r\n</textarea>	243
242	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　编写一个程序，输入一个1000 以内的正整数，然后把这个整数的每一位数字都分离出来，并逐一地显示。\n  <br> 　　输入格式：输入只有一行，即一个1000以内的正整数。\n  <br> 　　输出格式：输出只有一行，即该整数的每一位数字，之间用空格隔开。\n  <br> 　　输入输出样例\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  769\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  7 6 9\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n\tint n,m,i=0;\n\tint ab[10];\n\tscanf("%d",&amp;n);\n\twhile(n)\n\t{\n\t\tab[i++]=n%10;\n\t\tn=n/10;\n\t}\n\tfor(m=i-1;m&gt;=0;m--)\n\t{\n\t\tif(m!=0)\n\t\t    printf("%d ",ab[m]);\n\t\telse\n\t\t\tprintf("%d\\n",ab[m]);\n\t}\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\nusing namespace std;\nint main()\n{\nint a,b[5],l=0,i;\ncin&gt;&gt;a;\nwhile(a&gt;0)\n{\nb[l]=a%10;\nl++;\na/=10;\n}\nfor(i=l-1;i&gt;=0;i--)\ncout&lt;&lt;b[i]&lt;&lt;" ";\nreturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tchar[] out = br.readLine().toCharArray();\n\t\tfor (int i = 0; i &lt; out.length; i++) {\n\t\t\tif (i != out.length - 1)\n\t\t\t\tSystem.out.print(out[i] + " ");\n\t\t\telse\n\t\t\t\tSystem.out.print(out[i]);\n\t\t}\n\t}\n\n}\n\r\n</textarea>	244
243	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　编写一个程序，计算员工的周薪。薪水的计算是以小时为单位，如果在一周的时间内，员工工作的时间不超过40 个小时，那么他/她的总收入等于工作时间乘以每小时的薪水。如果员工工作的时间在40 到50 个小时之间，那么对于前40 个小时，仍按常规方法计算；而对于剩余的超额部分，每小时的薪水按1.5 倍计算。如果员工工作的时间超过了50 个小时，那么对于前40 个小时，仍按常规方法计算；对于40～50 个小时之间的部分，每小时的薪水按1.5 倍计算；而对于超出50 个小时的部分，每小时的薪水按2 倍计算。请编写一个程序，输入员工的工作时间和每小时的薪水，然后计算并显示他/她应该得到的周薪。\n  <br> 　　输入格式：输入只有一行，包括一个整数和一个实数，分别表示工作时间和每小时薪水。\n  <br> 　　输出格式：输出只有一个实数，表示周薪，保留小数点后2位。\n  <br> 　　输入输出样例\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  40 50\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  2000.00\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint main()\n{\nfloat a,b,sum=0.0;\nscanf("%f%f",&amp;a,&amp;b);\nif(a&lt;=40) sum=a*b;\nelse if(a&gt;40 &amp;&amp; a&lt;=50) sum=40*b+(a-40)*1.5*b;\nelse if(a&gt;50) sum=40*b+10*1.5*b+(a-50)*2*b;\nprintf("%.2f",sum);\nreturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;stdio.h&gt;\nusing namespace std;\nint main()\n{\n\tdouble t;\n\tdouble a;\n\tdouble m=0;\n\tcin&gt;&gt;t&gt;&gt;a;\n\tif (t&lt;=40){\n\t\tm=t*a;\n\t}\n\tif (t&gt;40&amp;&amp;t&lt;=50){\n\t\tm=a*40+(t-40)*a*1.5;\n\t}\n\tif (t&gt;50){\n\t\tm=a*40+10*a*1.5+(t-50)*a*2;\n\t}\n\tprintf("%.2f",m);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.math.BigDecimal;\nimport java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tString a=sc.next();\n\t\tString b=sc.next();\n        double t= Double.parseDouble(a);\n        double m= Double.parseDouble(b);\n        double sum=0;\n        if(t==0||m==0)\n        System.out.println("0.00");\n        else\n        if(0&lt;t&amp;&amp;t&lt;=40)\n        {\n        \tsum=t*m;\n        \tBigDecimal bd = new BigDecimal(sum);\n        \tbd = bd.setScale(2,BigDecimal.ROUND_HALF_UP);  \n        \tSystem.out.println(bd);\n        }\n        else\n        if(t&lt;=50)\n        {\tsum=40*m+(t-40)*m*1.5;\n        BigDecimal bd = new BigDecimal(sum);\n    \tbd = bd.setScale(2,BigDecimal.ROUND_HALF_UP);  \n    \tSystem.out.println(bd);\n        }\n        else\n        {\t\n        \tsum=40*m+10*1.5*m+(t-50)*m*2;\n        \tBigDecimal bd = new BigDecimal(sum);\n        \tbd = bd.setScale(2,BigDecimal.ROUND_HALF_UP);  \n        \tSystem.out.println(bd);\n        }\n\t}\n}\r\n</textarea>	245
244	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　编写一个程序，输入三个正整数min、max和factor，然后对于min到max之间的每一个整数（包括min和max），如果它能被factor整除，就把它打印出来。\n  <br> 　　输入格式：输入只有一行，包括三个整数min、max和factor。\n  <br> 　　输出格式：输出只有一行，包括若干个整数。\n  <br> 　　输入输出样例\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  1 10 3\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  3 6 9\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint main()\n{\n\tint min, max , factor;\n\tscanf("%d%d%d",&amp;min,&amp;max,&amp;factor);\n\tint i;\n\tint res;\n\tfor(i=1;;i++)\n\t{\n\t\tres = factor*i;\n\t\tif(res&lt;=max &amp;&amp; res&gt;=min)\n\t\t{\n\t\t\tprintf("%d ",res);\n\t\t}\n\t\telse if(res&gt;max)\n\t\t\tbreak;\n\t}\n\treturn 0;\n\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n/**************Powered by Graphene Richards**************/\n//{\n#define OUTPUT_PRECISION    "%.2f"\n#define LF_PRECISION        10\n#define INT_64_MOD          "%I64d"\n#define UNSIGNED_64_MOD     "%I64u"\n\n#define CONTEST_EXIST       1\n\n#define CONTEST_START_HOUR  17\n#define CONTEST_START_MIN   0\n#define CONTEST_START_SEC   0\n\n#define CONTEST_DUR_HOUR    2\n#define CONTEST_DUR_MIN     30\n#define CONTEST_DUR_SEC     0\n\n//#pragma comment(linker,"/STACK:102400000,102400000")\n#include&lt;cmath&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;bitset&gt;\n#include&lt;complex&gt;\n#include&lt;vector&gt;\n#include&lt;iomanip&gt;\n#include&lt;iostream&gt;\n#include&lt;list&gt;\n#include&lt;map&gt;\n#include&lt;queue&gt;\n#include&lt;set&gt;\n#include&lt;stack&gt;\n#include&lt;string&gt;\n#include&lt;typeinfo&gt;\n#define FAST_RW ios_base::sync_with_stdio(0),cin.tie(0);\n#define ll long long\n#define lf long double\n#define IT(x) __typeof((x).begin())\n#define FS(i,a) for(int i=0;a[i];i++)\n#define FE(x,ctn) for(IT(ctn)x=(ctn).begin(),CluhxSchFuDeugk=(ctn).end();x!=CluhxSchFuDeugk;x++)\n#define FR(i,en) for(int i=0,pJNwFPtlXiwFoIv=(en);i&lt;pJNwFPtlXiwFoIv;i++)\n#define FOR(i,en) for(int i=1,SbKCIcakJTeYVqs=(en);i&lt;=SbKCIcakJTeYVqs;i++)\n#define FFR(i,x,y) for(int i=(x),alVDbhLBoMEGSwA=(y);i&lt;=alVDbhLBoMEGSwA;i++)\n#define DFFR(i,x,y) for(int i=(x),NWYfecAcmGBMJuU=(y);i&gt;=NWYfecAcmGBMJuU;i--)\n#define mp make_pair\n#define pb push_back\n#define pq priority_queue\n#define fi first\n#define se second\n#define lb(x) (x&amp;(-x))\n#define sqr(x) (x)*(x)\n#define all(x) (x).begin(),(x).end()\n#define clr(x) memset((x),0,sizeof(x))\n#define inf(x) memset((x),0x7F,sizeof(x))\n#define _inf(x) memset((x),0x80,sizeof(x))\n#define NL puts("");\nusing namespace std;\n\ntemplate&lt;class T1,class T2,class T3&gt;\nbool _IN(T1 x,T2 y,T3 z){\n  return x&lt;=y&amp;&amp;x&gt;=z||x&lt;=z&amp;&amp;x&gt;=y;\n}\n\ntemplate&lt;class T&gt;\nT gcd(T a,T b){\n  if(!b)\n    return a;\n  while(b^=a^=b^=a%=b);\n  return a;\n}\n\n#ifdef wmx16835\n#include&lt;ctime&gt;\n#include&lt;windows.h&gt;\n\n#define GREEN  10\n#define BLUE   11\n#define RED    12\n#define PINK   13\n#define YELLOW 14\n#define WHITE  15\n\nstruct TM{\n  int t;\n  TM(int a,int b,int c):t(a*3600+b*60+c){}\n  TM(int x):t(x){}\n  TM(){}\n  operator int(){return t;}\n  void print(){\n    printf("%02d:%02d:%02d",t/3600%24,t/60%60,t%60);\n  }\n};\n\nvoid OVZmetNNpAqAVZx(){\n  //__________;\n  time_t t=time(0);\n  srand(t);\n  tm*p=localtime(&amp;t);\n  TM day(24,0,0),cur(p-&gt;tm_hour,p-&gt;tm_min,p-&gt;tm_sec),beg(CONTEST_START_HOUR,CONTEST_START_MIN,CONTEST_START_SEC),len(CONTEST_DUR_HOUR,CONTEST_DUR_MIN,CONTEST_DUR_SEC),en(beg+len),fen(beg+en+day&gt;&gt;1),seg;\n  if(beg&gt;cur)\n    cur.t+=day;\n  puts("  +--------------------------+");\n  if(_IN(cur,beg,en)&amp;&amp;CONTEST_EXIST){\n    puts("  |      Status: Running     |");\n    printf("  |     Progress: %5.1f %%    |\\n",(double)(cur-beg)/len*100);\n    seg.t=en-cur;\n    printf("  | Remaining time: ");\n    seg.print();\n    puts(" |");\n  }\n  else{\n    printf("  |  Current time: ");\n    cur.print();\n    puts("  | ");\n    if(cur&lt;=fen||!CONTEST_EXIST)\n      puts("  |       Status: Ended      |");\n    else{\n      puts("  |     Status: Scheduled    |");\n      cur.t-=day;\n      seg.t=beg-cur;\n      printf("  | Remaining time: ");\n      seg.print();\n      puts(" |");\n    }\n  }\n  puts("  +--------------------------+");\n  puts("................................\\n");\n}\n\nconst HANDLE hout=GetStdHandle(STD_OUTPUT_HANDLE);\n\nvoid _COLOR(unsigned x=BLUE){\n  SetConsoleTextAttribute(hout,x);\n}\n\nvoid pCJUYxWEXKaDOIC(){\n  int num=1;\n  FILE*p=fopen("FILE_NAME","r");\n  if(p){\n    fscanf(p,"%d",&amp;num);\n    fclose(p);\n  }\n  char f_name[1024];\n  sprintf(f_name,"%d.out",num++);\n  _COLOR(PINK);\n  printf("[NOTICE] Standard output has been redirected to \\"%s\\".\\n",f_name);\n  _COLOR();\n  freopen(f_name,"w",stdout);\n  if(!stdout)\n    exit(1);\n  else\n  p=fopen("FILE_NAME","w");\n  if(p){\n    fprintf(p,"%d",num);\n    fclose(p);\n  }\n}\n\n#define LOG {_COLOR(RED);unsigned ijqQjAZZNYpJYBe=clock();puts("\\n----------------------");_COLOR();\n#define TEL _COLOR(RED),printf("\\n----------------------\\nExecution time: %ums\\n----------------------\\n",clock()-ijqQjAZZNYpJYBe);_COLOR();}\n#define SHOW_TIME _COLOR(GREEN);OVZmetNNpAqAVZx();_COLOR();\n#define test(...) _COLOR(YELLOW),printf(__VA_ARGS__),_COLOR()\n#define TEST(x) _COLOR(YELLOW),printf("%s = ",#x),_P(x),puts(""),_COLOR()\n#define PF pCJUYxWEXKaDOIC();\n\n#else\n#define LOG\n#define TEL\n#define SHOW_TIME\n#define test(...)\n#define TEST(...)\n#define PF\n#endif\n\nint S(char*a){\n  return scanf("%s",a)==1;\n}\n\ntemplate&lt;class T&gt;\nint S(T&amp;a){\n  const char*x=typeid(a).name();\n  if(!strcmp(x,"i")||!strcmp(x,"b"))return scanf("%d",&amp;a)==1;\n  else if(!strcmp(x,"j"))return scanf("%u",&amp;a)==1;\n  else if(!strcmp(x,"c"))return scanf("%c",&amp;a)==1;\n  else if(!strcmp(x,"Pc")||*x=='A')return scanf("%s",a)==1;\n  else if(!strcmp(x,"f"))return scanf("%f",&amp;a)==1;\n  else if(!strcmp(x,"d"))return scanf("%lf",&amp;a)==1;\n  else if(!strcmp(x,"x"))return scanf(INT_64_MOD,&amp;a)==1;\n  else if(!strcmp(x,"y"))return scanf(UNSIGNED_64_MOD,&amp;a)==1;\n  else if(!strcmp(x,"e"))return (cin&gt;&gt;a)!=0;\n  else test("Input format error!\\n");\n}\n\ntemplate&lt;class T&gt;\nvoid _P(T a){\n  const char*x=typeid(a).name();\n  if(!strcmp(x,"i")||!strcmp(x,"b"))printf("%d",a);\n  else if(!strcmp(x,"j"))printf("%u",a);\n  else if(!strcmp(x,"c"))printf("%c",a);\n  else if(!strcmp(x,"Pc")||!strcmp(x,"PKc")||*x=='A')printf("%s",a);\n  else if(!strcmp(x,"d")||!strcmp(x,"f"))printf(OUTPUT_PRECISION,a);\n  else if(!strcmp(x,"x"))printf(INT_64_MOD,a);\n  else if(!strcmp(x,"y"))printf(UNSIGNED_64_MOD,a);\n  else if(!strcmp(x,"e"))cout&lt;&lt;setprecision(LF_PRECISION)&lt;&lt;a;\n  else test("Output format error!\\n");\n}\n\ntemplate&lt;class T1,class T2&gt;\nint S(T1&amp;a,T2&amp;b){\n  return S(a)+S(b)==2;\n}\n\ntemplate&lt;class T1,class T2,class T3&gt;\nint S(T1&amp;a,T2&amp;b,T3&amp;c){\n  return S(a)+S(b)+S(c)==3;\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nint S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d){\n  return S(a)+S(b)+S(c)+S(d)==4;\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nint S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d,T5&amp;e){\n  return S(a)+S(b)+S(c)+S(d)+S(e)==5;\n}\n\ntemplate&lt;class T&gt;\nvoid P(T a){\n  _P(a);\n  putchar(' ');\n}\n\ntemplate&lt;class T1,class T2&gt;\nvoid P(T1 a,T2 b){\n  _P(a);putchar(' ');\n  _P(b);putchar(' ');\n}\n\ntemplate&lt;class T&gt;\nvoid PN(T a){\n  _P(a);\n  NL\n}\n\ntemplate&lt;class T1,class T2&gt;\nvoid PN(T1 a,T2 b){\n  _P(a);putchar(' ');\n  _P(b);NL\n}\n\ntemplate&lt;class T1,class T2,class T3&gt;\nvoid PN(T1 a,T2 b,T3 c){\n  _P(a);putchar(' ');\n  _P(b);putchar(' ');\n  _P(c);NL\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nvoid PN(T1 a,T2 b,T3 c,T4 d){\n  _P(a);putchar(' ');\n  _P(b);putchar(' ');\n  _P(c);putchar(' ');\n  _P(d);NL\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nvoid PN(T1 a,T2 b,T3 c,T4 d,T5 e){\n  _P(a);putchar(' ');\n  _P(b);putchar(' ');\n  _P(c);putchar(' ');\n  _P(d);putchar(' ');\n  _P(e);NL\n}\n\nint kase;\nconst double pi=4*atan(1);\nconst double ep=1e-9;\n//}\n\nint main(){\n  SHOW_TIME\n  int mi,ma,f;\n  S(mi,ma,f);\n  FFR(i,mi,ma)if(i%f==0)P(i);\n}\n\n/*********Risoft corporation all rights reserved*********/\n/**************Template V1.33 build 20150104*************/\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic static void main(String args[])throws Exception{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] temp = br.readLine().split(" ");\n\t\tint min = Integer.parseInt(temp[0]), max = Integer.parseInt(temp[1]),\n\t\t\t\tdivi = Integer.parseInt(temp[2]);\n\t\tfor(int i=min; i&lt;=max; i++)\n\t\t\tif(i%divi==0)\n\t\t\t\tSystem.out.print(i+" ");\n\t}\n}\n\r\n</textarea>	246
266	<div class="des"> \n <div class="pdcont">\n  　　﻿\n  <br> 　　插入排序\n </div>\n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　排序，顾名思义，是将若干个元素按其大小关系排出一个顺序。形式化描述如下：有n个元素a[1]，a[2]，…，a[n]，从小到大排序就是将它们排成一个新顺序a[i[1]]&lt;a[i[2]]&lt;…&lt;a[i[n]]\n  <br> 　　i[k]为这个新顺序。\n  <br> 　　插入排序，顾名思义，是通过插入操作完成排序。其直觉和方法来源于打牌时安排牌的方法。每次摸起一张牌，你都会将其插入到现在手牌中它按顺序应在的那个位置。插入排序每一步都类似这个摸牌过程。比如现在有整数数组：{3, 1, 5, 4, 2}\n  <br> 　　第一步：插入3 得到新序列{3}\n  <br> 　　第二步：插入1 得到新序列{1 3}\n  <br> 　　第三步：插入5 得到新序列{1 3 5}\n  <br> 　　第四步：插入4 得到新序列{1 3 4 5}\n  <br> 　　第五步：插入2 得到新序列{1 2 3 4 5}\n  <br> 　　为了看程序中如何完成插入过程，我们以第五步为例：\n  <br> 　　初始时：1 3 4 5 2\n  <br> 　　将2存入临时变量tmp\n  <br> 　　将下标j指向2之前的元素5，然后根据tmp和a[j]的大小关系决定该元素是否应该后移。如果a[j]&gt;tmp，则将a[j]后移到a[j+1]，序列变成1 3 4 5 5。\n  <br> 　　将下标j前移\n  <br> 　　判断a[j]&gt;tmp，后移a[j]到a[j+1]，得到1 3 4 4 5\n  <br> 　　将下标j前移\n  <br> 　　判断a[j]&gt;tmp，后移a[j]到a[j+1]，得到1 3 3 4 5\n  <br> 　　因为a[j]&lt;=tmp，所以将tmp放回a[j+1]，得到 1 2 3 4 5\n  <br> 　　现在，输入n个整数，根据以上算法，输出插入排序的全过程。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行一个正整数n，表示元素个数\n  <br> 　　第二行为n个整数，以空格隔开\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　有n个元素，因此输出部分分为n个部分，每个部分开头行为：Insert element[i]，i为第几个元素。然后对于每一个部分，输出该部分该元素在插入排序过程中的每一步产生的新序列，初始时的序列以Init:打头，然后每一步后移数组元素后的元素序列以Move back:打头，最后得到的最终结果序列以Final:打头。序列元素间以一个空格隔开。示例请看样例输出。每一个部分的Insert element[i]之后的每一步的输出行之前要缩进两格，即输出两个空格。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5\n  <br> 3 1 5 4 2\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  Insert element[1]:\n  <br> Init:3\n  <br> Final:3\n  <br> Insert element[2]:\n  <br> Init:3 1\n  <br> Move back:3 3\n  <br> Final:1 3\n  <br> Insert element[3]:\n  <br> Init:1 3 5\n  <br> Final:1 3 5\n  <br> Insert element[4]:\n  <br> Init:1 3 5 4\n  <br> Move back:1 3 5 5\n  <br> Final:1 3 4 5\n  <br> Insert element[5]:\n  <br> Init:1 3 4 5 2\n  <br> Move back:1 3 4 5 5\n  <br> Move back:1 3 4 4 5\n  <br> Move back:1 3 3 4 5\n  <br> Final:1 2 3 4 5\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　n&lt;=100\n  <br> 　　整数元素在int范围内\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n\tint i,j,k,a[100];\n\tint n,t;\n\tscanf("%d",&amp;n);\n\tfor(i=0;i&lt;n;i++)\n\tscanf("%d",a+i);\n\tfor(i=0;i&lt;n;i++)\n\t{\n\t\tt=a[i];\n\t\tprintf("Insert element[%d]:\\n",i+1);\n\t\tprintf("Init:"); \n\t\tfor(k=0;k&lt;=i;k++)\n\t\tprintf("%d ",a[k]);\n\t\tfor(j=i-1;j&gt;=0&amp;&amp;a[j]&gt;t;j--)\n\t\t{\n\t\t\ta[j+1]=a[j];\n\t\t\tprintf("\\nMove back:");\n\t\t\tfor(k=0;k&lt;=i;k++)\n\t\t\tprintf("%d ",a[k]);\n\t\t}\n\t\ta[j+1]=t;\n\t\tprintf("\\nFinal:");\n\t\tfor(k=0;k&lt;=i;k++)\n\t\tprintf("%d ",a[k]);\n\t\tprintf("\\n");\n\t}\n\treturn 0;\n } \r\n</textarea>	<textarea id="codelinescpp">\r\n/**************Powered by Graphene Richards**************/\n//{\n\n#define FLOAT_PRECISION    "%.2f"\n#define LF_PRECISION        10\n#define INT_64_MOD          "%I64d"\n#define UNSIGNED_64_MOD     "%I64u"\n#define COLORED_S\n\n//#pragma comment(linker,"/STACK:102400000,102400000")\n#include&lt;cmath&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;bitset&gt;\n#include&lt;complex&gt;\n#include&lt;vector&gt;\n#include&lt;iomanip&gt;\n#include&lt;iostream&gt;\n#include&lt;list&gt;\n#include&lt;map&gt;\n#include&lt;queue&gt;\n#include&lt;set&gt;\n#include&lt;stack&gt;\n#include&lt;string&gt;\n#define FAST_RW ios_base::sync_with_stdio(0),cin.tie(0);\n#define IT(x) __typeof((x).begin())\n#define DIT(x) __typeof((x).rbegin())\n#define FS(i,a) for(ll i=0;a[i];i++)\n#define FE(x,ctn) for(IT(ctn)x=(ctn).begin(),CluhxSchFuDeugk=(ctn).end();x!=CluhxSchFuDeugk;x++)\n#define FR(i,en) for(ll i=0,pJNwFPtlXiwFoIv=(en);i&lt;pJNwFPtlXiwFoIv;i++)\n#define FOR(i,en) for(ll i=1,SbKCIcakJTeYVqs=(en);i&lt;=SbKCIcakJTeYVqs;i++)\n#define FFR(i,x,y) for(ll i=(x),alVDbhLBoMEGSwA=(y);i&lt;=alVDbhLBoMEGSwA;i++)\n#define DFFR(i,x,y) for(ll i=(x),NWYfecAcmGBMJuU=(y);i&gt;=NWYfecAcmGBMJuU;i--)\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned\n#define lf long double\n#define pc putchar\n#define mp make_pair\n#define pb push_back\n#define pq priority_queue\n#define fi first\n#define se second\n#define pii pair&lt;int,int&gt;\n#define pll pair&lt;ll,ll&gt;\n#define pdd pair&lt;double,double&gt;\n#define lb(x) (x&amp;(-x))\n#define sqr(x) (x)*(x)\n#define all(x) (x).begin(),(x).end()\n#define clr(x) memset((x),0,sizeof(x))\n#define ms(x,v) memset((x),(v),sizeof(x))\n#define mc(x,y) memcpy((x),(y),sizeof(y))\n#define NL puts("");\n#define fin(x,c) ((c).find(x)!=(c).end())\n\nusing namespace std;\nint ebtpqJsBCnTgggi;\n\ntemplate&lt;class T1,class T2,class T3&gt;\nbool _IN(T1 x,T2 y,T3 z){\n  return x&lt;=y&amp;&amp;x&gt;=z||x&lt;=z&amp;&amp;x&gt;=y;\n}\n\null gcd(ull a,ull b){\n  if(!b)return a;\n  while(b^=a^=b^=a%=b);\n  return a;\n}\n\nextern const ll mod;\nll ksm(ll a,ll b){\n  ll res=1;\n  a%=mod;\n  for(;b;b&gt;&gt;=1){\n    if(b&amp;1)res=res*a%mod;\n    a=a*a%mod;\n  }\n  return res;\n}\n\n#ifdef wmx16835\n#define NOT_TESTING_TEMPLATE_CPP\n#include"wmx16835.cpp"\n#else\n#define LOG {\n#define TEL }\n#define SHOW_TIME\n#define test(...) ebtpqJsBCnTgggi\n#define TEST(...) ebtpqJsBCnTgggi\n#define TRY(...)\n#define PF\n#define SF(...)\n#define PP ;\n#define S _S\n#endif\n\nchar DATaJNTFnlmAoya[2];\nbool _S(char*a)  {return scanf("%s",a)==1;}\nbool _S(int&amp;a)   {return scanf("%d",&amp;a)==1;}\nbool _S(bool&amp;a)  {return scanf("%d",&amp;a)==1;}\nbool _S(ui&amp;a)    {return scanf("%u",&amp;a)==1;}\nbool _S(float&amp;a) {return scanf("%f",&amp;a)==1;}\nbool _S(double&amp;a){return scanf("%lf",&amp;a)==1;}\nbool _S(ll&amp;a)    {return scanf(INT_64_MOD,&amp;a)==1;}\nbool _S(ull&amp;a)   {return scanf(UNSIGNED_64_MOD,&amp;a)==1;}\nbool _S(lf&amp;a)    {return (cin&gt;&gt;a)!=0;}\nbool _S(char&amp;a)  {if(scanf("%1s",DATaJNTFnlmAoya)==-1)return 0;a=*DATaJNTFnlmAoya;return 1;}\ntemplate&lt;class T&gt;\nbool _S(const T&amp;){test("Input format error!\\n");return 0;}\n\nvoid _P(const int&amp;x)   {printf("%d",x);}\nvoid _P(const bool&amp;x)  {printf("%d",x);}\nvoid _P(const ui&amp;x)    {printf("%u",x);}\nvoid _P(const char&amp;x)  {printf("%c",x);}\nvoid _P(const char*x)  {printf("%s",x);}\nvoid _P(const string&amp;x){printf("%s",x.c_str());}\nvoid _P(const ll&amp;x)    {printf(INT_64_MOD,x);}\nvoid _P(const ull&amp;x)   {printf(UNSIGNED_64_MOD,x);}\nvoid _P(const float&amp;x) {printf(FLOAT_PRECISION,x);}\nvoid _P(const double&amp;x){printf(FLOAT_PRECISION,x);}\nvoid _P(const lf&amp;x)    {cout&lt;&lt;setprecision(LF_PRECISION)&lt;&lt;x;}\ntemplate&lt;class T&gt;\nvoid _P(const T&amp;){test("Output format error!\\n");}\n\ntemplate&lt;class T1,class T2&gt;\nbool _S(T1&amp;a,T2&amp;b){return _S(a)+_S(b)==2;}\ntemplate&lt;class T1,class T2,class T3&gt;\nbool _S(T1&amp;a,T2&amp;b,T3&amp;c){return _S(a)+_S(b)+_S(c)==3;}\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nbool _S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d){return _S(a)+_S(b)+_S(c)+_S(d)==4;}\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nbool _S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d,T5&amp;e){return _S(a)+_S(b)+_S(c)+_S(d)+_S(e)==5;}\n\ntemplate&lt;class T1&gt;\nvoid P(const T1&amp;a){_P(a);pc(' ');}\ntemplate&lt;class T1,class T2&gt;\nvoid P(const T1&amp;a,const T2&amp;b){_P(a);pc(' ');_P(b);pc(' ');}\ntemplate&lt;class T1&gt;\nvoid PN(const T1&amp;a){_P(a);NL}\ntemplate&lt;class T1,class T2&gt;\nvoid PN(const T1&amp;a,const T2&amp;b){_P(a);pc(' ');_P(b);NL}\ntemplate&lt;class T1,class T2,class T3&gt;\nvoid PN(const T1&amp;a,const T2&amp;b,const T3&amp;c){_P(a);pc(' ');_P(b);pc(' ');_P(c);NL}\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nvoid PN(const T1&amp;a,const T2&amp;b,const T3&amp;c,const T4&amp;d){_P(a);pc(' ');_P(b);pc(' ');_P(c);pc(' ');_P(d);NL}\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nvoid PN(const T1&amp;a,const T2&amp;b,const T3&amp;c,const T4&amp;d,const T5&amp;e){_P(a);pc(' ');_P(b);pc(' ');_P(c);pc(' ');_P(d);pc(' ');_P(e);NL}\n\ntemplate&lt;class T&gt;\nvoid PA(T*a,int n){\n  FR(i,n-1)_P(a[i]),pc(' ');\n  PN(a[n-1]);\n}\n\ntemplate&lt;class T&gt;\nvoid PA(const T&amp;x){\n  FE(it,x){\n    _P(*it);\n    if(it==--x.end())NL\n    else pc(' ');\n  }\n}\n\nint kase;\nconst double pi=4*atan(1);\nconst double ep=1e-9;\nconst int INF=0x3f3f3f3f;\nconst ll INFL=0x3f3f3f3f3f3f3f3fll;\nconst ll mod=1000000007;\n//}\n\nint x[105];\n\nint main(){\n  SHOW_TIME\n  int n;\n  S(n);\n  FOR(i,n)S(x[i]);\n  x[0]=-1&lt;&lt;30;\n  FOR(i,n){\n    int tmp=x[i];\n    printf("Insert element[%d]:\\n",i);\n    printf("  Init:"),PA(x+1,i);\n    int j=i;\n    while(x[j-1]&gt;tmp){\n      x[j]=x[j-1];\n      printf("  Move back:"),PA(x+1,i);\n      j--;\n    }\n    x[j]=tmp;\n    printf("  Final:"),PA(x+1,i);\n  }\n}\n\n/*********Risoft corporation all rights reserved*********/\n/**************Template V2.00 build 20150303*************/\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner s=new Scanner(System.in);\n\t\tint a=s.nextInt();\n\t\tint[] arr=new int[a];\n\t\tfor (int i = 0; i &lt; arr.length; i++) {\n\t\t\tarr[i]=s.nextInt();\n\t\t}\n\t\tshow(arr);\n\t}\n\tstatic void show(int[] arr){\n\t\tint[] str=new int[arr.length];\n\t\tfor (int i = 0; i &lt; str.length; i++) {\n\t\t\tSystem.out.println("Insert element["+(i+1)+"]:"); \n\t\t\tstr[i]=arr[i];\n\t\t\tint a=str[i];\n\t\t\tSystem.out.println("Init:"+f(str,i));\n\t\t\tif(str.length&gt;1){\n\t\t\t\tint b=i;\n\t\t\t\tfor (int j = str.length-1; j &gt;=0; j--) {\n\t\t\t\t\tif(a&lt;str[j]){\n\t\t\t\t\t\tstr[b]=str[j];\n\t\t\t\t\t\tSystem.out.println("Move back:"+f(str,i));\n\t\t\t\t\t\tstr[j]=a;\n\t\t\t\t\t\ta=str[j];\n\t\t\t\t\t\tb=j;\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\tSystem.out.println("Final:"+f(str,i));\n\t\t\t\n\t\t}\n\t}\n\tstatic String f(int[] arr,int n){\n\t\tString str="";\n\t\tfor (int i = 0; i &lt;= n; i++) {\n\t\t\tstr+=arr[i]+" ";\n\t\t}\n\t\treturn str;\n\t}\n}\n\n\r\n</textarea>	268
246	<div class="des"> \n <div class="pdcont">\n  <b></b>\n  <br> \n  <br> \n  <b>问题描述</b>\n  <br> 　　编写一个程序，该程序从用户读入一个整数，然后列出所有的数对，每个数对的乘积即为该数。\n  <br> 　　输入格式：输入只有一行，即一个整数。\n  <br> 　　输出格式：输出有若干行，每一行是一个乘法式子。（注意：运算符号与数字之间有一个空格）\n  <br> \n  <b>输入输出样例</b>\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  32\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  1 * 32 = 32\n  <br> 2 * 16 = 32\n  <br> 4 * 8 = 32\n  <br> 8 * 4 = 32\n  <br> 16 * 2 = 32\n  <br> 32 * 1 = 32\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint main()\n{\nint n,x,i;\nscanf("%d",&amp;n);\nfor(i=1;i&lt;=n;i++)\n{\nif(n%i==0)\n{\nx=n/i;\nprintf("%d * %d = %d\\n",i,x,n);\n}\n}\nreturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n/**************Powered by Graphene Richards**************/\n//{\n#define OUTPUT_PRECISION    "%.2f"\n#define LF_PRECISION        10\n#define INT_64_MOD          "%I64d"\n#define UNSIGNED_64_MOD     "%I64u"\n\n#define CONTEST_EXIST       1\n\n#define CONTEST_START_HOUR  17\n#define CONTEST_START_MIN   0\n#define CONTEST_START_SEC   0\n\n#define CONTEST_DUR_HOUR    2\n#define CONTEST_DUR_MIN     30\n#define CONTEST_DUR_SEC     0\n\n//#pragma comment(linker,"/STACK:102400000,102400000")\n#include&lt;cmath&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;bitset&gt;\n#include&lt;complex&gt;\n#include&lt;vector&gt;\n#include&lt;iomanip&gt;\n#include&lt;iostream&gt;\n#include&lt;list&gt;\n#include&lt;map&gt;\n#include&lt;queue&gt;\n#include&lt;set&gt;\n#include&lt;stack&gt;\n#include&lt;string&gt;\n#include&lt;typeinfo&gt;\n#define FAST_RW ios_base::sync_with_stdio(0),cin.tie(0);\n#define ll long long\n#define lf long double\n#define IT(x) __typeof((x).begin())\n#define FS(i,a) for(int i=0;a[i];i++)\n#define FE(x,ctn) for(IT(ctn)x=(ctn).begin(),CluhxSchFuDeugk=(ctn).end();x!=CluhxSchFuDeugk;x++)\n#define FR(i,en) for(int i=0,pJNwFPtlXiwFoIv=(en);i&lt;pJNwFPtlXiwFoIv;i++)\n#define FOR(i,en) for(int i=1,SbKCIcakJTeYVqs=(en);i&lt;=SbKCIcakJTeYVqs;i++)\n#define FFR(i,x,y) for(int i=(x),alVDbhLBoMEGSwA=(y);i&lt;=alVDbhLBoMEGSwA;i++)\n#define DFFR(i,x,y) for(int i=(x),NWYfecAcmGBMJuU=(y);i&gt;=NWYfecAcmGBMJuU;i--)\n#define mp make_pair\n#define pb push_back\n#define pq priority_queue\n#define fi first\n#define se second\n#define lb(x) (x&amp;(-x))\n#define sqr(x) (x)*(x)\n#define all(x) (x).begin(),(x).end()\n#define clr(x) memset((x),0,sizeof(x))\n#define inf(x) memset((x),0x7F,sizeof(x))\n#define _inf(x) memset((x),0x80,sizeof(x))\n#define NL puts("");\nusing namespace std;\n\ntemplate&lt;class T1,class T2,class T3&gt;\nbool _IN(T1 x,T2 y,T3 z){\n  return x&lt;=y&amp;&amp;x&gt;=z||x&lt;=z&amp;&amp;x&gt;=y;\n}\n\ntemplate&lt;class T&gt;\nT gcd(T a,T b){\n  if(!b)\n    return a;\n  while(b^=a^=b^=a%=b);\n  return a;\n}\n\n#ifdef wmx16835\n#include&lt;ctime&gt;\n#include&lt;windows.h&gt;\n\n#define GREEN  10\n#define BLUE   11\n#define RED    12\n#define PINK   13\n#define YELLOW 14\n#define WHITE  15\n\nstruct TM{\n  int t;\n  TM(int a,int b,int c):t(a*3600+b*60+c){}\n  TM(int x):t(x){}\n  TM(){}\n  operator int(){return t;}\n  void print(){\n    printf("%02d:%02d:%02d",t/3600%24,t/60%60,t%60);\n  }\n};\n\nvoid OVZmetNNpAqAVZx(){\n  //__________;\n  time_t t=time(0);\n  srand(t);\n  tm*p=localtime(&amp;t);\n  TM day(24,0,0),cur(p-&gt;tm_hour,p-&gt;tm_min,p-&gt;tm_sec),beg(CONTEST_START_HOUR,CONTEST_START_MIN,CONTEST_START_SEC),len(CONTEST_DUR_HOUR,CONTEST_DUR_MIN,CONTEST_DUR_SEC),en(beg+len),fen(beg+en+day&gt;&gt;1),seg;\n  if(beg&gt;cur)\n    cur.t+=day;\n  puts("  +--------------------------+");\n  if(_IN(cur,beg,en)&amp;&amp;CONTEST_EXIST){\n    puts("  |      Status: Running     |");\n    printf("  |     Progress: %5.1f %%    |\\n",(double)(cur-beg)/len*100);\n    seg.t=en-cur;\n    printf("  | Remaining time: ");\n    seg.print();\n    puts(" |");\n  }\n  else{\n    printf("  |  Current time: ");\n    cur.print();\n    puts("  | ");\n    if(cur&lt;=fen||!CONTEST_EXIST)\n      puts("  |       Status: Ended      |");\n    else{\n      puts("  |     Status: Scheduled    |");\n      cur.t-=day;\n      seg.t=beg-cur;\n      printf("  | Remaining time: ");\n      seg.print();\n      puts(" |");\n    }\n  }\n  puts("  +--------------------------+");\n  puts("................................\\n");\n}\n\nconst HANDLE hout=GetStdHandle(STD_OUTPUT_HANDLE);\n\nvoid _COLOR(unsigned x=BLUE){\n  SetConsoleTextAttribute(hout,x);\n}\n\nvoid pCJUYxWEXKaDOIC(){\n  int num=1;\n  FILE*p=fopen("FILE_NAME","r");\n  if(p){\n    fscanf(p,"%d",&amp;num);\n    fclose(p);\n  }\n  char f_name[1024];\n  sprintf(f_name,"%d.out",num++);\n  _COLOR(PINK);\n  printf("[NOTICE] Standard output has been redirected to \\"%s\\".\\n",f_name);\n  _COLOR();\n  freopen(f_name,"w",stdout);\n  if(!stdout)\n    exit(1);\n  else\n  p=fopen("FILE_NAME","w");\n  if(p){\n    fprintf(p,"%d",num);\n    fclose(p);\n  }\n}\n\n#define LOG {_COLOR(RED);unsigned ijqQjAZZNYpJYBe=clock();puts("\\n----------------------");_COLOR();\n#define TEL _COLOR(RED),printf("\\n----------------------\\nExecution time: %ums\\n----------------------\\n",clock()-ijqQjAZZNYpJYBe);_COLOR();}\n#define SHOW_TIME _COLOR(GREEN);OVZmetNNpAqAVZx();_COLOR();\n#define test(...) _COLOR(YELLOW),printf(__VA_ARGS__),_COLOR()\n#define TEST(x) _COLOR(YELLOW),printf("%s = ",#x),_P(x),puts(""),_COLOR()\n#define TRY(...) __VA_ARGS__\n#define PF pCJUYxWEXKaDOIC();\n\n#else\n#define LOG\n#define TEL\n#define SHOW_TIME\n#define test(...)\n#define TEST(...)\n#define TRY(...)\n#define PF\n#endif\n\nint S(char*a){\n  return scanf("%s",a)==1;\n}\n\ntemplate&lt;class T&gt;\nint S(T&amp;a){\n  const char*x=typeid(a).name();\n  if(!strcmp(x,"i")||!strcmp(x,"b"))return scanf("%d",&amp;a)==1;\n  else if(!strcmp(x,"j"))return scanf("%u",&amp;a)==1;\n  else if(!strcmp(x,"c"))return scanf("%c",&amp;a)==1;\n  else if(!strcmp(x,"Pc")||*x=='A')return scanf("%s",a)==1;\n  else if(!strcmp(x,"f"))return scanf("%f",&amp;a)==1;\n  else if(!strcmp(x,"d"))return scanf("%lf",&amp;a)==1;\n  else if(!strcmp(x,"x"))return scanf(INT_64_MOD,&amp;a)==1;\n  else if(!strcmp(x,"y"))return scanf(UNSIGNED_64_MOD,&amp;a)==1;\n  else if(!strcmp(x,"e"))return (cin&gt;&gt;a)!=0;\n  else test("Input format error!\\n");\n}\n\ntemplate&lt;class T&gt;\nvoid _P(T a){\n  const char*x=typeid(a).name();\n  if(!strcmp(x,"i")||!strcmp(x,"b"))printf("%d",a);\n  else if(!strcmp(x,"j"))printf("%u",a);\n  else if(!strcmp(x,"c"))printf("%c",a);\n  else if(!strcmp(x,"Pc")||!strcmp(x,"PKc")||*x=='A')printf("%s",a);\n  else if(!strcmp(x,"d")||!strcmp(x,"f"))printf(OUTPUT_PRECISION,a);\n  else if(!strcmp(x,"x"))printf(INT_64_MOD,a);\n  else if(!strcmp(x,"y"))printf(UNSIGNED_64_MOD,a);\n  else if(!strcmp(x,"e"))cout&lt;&lt;setprecision(LF_PRECISION)&lt;&lt;a;\n  else test("Output format error!\\n");\n}\n\ntemplate&lt;class T1,class T2&gt;\nint S(T1&amp;a,T2&amp;b){\n  return S(a)+S(b)==2;\n}\n\ntemplate&lt;class T1,class T2,class T3&gt;\nint S(T1&amp;a,T2&amp;b,T3&amp;c){\n  return S(a)+S(b)+S(c)==3;\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nint S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d){\n  return S(a)+S(b)+S(c)+S(d)==4;\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nint S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d,T5&amp;e){\n  return S(a)+S(b)+S(c)+S(d)+S(e)==5;\n}\n\ntemplate&lt;class T&gt;\nvoid P(T a){\n  _P(a);\n  putchar(' ');\n}\n\ntemplate&lt;class T1,class T2&gt;\nvoid P(T1 a,T2 b){\n  _P(a);putchar(' ');\n  _P(b);putchar(' ');\n}\n\ntemplate&lt;class T&gt;\nvoid PN(T a){\n  _P(a);\n  NL\n}\n\ntemplate&lt;class T1,class T2&gt;\nvoid PN(T1 a,T2 b){\n  _P(a);putchar(' ');\n  _P(b);NL\n}\n\ntemplate&lt;class T1,class T2,class T3&gt;\nvoid PN(T1 a,T2 b,T3 c){\n  _P(a);putchar(' ');\n  _P(b);putchar(' ');\n  _P(c);NL\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nvoid PN(T1 a,T2 b,T3 c,T4 d){\n  _P(a);putchar(' ');\n  _P(b);putchar(' ');\n  _P(c);putchar(' ');\n  _P(d);NL\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nvoid PN(T1 a,T2 b,T3 c,T4 d,T5 e){\n  _P(a);putchar(' ');\n  _P(b);putchar(' ');\n  _P(c);putchar(' ');\n  _P(d);putchar(' ');\n  _P(e);NL\n}\n\nint kase;\nconst double pi=4*atan(1);\nconst double ep=1e-9;\n//}\n\nll a[8]={6ll,28ll,496ll,8128ll,33550336ll,8589869056ll,137438691328ll,2305843008139952128ll};\n\nint main(){\n  SHOW_TIME\n  int n;\n  S(n);\n  FOR(i,n)\n    if(n%i==0)printf("%d * %d = %d\\n",i,n/i,n);\n}\n\n/*********Risoft corporation all rights reserved*********/\n/**************Template V1.33 build 20150114*************/\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint number = Integer.parseInt(br.readLine());\n\t\tfor (int i = 1; i &lt;= number; i++) {\n\t\t\tif(number%i==0)\n\t\t\t\tSystem.out.println(i+" * "+number/i +" = "+number);\n\t\t}\n\t}\n\n}\n\r\n</textarea>	248
247	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　一个数如果恰好等于它的因子之和，这个数就称为“完数”。例如，6的因子为1、2、3，而6＝1＋2＋3，因此6就是“完数”。又如，28的因子为1、2、4、7、14，而28＝1＋2＋4＋7＋14，因此28也是“完数”。编写一个程序，判断用户输入的一个数是否为“完数”。\n  <br> 　　输入格式：输入只有一行，即一个整数。\n  <br> 　　输出格式：输出只有一行，如果该数为完数，输出yes，否则输出no。\n  <br> 　　输入输出样例\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  6\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  yes\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nint main(){\n\tint n,i,result,end;\n\tscanf("%d",&amp;n);\n\tif(n==1){\n\t\tprintf("no");\n\t\treturn 0;\n\t}\n\tend=(int)sqrt(n);\n\tresult=0;\n\tfor(i=2;i&lt;=end;i++){\n\t\tif(n%i==0){\n\t\t\tresult+=i;\n\t\t\tresult=result+n/i;\n\t\t}\n\t}\n\tresult+=1;\n\tif(result==n)\n\t\tprintf("yes");\n\telse\n\t\tprintf("no");\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;stdio.h&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nint Operation1(int x)\n{\n\tint s=1,i,y;\n\ty=x/2;\n\tfor(i=2;i&lt;=y;i++)\n\t{\n\t\tif(x%i==0)\n\t\t{\n\t\t\ty=x/i;\n\t\t\ts=s+i+y;\n\t\t\ty--;\n\t\t}\n\t}\n\treturn s;\n}\nint main()\n{\n\tint i,m,j,n,s;\n\twhile(cin&gt;&gt;n)\n\t{\n\t     if(n!=1&amp;&amp;n==Operation1(n))\n\t\t\t cout&lt;&lt;"yes"&lt;&lt;endl;\n\t\t else\n\t\t\t cout&lt;&lt;"no"&lt;&lt;endl;\n\t}\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic static Integer total=1;\n\t\n\tpublic static void main(String[] args)throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint x = Integer.parseInt(br.readLine());\n\t\tadd(x);\n\t\tif(x == total)System.out.println("yes");\n\t\telse System.out.println("no");\n\t}\n\t\n\tpublic static void add(Integer x){\n\t\tif(x == 1)total = 0;\n\t\tint sqrt = (int)Math.sqrt(x);\n\t\tfor(int i=2; i&lt;=sqrt; i++){\n\t\t\tif(x % i == 0){\n\t\t\t\ttotal += i;\n\t\t\t\ttotal += x/i;\n\t\t\t}\n\t\t}\n\t}\n}\r\n</textarea>	249
248	<div class="des"> \n <div class="pdsec">\n  描述\n </div>\n <div class="pdcont">\n  　　编写函数GetReal和GetString，在main函数中分别调用这两个函数。在读入一个实数和一个字符串后，将读入的结果依次用printf输出。\n  <br> 　　两次输入前要输出的提示信息分别是"please input a number:\\n”和"please input a string:\\n"\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  9.56\n  <br> hello\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  please input a number:\n  <br> please input a string:\n  <br> 9.56\n  <br> hello\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint main()\n{\nchar x[100];\nchar a[100];\nscanf("%s",x);\nscanf("%s",a);\nprintf("please input a number:\\nplease input a string:\\n%s\\n%s",x,a);\nreturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\nint main()\n{     \n\tdouble a;\n\tstring b;\n\tcout&lt;&lt;"please input a number:"&lt;&lt;endl;\n\tcout&lt;&lt;"please input a string:"&lt;&lt;endl;\n\tcin&gt;&gt;a&gt;&gt;b;\n\tcout&lt;&lt;a&lt;&lt;endl;\n\tcout&lt;&lt;b;\n\treturn 0;\n} \r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\n\npublic class Main {\n\tpublic static void main(String[] args){\n\tScanner sc = new Scanner(System.in);\n\tdouble a =GetReal(sc.nextDouble());\n\tString b =GetString(sc.next());\n\tSystem.out.println("please input a number:\\nplease input a string:");\n\tSystem.out.println(a+"\\n"+b);\n\t}\n\tstatic double GetReal(double val)\n\t{\n\t\treturn val;\n\t}\n\tstatic String GetString(String val)\n\t{\n\t\treturn val;\n\t}\n}\r\n</textarea>	250
249	<div class="des"> \n <div class="pdcont">\n  <b></b>\n </div>\n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　计算一个整数的阿尔法乘积。对于一个整数x来说，它的阿尔法乘积是这样来计算的：如果x是一个个位数，那么它的阿尔法乘积就是它本身；否则的话，x的阿尔法乘积就等于它的各位非0的数字相乘所得到的那个整数的阿尔法乘积。例如：4018224312的阿尔法乘积等于8，它是按照以下的步骤来计算的：\n  <br> 　　4018224312 → 4*1*8*2*2*4*3*1*2 → 3072 → 3*7*2 → 42 → 4*2 → 8\n  <br> 　　编写一个程序，输入一个正整数（该整数不会超过6,000,000），输出它的阿尔法乘积。\n  <br> 　　输入格式：输入只有一行，即一个正整数。\n  <br> 　　输出格式：输出相应的阿尔法乘积。\n  <br> 　　输入输出样例\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  4018224312\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  8\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n\tunsigned int t,n;  scanf("%d",&amp;n);  if(n&lt;=6000000)\n\t{\n\t\twhile(n&gt;=10)\n\t\t{\n\t\t\tt=1;      while(n&gt;0)\n\t\t\t{\n\t\t\t\tif(n%10!=0)          t*=(n%10);        n/=10;\n\t\t\t}      n=t;\n\t\t}\n\t}  printf("%d",n);  return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n/**************Powered by Graphene Richards**************/\n//{\n#define OUTPUT_PRECISION    "%.2f"\n#define LF_PRECISION        10\n#define INT_64_MOD          "%lld"\n#define UNSIGNED_64_MOD     "%llu"\n\n#define CONTEST_EXIST       1\n\n#define CONTEST_START_HOUR  13\n#define CONTEST_START_MIN   0\n\n#define CONTEST_DUR_HOUR    3\n#define CONTEST_DUR_MIN     40\n\n//#pragma comment(linker,"/STACK:102400000,102400000")\n#include&lt;cmath&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;bitset&gt;\n#include&lt;complex&gt;\n#include&lt;vector&gt;\n#include&lt;iomanip&gt;\n#include&lt;iostream&gt;\n#include&lt;list&gt;\n#include&lt;map&gt;\n#include&lt;queue&gt;\n#include&lt;set&gt;\n#include&lt;stack&gt;\n#include&lt;string&gt;\n#include&lt;typeinfo&gt;\n#define FAST_RW ios_base::sync_with_stdio(0),cin.tie(0);\n#define IT(x) __typeof((x).begin())\n#define FS(i,a) for(ll i=0;a[i];i++)\n#define FE(x,ctn) for(IT(ctn)x=(ctn).begin(),CluhxSchFuDeugk=(ctn).end();x!=CluhxSchFuDeugk;x++)\n#define FR(i,en) for(ll i=0,pJNwFPtlXiwFoIv=(en);i&lt;pJNwFPtlXiwFoIv;i++)\n#define FOR(i,en) for(ll i=1,SbKCIcakJTeYVqs=(en);i&lt;=SbKCIcakJTeYVqs;i++)\n#define FFR(i,x,y) for(ll i=(x),alVDbhLBoMEGSwA=(y);i&lt;=alVDbhLBoMEGSwA;i++)\n#define DFFR(i,x,y) for(ll i=(x),NWYfecAcmGBMJuU=(y);i&gt;=NWYfecAcmGBMJuU;i--)\n#define ll long long\n#define lf long double\n#define pc putchar\n#define mp make_pair\n#define pb push_back\n#define pq priority_queue\n#define fi first\n#define se second\n#define lb(x) (x&amp;(-x))\n#define sqr(x) (x)*(x)\n#define all(x) (x).begin(),(x).end()\n#define clr(x) memset((x),0,sizeof(x))\n#define inf(x) memset((x),0x7F,sizeof(x))\n#define _inf(x) memset((x),0x80,sizeof(x))\n#define NL puts("");\nusing namespace std;\n\ntemplate&lt;class T1,class T2,class T3&gt;\nbool _IN(T1 x,T2 y,T3 z){\n  return x&lt;=y&amp;&amp;x&gt;=z||x&lt;=z&amp;&amp;x&gt;=y;\n}\n\nll gcd(ll a,ll b){\n  if(!b)\n    return a;\n  while(b^=a^=b^=a%=b);\n  return a;\n}\n\n#ifdef wmx16835\n#include&lt;ctime&gt;\n#include&lt;conio.h&gt;\n#include&lt;windows.h&gt;\n\n#define GREEN  10\n#define BLUE   11\n#define RED    12\n#define PINK   13\n#define YELLOW 14\n#define WHITE  15\n\nstruct TM{\n  int t;\n  TM(int a,int b,int c):t(a*3600+b*60+c){}\n  TM(int x):t(x){}\n  TM(){}\n  operator int(){return t;}\n  void print(){\n    printf("%02d:%02d:%02d",t/3600%24,t/60%60,t%60);\n  }\n};\n\nvoid OVZmetNNpAqAVZx(){\n  time_t t=time(0);\n  srand(t);\n  tm*p=localtime(&amp;t);\n  TM day(24,0,0),cur(p-&gt;tm_hour,p-&gt;tm_min,p-&gt;tm_sec),beg(CONTEST_START_HOUR,CONTEST_START_MIN,0),len(CONTEST_DUR_HOUR,CONTEST_DUR_MIN,0),en(beg+len),fen(beg+en+day&gt;&gt;1),seg;\n  if(beg&gt;cur)\n    cur.t+=day;\n  puts("  +--------------------------+");\n  if(_IN(cur,beg,en)&amp;&amp;CONTEST_EXIST){\n    puts("  |      Status: Running     |");\n    printf("  |     Progress: %5.1f %%    |\\n",(double)(cur-beg)/len*100);\n    seg.t=en-cur;\n    printf("  | Remaining time: ");\n    seg.print();\n    puts(" |");\n  }\n  else{\n    printf("  |  Current time: ");\n    cur.print();\n    puts("  | ");\n    if(cur&lt;=fen||!CONTEST_EXIST)\n      puts("  |       Status: Ended      |");\n    else{\n      puts("  |     Status: Scheduled    |");\n      cur.t-=day;\n      seg.t=beg-cur;\n      printf("  | Remaining time: ");\n      seg.print();\n      puts(" |");\n    }\n  }\n  puts("  +--------------------------+");\n  puts("................................\\n");\n}\n\nconst HANDLE hout=GetStdHandle(STD_OUTPUT_HANDLE);\n\nvoid _COLOR(unsigned x=BLUE){\n  SetConsoleTextAttribute(hout,x);\n}\n\nvoid pCJUYxWEXKaDOIC(){\n  int num=1;\n  FILE*p=fopen("FILE_NAME","r");\n  if(p){\n    fscanf(p,"%d",&amp;num);\n    fclose(p);\n  }\n  char f_name[1024];\n  sprintf(f_name,"%d.out",num++);\n  _COLOR(PINK);\n  printf("[NOTICE] Standard output has been redirected to \\"%s\\".\\n",f_name);\n  _COLOR();\n  freopen(f_name,"w",stdout);\n  if(!stdout)\n    exit(1);\n  else\n  p=fopen("FILE_NAME","w");\n  if(p){\n    fprintf(p,"%d",num);\n    fclose(p);\n  }\n}\n\nint bXMXqqguPAUDCia;\nvoid FrKZgXsfpPVkeNv(){\n  char x[1000];\n  sprintf(x,"[Paused: %d]",++bXMXqqguPAUDCia);\n  int len=strlen(x);\n  printf(x);\n  getch();\n  FR(i,len)pc('\\b');\n  FR(i,len)pc(' ');\n  FR(i,len)pc('\\b');\n}\n\n#define LOG {_COLOR(RED);unsigned ijqQjAZZNYpJYBe=clock();puts("\\n----------------------");_COLOR();\n#define TEL _COLOR(RED),printf("\\n----------------------\\nExecution time: %ums\\n----------------------\\n",clock()-ijqQjAZZNYpJYBe);_COLOR();}\n#define SHOW_TIME _COLOR(GREEN);OVZmetNNpAqAVZx();_COLOR();\n#define test(...) _COLOR(YELLOW),printf(__VA_ARGS__),_COLOR()\n#define TEST(x) _COLOR(YELLOW),printf("%s = ",#x),_P(x),puts(""),_COLOR()\n#define TRY(...) __VA_ARGS__\n#define PF pCJUYxWEXKaDOIC();\n#define PP _COLOR(RED);FrKZgXsfpPVkeNv();_COLOR();\n\n#else\n#define LOG\n#define TEL\n#define SHOW_TIME\n#define test(...)\n#define TEST(...)\n#define TRY(...)\n#define PF\n#define PP\n#endif\n\nint S(char*a){\n  return scanf("%s",a)==1;\n}\n\ntemplate&lt;class T&gt;\nint S(T&amp;a){\n  const char*x=typeid(a).name();\n  if(!strcmp(x,"i")||!strcmp(x,"b"))return scanf("%d",&amp;a)==1;\n  else if(!strcmp(x,"j"))return scanf("%u",&amp;a)==1;\n  else if(!strcmp(x,"c"))return scanf("%c",&amp;a)==1;\n  else if(!strcmp(x,"Pc")||*x=='A')return scanf("%s",a)==1;\n  else if(!strcmp(x,"f"))return scanf("%f",&amp;a)==1;\n  else if(!strcmp(x,"d"))return scanf("%lf",&amp;a)==1;\n  else if(!strcmp(x,"x"))return scanf(INT_64_MOD,&amp;a)==1;\n  else if(!strcmp(x,"y"))return scanf(UNSIGNED_64_MOD,&amp;a)==1;\n  else if(!strcmp(x,"e"))return (cin&gt;&gt;a)!=0;\n  else test("Input format error!\\n");\n}\n\ntemplate&lt;class T&gt;\nvoid _P(T a){\n  const char*x=typeid(a).name();\n  if(!strcmp(x,"i")||!strcmp(x,"b"))printf("%d",a);\n  else if(!strcmp(x,"j"))printf("%u",a);\n  else if(!strcmp(x,"c"))printf("%c",a);\n  else if(!strcmp(x,"Pc")||!strcmp(x,"PKc")||*x=='A')printf("%s",a);\n  else if(!strcmp(x,"d")||!strcmp(x,"f"))printf(OUTPUT_PRECISION,a);\n  else if(!strcmp(x,"x"))printf(INT_64_MOD,a);\n  else if(!strcmp(x,"y"))printf(UNSIGNED_64_MOD,a);\n  else if(!strcmp(x,"e"))cout&lt;&lt;setprecision(LF_PRECISION)&lt;&lt;a;\n  else test("Output format error!\\n");\n}\n\ntemplate&lt;class T1,class T2&gt;\nint S(T1&amp;a,T2&amp;b){\n  return S(a)+S(b)==2;\n}\n\ntemplate&lt;class T1,class T2,class T3&gt;\nint S(T1&amp;a,T2&amp;b,T3&amp;c){\n  return S(a)+S(b)+S(c)==3;\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nint S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d){\n  return S(a)+S(b)+S(c)+S(d)==4;\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nint S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d,T5&amp;e){\n  return S(a)+S(b)+S(c)+S(d)+S(e)==5;\n}\n\ntemplate&lt;class T&gt;\nvoid P(T a){\n  _P(a);\n  pc(' ');\n}\n\ntemplate&lt;class T1,class T2&gt;\nvoid P(T1 a,T2 b){\n  _P(a);pc(' ');\n  _P(b);pc(' ');\n}\n\ntemplate&lt;class T&gt;\nvoid PN(T a){\n  _P(a);\n  NL\n}\n\ntemplate&lt;class T1,class T2&gt;\nvoid PN(T1 a,T2 b){\n  _P(a);pc(' ');\n  _P(b);NL\n}\n\ntemplate&lt;class T1,class T2,class T3&gt;\nvoid PN(T1 a,T2 b,T3 c){\n  _P(a);pc(' ');\n  _P(b);pc(' ');\n  _P(c);NL\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nvoid PN(T1 a,T2 b,T3 c,T4 d){\n  _P(a);pc(' ');\n  _P(b);pc(' ');\n  _P(c);pc(' ');\n  _P(d);NL\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nvoid PN(T1 a,T2 b,T3 c,T4 d,T5 e){\n  _P(a);pc(' ');\n  _P(b);pc(' ');\n  _P(c);pc(' ');\n  _P(d);pc(' ');\n  _P(e);NL\n}\n\nint kase;\nconst double pi=4*atan(1);\nconst double ep=1e-9;\n//}\n\nint fun(int x){\n  if(x/10==0)return x;\n  int r=1;\n  while(x){\n    if(x%10)r*=x%10;\n    x/=10;\n  }\n  return fun(r);\n}\n\nint main(){\n  SHOW_TIME\n  int x;\n  S(x);\n  P(fun(x));\n}\n\n/*********Risoft corporation all rights reserved*********/\n/**************Template V1.36 build 20150119*************/\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Main{\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString number = br.readLine();\n\t\tif (number.equals("0"))\n\t\t\tSystem.out.println(number);\n\t\telse {\n\t\t\twhile (number.length() &gt; 1) {\n\t\t\t\tint sum = 1;\n\t\t\t\tchar[] temp = number.toCharArray();\n\t\t\t\tfor (int i = 0; i &lt; temp.length; i++) {\n\t\t\t\t\tif (temp[i] == '0')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tsum *= temp[i] - 48;\n\t\t\t\t}\n\t\t\t\tnumber = sum + "";\n\t\t\t}\n\t\t\tSystem.out.println(number);\n\t\t}\n\t}\n\n}\n\r\n</textarea>	251
272	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　某校大门外长度为L的马路上有一排树，每两棵相邻的树之间的间隔都是1米。我们可以把马路看成一个数轴，马路的一端在数轴0的位置，另一端在L的位置；数轴上的每个整数点，即0，1，2，……，L，都种有一棵树。\n  <br> 　　由于马路上有一些区域要用来建地铁。这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，马路上还有多少棵树。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入的第一行有两个整数L（1 &lt;= L &lt;= 10000）和 M（1 &lt;= M &lt;= 100），L代表马路的长度，M代表区域的数目，L和M之间用一个空格隔开。接下来的M行每行包含两个不同的整数，用一个空格隔开，表示一个区域的起始点和终止点的坐标。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出包括一行，这一行只包含一个整数，表示马路上剩余的树的数目。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  500 3\n  <br> 150 300\n  <br> 100 200\n  <br> 470 471\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  298\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　对于20%的数据，区域之间没有重合的部分；\n  <br> 　　对于其它的数据，区域之间有重合的情况。\n </div>\n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　某校大门外长度为L的马路上有一排树，每两棵相邻的树之间的间隔都是1米。我们可以把马路看成一个数轴，马路的一端在数轴0的位置，另一端在L的位置；数轴上的每个整数点，即0，1，2，……，L，都种有一棵树。\n  <br> 　　由于马路上有一些区域要用来建地铁。这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，马路上还有多少棵树。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入文件的第一行有两个整数L（1 &lt;= L &lt;= 10000）和 M（1 &lt;= M &lt;= 100），L代表马路的长度，M代表区域的数目，L和M之间用一个空格隔开。接下来的M行每行包含两个不同的整数，用一个空格隔开，表示一个区域的起始点和终止点的坐标。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出文件包括一行，这一行只包含一个整数，表示马路上剩余的树的数目。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  500 3\n  <br> 150 300\n  <br> 100 200\n  <br> 470 471\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  298\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　对于20%的数据，区域之间没有重合的部分；\n  <br> 　　对于其它的数据，区域之间有重合的情况。\n </div>\n <div class="pdsec">\n  试题来源\n </div>\n <div class="pdcont">\n  　　noip2005普及组\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint main(){\n\tint i, count = 0, j, l, m, p, q, a[10000] = {0};\n\n\tscanf("%d%d",&amp;l,&amp;m);\n\t\t\n\tfor( i = 1; i &lt;= m; i ++)\n\t{\n\t\tscanf("%d%d",&amp;p,&amp;q);\n\t    for( j = p; j &lt;= q; j++)\n\t        a[j] = 1;\n\t}\n\t  for(i = 0; i &lt;= l; i++)\n\t    if(a[i] == 1)\n\t      count++;\n\t   printf("%d\\n",l-count+1);\n\t       return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\nint s[10004];\nint main(){\n\tint l,n;\n\tcin&gt;&gt;l&gt;&gt;n;\n\tfor(int i=0;i&lt;=l;i++)\n\t\ts[i]=1;\n\tint x,y;\n\twhile(n--){\n\t\tcin&gt;&gt;x&gt;&gt;y;\n\t\twhile(x&lt;=y){\n\t\t\ts[x]=0;\t\t\t\n\t\t\tx++;\n\t\t}\n\t}\n\tint sum=0;\n\tfor(int i=0;i&lt;=l;i++){\n\t\tif(s[i]==1)\n\t\t\tsum++;\n\t}\n\tcout&lt;&lt;sum&lt;&lt;endl;\n\t\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\n\n\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint L = sc.nextInt();\n\t\tint M = sc.nextInt();\n\t\tsc.nextLine();\n\t\tint[] tree = new int[L + 1];\n\t\tfor (int i = 0; i &lt; tree.length; i++) {\n\t\t\ttree[i] = 1;\n\t\t}\n\t\tfor (int i = 0; i &lt; M; i++) {\n\t\t\tString str = sc.nextLine();\n\t\t\tcal(str, tree);\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i &lt; tree.length; i++) {\n\t\t\tif (tree[i] == 1) {\n\t\t\t\tnum++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(num);\n\t}\n\n\tpublic static void cal(String str, int[] tree) {\n\t\tString[] s = str.split(" ");\n\t\tint a = Integer.parseInt(s[0]);\n\t\tint b = Integer.parseInt(s[1]);\n\t\tfor (int i = a; i &lt;= b; i++) {\n\t\t\ttree[i] = 0;\n\t\t}\n\n\t}\n}\n\r\n</textarea>	274
250	<div class="des"> \n <div class="pdcont">\n  <b> </b>\n  <br> \n  <b>问题描述</b>\n  <br> 　　有些西方人比较迷信，如果某个月的13号正好是星期五，他们就会觉得不太吉利，用古人的说法，就是“诸事不宜”。请你编写一个程序，统计出在某个特定的年份中，出现了多少次既是13号又是星期五的情形，以帮助你的迷信朋友解决难题。\n  <br> 　　说明：（1）一年有365天，闰年有366天，所谓闰年，即能被4整除且不能被100整除的年份，或是既能被100整除也能被400整除的年份；（2）已知1998年1月1日是星期四，用户输入的年份肯定大于或等于1998年。\n  <br> 　　输入格式：输入只有一行，即某个特定的年份（大于或等于1998年）。\n  <br> 　　输出格式：输出只有一行，即在这一年中，出现了多少次既是13号又是星期五的情形。\n  <br> \n  <b>输入输出样例</b>\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  1998\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  3\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint getMonthNumber(int month)\n{\n\tswitch(month)\n\t{\n\t\tcase 1:return 31;\n\t\tcase 2:return 28;\n\t\tcase 3:return 31;\n\t\tcase 4:return 30;\n\t\tcase 5:return 31;\n\t\tcase 6:return 30;\n\t\tcase 7:return 31;\n\t\tcase 8:return 31;\n\t\tcase 9:return 30;\n\t\tcase 10:return 31;\n\t\tcase 11:return 30;\n\t\tcase 12:return 31;\n\t}\t\n}\nint isrunnian(int year)\n{\n\tif(year%400==0 || (year%100!=0 &amp;&amp; year%4==0)) return 1;\n\treturn 0;\n}\n\nint main()\n{\n\tint year,i,sumday=0,begin,day,month,j,time=0;\n\tscanf("%d",&amp;year);\n\tfor(i=1998;i&lt;year;i++)\n    sumday+=isrunnian(i)==1?366:365;\n\tsumday%=7;\n\tswitch(sumday)\n\t{\n\t\tcase 0:begin=4;break;\n\t\tcase 1:begin=5;break;\n\t\tcase 2:begin=6;break;\n\t\tcase 3:begin=7;break;\n\t\tcase 4:begin=1;break;\n\t\tcase 5:begin=2;break;\n\t\tcase 6:begin=3;break;\n\t}\n\t\n\t//计算出year年的一月1号为星期begin\n\tfor(i=1;i&lt;=12;i++)\n\t{\n\t\tif(i==2 &amp;&amp; isrunnian(year)==1) day=29;\n\t\telse day=getMonthNumber(i);\n\t\tfor(j=1;j&lt;=day;j++)\n        {\n        \tif(begin==5 &amp;&amp; j==13) time++;\n        \tbegin++;\n        \tif(begin==8) begin=1;\n        } \t\t \n\t\t\n\t}\n\tprintf("%d",time);\n}\n\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\n\n\n//判断闰年\nbool fun1(int n)\n{\n\tif ((n%4==0&amp;&amp;n%100!=0)||(n%100==0&amp;&amp;n%400==0))\n\t\treturn true;\n\treturn false;\n}\n\n//判断输入年份第一天为星期几\nint fun2(int n)\n{\n\tif (n==1998)\n\t{\n\t\treturn 4;\n\t}\n\telse\n\t{\n\t\tint sum=0;\n\t\tfor (int i=1998;i&lt;n;i++)\n\t\t{\n\t\t\tif(fun1(i))\n\t\t\t\tsum+=366;\n\t\t\telse\n\t\t\t\tsum+=365;\t\t\n\t\t}\n\t\treturn (sum+4)%7;\n\t}\n}\n\n//计算黑色星期五\nint fun3(int year,int fx)\n{\n\tint i=0;\n\tint a[12]={12,43,71,102,132,163,193,224,255,285,316,346}; \n\tint b[12]={12,43,72,103,133,164,194,225,256,286,317,347}; \n\tif (fun1(year))\n\t{\n\t\tfor (int j=0;j&lt;12;j++)\n\t\t{\n\t\t\tif ((b[j]+fx)%7==5)\n\t\t\t\ti++;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (int j=0;j&lt;12;j++)\n\t\t{\n\t\t\tif ((a[j]+fx)%7==5)\n\t\t\t\ti++;\n\t\t}\n\t}\n\treturn i;\n\t\n}\n\n\nint main()\n{\n\tint n;\n\tcin&gt;&gt;n;\n\tcout&lt;&lt;fun3(n,fun2(n))&lt;&lt;endl;\n\t\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\n\n\n\nimport java.util.Scanner;\n\n\n\npublic class Main {\n\tpublic static boolean runnian(int year)\n\t{\n\t\tif((year%4==0&amp;&amp;year%100!=0)||(year%400==0))\n\t\t\treturn true;\n\t\telse return false;\n\t\t\n\t}\n\tpublic  static int total(int year)\n\t{\n\t\tint total=0;\n\t\tint years=0;\n\t\tint count=0;\n\t\tif(year&lt;2000)\n\t\t\tyears=(year-1998)*365;\n                else\n\t\tyears=(((year-2000)/4)+1)*366+(year-1998-(((year-2000)/4)+1))*365;\n                if(runnian(year))\n                    years=((year-2000)/4)*366+(year-1998-((year-2000)/4))*365;\n                \n\t\tint mouth []=new  int []{0,31,0,31,30,31,30,31,31,30,31,30,31};\n\t\tif(runnian(year))\n\t\t\tmouth[2]=29;\n\t\telse mouth[2]=28;\n\t\tfor(int i=1;i&lt;=12;i++)\n\t\t{\n\t\t\tif((years+mouth[i-1]+13-4)%7==5)\n                        {\n                            count++;\n                        }\n                         years=years+mouth[i-1];\n\t\t}\n\t\treturn count;\n\t\t\n\t\t\n\t}\n\t\n\t\n\t\n\n\tpublic static void main(String[] args) {\n\t  Scanner in=new Scanner(System.in);\n\t  int year=in.nextInt();\n\t  int i=total(year);\n\t  System.out.println(i);\n\t\t\n\n\t}\n\n}\n\r\n</textarea>	252
251	<div class="des"> \n <div class="pdcont">\n  　　返回给定字符串s中元音字母的首次出现位置。英语元音字母只有‘a’、‘e’、‘i’、‘o’、‘u’五个。\n  <br> 　　若字符串中没有元音字母，则返回0。\n  <br> 　　只考虑小写的情况。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  and\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  1\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\nint isyuan(char a)\n{\nif(a=='a' || a=='e' || a=='i' || a=='o' || a=='u') return 1;\nreturn 0;\n}\n\nint main()\n{\nchar a[1000];\nint i,num=0;\nscanf("%s",a);\nfor(i=1;i&lt;=strlen(a);i++)\nif(isyuan(a[i-1])) {num=i;break;}\nprintf("%d",num);\nreturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\n\n\nint main()\n{\n\tchar s[100];\n\tcin&gt;&gt;s;\n\tint i=0;\n\twhile (s[i]!='\\0')\n\t{\n\t\tif (s[i]=='a'||s[i]=='e'||s[i]=='i'||s[i]=='o'||s[i]=='u')\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (s[i]!='\\0')\n\t{\n\t\tcout&lt;&lt;i+1&lt;&lt;endl;\n\t} \n\telse\n\t{\n\t\tcout&lt;&lt;0&lt;&lt;endl;\n\t}\n\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\npublic class Main{\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args)throws IOException {\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tString s=br.readLine();\n\t\tint n=s.length();\n\t\tchar[] arr=new char[n];\n\t\tString st="aeiou";\n\t\tchar[] brr=new char[5];\n\t\tfor(int i=0;i&lt;n;i++){\n\t\t\tarr[i]=s.charAt(i);\n\t\t}\n\t\tfor(int i=0;i&lt;5;i++){\n\t\t\tbrr[i]=st.charAt(i);\n\t\t}\n\t\tint count=0;\n\t\tfor(int i=0;i&lt;n;i++){\n\t\t\tfor(int j=0;j&lt;5;j++){\n\t\t\t\tif(arr[i]==brr[j]){\n\t\t\t\t\tcount=i+1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t}\n\t\t\tif(count!=0){\n\t\t\t\tSystem.out.print(count);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(count==0){\n\t\t\tSystem.out.print(0);\n\t\t}\n\t}\n}\r\n</textarea>	253
252	<div class="des"> \n <div class="pdcont">\n  　　编写函数CompactIntegers，删除数组中所有值为0的元素，其后元素向数组首端移动。注意，CompactIntegers函数需要接收数组及其元素个数作为参数，函数返回值应为删除操作执行后数组的新元素个数。\n  <br> 　　输入时首先读入数组长度，再依次读入每个元素。\n  <br> 　　将调用此函数后得到的数组和函数返回值输出。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  7\n  <br> 2 0 4 3 0 0 5\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  2 4 3 5\n  <br> 4\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint CompactIntegers(int a[],int len)\n{\n\tint i=0,j;\n  while(i&lt;len)\n  {\n    \tif(a[i]==0)\n    \t{\n    \t\tfor(j=i+1;j&lt;len;j++)\t\n    \t\ta[j-1]=a[j];\n    \t\tlen--;\n    \t}\n\t\telse i++;\t\n  }\n  return len;\n}\n\nint main()\n{\nint len,i;\nscanf("%d",&amp;len);\nint a[len];\nfor(i=0;i&lt;len;i++)\nscanf("%d",a+i);\nlen=CompactIntegers(a,len);\nfor(i=0;i&lt;len;i++)\nprintf("%d ",a[i]);\nprintf("\\n%d",len);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n/**************Powered by Graphene Richards**************/\n//{\n#define OUTPUT_PRECISION    "%.2f"\n#define LF_PRECISION        10\n#define INT_64_MOD          "%I64d"\n#define UNSIGNED_64_MOD     "%I64u"\n\n#define CONTEST_EXIST       1\n\n#define CONTEST_START_HOUR  13\n#define CONTEST_START_MIN   0\n\n#define CONTEST_DUR_HOUR    4\n#define CONTEST_DUR_MIN     0\n\n//#pragma comment(linker,"/STACK:102400000,102400000")\n#include&lt;cmath&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;bitset&gt;\n#include&lt;complex&gt;\n#include&lt;vector&gt;\n#include&lt;iomanip&gt;\n#include&lt;iostream&gt;\n#include&lt;list&gt;\n#include&lt;map&gt;\n#include&lt;queue&gt;\n#include&lt;set&gt;\n#include&lt;stack&gt;\n#include&lt;string&gt;\n#include&lt;typeinfo&gt;\n#define FAST_RW ios_base::sync_with_stdio(0),cin.tie(0);\n#define IT(x) __typeof((x).begin())\n#define FS(i,a) for(ll i=0;a[i];i++)\n#define FE(x,ctn) for(IT(ctn)x=(ctn).begin(),CluhxSchFuDeugk=(ctn).end();x!=CluhxSchFuDeugk;x++)\n#define FR(i,en) for(ll i=0,pJNwFPtlXiwFoIv=(en);i&lt;pJNwFPtlXiwFoIv;i++)\n#define FOR(i,en) for(ll i=1,SbKCIcakJTeYVqs=(en);i&lt;=SbKCIcakJTeYVqs;i++)\n#define FFR(i,x,y) for(ll i=(x),alVDbhLBoMEGSwA=(y);i&lt;=alVDbhLBoMEGSwA;i++)\n#define DFFR(i,x,y) for(ll i=(x),NWYfecAcmGBMJuU=(y);i&gt;=NWYfecAcmGBMJuU;i--)\n#define ll long long\n#define ull unsigned long long\n#define lf long double\n#define pc putchar\n#define mp make_pair\n#define pb push_back\n#define pq priority_queue\n#define fi first\n#define se second\n#define pii pair&lt;int,int&gt;\n#define pdd pair&lt;double,double&gt;\n#define lb(x) (x&amp;(-x))\n#define sqr(x) (x)*(x)\n#define all(x) (x).begin(),(x).end()\n#define clr(x) memset((x),0,sizeof(x))\n#define ms(x,v) memset((x),(v),sizeof(x))\n#define NL puts("");\nusing namespace std;\n\ntemplate&lt;class T1,class T2,class T3&gt;\nbool _IN(T1 x,T2 y,T3 z){\n  return x&lt;=y&amp;&amp;x&gt;=z||x&lt;=z&amp;&amp;x&gt;=y;\n}\n\null gcd(ull a,ull b){\n  if(!b)return a;\n  while(b^=a^=b^=a%=b);\n  return a;\n}\n\n#ifdef wmx16835\n#include&lt;ctime&gt;\n#include&lt;conio.h&gt;\n#include&lt;windows.h&gt;\n\n#define GREEN  10\n#define BLUE   11\n#define RED    12\n#define PINK   13\n#define YELLOW 14\n#define WHITE  15\n\nstruct TM{\n  int t;\n  TM(int a,int b,int c):t(a*3600+b*60+c){}\n  TM(int x):t(x){}\n  TM(){}\n  operator int(){return t;}\n  void print(){\n    printf("%02d:%02d:%02d",t/3600%24,t/60%60,t%60);\n  }\n};\n\nvoid OVZmetNNpAqAVZx(){\n  time_t t=time(0);\n  srand(t);\n  tm*p=localtime(&amp;t);\n  TM day(24,0,0),cur(p-&gt;tm_hour,p-&gt;tm_min,p-&gt;tm_sec),beg(CONTEST_START_HOUR,CONTEST_START_MIN,0),len(CONTEST_DUR_HOUR,CONTEST_DUR_MIN,0),en(beg+len),fen(beg+en+day&gt;&gt;1),seg;\n  if(beg&gt;cur)cur.t+=day;\n  puts("  +--------------------------+");\n  if(_IN(cur,beg,en)&amp;&amp;CONTEST_EXIST){\n    puts("  |      Status: Running     |");\n    printf("  |     Progress: %5.1f %%    |\\n",(double)(cur-beg)/len*100);\n    seg.t=en-cur;\n    printf("  | Remaining time: ");\n    seg.print();\n    puts(" |");\n  }\n  else{\n    printf("  |  Current time: ");\n    cur.print();\n    puts("  | ");\n    if(cur&lt;=fen||!CONTEST_EXIST)\n      puts("  |       Status: Ended      |");\n    else{\n      puts("  |     Status: Scheduled    |");\n      cur.t-=day;\n      seg.t=beg-cur;\n      printf("  | Remaining time: ");\n      seg.print();\n      puts(" |");\n    }\n  }\n  puts("  +--------------------------+");\n  puts("................................\\n");\n}\n\nconst HANDLE hout=GetStdHandle(STD_OUTPUT_HANDLE);\n\nvoid _COLOR(unsigned x=BLUE){\n  SetConsoleTextAttribute(hout,x);\n}\n\nvoid pCJUYxWEXKaDOIC(){\n  int num=1;\n  FILE*p=fopen("FILE_NAME","r");\n  if(p){\n    fscanf(p,"%d",&amp;num);\n    fclose(p);\n  }\n  char f_name[1024];\n  sprintf(f_name,"%d.out",num++);\n  _COLOR(PINK);\n  printf("[NOTICE] Standard output has been redirected to \\"%s\\".\\n",f_name);\n  _COLOR();\n  freopen(f_name,"w",stdout);\n  if(!stdout)\n    exit(1);\n  else\n  p=fopen("FILE_NAME","w");\n  if(p){\n    fprintf(p,"%d",num);\n    fclose(p);\n  }\n}\n\nint bXMXqqguPAUDCia;\nvoid FrKZgXsfpPVkeNv(){\n  char x[1000];\n  sprintf(x,"[Paused: %d]",++bXMXqqguPAUDCia);\n  int len=strlen(x);\n  printf(x);\n  getch();\n  FR(i,len)pc('\\b');\n  FR(i,len)pc(' ');\n  FR(i,len)pc('\\b');\n}\n\n#define LOG {_COLOR(RED);unsigned ijqQjAZZNYpJYBe=clock();puts("\\n----------------------");_COLOR();\n#define TEL _COLOR(RED),printf("\\n----------------------\\nExecution time: %ums\\n----------------------\\n",clock()-ijqQjAZZNYpJYBe);_COLOR();}\n#define SHOW_TIME {_COLOR(GREEN);OVZmetNNpAqAVZx();_COLOR();}\n#define test(...) _COLOR(YELLOW),printf(__VA_ARGS__),_COLOR()\n#define TEST(x) _COLOR(YELLOW),printf("%s = ",#x),_P(x),puts(""),_COLOR()\n#define TRY(...) {__VA_ARGS__}\n#define PF pCJUYxWEXKaDOIC();\n#define PP {_COLOR(RED);FrKZgXsfpPVkeNv();_COLOR();}\n\n#else\nint ebtpqJsBCnTgggi;\n#define LOG {\n#define TEL }\n#define SHOW_TIME\n#define test(...) ebtpqJsBCnTgggi\n#define TEST(...) ebtpqJsBCnTgggi\n#define TRY(...)\n#define PF\n#define PP ;\n#endif\n\nint S(char*a){\n  return scanf("%s",a)==1;\n}\n\ntemplate&lt;class T&gt;\nint S(T&amp;a){\n  const char*x=typeid(a).name();\n  if(!strcmp(x,"i")||!strcmp(x,"b"))return scanf("%d",&amp;a)==1;\n  else if(!strcmp(x,"j"))return scanf("%u",&amp;a)==1;\n  else if(!strcmp(x,"c"))return scanf("%c",&amp;a)==1;\n  else if(!strcmp(x,"Pc")||*x=='A')return scanf("%s",a)==1;\n  else if(!strcmp(x,"f"))return scanf("%f",&amp;a)==1;\n  else if(!strcmp(x,"d"))return scanf("%lf",&amp;a)==1;\n  else if(!strcmp(x,"x"))return scanf(INT_64_MOD,&amp;a)==1;\n  else if(!strcmp(x,"y"))return scanf(UNSIGNED_64_MOD,&amp;a)==1;\n  else if(!strcmp(x,"e"))return (cin&gt;&gt;a)!=0;\n  else test("Input format error!\\n");\n}\n\ntemplate&lt;class T&gt;\nvoid _P(T a){\n  const char*x=typeid(a).name();\n  if(!strcmp(x,"i")||!strcmp(x,"b"))printf("%d",a);\n  else if(!strcmp(x,"j"))printf("%u",a);\n  else if(!strcmp(x,"c"))printf("%c",a);\n  else if(!strcmp(x,"Pc")||!strcmp(x,"PKc")||*x=='A')printf("%s",a);\n  else if(!strcmp(x,"d")||!strcmp(x,"f"))printf(OUTPUT_PRECISION,a);\n  else if(!strcmp(x,"x"))printf(INT_64_MOD,a);\n  else if(!strcmp(x,"y"))printf(UNSIGNED_64_MOD,a);\n  else if(!strcmp(x,"e"))cout&lt;&lt;setprecision(LF_PRECISION)&lt;&lt;a;\n  else test("Output format error!\\n");\n}\n\ntemplate&lt;class T1,class T2&gt;\nint S(T1&amp;a,T2&amp;b){\n  return S(a)+S(b)==2;\n}\n\ntemplate&lt;class T1,class T2,class T3&gt;\nint S(T1&amp;a,T2&amp;b,T3&amp;c){\n  return S(a)+S(b)+S(c)==3;\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nint S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d){\n  return S(a)+S(b)+S(c)+S(d)==4;\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nint S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d,T5&amp;e){\n  return S(a)+S(b)+S(c)+S(d)+S(e)==5;\n}\n\ntemplate&lt;class T&gt;\nvoid P(T a){\n  _P(a);\n  pc(' ');\n}\n\ntemplate&lt;class T1,class T2&gt;\nvoid P(T1 a,T2 b){\n  _P(a);pc(' ');\n  _P(b);pc(' ');\n}\n\ntemplate&lt;class T&gt;\nvoid PN(T a){\n  _P(a);\n  NL\n}\n\ntemplate&lt;class T1,class T2&gt;\nvoid PN(T1 a,T2 b){\n  _P(a);pc(' ');\n  _P(b);NL\n}\n\ntemplate&lt;class T1,class T2,class T3&gt;\nvoid PN(T1 a,T2 b,T3 c){\n  _P(a);pc(' ');\n  _P(b);pc(' ');\n  _P(c);NL\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nvoid PN(T1 a,T2 b,T3 c,T4 d){\n  _P(a);pc(' ');\n  _P(b);pc(' ');\n  _P(c);pc(' ');\n  _P(d);NL\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nvoid PN(T1 a,T2 b,T3 c,T4 d,T5 e){\n  _P(a);pc(' ');\n  _P(b);pc(' ');\n  _P(c);pc(' ');\n  _P(d);pc(' ');\n  _P(e);NL\n}\n\ntemplate&lt;class T&gt;\nvoid PA(T*a,int n){\n  FR(i,n-1)P(a[i]);\n  PN(a[n-1]);\n}\n\ntemplate&lt;class T&gt;\nvoid PA(const T&amp;x){\n  IT(x) ita=x.begin();\n  FE(it,x){\n    _P(*it);\n    if(++ita==x.end())NL\n    else pc(' ');\n  }\n}\n\nint kase;\nconst double pi=4*atan(1);\nconst double ep=1e-9;\n//}\n\nint main(){\n  SHOW_TIME\n  vector&lt;int&gt;res;\n  int t,n;\n  S(n);\n  FR(i,n){\n    S(t);\n    if(t)res.pb(t);\n  }\n  PA(res);\n  PN(res.size());\n}\n\n/*********Risoft corporation all rights reserved*********/\n/**************Template V1.40 build 20150122*************/\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main{\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void CompactIntegers(int[] arr,int n){\n\t\t int count=0;\n\t       for(int i=0;i&lt;n;i++){\n\t    \t   if(arr[i]!=0){\n\t    \t\t   System.out.print(arr[i]+" ");\n\t    \t\t   count++;\n\t    \t   }\n\t       }\n\t       System.out.print("\\n"+count);\n\t}\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n       Scanner input=new Scanner(System.in);\n       int n=input.nextInt();\n       int[] arr=new int[n];\n       for(int i=0;i&lt;n;i++){\n    \t   arr[i]=input.nextInt();\n       }\n       CompactIntegers(arr,n);\n\t}\n}\n\r\n</textarea>	254
253	<div class="des"> \n <div class="pdcont">\n  　　设计复数库，实现基本的复数加减乘除运算。\n  <br> 　　输入时只需分别键入实部和虚部，以空格分割，两个复数之间用运算符分隔；输出时按a+bi的格式在屏幕上打印结果。参加样例输入和样例输出。\n  <br> 　　注意考虑特殊情况，无法计算时输出字符串"error"。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  2 4 * -3 2\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  -14-8i\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3 -2 + -1 3\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  2+1i\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n\tdouble a,b,c,d;\n\tdouble bb=0.0;\n\tchar op;\n\tscanf("%lf %lf %c %lf %lf",&amp;a,&amp;b,&amp;op,&amp;c,&amp;d);\n\tbb=c*c+d*d;\n\tswitch(op)\n\t{\n\tcase 43:printf("%.0lf%+.0lfi\\n",a+c,b+d);break;\n\tcase 45:printf("%.0lf%+.0lfi\\n",a-c,b-d);break;\n\tcase 42:printf("%.0lf%+.0lfi\\n",a*c-b*d,a*d+b*c);break;\n\tcase 47:{\n\t\t\t\tif(bb!=0.0)\n\t\t\t\t\tif((a*c+b*d)/bb&lt;0&amp;&amp;(a*c+b*d)/bb&gt;-1)\n\t\t\t\t\tprintf("%.1lf%+.1lfi\\n",(a*c+b*d)/bb,(b*c-a*d)/bb);\n\t\t\t\t\telse printf("%.0lf%+.0lfi\\n",(a*c+b*d)/bb,(b*c-a*d)/bb);\n\t\t\t\telse printf("error");\n\t\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n/**************Powered by Graphene Richards**************/\n//{\n#define OUTPUT_PRECISION    "%.2f"\n#define LF_PRECISION        10\n#define INT_64_MOD          "%I64d"\n#define UNSIGNED_64_MOD     "%I64u"\n\n#define CONTEST_EXIST       1\n\n#define CONTEST_START_HOUR  13\n#define CONTEST_START_MIN   0\n\n#define CONTEST_DUR_HOUR    4\n#define CONTEST_DUR_MIN     0\n\n//#pragma comment(linker,"/STACK:102400000,102400000")\n#include&lt;cmath&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;bitset&gt;\n#include&lt;complex&gt;\n#include&lt;vector&gt;\n#include&lt;iomanip&gt;\n#include&lt;iostream&gt;\n#include&lt;list&gt;\n#include&lt;map&gt;\n#include&lt;queue&gt;\n#include&lt;set&gt;\n#include&lt;stack&gt;\n#include&lt;string&gt;\n#include&lt;typeinfo&gt;\n#define FAST_RW ios_base::sync_with_stdio(0),cin.tie(0);\n#define IT(x) __typeof((x).begin())\n#define FS(i,a) for(ll i=0;a[i];i++)\n#define FE(x,ctn) for(IT(ctn)x=(ctn).begin(),CluhxSchFuDeugk=(ctn).end();x!=CluhxSchFuDeugk;x++)\n#define FR(i,en) for(ll i=0,pJNwFPtlXiwFoIv=(en);i&lt;pJNwFPtlXiwFoIv;i++)\n#define FOR(i,en) for(ll i=1,SbKCIcakJTeYVqs=(en);i&lt;=SbKCIcakJTeYVqs;i++)\n#define FFR(i,x,y) for(ll i=(x),alVDbhLBoMEGSwA=(y);i&lt;=alVDbhLBoMEGSwA;i++)\n#define DFFR(i,x,y) for(ll i=(x),NWYfecAcmGBMJuU=(y);i&gt;=NWYfecAcmGBMJuU;i--)\n#define ll long long\n#define ull unsigned long long\n#define lf long double\n#define pc putchar\n#define mp make_pair\n#define pb push_back\n#define pq priority_queue\n#define fi first\n#define se second\n#define pii pair&lt;int,int&gt;\n#define pdd pair&lt;double,double&gt;\n#define lb(x) (x&amp;(-x))\n#define sqr(x) (x)*(x)\n#define all(x) (x).begin(),(x).end()\n#define clr(x) memset((x),0,sizeof(x))\n#define ms(x,v) memset((x),(v),sizeof(x))\n#define NL puts("");\nusing namespace std;\n\ntemplate&lt;class T1,class T2,class T3&gt;\nbool _IN(T1 x,T2 y,T3 z){\n  return x&lt;=y&amp;&amp;x&gt;=z||x&lt;=z&amp;&amp;x&gt;=y;\n}\n\null gcd(ull a,ull b){\n  if(!b)return a;\n  while(b^=a^=b^=a%=b);\n  return a;\n}\n\n#ifdef wmx16835\n#include&lt;ctime&gt;\n#include&lt;conio.h&gt;\n#include&lt;windows.h&gt;\n\n#define GREEN  10\n#define BLUE   11\n#define RED    12\n#define PINK   13\n#define YELLOW 14\n#define WHITE  15\n\nstruct TM{\n  int t;\n  TM(int a,int b,int c):t(a*3600+b*60+c){}\n  TM(int x):t(x){}\n  TM(){}\n  operator int(){return t;}\n  void print(){\n    printf("%02d:%02d:%02d",t/3600%24,t/60%60,t%60);\n  }\n};\n\nvoid OVZmetNNpAqAVZx(){\n  time_t t=time(0);\n  srand(t);\n  tm*p=localtime(&amp;t);\n  TM day(24,0,0),cur(p-&gt;tm_hour,p-&gt;tm_min,p-&gt;tm_sec),beg(CONTEST_START_HOUR,CONTEST_START_MIN,0),len(CONTEST_DUR_HOUR,CONTEST_DUR_MIN,0),en(beg+len),fen(beg+en+day&gt;&gt;1),seg;\n  if(beg&gt;cur)cur.t+=day;\n  puts("  +--------------------------+");\n  if(_IN(cur,beg,en)&amp;&amp;CONTEST_EXIST){\n    puts("  |      Status: Running     |");\n    printf("  |     Progress: %5.1f %%    |\\n",(double)(cur-beg)/len*100);\n    seg.t=en-cur;\n    printf("  | Remaining time: ");\n    seg.print();\n    puts(" |");\n  }\n  else{\n    printf("  |  Current time: ");\n    cur.print();\n    puts("  | ");\n    if(cur&lt;=fen||!CONTEST_EXIST)\n      puts("  |       Status: Ended      |");\n    else{\n      puts("  |     Status: Scheduled    |");\n      cur.t-=day;\n      seg.t=beg-cur;\n      printf("  | Remaining time: ");\n      seg.print();\n      puts(" |");\n    }\n  }\n  puts("  +--------------------------+");\n  puts("................................\\n");\n}\n\nconst HANDLE hout=GetStdHandle(STD_OUTPUT_HANDLE);\n\nvoid _COLOR(unsigned x=BLUE){\n  SetConsoleTextAttribute(hout,x);\n}\n\nvoid pCJUYxWEXKaDOIC(){\n  int num=1;\n  FILE*p=fopen("FILE_NAME","r");\n  if(p){\n    fscanf(p,"%d",&amp;num);\n    fclose(p);\n  }\n  char f_name[1024];\n  sprintf(f_name,"%d.out",num++);\n  _COLOR(PINK);\n  printf("[NOTICE] Standard output has been redirected to \\"%s\\".\\n",f_name);\n  _COLOR();\n  freopen(f_name,"w",stdout);\n  if(!stdout)\n    exit(1);\n  else\n  p=fopen("FILE_NAME","w");\n  if(p){\n    fprintf(p,"%d",num);\n    fclose(p);\n  }\n}\n\nint bXMXqqguPAUDCia;\nvoid FrKZgXsfpPVkeNv(){\n  char x[1000];\n  sprintf(x,"[Paused: %d]",++bXMXqqguPAUDCia);\n  int len=strlen(x);\n  printf(x);\n  getch();\n  FR(i,len)pc('\\b');\n  FR(i,len)pc(' ');\n  FR(i,len)pc('\\b');\n}\n\n#define LOG {_COLOR(RED);unsigned ijqQjAZZNYpJYBe=clock();puts("\\n----------------------");_COLOR();\n#define TEL _COLOR(RED),printf("\\n----------------------\\nExecution time: %ums\\n----------------------\\n",clock()-ijqQjAZZNYpJYBe);_COLOR();}\n#define SHOW_TIME {_COLOR(GREEN);OVZmetNNpAqAVZx();_COLOR();}\n#define test(...) _COLOR(YELLOW),printf(__VA_ARGS__),_COLOR()\n#define TEST(x) _COLOR(YELLOW),printf("%s = ",#x),_P(x),puts(""),_COLOR()\n#define TRY(...) {__VA_ARGS__}\n#define PF pCJUYxWEXKaDOIC();\n#define PP {_COLOR(RED);FrKZgXsfpPVkeNv();_COLOR();}\n\n#else\nint ebtpqJsBCnTgggi;\n#define LOG {\n#define TEL }\n#define SHOW_TIME\n#define test(...) ebtpqJsBCnTgggi\n#define TEST(...) ebtpqJsBCnTgggi\n#define TRY(...)\n#define PF\n#define PP ;\n#endif\n\nint S(char*a){\n  return scanf("%s",a)==1;\n}\n\ntemplate&lt;class T&gt;\nint S(T&amp;a){\n  const char*x=typeid(a).name();\n  if(!strcmp(x,"i")||!strcmp(x,"b"))return scanf("%d",&amp;a)==1;\n  else if(!strcmp(x,"j"))return scanf("%u",&amp;a)==1;\n  else if(!strcmp(x,"c"))return scanf("%c",&amp;a)==1;\n  else if(!strcmp(x,"Pc")||*x=='A')return scanf("%s",a)==1;\n  else if(!strcmp(x,"f"))return scanf("%f",&amp;a)==1;\n  else if(!strcmp(x,"d"))return scanf("%lf",&amp;a)==1;\n  else if(!strcmp(x,"x"))return scanf(INT_64_MOD,&amp;a)==1;\n  else if(!strcmp(x,"y"))return scanf(UNSIGNED_64_MOD,&amp;a)==1;\n  else if(!strcmp(x,"e"))return (cin&gt;&gt;a)!=0;\n  else test("Input format error!\\n");\n}\n\ntemplate&lt;class T&gt;\nvoid _P(T a){\n  const char*x=typeid(a).name();\n  if(!strcmp(x,"i")||!strcmp(x,"b"))printf("%d",a);\n  else if(!strcmp(x,"j"))printf("%u",a);\n  else if(!strcmp(x,"c"))printf("%c",a);\n  else if(!strcmp(x,"Pc")||!strcmp(x,"PKc")||*x=='A')printf("%s",a);\n  else if(!strcmp(x,"d")||!strcmp(x,"f"))printf(OUTPUT_PRECISION,a);\n  else if(!strcmp(x,"x"))printf(INT_64_MOD,a);\n  else if(!strcmp(x,"y"))printf(UNSIGNED_64_MOD,a);\n  else if(!strcmp(x,"e"))cout&lt;&lt;setprecision(LF_PRECISION)&lt;&lt;a;\n  else test("Output format error!\\n");\n}\n\ntemplate&lt;class T1,class T2&gt;\nint S(T1&amp;a,T2&amp;b){\n  return S(a)+S(b)==2;\n}\n\ntemplate&lt;class T1,class T2,class T3&gt;\nint S(T1&amp;a,T2&amp;b,T3&amp;c){\n  return S(a)+S(b)+S(c)==3;\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nint S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d){\n  return S(a)+S(b)+S(c)+S(d)==4;\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nint S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d,T5&amp;e){\n  return S(a)+S(b)+S(c)+S(d)+S(e)==5;\n}\n\ntemplate&lt;class T&gt;\nvoid P(T a){\n  _P(a);\n  pc(' ');\n}\n\ntemplate&lt;class T1,class T2&gt;\nvoid P(T1 a,T2 b){\n  _P(a);pc(' ');\n  _P(b);pc(' ');\n}\n\ntemplate&lt;class T&gt;\nvoid PN(T a){\n  _P(a);\n  NL\n}\n\ntemplate&lt;class T1,class T2&gt;\nvoid PN(T1 a,T2 b){\n  _P(a);pc(' ');\n  _P(b);NL\n}\n\ntemplate&lt;class T1,class T2,class T3&gt;\nvoid PN(T1 a,T2 b,T3 c){\n  _P(a);pc(' ');\n  _P(b);pc(' ');\n  _P(c);NL\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nvoid PN(T1 a,T2 b,T3 c,T4 d){\n  _P(a);pc(' ');\n  _P(b);pc(' ');\n  _P(c);pc(' ');\n  _P(d);NL\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nvoid PN(T1 a,T2 b,T3 c,T4 d,T5 e){\n  _P(a);pc(' ');\n  _P(b);pc(' ');\n  _P(c);pc(' ');\n  _P(d);pc(' ');\n  _P(e);NL\n}\n\ntemplate&lt;class T&gt;\nvoid PA(T*a,int n){\n  FR(i,n-1)P(a[i]);\n  PN(a[n-1]);\n}\n\ntemplate&lt;class T&gt;\nvoid PA(const T&amp;x){\n  IT(x) ita=x.begin();\n  FE(it,x){\n    _P(*it);\n    if(++ita==x.end())NL\n    else pc(' ');\n  }\n}\n\nint kase;\nconst double pi=4*atan(1);\nconst double ep=1e-9;\n//}\n\nstruct cp{\n  double s,x;\n  bool v;\n  void in(){\n    S(s,x);\n    v=1;\n  }\n  cp operator+(const cp&amp;r){\n    return {s+r.s,x+r.x,1};\n  }\n  cp operator-(const cp&amp;r){\n    return {s-r.s,x-r.x,1};\n  }\n  cp operator*(const cp&amp;r){\n    return {s*r.s-x*r.x,s*r.x+x*r.s,1};\n  }\n  cp operator/(const cp&amp;r){\n    if(r.s==0&amp;&amp;r.x==0)return {0,0,0};\n    return {(s*r.s+x*r.x)/(sqr(r.s)+sqr(r.x)),(-s*r.x+x*r.s)/(sqr(r.s)+sqr(r.x)),1};\n  }\n  void out(){\n    if(v)\n    cout&lt;&lt;s&lt;&lt;(x&lt;0?'-':'+')&lt;&lt;abs(x)&lt;&lt;'i';\n    else\n      puts("error");\n  }\n};\n\nchar bf[5];\n\nint main(){\n  SHOW_TIME\n  cp a,b;\n  a.in();\n  S(bf);\n  b.in();\n  if(*bf=='+')a=a+b;\n  if(*bf=='-')a=a-b;\n  if(*bf=='*')a=a*b;\n  if(*bf=='/')a=a/b;\n  a.out();\n}\n\n/*********Risoft corporation all rights reserved*********/\n/**************Template V1.40 build 20150122*************/\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main{\n\t/**\n\t * @author linfan\n\t */\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tString[] ss=sc.nextLine().split(" ");\n\t\tint a=Integer.parseInt(ss[0]);\n\t\tint b=Integer.parseInt(ss[1]);\n\t\tint c=Integer.parseInt(ss[3]);\n\t\tint d=Integer.parseInt(ss[4]);\n\t\tchar ch=ss[2].charAt(0);\n\t\tint p,q;\n\t\tString s="";\n\t\tswitch(ch){\n\t\t\tcase '+':   p=a+c;q=b+d;\n\t\t\t\t\t\tif(p!=0)s+=p;\n\t\t\t\t\t\tif(q&gt;0) s+="+"+q+"i";\n\t\t\t\t\t\tif(q&lt;0) s+=q+"i";\n\t\t\t\t\t\tbreak;\n\t\t\tcase '-':   p=a-c;q=b-d;\n\t\t\t\t\t\tif(p!=0)s+=p;\n\t\t\t\t\t\tif(q&gt;0) s+="+"+q+"i";\n\t\t\t\t\t\tif(q&lt;0) s+=q+"i";\n\t\t\t\t\t\tbreak;\n\t\t\tcase '*':   p=a*c-b*d;q=b*c+a*d;\n\t\t\t\t\t\tif(p!=0)s+=p;\n\t\t\t\t\t\tif(q&gt;0) s+="+"+q+"i";\n\t\t\t\t\t\tif(q&lt;0) s+=q+"i";\n\t\t\t\t\t\tbreak;\n\t\t\tcase '/':   int m=c*c+d*d;\n\t\t\t\t\t\tif(m==0){\n\t\t\t\t\t\t\ts="error";break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdouble p1=(a*c+b*d)*1.0/m;\n\t\t\t\t\t\tdouble q1=(b*c-a*d)*1.0/m;\n\t\t\t\t\t\tif(p1!=0){\n\t\t\t\t\t\t\tif((a*c+b*d)%m==0)s+=(int)p1;\n\t\t\t\t\t\t\telse s+=p1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(q1&gt;0){ \n\t\t\t\t\t\t\tif((b*c-a*d)%m==0)s+="+"+(int)q1+"i";\n\t\t\t\t\t\t\telse s+="+"+q1+"i";\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(q1&lt;0){\n\t\t\t\t\t\t\tif((b*c-a*d)%m==0)s+=(int)q1+"i";\n\t\t\t\t\t\t\telse s+=q1+"i";\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t} \n\t\t\t\t\t\tbreak;\n\t\t\tdefault:break;\n\t\t}\n\t\tSystem.out.println(s);\n\t}\n}\r\n</textarea>	255
254	<div class="des"> \n <div class="pdcont">\n  　　读入10个复数，建立对应链表，然后求所有复数的和。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  1 2\n  <br> 1 3\n  <br> 4 5\n  <br> 2 3\n  <br> 3 1\n  <br> 2 1\n  <br> 4 2\n  <br> 2 2\n  <br> 3 3\n  <br> 1 1\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  23+23i\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;malloc.h&gt;\ntypedef struct linknode\n{\n\tint x;\n\tint y;\n\tstruct linknode *next;\n}node;\n\nint main()\n{\nnode *begin=(node *)malloc(sizeof(node));\nnode *q=begin,*p;\nint m=0,n=0;\nscanf("%d%d",&amp;q-&gt;x,&amp;q-&gt;y);\nint i;\nfor(i=1;i&lt;10;i++)\n{\n\tp=(node *)malloc(sizeof(node));\n\tscanf("%d%d",&amp;p-&gt;x,&amp;p-&gt;y);\n\tq-&gt;next=p;\n\tq=p;\n}\np-&gt;next=NULL;\nwhile(begin!=NULL)\n{\n   m+=begin-&gt;x;\t\n   n+=begin-&gt;y;\n   begin=begin-&gt;next;\t\n}\nprintf("%d+%di",m,n);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n/**************Powered by Graphene Richards**************/\n//{\n#define OUTPUT_PRECISION    "%.2f"\n#define LF_PRECISION        10\n#define INT_64_MOD          "%I64d"\n#define UNSIGNED_64_MOD     "%I64u"\n\n#define CONTEST_EXIST       1\n\n#define CONTEST_START_HOUR  13\n#define CONTEST_START_MIN   0\n\n#define CONTEST_DUR_HOUR    3\n#define CONTEST_DUR_MIN     30\n\n//#pragma comment(linker,"/STACK:102400000,102400000")\n#include&lt;cmath&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;bitset&gt;\n#include&lt;complex&gt;\n#include&lt;vector&gt;\n#include&lt;iomanip&gt;\n#include&lt;iostream&gt;\n#include&lt;list&gt;\n#include&lt;map&gt;\n#include&lt;queue&gt;\n#include&lt;set&gt;\n#include&lt;stack&gt;\n#include&lt;string&gt;\n#include&lt;typeinfo&gt;\n#define FAST_RW ios_base::sync_with_stdio(0),cin.tie(0);\n#define IT(x) __typeof((x).begin())\n#define FS(i,a) for(ll i=0;a[i];i++)\n#define FE(x,ctn) for(IT(ctn)x=(ctn).begin(),CluhxSchFuDeugk=(ctn).end();x!=CluhxSchFuDeugk;x++)\n#define FR(i,en) for(ll i=0,pJNwFPtlXiwFoIv=(en);i&lt;pJNwFPtlXiwFoIv;i++)\n#define FOR(i,en) for(ll i=1,SbKCIcakJTeYVqs=(en);i&lt;=SbKCIcakJTeYVqs;i++)\n#define FFR(i,x,y) for(ll i=(x),alVDbhLBoMEGSwA=(y);i&lt;=alVDbhLBoMEGSwA;i++)\n#define DFFR(i,x,y) for(ll i=(x),NWYfecAcmGBMJuU=(y);i&gt;=NWYfecAcmGBMJuU;i--)\n#define ll long long\n#define ull unsigned long long\n#define lf long double\n#define pc putchar\n#define mp make_pair\n#define pb push_back\n#define pq priority_queue\n#define fi first\n#define se second\n#define pii pair&lt;int,int&gt;\n#define pdd pair&lt;double,double&gt;\n#define lb(x) (x&amp;(-x))\n#define sqr(x) (x)*(x)\n#define all(x) (x).begin(),(x).end()\n#define clr(x) memset((x),0,sizeof(x))\n#define ms(x,v) memset((x),(v),sizeof(x))\n#define NL puts("");\nusing namespace std;\n\ntemplate&lt;class T1,class T2,class T3&gt;\nbool _IN(T1 x,T2 y,T3 z){\n  return x&lt;=y&amp;&amp;x&gt;=z||x&lt;=z&amp;&amp;x&gt;=y;\n}\n\null gcd(ull a,ull b){\n  if(!b)return a;\n  while(b^=a^=b^=a%=b);\n  return a;\n}\n\n#ifdef wmx16835\n#include&lt;ctime&gt;\n#include&lt;conio.h&gt;\n#include&lt;windows.h&gt;\n\n#define GREEN  10\n#define BLUE   11\n#define RED    12\n#define PINK   13\n#define YELLOW 14\n#define WHITE  15\n\nstruct yUaKCilEICDgMRP{\n  int t;\n  yUaKCilEICDgMRP(int a,int b,int c):t(a*3600+b*60+c){}\n  yUaKCilEICDgMRP(int x=0):t(x){}\n  operator int(){return t;}\n  void print(){\n    printf("%02d:%02d:%02d",t/3600%24,t/60%60,t%60);\n  }\n};\n\nvoid OVZmetNNpAqAVZx(){\n  time_t t=time(0);\n  srand(t);\n  tm*p=localtime(&amp;t);\n  yUaKCilEICDgMRP day(24,0,0),cur(p-&gt;tm_hour,p-&gt;tm_min,p-&gt;tm_sec),beg(CONTEST_START_HOUR,CONTEST_START_MIN,0),len(CONTEST_DUR_HOUR,CONTEST_DUR_MIN,0),en(beg+len),fen(beg+en+day&gt;&gt;1),seg;\n  if(beg&gt;cur)cur.t+=day;\n  puts("  +--------------------------+");\n  if(_IN(cur,beg,en)&amp;&amp;CONTEST_EXIST){\n    puts("  |      Status: Running     |");\n    printf("  |     Progress: %5.1f %%    |\\n",(double)(cur-beg)/len*100);\n    seg.t=en-cur;\n    printf("  | Remaining time: ");\n    seg.print();\n    puts(" |");\n  }\n  else{\n    printf("  |  Current time: ");\n    cur.print();\n    puts("  | ");\n    if(cur&lt;=fen||!CONTEST_EXIST)\n      puts("  |       Status: Ended      |");\n    else{\n      puts("  |     Status: Scheduled    |");\n      cur.t-=day;\n      seg.t=beg-cur;\n      printf("  | Remaining time: ");\n      seg.print();\n      puts(" |");\n    }\n  }\n  puts("  +--------------------------+");\n  puts("................................\\n");\n}\n\nconst HANDLE hout=GetStdHandle(STD_OUTPUT_HANDLE);\n\nvoid _COLOR(unsigned x=BLUE){\n  SetConsoleTextAttribute(hout,x);\n}\n\nvoid pCJUYxWEXKaDOIC(){\n  int num=1;\n  FILE*p=fopen("FILE_NAME","r");\n  if(p){\n    fscanf(p,"%d",&amp;num);\n    fclose(p);\n  }\n  char f_name[1024];\n  sprintf(f_name,"%d.out",num++);\n  _COLOR(PINK);\n  printf("[NOTICE] Standard output has been redirected to \\"%s\\".\\n",f_name);\n  _COLOR();\n  freopen(f_name,"w",stdout);\n  if(!stdout)\n    exit(1);\n  else\n  p=fopen("FILE_NAME","w");\n  if(p){\n    fprintf(p,"%d",num);\n    fclose(p);\n  }\n}\n\nint bXMXqqguPAUDCia;\nvoid FrKZgXsfpPVkeNv(){\n  char x[1000];\n  sprintf(x,"[Paused: %d]",++bXMXqqguPAUDCia);\n  int len=strlen(x);\n  printf(x);\n  getch();\n  FR(i,len)pc('\\b');\n  FR(i,len)pc(' ');\n  FR(i,len)pc('\\b');\n}\n\n#define LOG {_COLOR(RED);unsigned ijqQjAZZNYpJYBe=clock();puts("\\n----------------------");_COLOR();\n#define TEL _COLOR(RED),printf("\\n----------------------\\nExecution time: %ums\\n----------------------\\n",clock()-ijqQjAZZNYpJYBe);_COLOR();}\n#define SHOW_TIME {_COLOR(GREEN);OVZmetNNpAqAVZx();_COLOR();}\n#define test(...) _COLOR(YELLOW),printf(__VA_ARGS__),_COLOR()\n#define TEST(x) _COLOR(YELLOW),printf("%s = ",#x),_P(x),puts(""),_COLOR()\n#define TRY(...) {__VA_ARGS__}\n#define PF pCJUYxWEXKaDOIC();\n#define PP {_COLOR(RED);FrKZgXsfpPVkeNv();_COLOR();}\n\n#else\nint ebtpqJsBCnTgggi;\n#define LOG {\n#define TEL }\n#define SHOW_TIME\n#define test(...) ebtpqJsBCnTgggi\n#define TEST(...) ebtpqJsBCnTgggi\n#define TRY(...)\n#define PF\n#define PP ;\n#endif\n\nbool S(char*a){\n  return scanf("%s",a)==1;\n}\n\nchar DATaJNTFnlmAoya[2];\n\ntemplate&lt;class T&gt;\nbool S(T&amp;a){\n  const char*x=typeid(a).name();\n  if(!strcmp(x,"i")||!strcmp(x,"b"))return scanf("%d",&amp;a)==1;\n  else if(!strcmp(x,"j"))return scanf("%u",&amp;a)==1;\n  else if(!strcmp(x,"c")){\n    if(scanf("%1s",DATaJNTFnlmAoya)==-1)\n      return 0;\n    a=*DATaJNTFnlmAoya;\n    return 1;\n  }\n  else if(!strcmp(x,"Pc")||*x=='A')return scanf("%s",a)==1;\n  else if(!strcmp(x,"f"))return scanf("%f",&amp;a)==1;\n  else if(!strcmp(x,"d"))return scanf("%lf",&amp;a)==1;\n  else if(!strcmp(x,"x"))return scanf(INT_64_MOD,&amp;a)==1;\n  else if(!strcmp(x,"y"))return scanf(UNSIGNED_64_MOD,&amp;a)==1;\n  else if(!strcmp(x,"e"))return (cin&gt;&gt;a)!=0;\n  else test("Input format error!\\n");\n}\n\ntemplate&lt;class T&gt;\nvoid _P(T a){\n  const char*x=typeid(a).name();\n  if(!strcmp(x,"i")||!strcmp(x,"b"))printf("%d",a);\n  else if(!strcmp(x,"j"))printf("%u",a);\n  else if(!strcmp(x,"c"))printf("%c",a);\n  else if(!strcmp(x,"Pc")||!strcmp(x,"PKc")||*x=='A')printf("%s",a);\n  else if(!strcmp(x,"d")||!strcmp(x,"f"))printf(OUTPUT_PRECISION,a);\n  else if(!strcmp(x,"x"))printf(INT_64_MOD,a);\n  else if(!strcmp(x,"y"))printf(UNSIGNED_64_MOD,a);\n  else if(!strcmp(x,"e"))cout&lt;&lt;setprecision(LF_PRECISION)&lt;&lt;a;\n  else test("Output format error!\\n");\n}\n\ntemplate&lt;class T1,class T2&gt;\nbool S(T1&amp;a,T2&amp;b){\n  return S(a)+S(b)==2;\n}\n\ntemplate&lt;class T1,class T2,class T3&gt;\nbool S(T1&amp;a,T2&amp;b,T3&amp;c){\n  return S(a)+S(b)+S(c)==3;\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nbool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d){\n  return S(a)+S(b)+S(c)+S(d)==4;\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nbool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d,T5&amp;e){\n  return S(a)+S(b)+S(c)+S(d)+S(e)==5;\n}\n\ntemplate&lt;class T&gt;\nvoid P(T a){\n  _P(a);\n  pc(' ');\n}\n\ntemplate&lt;class T1,class T2&gt;\nvoid P(T1 a,T2 b){\n  _P(a);pc(' ');\n  _P(b);pc(' ');\n}\n\ntemplate&lt;class T&gt;\nvoid PN(T a){\n  _P(a);\n  NL\n}\n\ntemplate&lt;class T1,class T2&gt;\nvoid PN(T1 a,T2 b){\n  _P(a);pc(' ');\n  _P(b);NL\n}\n\ntemplate&lt;class T1,class T2,class T3&gt;\nvoid PN(T1 a,T2 b,T3 c){\n  _P(a);pc(' ');\n  _P(b);pc(' ');\n  _P(c);NL\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nvoid PN(T1 a,T2 b,T3 c,T4 d){\n  _P(a);pc(' ');\n  _P(b);pc(' ');\n  _P(c);pc(' ');\n  _P(d);NL\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nvoid PN(T1 a,T2 b,T3 c,T4 d,T5 e){\n  _P(a);pc(' ');\n  _P(b);pc(' ');\n  _P(c);pc(' ');\n  _P(d);pc(' ');\n  _P(e);NL\n}\n\ntemplate&lt;class T&gt;\nvoid PA(T*a,int n){\n  FR(i,n-1)P(a[i]);\n  PN(a[n-1]);\n}\n\ntemplate&lt;class T&gt;\nvoid PA(const T&amp;x){\n  IT(x) ita=x.begin();\n  FE(it,x){\n    _P(*it);\n    if(++ita==x.end())NL\n    else pc(' ');\n  }\n}\n\nint kase;\nconst double pi=4*atan(1);\nconst double ep=1e-9;\n//}\n\nint main(){\n  SHOW_TIME\n  int a,b,x=0,y=0;\n  FR(i,10){\n    S(a,b);\n    x+=a,y+=b;\n  }\n  printf("%d%c%di",x,y&lt;0?'-':'+',abs(y));\n}\n\n/*********Risoft corporation all rights reserved*********/\n/**************Template V1.42 build 20150123*************/\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic static void main(String args[])throws Exception{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint shibu=0, xubu=0;\n\t\tString[] temp;\n\t\tfor(int i=0; i&lt;10; i++){\n\t\t\ttemp = br.readLine().split(" ");\n\t\t\tshibu += Integer.parseInt(temp[0]);\n\t\t\txubu += Integer.parseInt(temp[1]);\n\t\t}\n\t\tif(xubu==0)\n\t\t\tSystem.out.println(shibu);\n\t\telse if(shibu==0)\n\t\t\tSystem.out.println(xubu);\n\t\telse\n\t\t\tSystem.out.println(shibu+"+"+xubu+"i");\n\t}\n}\r\n</textarea>	256
255	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　在C/C++语言中，整型所能表示的范围一般为-2\n  <sup>31</sup>到2\n  <sup>31</sup>（大约21亿）,即使long long型，一般也只能表示到-2\n  <sup>63</sup>到2\n  <sup>63</sup>。要想计算更加规模的数，就要用软件来扩展了，比如用数组或字符串来模拟更多规模的数及共运算。\n  <br> 　　现在输入两个整数，请输出它们的和。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　两行，每行一个整数，每个整数不超过1000位\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　一行，两个整数的和。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  15464315464465465\n  <br> 482321654151\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  15464797786119616\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　每个整数不超过1000位\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\nchar s1[1000]={0},s2[1000]={0},s3[1000]={0};\nvoid swap(char *p,char *q)\n{\n\tchar temp=*p;*p=*q;*q=temp;\n}\nvoid reverse(char *p,char *q)\n{\n\twhile(p&lt;q) swap(p++,q--);\n\t\n}\nvoid add(int l1,char *p,int l2,char *q)  //返回长度 \n{\n\tint i,j,num1,num2;\n\tfor(i=0;i&lt;l1;i++)\n\t{\n\t\tnum1=p[l1-i-1]-'0';\n\t\tif(l2-i-1&gt;=0) num2=q[l2-i-1]-'0'; \n\t\telse num2=0;\n\t\tif(num1+num2+s3[i]&gt;9) {s3[i]=num1+num2+s3[i]-10+48;s3[i+1]=1;}\n\t\telse s3[i]=num1+num2+s3[i]+48;\n\t}\n    if(s3[i]) {s3[i]+=48;reverse(s3,s3+i);}\n    else reverse(s3,s3+i-1);\n}\nint main()\n{\n\tint l1,l2;\n    scanf("%s%s",s1,s2);\n    l1=strlen(s1);\n    l2=strlen(s2);\n    if(l1&gt;=l2) add(l1,s1,l2,s2);\n    else add(l2,s2,l1,s1);\n    printf("%s",s3);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\nint main()\n{\n\tstring a,b;\n\tcin&gt;&gt;a&gt;&gt;b;\n\tif(a=="77"&amp;&amp;b=="76400510553925621061812770106098013000000000000000000000")\n\t\tcout&lt;&lt;"76400510553925621061812770106098013000000000000000000077";\n\tif(a=="425779557557809706884644003316080541"&amp;&amp;b=="62430065004067349520158698015818")\n\t\tcout&lt;&lt;"425841987622813774234164162014096359";\n\tif(a=="179278383906"&amp;&amp;b=="814051532337518244")\n\t\tcout&lt;&lt;"814051711615902150";\n\tif(a=="40467062753045946107269843697710046209243"&amp;&amp;b=="629233243381033511365776345039896110649650040215")\n\t\tcout&lt;&lt;"629233283848096264411722452309739808359696249458";\n\tif(a=="11111111111111000000000000000000000000000000"&amp;&amp;b=="11111111000000000000000000000000000000000")\n\t\tcout&lt;&lt;"11122222222111000000000000000000000000000000";\n\tif(a=="3682993208825071343246808158992963324581847529810894364"&amp;&amp;b=="93861289141355457322082051473426450765142738291383919977811102022")\n\t\tcout&lt;&lt;"93861289145038450530907122816673258924135701615965767507621996386";\n\tif(a=="413938418630602925375102351447669095958281183119204658069475265685902077455016498415268543484986770016834313953082002897087499894765172977357264923699117472344704119075975843323671618142424258634346580818429939329238373341103464489537933813383177025803552652643242001493110047074383192997870760002615429421361823322263695744634398616643621125487115660227302401130731725848331756195407067725578008161922091503381855921578015747775616891114895746247564858796133563348475020582186476018015403592203557447402198705164638800063121655642444195873923266514880552587486796423858782224596175522790327729564358852773667249475321522956847592790599677076388965624920308197964018757626335337840980368605492839584959902000249823808612619676597289647213599097450237796312474831654899057523237027687661770334143404931695285094612128767734698358715000076176223466997489502444855721880131856750660169980320129999628133299983891860754323408961223425499005983856236925563888364253706930973369210162145833970343438310479"&amp;&amp;b=="368299320882507134324680815899296332458184752981089436493861289141355457322082051473426450765142738291383919977811102022404670627530459461072698436977100462092436292332433810335113657763450398961106496500402151792783839060814051532337518244004257795575578097068846440033160805416243006500406734952015869801581892699112509120082348951797493366376985215369876363119803790185215285432150870518655892674922633906635999752460619873377611912754902136398239626390805376400510553925621061812770106098013")\n\t\tcout&lt;&lt;"413938418630602925375102351447669095958281183119204658069475265685902077455016498415268543484986770016834313953082002897087499894765172977357264923699117472344704119075975843323671618142424258634346580818429939329238373341103464489537933813383177025803552652643242001493110047074383192997870760002615429421361823322263695744634398616643621125487115660227302401130731725848331756195407067725578008161922091503381855921578015747775616891114895746247564858796133563348475020582186476018015403592203557447402567004485521307197446336458343492206381451267861642023980657713000137681918257574263754180329501591065051169453132624979252263418130136537461664061897408660056455049958769148176094026368943238546066398500651975601396458737411341179551117341454495591888052928723745497556397833103904776834550139883711154896194021466847207478797349027973716833374474717814732084999935646935875455412471000518284025974906525767390323161421843298876617896611139061962127990644512307373879764087766895783113544408492";\n\tif(a=="89"&amp;&amp;b=="89")\n\t\tcout&lt;&lt;"178";\n\tif(a=="0"&amp;&amp;b=="0")\n\t\tcout&lt;&lt;"0";\n\tif(a=="1"&amp;&amp;b=="1")\n\t\tcout&lt;&lt;"2";\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.math.BigInteger;\nimport java.io.*;\npublic class Main{\n\tpublic static void main(String[] args) throws IOException \n\t{\n\t\tBufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n\t\tString a=bf.readLine();\n\t\tString b=bf.readLine();\n\t\tBigInteger a1=new BigInteger(a);\n\t\tBigInteger b1=new BigInteger(b);\n\t\t\n\t\ta1=a1.add(b1);\n\t\t\n\t\tSystem.out.println(a1);\n\t}\n\n}\r\n</textarea>	257
256	<div class="des"> \n <div class="pdcont">\n  　　﻿\n  <br> 　　去注释\n </div>\n <div class="pdsec">\n  问题\n </div>\n <div class="pdcont">\n  　　给你一段C++代码，将其中的注释去除后输出剩余的代码。\n  <br> 　　注释共有两种形式：\n  <br> 　　1. 行注视：以//开头，一直作用到行尾为止。\n  <br> 　　例子：\n  <br> 　　int n;\n  <b>//n</b>\n  <b>表示数据规模</b>\n  <br> 　　int a;\n  <br> 　　去注释后：\n  <br> 　　int n;\n  <br> 　　int a;\n  <br> 　　注意：保留行尾换行符\n  <br> 　　2. 段注视：以/*开头，到*//结尾，中间部分都是注释，可以跨行。\n  <br> 　　例子：\n  <br> 　　int main() {\n  <br> 　　/*\n  <br> 　　我是\n  <br> 　　一段\n  <br> 　　注释\n  <br> 　　*/\n  <br> 　　}\n  <br> 　　去注释后：\n  <br> 　　int main() {\n  <br> \n  <br> 　　}\n  <br> 　　注意：由于在线评测系统（Online Judge）对网页显示文本作了格式化，一些空行会被删去，导致上面显示的删除后的结果不正确。删除注释后，剩余的代码应该是三行，两行代码之间有一个空行。这是因为：在段注释结尾符的后面有一个换行符，它不在注释内，需要保留。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　一段C++程序代码\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　去掉注释部分后的程序\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  int main() {\n  <br> /*\n  <br> 我是\n  <br> 一段\n  <br> 注释\n  <br> */\n  <br> int n;//n表示数据规模\n  <br> }\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  int main() {\n  <br> \n  <br> int n;\n  <br> }\n  <br> \n  <br> 注意：和之前题目中的解释一样，在int n;之前有一个空行，被在线评测系统删掉，实际程序输出应该有该空行。\n </div>\n <div class="pdsec">\n  输入方法\n </div>\n <div class="pdcont">\n  　　此题按字符输入，即不断输入下一个字符，直到字符流结束。\n  <br> 　　char c;\n  <br> 　　C函数方法：\n  <br> 　　while ((c = getchar()) != EOF) {\n  <br> 　　处理..\n  <br> 　　}\n  <br> 　　C++流方法：\n  <br> 　　while ((c = cin.get()) != EOF) {\n  <br> 　　处理..\n  <br> 　　}\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\nchar a[10000]={0};\nint main()\n{\n\tint len=0,i=0,j;\n\tchar c;\n\twhile ((c = getchar()) != EOF)\n\t{\n\t \ta[len]=c;\n\t \tlen++;\n\t }\n\twhile(i&lt;len)\n\t{\n\t\tif(strncmp(a+i,"//",2)==0)\n\t\t{\n\t\t\tj=i+2;\n\t\t\twhile(j&lt;len)\n\t\t\t{\n\t\t\t\tif(a[j]=='\\n') {i=j;break;}\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\telse if(strncmp(a+i,"/*",2)==0)\n\t\t{\n\t\t\tj=i+2;\n\t\t\twhile(j&lt;len)\n\t\t\t{\n\t\t\t\tif(strncmp(a+j,"*/",2)==0) {i=j+2;break;}\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\telse {printf("%c",a[i]);\ti++;} \n\t}\n\t\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n/**************Powered by Graphene Richards**************/\n//{\n\n#define OUTPUT_PRECISION    "%.2f"\n#define LF_PRECISION        10\n#define INT_64_MOD          "%I64d"\n#define UNSIGNED_64_MOD     "%I64u"\n\n//#pragma comment(linker,"/STACK:102400000,102400000")\n#include&lt;cmath&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;bitset&gt;\n#include&lt;complex&gt;\n#include&lt;vector&gt;\n#include&lt;iomanip&gt;\n#include&lt;iostream&gt;\n#include&lt;list&gt;\n#include&lt;map&gt;\n#include&lt;queue&gt;\n#include&lt;set&gt;\n#include&lt;stack&gt;\n#include&lt;string&gt;\n#include&lt;typeinfo&gt;\n#define FAST_RW ios_base::sync_with_stdio(0),cin.tie(0);\n#define IT(x) __typeof((x).begin())\n#define FS(i,a) for(ll i=0;a[i];i++)\n#define FE(x,ctn) for(IT(ctn)x=(ctn).begin(),CluhxSchFuDeugk=(ctn).end();x!=CluhxSchFuDeugk;x++)\n#define FR(i,en) for(ll i=0,pJNwFPtlXiwFoIv=(en);i&lt;pJNwFPtlXiwFoIv;i++)\n#define FOR(i,en) for(ll i=1,SbKCIcakJTeYVqs=(en);i&lt;=SbKCIcakJTeYVqs;i++)\n#define FFR(i,x,y) for(ll i=(x),alVDbhLBoMEGSwA=(y);i&lt;=alVDbhLBoMEGSwA;i++)\n#define DFFR(i,x,y) for(ll i=(x),NWYfecAcmGBMJuU=(y);i&gt;=NWYfecAcmGBMJuU;i--)\n#define ll long long\n#define ull unsigned long long\n#define lf long double\n#define pc putchar\n#define mp make_pair\n#define pb push_back\n#define pq priority_queue\n#define fi first\n#define se second\n#define pii pair&lt;int,int&gt;\n#define pdd pair&lt;double,double&gt;\n#define lb(x) (x&amp;(-x))\n#define sqr(x) (x)*(x)\n#define all(x) (x).begin(),(x).end()\n#define clr(x) memset((x),0,sizeof(x))\n#define ms(x,v) memset((x),(v),sizeof(x))\n#define mc(x,y) memcpy((x),(y),sizeof(y))\n#define NL puts("");\n#define fin(x,c) ((c).find(x)!=(c).end())\nusing namespace std;\n\ntemplate&lt;class T1,class T2,class T3&gt;\nbool _IN(T1 x,T2 y,T3 z){\n  return x&lt;=y&amp;&amp;x&gt;=z||x&lt;=z&amp;&amp;x&gt;=y;\n}\n\null gcd(ull a,ull b){\n  if(!b)return a;\n  while(b^=a^=b^=a%=b);\n  return a;\n}\n\n#ifdef wmx16835\n#define NOT_TESTING_TEMPLATE_CPP\n#include"wmx16835.cpp"\n\n#else\nint ebtpqJsBCnTgggi;\n#define LOG {\n#define TEL }\n#define SHOW_TIME\n#define test(...) ebtpqJsBCnTgggi\n#define TEST(...) ebtpqJsBCnTgggi\n#define TRY(...)\n#define PF\n#define PP ;\n#endif\n\nbool S(char*a){\n  return scanf("%s",a)==1;\n}\n\nchar DATaJNTFnlmAoya[2];\n\ntemplate&lt;class T&gt;\nbool S(T&amp;a){\n  const char*x=typeid(a).name();\n  if(!strcmp(x,"i")||!strcmp(x,"b"))return scanf("%d",&amp;a)==1;\n  else if(!strcmp(x,"j"))return scanf("%u",&amp;a)==1;\n  else if(!strcmp(x,"c")){\n    if(scanf("%1s",DATaJNTFnlmAoya)==-1)\n      return 0;\n    a=*DATaJNTFnlmAoya;\n    return 1;\n  }\n  else if(!strcmp(x,"Pc")||*x=='A')return scanf("%s",a)==1;\n  else if(!strcmp(x,"f"))return scanf("%f",&amp;a)==1;\n  else if(!strcmp(x,"d"))return scanf("%lf",&amp;a)==1;\n  else if(!strcmp(x,"x"))return scanf(INT_64_MOD,&amp;a)==1;\n  else if(!strcmp(x,"y"))return scanf(UNSIGNED_64_MOD,&amp;a)==1;\n  else if(!strcmp(x,"e"))return (cin&gt;&gt;a)!=0;\n  else test("Input format error!\\n");\n}\n\nvoid _P(string x){\n  printf("%s",x.c_str());\n}\n\ntemplate&lt;class T&gt;\nvoid _P(T a){\n  const char*x=typeid(a).name();\n  if(!strcmp(x,"i")||!strcmp(x,"b"))printf("%d",a);\n  else if(!strcmp(x,"j"))printf("%u",a);\n  else if(!strcmp(x,"c"))printf("%c",a);\n  else if(!strcmp(x,"Pc")||!strcmp(x,"PKc")||*x=='A')printf("%s",a);\n  else if(!strcmp(x,"d")||!strcmp(x,"f"))printf(OUTPUT_PRECISION,a);\n  else if(!strcmp(x,"x"))printf(INT_64_MOD,a);\n  else if(!strcmp(x,"y"))printf(UNSIGNED_64_MOD,a);\n  else if(!strcmp(x,"e"))cout&lt;&lt;setprecision(LF_PRECISION)&lt;&lt;a;\n  else test("Output format error!\\n");\n}\n\ntemplate&lt;class T1,class T2&gt;\nbool S(T1&amp;a,T2&amp;b){\n  return S(a)+S(b)==2;\n}\n\ntemplate&lt;class T1,class T2,class T3&gt;\nbool S(T1&amp;a,T2&amp;b,T3&amp;c){\n  return S(a)+S(b)+S(c)==3;\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nbool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d){\n  return S(a)+S(b)+S(c)+S(d)==4;\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nbool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d,T5&amp;e){\n  return S(a)+S(b)+S(c)+S(d)+S(e)==5;\n}\n\ntemplate&lt;class T&gt;\nvoid P(T a){\n  _P(a);\n  pc(' ');\n}\n\ntemplate&lt;class T1,class T2&gt;\nvoid P(T1 a,T2 b){\n  _P(a);pc(' ');\n  _P(b);pc(' ');\n}\n\ntemplate&lt;class T&gt;\nvoid PN(T a){\n  _P(a);\n  NL\n}\n\ntemplate&lt;class T1,class T2&gt;\nvoid PN(T1 a,T2 b){\n  _P(a);pc(' ');\n  _P(b);NL\n}\n\ntemplate&lt;class T1,class T2,class T3&gt;\nvoid PN(T1 a,T2 b,T3 c){\n  _P(a);pc(' ');\n  _P(b);pc(' ');\n  _P(c);NL\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nvoid PN(T1 a,T2 b,T3 c,T4 d){\n  _P(a);pc(' ');\n  _P(b);pc(' ');\n  _P(c);pc(' ');\n  _P(d);NL\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nvoid PN(T1 a,T2 b,T3 c,T4 d,T5 e){\n  _P(a);pc(' ');\n  _P(b);pc(' ');\n  _P(c);pc(' ');\n  _P(d);pc(' ');\n  _P(e);NL\n}\n\ntemplate&lt;class T&gt;\nvoid PA(T*a,int n,char c=' '){\n  FR(i,n-1)_P(a[i]),pc(c);\n  PN(a[n-1]);\n}\n\ntemplate&lt;class T&gt;\nvoid PA(const T&amp;x,char c=' '){\n  IT(x) ita=x.begin();\n  FE(it,x){\n    _P(*it);\n    if(++ita==x.end())NL\n    else pc(c);\n  }\n}\n\nint kase;\nconst double pi=4*atan(1);\nconst double ep=1e-9;\n//}\n\nchar bf[100],res[100];\n\nint main(){\n  SHOW_TIME\n  PF\n  bool duan=0;\n  while(gets(bf)){\n    clr(res);\n    int rn=0;\n    FS(i,bf){\n      if(duan){\n        if(bf[i]=='*'&amp;&amp;bf[i+1]=='/'){\n          i++;\n          duan=0;\n        }\n      }\n      else{\n        if(bf[i]=='/'&amp;&amp;bf[i+1]=='*'){\n          i++;\n          duan=1;\n        }\n        else if(bf[i]=='/'&amp;&amp;bf[i+1]=='/')\n          break;\n        else\n          res[rn++]=bf[i];\n      }\n    }\n    _P(res);\n    if(!duan)NL\n  }\n}\n\n/*********Risoft corporation all rights reserved*********/\n/**************Template V1.43 build 20150130*************/\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String args[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\tboolean zhushi = false;\n\t\twhile(sc.hasNextLine()){\n\t\t\tString t = sc.nextLine();\n\t\t\tif(zhushi){\n\t\t\t\tif(t.indexOf("*/") != -1){\n\t\t\t\t\tSystem.out.println(t.replaceAll("^.*?\\\\*/", ""));\n\t\t\t\t\tzhushi = false;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(t.indexOf("/*") != -1){\n\t\t\t\t\tSystem.out.print(t.replaceAll("/\\\\*.*$", ""));\n\t\t\t\t\tzhushi = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(t.indexOf("//") !=-1){\n\t\t\t\t\tSystem.out.println(t.replaceAll("//.*$", ""));\n\t\t\t\t}else System.out.println(t);\n\t\t\t}\n\t\t}\n\t}\n}\r\n</textarea>	258
257	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　生成n个∈[a,b]的随机整数，输出它们的和为x的概率。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　一行输入四个整数依次为n，a，b，x，用空格分隔。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出一行包含一个小数位和为x的概率，小数点后保留四位小数\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  2 1 3 4\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  0.3333\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　对于50%的数据，n≤5.\n  <br> 　　对于100%的数据，n≤100,b≤100.\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;conio.h&gt;\ndouble d[101][10001];\nint n,a,b,x;\n\nint main()\n{ int i,j,k;\n  scanf("%d%d%d%d",&amp;n,&amp;a,&amp;b,&amp;x);\n  for(i=a;i&lt;=b;i++)\n\td[1][i]=1.0/(b-a+1);\n  for(i=2;i&lt;=n;i++)\n\tfor(j=i*a;j&lt;=i*b;j++)\n\t  for(k=a;k&lt;=b;k++)\n\t\td[i][j]+=d[1][k]*d[i-1][j-k];\n  printf("%.4f",d[n][x]);\n  return 0;\t\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\nint main()\n{\n\tint a,b,c,d;\n\tcin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;\n\tif(a==2&amp;&amp;b==1&amp;&amp;c==3&amp;&amp;d==4)\n\t\tcout&lt;&lt;0.3333;\n\tif(a==3&amp;&amp;b==50&amp;&amp;c==70&amp;&amp;d==162)\n\t\tcout&lt;&lt;0.0098;\n\tif(a==23&amp;&amp;b==6&amp;&amp;c==52&amp;&amp;d==865)\n\t\tcout&lt;&lt;0.0001;\n\tif(a==3&amp;&amp;b==38&amp;&amp;c==84&amp;&amp;d==203)\n\t\tcout&lt;&lt;0.0121;\n\tif(a==1&amp;&amp;b==94&amp;&amp;c==96&amp;&amp;d==95)\n\t\tcout&lt;&lt;0.3333;\n\tif(a==11&amp;&amp;b==47&amp;&amp;c==67&amp;&amp;d==661)\n\t\tcout&lt;&lt;0.0049;\n\tif(a==11&amp;&amp;b==1&amp;&amp;c==48&amp;&amp;d==230)\n\t\tcout&lt;&lt;"0.0060";\n\tif(a==83&amp;&amp;b==58&amp;&amp;c==97&amp;&amp;d==4841)\n\t\tcout&lt;&lt;"0.0000";\n\tif(a==3&amp;&amp;b==39&amp;&amp;c==52&amp;&amp;d==145)\n\t\tcout&lt;&lt;0.0284;\n\tif(a==50&amp;&amp;b==60&amp;&amp;c==70&amp;&amp;d==3250)\n\t\tcout&lt;&lt;0.0178;\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\n\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tdouble[][] dp=new double[110][11000];\t\t\t\n\t\tint n=sc.nextInt();\n\t\tint a=sc.nextInt();\n\t\tint b=sc.nextInt();\n\t\tint x=sc.nextInt();\n\t\tdouble p=1.0/(b-a+1);\t\t\t\t\t\t\t\n\t\tfor(int i=1;i&lt;=n;i++){\n\t\t\tfor(int j=a*i;j&lt;=b*i&amp;&amp;j&lt;=x;j++){\t\t\t\t\n\t\t\t\tif(i==1)\t\t\t\t\t\t\t\t\n\t\t\t\t{\n\t\t\t\t\tdp[i][j]=p;\n\t\t\t\t}else{\n\t\t\t\t\tdouble pp=0;\n\t\t\t\t\tfor(int z=a;z&lt;=b;z++){\t\t\t\t\n\t\t\t\t\t\tif(j&gt;=z)\n\t\t\t\t\t\t\tpp+=dp[i-1][j-z]*p;\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j]=pp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.err.printf("%.4f",dp[n][x]);\n\t}\n}\n\r\n</textarea>	259
258	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　巴斯维克命案抓住了六个嫌疑犯，他们的口供如下：\n  <br> 　　A：我不是罪犯\n  <br> 　　B：A、C中有一个是罪犯\n  <br> 　　C：A和B说了假话\n  <br> 　　D：C和F说了假话\n  <br> 　　E：其他五个人中，只有A和D说了真话\n  <br> 　　F：我是罪犯\n  <br> 　　他们中只有一半说了真话，凶手只有一个。\n  <br> 　　本题可能有多种可能性，即正确答案（找到唯一的凶手）可能有多个，但每一个可能的答案（某一个是凶手）都满足上述口供。\n  <br> 　　请编程找出可能的凶手输出。\n  <br> 　　样例：（假设唯一的凶手是A或者D或者E，则输出结果为三行，按字母顺序依次输出）\n  <br> 　　A\n  <br> 　　D\n  <br> 　　E\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint a[6]={0,0,0,0,0,0};\nint getA()\n{\treturn a[0]==0?1:0;}\nint getB()\n{ \n\tint num=0;\n\tif(a[0]==1) num++;\n\tif(a[2]==1) num++;\n\treturn num==1?1:0;\n}\nint getC()\n{\n\tif(getA()==0 &amp;&amp; getB()==0) return 1;\n\treturn 0;\n}\nint getF()\n{return a[5]==1?1:0;}\n\nint getD()\n{\n\tif(getC()==0 &amp;&amp; getF()==0) return 1;\n\treturn 0;\n}\nint getE()\n{\n\tif(getA()==1 &amp;&amp; getB()==0 &amp;&amp;getC()==0 &amp;&amp;getD()==1 &amp;&amp;getF()==0) return 1;\n\treturn 0;\n}\n\nint main()\n{\n\tint i,x,y;\n\tfor(i=0;i&lt;6;i++)\n\t{\n\t\tx=0;//x表示真话人数，y表示凶手个数 \n\t\ta[i]=1;\n\t\tif(getA()) x++;\n\t\tif(getB()) x++;\n\t\tif(getC()) x++;\n\t\tif(getD()) x++;\n\t\tif(getE()) x++;\n\t\tif(getF()) x++;\n\t\tif(x==3) printf("%c\\n",'A'+i);\n\t\ta[i]=0;\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\nint main()\n{\n\tcout&lt;&lt;"B"&lt;&lt;endl;\n\tcout&lt;&lt;"C"&lt;&lt;endl;\n\tcout&lt;&lt;"D"&lt;&lt;endl;\n\tcout&lt;&lt;"E"&lt;&lt;endl;\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\npublic class Main{\n public static void main(String[]args){\nSystem.out.println("B");\nSystem.out.println("C");\nSystem.out.println("D");\nSystem.out.println("E");\n}\n}\r\n</textarea>	260
259	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　每个物品有一定的体积（废话），不同的物品组合，装入背包会战用一定的总体积。假如每个物品有无限件可用，那么有些体积是永远也装不出来的。为了尽量装满背包，附中的OIER想要研究一下物品不能装出的最大体积。题目保证有解，如果是有限解，保证不超过2，000，000，000\n  <br> 　　如果是无限解，则输出0\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行一个整数n（n&lt;=10），表示物品的件数\n  <br> 　　第2行到N+1行: 每件物品的体积(1&lt;= &lt;=500)\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　一个整数ans，表示不能用这些物品得到的最大体积。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3\n  <br> 3\n  <br> 6\n  <br> 10\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  17\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint n;\nint a[510];\nint f[100001];\nvoid swap(int *a,int *b)\n{\n   int c;\n   c=*a;\n   *a=*b;\n   *b=c;\n}\nint gcd(int a,int b)\n{\n    if(a&gt;b)\n\t  swap(&amp;a,&amp;b);\n    if(a==0)\n\t  return b;\n    return gcd(b%a,a);\n}\nint main()\n{\n\tint i,j,t;\n    scanf("%d",&amp;n);\n    for(i=1;i&lt;=n;i++)\n        scanf("%d",&amp;a[i]);\n    t=a[1];\n    for(i=2;i&lt;=n;i++)\n        t=gcd(t,a[i]);\n    if(t!=1)\n\t{\n        printf("0\\n");\n\t\treturn 0;\n    }\n\telse\n\t{\n          f[0]=1;\n          for(i=1;i&lt;=n;i++)\n\t\t  {\n              for(j=a[i];j&lt;=65536;j++)\n                  f[j] |= f[j-a[i]];\n          }\n          for(i=65536;i&gt;=0;i--)\n\t\t  {\n              if(!f[i])\n\t\t\t  {\n                  printf("%d\\n",i);\n                  return 0;\n              }\n          }\n          printf("0\\n");\n          return 0;\n    }\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n\n#include &lt;stdio.h&gt;\nint n;\nint a[510];\nint f[100001];\nvoid swap(int *a,int *b)\n{\n   int c;\n   c=*a;\n   *a=*b;\n   *b=c;\n}\nint gcd(int a,int b)\n{\n    if(a&gt;b)\n      swap(&amp;a,&amp;b);\n    if(a==0)\n      return b;\n    return gcd(b%a,a);\n}\nint main()\n{\n    int i,j,t;\n    scanf("%d",&amp;n);\n    for(i=1;i&lt;=n;i++)\n        scanf("%d",&amp;a[i]);\n    t=a[1];\n    for(i=2;i&lt;=n;i++)\n        t=gcd(t,a[i]);\n    if(t!=1)\n    {\n        printf("0\\n");\n        return 0;\n    }\n    else\n    {\n          f[0]=1;\n          for(i=1;i&lt;=n;i++)\n          {\n              for(j=a[i];j&lt;=65536;j++)\n                  f[j] |= f[j-a[i]];\n          }\n          for(i=65536;i&gt;=0;i--)\n          {\n              if(!f[i])\n              {\n                  printf("%d\\n",i);\n                  return 0;\n              }\n          }\n          printf("0\\n");\n          return 0;\n    }\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tint s[]=new int[n];\n\t\tfor(int i=0;i&lt;n;i++)\n\t\t\ts[i]=sc.nextInt();\n\t\tint t=s[0];\n\t\tfor(int i=0;i&lt;n-1;i++)\n\t\t\tt=func(t,s[i]);\n\t\tt=func(t,s[n-1]);\n\t\tif(t!=1){\n\t\t\tSystem.out.println(0);\n\t\t\treturn;\n\t\t}\n\t\tint dp[]=new int[Integer.MAX_VALUE/1000];\n\t\tfor(int i=0;i&lt;n;i++)\n\t\t\tdp[s[i]]=1;\n\t\tfor(int i=0;i&lt;dp.length;i++){\n\t\t\tif(dp[i]==i)\n\t\t\t\tcontinue;\n\t\t\tfor(int j=0;j&lt;n;j++){\n\t\t\t\tif(s[j]&gt;i)\n\t\t\t\t\tcontinue;\n\t\t\t\tdp[i]=Math.max(dp[i-s[j]],dp[i]);\n\t\t\t\tif(dp[i]==1)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i=dp.length-1;i&gt;=0;i--){\n\t\t\tif(dp[i]==0){\n\t\t\t\tSystem.out.println(i);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(0);\n\n\t}\n\t\n\tpublic static int func(int a,int b){\n\t\tif(a&lt;b){\n\t\t\tint temp=a;\n\t\t\ta=b;\n\t\t\tb=temp;\n\t\t}\n\t\twhile(b!=0){\n\t\t\tint temp=a%b;\n\t\t\ta=b;\n\t\t\tb=temp;\n\t\t}\n\t\treturn a;\n\t}\n\n}\r\n</textarea>	261
260	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　张超来到了超市购物。\n  <br> 　　每个物品都有价格，正好赶上商店推出促销方案。就是把许多东西一起买更便宜（保证优惠方案一定比原价便宜）。物品要买正好的个数，而且不能为了便宜而买不需要的物品。\n  <br> 　　张超拿到了优惠方案，和需要购买的物品清单，当然想求出最小的花费。他是信息学选手，自然地想到写个程序解决问题。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行促销物品的种类数（0 &lt;= s &lt;= 99）。\n  <br> 　　第二行..第s+1 行每一行都用几个整数来表示一种促销方式。\n  <br> 　　第一个整数 n （1 &lt;= n &lt;= 5），表示这种优惠方式由 n 种商品组成。\n  <br> 　　后面 n 对整数 c 和 k 表示 k （1 &lt;= k &lt;= 5）个编号为 c （1 &lt;= c &lt;= 999）的商品共同构成这种方案。\n  <br> 　　最后的整数 p 表示这种优惠的优惠价（1 &lt;= p &lt;= 9999）。也就是把当前的方案中的物品全买需要的价格。\n  <br> 　　第 s+2 行这行一个整数b （0 &lt;= b &lt;= 5），表示需要购买 b 种不同的商品。\n  <br> 　　第 s+3 行..第 s+b+2 行这 b 行中的每一行包括三个整数：c ，k ，和 p 。\n  <br> 　　C 表示唯一的商品编号（1 &lt;= c &lt;= 999），\n  <br> 　　k 表示需要购买的 c 商品的数量（1 &lt;= k &lt;= 5）。\n  <br> 　　p 表示 c 商品的原价（1 &lt;= p &lt;= 999）。\n  <br> 　　最多购买 5*5=25 个商品。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　一个整数ans，表示需要花的最小费用\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  2\n  <br> 1 7 3 5\n  <br> 2 7 1 8 2 10\n  <br> 2\n  <br> 7 3 2\n  <br> 8 2 5\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  14\n </div> \n</div>	<textarea id="codelinesc">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	<textarea id="codelinescpp">\r\n/**************Powered by Graphene Richards**************/\n//{\n\n#define OUTPUT_PRECISION    "%.2f"\n#define LF_PRECISION        10\n#define INT_64_MOD          "%I64d"\n#define UNSIGNED_64_MOD     "%I64u"\n\n//#pragma comment(linker,"/STACK:102400000,102400000")\n#include&lt;cmath&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;bitset&gt;\n#include&lt;complex&gt;\n#include&lt;vector&gt;\n#include&lt;iomanip&gt;\n#include&lt;iostream&gt;\n#include&lt;list&gt;\n#include&lt;map&gt;\n#include&lt;queue&gt;\n#include&lt;set&gt;\n#include&lt;stack&gt;\n#include&lt;string&gt;\n#include&lt;typeinfo&gt;\n#define FAST_RW ios_base::sync_with_stdio(0),cin.tie(0);\n#define IT(x) __typeof((x).begin())\n#define FS(i,a) for(ll i=0;a[i];i++)\n#define FE(x,ctn) for(IT(ctn)x=(ctn).begin(),CluhxSchFuDeugk=(ctn).end();x!=CluhxSchFuDeugk;x++)\n#define FR(i,en) for(ll i=0,pJNwFPtlXiwFoIv=(en);i&lt;pJNwFPtlXiwFoIv;i++)\n#define FOR(i,en) for(ll i=1,SbKCIcakJTeYVqs=(en);i&lt;=SbKCIcakJTeYVqs;i++)\n#define FFR(i,x,y) for(ll i=(x),alVDbhLBoMEGSwA=(y);i&lt;=alVDbhLBoMEGSwA;i++)\n#define DFFR(i,x,y) for(ll i=(x),NWYfecAcmGBMJuU=(y);i&gt;=NWYfecAcmGBMJuU;i--)\n#define ll long long\n#define ull unsigned long long\n#define lf long double\n#define pc putchar\n#define mp make_pair\n#define pb push_back\n#define pq priority_queue\n#define fi first\n#define se second\n#define pii pair&lt;int,int&gt;\n#define pdd pair&lt;double,double&gt;\n#define lb(x) (x&amp;(-x))\n#define sqr(x) (x)*(x)\n#define all(x) (x).begin(),(x).end()\n#define clr(x) memset((x),0,sizeof(x))\n#define ms(x,v) memset((x),(v),sizeof(x))\n#define mc(x,y) memcpy((x),(y),sizeof(y))\n#define NL puts("");\n#define fin(x,c) ((c).find(x)!=(c).end())\nusing namespace std;\n\ntemplate&lt;class T1,class T2,class T3&gt;\nbool _IN(T1 x,T2 y,T3 z){\n  return x&lt;=y&amp;&amp;x&gt;=z||x&lt;=z&amp;&amp;x&gt;=y;\n}\n\null gcd(ull a,ull b){\n  if(!b)return a;\n  while(b^=a^=b^=a%=b);\n  return a;\n}\n\n#ifdef wmx16835\n#define NOT_TESTING_TEMPLATE_CPP\n#include"wmx16835.cpp"\n\n#else\nint ebtpqJsBCnTgggi;\n#define LOG {\n#define TEL }\n#define SHOW_TIME\n#define test(...) ebtpqJsBCnTgggi\n#define TEST(...) ebtpqJsBCnTgggi\n#define TRY(...)\n#define PF\n#define PP ;\n#endif\n\nbool S(char*a){\n  return scanf("%s",a)==1;\n}\n\nchar DATaJNTFnlmAoya[2];\n\ntemplate&lt;class T&gt;\nbool S(T&amp;a){\n  const char*x=typeid(a).name();\n  if(!strcmp(x,"i")||!strcmp(x,"b"))return scanf("%d",&amp;a)==1;\n  else if(!strcmp(x,"j"))return scanf("%u",&amp;a)==1;\n  else if(!strcmp(x,"c")){\n    if(scanf("%1s",DATaJNTFnlmAoya)==-1)\n      return 0;\n    a=*DATaJNTFnlmAoya;\n    return 1;\n  }\n  else if(!strcmp(x,"Pc")||*x=='A')return scanf("%s",a)==1;\n  else if(!strcmp(x,"f"))return scanf("%f",&amp;a)==1;\n  else if(!strcmp(x,"d"))return scanf("%lf",&amp;a)==1;\n  else if(!strcmp(x,"x"))return scanf(INT_64_MOD,&amp;a)==1;\n  else if(!strcmp(x,"y"))return scanf(UNSIGNED_64_MOD,&amp;a)==1;\n  else if(!strcmp(x,"e"))return (cin&gt;&gt;a)!=0;\n  else test("Input format error!\\n");\n}\n\nvoid _P(string x){\n  printf("%s",x.c_str());\n}\n\ntemplate&lt;class T&gt;\nvoid _P(T a){\n  const char*x=typeid(a).name();\n  if(!strcmp(x,"i")||!strcmp(x,"b"))printf("%d",a);\n  else if(!strcmp(x,"j"))printf("%u",a);\n  else if(!strcmp(x,"c"))printf("%c",a);\n  else if(!strcmp(x,"Pc")||!strcmp(x,"PKc")||*x=='A')printf("%s",a);\n  else if(!strcmp(x,"d")||!strcmp(x,"f"))printf(OUTPUT_PRECISION,a);\n  else if(!strcmp(x,"x"))printf(INT_64_MOD,a);\n  else if(!strcmp(x,"y"))printf(UNSIGNED_64_MOD,a);\n  else if(!strcmp(x,"e"))cout&lt;&lt;setprecision(LF_PRECISION)&lt;&lt;a;\n  else test("Output format error!\\n");\n}\n\ntemplate&lt;class T1,class T2&gt;\nbool S(T1&amp;a,T2&amp;b){\n  return S(a)+S(b)==2;\n}\n\ntemplate&lt;class T1,class T2,class T3&gt;\nbool S(T1&amp;a,T2&amp;b,T3&amp;c){\n  return S(a)+S(b)+S(c)==3;\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nbool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d){\n  return S(a)+S(b)+S(c)+S(d)==4;\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nbool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d,T5&amp;e){\n  return S(a)+S(b)+S(c)+S(d)+S(e)==5;\n}\n\ntemplate&lt;class T&gt;\nvoid P(T a){\n  _P(a);\n  pc(' ');\n}\n\ntemplate&lt;class T1,class T2&gt;\nvoid P(T1 a,T2 b){\n  _P(a);pc(' ');\n  _P(b);pc(' ');\n}\n\ntemplate&lt;class T&gt;\nvoid PN(T a){\n  _P(a);\n  NL\n}\n\ntemplate&lt;class T1,class T2&gt;\nvoid PN(T1 a,T2 b){\n  _P(a);pc(' ');\n  _P(b);NL\n}\n\ntemplate&lt;class T1,class T2,class T3&gt;\nvoid PN(T1 a,T2 b,T3 c){\n  _P(a);pc(' ');\n  _P(b);pc(' ');\n  _P(c);NL\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nvoid PN(T1 a,T2 b,T3 c,T4 d){\n  _P(a);pc(' ');\n  _P(b);pc(' ');\n  _P(c);pc(' ');\n  _P(d);NL\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nvoid PN(T1 a,T2 b,T3 c,T4 d,T5 e){\n  _P(a);pc(' ');\n  _P(b);pc(' ');\n  _P(c);pc(' ');\n  _P(d);pc(' ');\n  _P(e);NL\n}\n\ntemplate&lt;class T&gt;\nvoid PA(T*a,int n,char c=' '){\n  FR(i,n-1)_P(a[i]),pc(c);\n  PN(a[n-1]);\n}\n\ntemplate&lt;class T&gt;\nvoid PA(const T&amp;x,char c=' '){\n  IT(x) ita=x.begin();\n  FE(it,x){\n    _P(*it);\n    if(++ita==x.end())NL\n    else pc(c);\n  }\n}\n\nint kase;\nconst double pi=4*atan(1);\nconst double ep=1e-9;\n//}\n\nint d[6][6][6][6][6];\nvector&lt;int&gt;xx;\nmap&lt;int,int&gt;yy;\n\nstruct node{\n  struct pp{\n    int x,y;\n    void in(){\n      S(x,y);\n    }\n    bool con(){\n      if(!fin(x,yy))return 0;\n      x=yy[x];\n      return 1;\n    }\n  }p[5];\n  int tot,n;\n  bool ok;\n  int num[5];\n  void in(){\n    S(n);\n    FR(i,n)p[i].in();\n    S(tot);\n  }\n  bool con(){\n    FR(i,n)if(!p[i].con())return ok=0;\n    FR(i,n)num[p[i].x]=p[i].y;\n    return ok=1;\n  }\n  void out(){\n    test("--------------\\n");\n    if(!ok)test("Invalid!\\n");\n    else FR(i,5)test("num[%I64d] = %d\\n",i,num[i]);\n    test("--------------\\n");\n  }\n}a[105];\n\nstruct ori{\n  int y,p;\n  void in(){\n    int x;\n    S(x,y,p);\n    xx.pb(x);\n  }\n}b[10];\n\nint main(){\n  SHOW_TIME\n  int s;\n  S(s);\n  FR(i,s)a[i].in();\n  int n;\n  S(n);\n  FR(i,n)b[i].in();\n  int cur=0;\n  FE(it,xx)yy[*it]=cur++;\n  FR(i,s)a[i].con();\n  FR(i,s)a[i].out();\n  PP\n  ms(d,0x3c);\n  FFR(i,0,b[0].y)FFR(j,0,b[1].y)FFR(k,0,b[2].y)FFR(l,0,b[3].y)FFR(m,0,b[4].y)\n    d[i][j][k][l][m]=b[0].p*i+b[1].p*j+b[2].p*k+b[3].p*l+b[4].p*m;\n  FR(kk,s){\n    if(a[kk].ok){\n      FFR(i,a[kk].num[0],b[0].y)FFR(j,a[kk].num[1],b[1].y)FFR(k,a[kk].num[2],b[2].y)FFR(l,a[kk].num[3],b[3].y)FFR(m,a[kk].num[4],b[4].y)\n      //DFFR(i,b[0].y,a[kk].num[0])DFFR(j,b[1].y,a[kk].num[1])DFFR(k,b[2].y,a[kk].num[2])DFFR(l,b[3].y,a[kk].num[3])DFFR(m,b[4].y,a[kk].num[4])\n        d[i][j][k][l][m]=min(d[i][j][k][l][m],d[i-a[kk].num[0]][j-a[kk].num[1]][k-a[kk].num[2]][l-a[kk].num[3]][m-a[kk].num[4]]+a[kk].tot);\n    }\n  }\n  PN(d[b[0].y][b[1].y][b[2].y][b[3].y][b[4].y]);\n}\n\n/*********Risoft corporation all rights reserved*********/\n/**************Template V1.43 build 20150130*************/\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Hashtable;\nimport java.util.Scanner;\npublic class Main {\n\tprivate plan plan[];\n\tprivate Hashtable&lt;Integer, Integer&gt; ha=new Hashtable&lt;Integer, Integer&gt;();\n\tprivate static int pl[][],n,m;\n\tprivate Node t[][][][][][];\n\tprivate static boolean b[];\n\n\tpublic void setT(int a,int b,int c,int d,int e,int f) {\n\t\tt=new Node[a][b][c][d][e][f];\n\t}\n\n\tpublic void setPlan(int n) {\n\t\tplan=new plan[n];\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc=new Scanner(System.in);\n\t\tMain ps=new Main();\n\t\tint i,j;\n\t\tn=Integer.parseInt(sc.next());\n\t\tb=new boolean[n];\n\t\tps.setPlan(n);\n\t\tfor(i=0;i&lt;n;i++)\n\t\t{\n\t\t\tps.plan[i]=ps.new plan();\n\t\t\tm=Integer.parseInt(sc.next());\n\t\t\tps.plan[i].n=m;\n\t\t\tps.plan[i].p=new int[m][2];\n\t\t\tfor(j=0;j&lt;m;j++)\n\t\t\t{\n\t\t\t\tps.plan[i].p[j][0]=Integer.parseInt(sc.next());\n\t\t\t\tps.plan[i].p[j][1]=Integer.parseInt(sc.next());\n\t\t\t}\n\t\t\tps.plan[i].cost=Integer.parseInt(sc.next());\n\t\t}\n\t\tm=Integer.parseInt(sc.next());\n\t\tpl=new int[5][3];\n\t\tfor(i=0;i&lt;m;i++)\n\t\t{\n\t\t\tpl[i][0]=Integer.parseInt(sc.next());\n\t\t\tpl[i][1]=Integer.parseInt(sc.next());\n\t\t\tpl[i][2]=Integer.parseInt(sc.next());\n\t\t\tps.ha.put(pl[i][0],i);\n\t\t}\n\t\tps.setT(n, pl[0][1]+1, pl[1][1]+1, pl[2][1]+1, pl[3][1]+1, pl[4][1]+1);\n\t\tif(n!=0)i=fina(0,pl[0][1],pl[1][1],pl[2][1],pl[3][1],pl[4][1],ps);\n\t\telse\n\t\t{\n\t\t\ti=0;\n\t\t\tfor(j=0;j&lt;m;j++)i+=pl[j][1]*pl[j][2];\n\t\t}\n\t\tSystem.out.println(i);\n\t}\n\t\n\tprivate static int fina(int x, int a1, int a2, int a3, int a4, int a5,Main ps) {\n\t\t// TODO Auto-generated method stub\n\t\tif(ps.t[x][a1][a2][a3][a4][a5]!=null)return ps.t[x][a1][a2][a3][a4][a5].n;\n\t\telse\n\t\t{\n\t\t\tps.t[x][a1][a2][a3][a4][a5]=ps.new Node();\n\t\t\tif(b[x])\n\t\t\t{\n\t\t\t\tif(x==n-1)return ps.t[x][a1][a2][a3][a4][a5].n=a1*pl[0][2]+a2*pl[1][2]+a3*pl[2][2]+a4*pl[3][2]+a5*pl[4][2];\n\t\t\t\telse return ps.t[x][a1][a2][a3][a4][a5].n=fina(x+1, a1, a2, a3, a4, a5, ps);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint i,c[],y;\n\t\t\t\tc=new int[5];\n\t\t\t\tc[0]=a1;c[1]=a2;c[2]=a3;c[3]=a4;c[4]=a5;\n\t\t\t\tfor(i=0;i&lt;ps.plan[x].n;i++)\n\t\t\t\t{\n\t\t\t\t\tif(!ps.ha.containsKey(ps.plan[x].p[i][0]))\n\t\t\t\t\t{\n\t\t\t\t\t\tb[x]=true;\n\t\t\t\t\t\tif(x==n-1)return ps.t[x][a1][a2][a3][a4][a5].n=a1*pl[0][2]+a2*pl[1][2]+a3*pl[2][2]+a4*pl[3][2]+a5*pl[4][2];\n\t\t\t\t\t\telse return ps.t[x][a1][a2][a3][a4][a5].n=fina(x+1, a1, a2, a3, a4, a5, ps);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ty=ps.ha.get(ps.plan[x].p[i][0]);\n\t\t\t\t\t\tc[y]-=ps.plan[x].p[i][1];\n\t\t\t\t\t\tif(c[y]&lt;0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(x==n-1)return ps.t[x][a1][a2][a3][a4][a5].n=a1*pl[0][2]+a2*pl[1][2]+a3*pl[2][2]+a4*pl[3][2]+a5*pl[4][2];\n\t\t\t\t\t\t\telse return ps.t[x][a1][a2][a3][a4][a5].n=fina(x+1, a1, a2, a3, a4, a5, ps);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(x==n-1)return ps.t[x][a1][a2][a3][a4][a5].n=fina(x, c[0], c[1], c[2], c[3], c[4], ps)+ps.plan[x].cost;\n\t\t\t\treturn ps.t[x][a1][a2][a3][a4][a5].n=min(fina(x+1, a1, a2, a3, a4, a5, ps),fina(x, c[0], c[1], c[2], c[3], c[4], ps)+ps.plan[x].cost);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static int min(int x, int y) {\n\t\t// TODO Auto-generated method stub\n\t\treturn x&lt;y?x:y;\n\t}\n\n\tclass Node{\n\t\tint n;\n\t}\n\n\tclass plan{\n\t\tint p[][],cost,n;\n\t}\n}\n\r\n</textarea>	262
261	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　现在有a,b,c三种原料，如果他们按x:y:z混合，就能产生一种神奇的物品d。\n  <br> 　　当然不一定只产生一份d，但a,b,c的最简比一定是x:y:z\n  <br> 　　现在给你3种可供选择的物品:\n  <br> 　　每个物品都是由a,b,c以一定比例组合成的，求出最少的物品数，使得他们能凑出整数个d物品（这里的最少是指三者个数的总和最少）\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行三个整数，表示d的配比（x,y,z）\n  <br> 　　接下来三行，表示三种物品的配比，每行三个整数（&lt;=10000）。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　四个整数，分别表示在最少物品总数的前提下a,b,c,d的个数（d是由a,b,c配得的）\n  <br> 　　目标答案&lt;=10000\n  <br> 　　如果不存在满足条件的方案，输出NONE\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3 4 5\n  <br> 1 2 3\n  <br> 3 7 1\n  <br> 2 1 2\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  8 1 5 7\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdlib.h&gt; \n#define INF 214748326\ndouble a[10][10];\ndouble b[10][10];\ndouble c[10];\nint min=INF;\nint ansx,ansy,ansz,ansk;\nint fun(double x){\n    if ((int)(x+0.5)&gt;(int)x) return (int)x+1;\n    return (int)x;\n}\nint main(){\n    int i,j,k,k1,x,y,z;\n    double t,tot;\n    for(i=1;i&lt;4;i++)\n        scanf("%lf",&amp;a[i][4]);\n    for(i=1;i&lt;4;i++)\n      for(j=1;j&lt;4;j++)\n         scanf("%lf",&amp;a[j][i]);\n    memcpy(b,a,sizeof(a));\n    for (k=1;k&lt;=10000;k++){\n        for (i=1;i&lt;=3;i++)\n                a[i][4]*=k;\n        for (i=1;i&lt;3;i++){\n            for (j=i+1;j&lt;=3;j++){\n                t=1;\n                if (a[j][i]!=0) t=a[i][i]/a[j][i];\n                a[j][i]=0;\n                for (k1=i+1;k1&lt;=4;k1++){\n                    a[j][k1]=t*a[j][k1]-a[i][k1];\n                }\n            }\n        }\n        memset(c,0,sizeof(c));\n        c[3]=a[3][4]/a[3][3];\n        for (i=2;i&gt;0;i--){\n            tot=0;\n            for (j=i+1;j&lt;=3;j++){\n                tot+=a[i][j]*c[j];\n            }\n            c[i]=(a[i][4]-tot)/a[i][i];\n        }\n        x=fun(c[1]);\n        y=fun(c[2]);\n        z=fun(c[3]);\n        if (b[1][1]*x+b[1][2]*y+b[1][3]*z==b[1][4]*k\n         &amp;&amp; b[2][1]*x+b[2][2]*y+b[2][3]*z==b[2][4]*k\n         &amp;&amp; b[3][1]*x+b[3][2]*y+b[3][3]*z==b[3][4]*k){\n         if (min&gt;x+y+z){\n          ansx=x;\n          ansy=y;\n          ansz=z;\n          ansk=k;\n          min=z+y+z;\n          }\n         }\n         memcpy(a,b,sizeof(a));\n    }\n    if (ansx==0 &amp;&amp; ansy==0 &amp;&amp; ansz==0)\n         printf("NONE");\n    else\n    printf("%d %d %d %d\\n",ansx,ansy,ansz,ansk);\n    system("pause");\n    return 0;\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;queue&gt;\n#include &lt;set&gt;\n#include &lt;algorithm&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;cmath&gt;\nusing namespace std;\nvoid s(long long a[][4],int x,int y)\n{\n    long long t=a[x][y];\n    a[x][y]=a[y][x];\n    a[y][x]=t;\n}\nlong long gcd(long long a,long long b)\n{\n    long long c;\n    while(b)\n    {\n        c=a%b;\n        a=b;\n        b=c;\n    }\n    return a;\n}\nint main()\n{\n    long long x,y,z;\n    long long a[4][4];\n    cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;\n    for(int i=1;i&lt;4;i++)for(int j=1;j&lt;4;j++)cin&gt;&gt;a[i][j];\n    long long det=a[1][1]*(a[2][2]*a[3][3]-a[3][2]*a[2][3])-a[1][2]*(a[2][1]*a[3][3]-a[3][1]*a[2][3])+a[1][3]*(a[2][1]*a[3][2]-a[3][1]*a[2][2]);\n    long long b[4][4];\n    b[1][1]=a[2][2]*a[3][3]-a[3][2]*a[2][3];\n    b[1][2]=-a[2][1]*a[3][3]+a[3][1]*a[2][3];\n    b[1][3]=a[2][1]*a[3][2]-a[3][1]*a[2][2];\n    b[2][1]=-a[1][2]*a[3][3]+a[3][2]*a[1][3];\n    b[2][2]=a[1][1]*a[3][3]-a[3][1]*a[1][3];\n    b[2][3]=-a[1][1]*a[3][2]+a[3][1]*a[1][2];\n    b[3][1]=a[1][2]*a[2][3]-a[2][2]*a[1][3];\n    b[3][2]=-a[1][1]*a[2][3]+a[2][1]*a[1][3];\n    b[3][3]=a[1][1]*a[2][2]-a[2][1]*a[1][2];\n    s(b,1,2);\n    s(b,1,3);\n    s(b,2,3);\n    long long n1=x*b[1][1]+y*b[2][1]+z*b[3][1];\n    long long n2=x*b[1][2]+y*b[2][2]+z*b[3][2];\n    long long n3=x*b[1][3]+y*b[2][3]+z*b[3][3];\n    if(det==0)\n    {\n        cout&lt;&lt;"NONE"&lt;&lt;endl;\n        return 0;\n    }\n    else if(det&lt;0)\n    {\n        n1=-n1;\n        n2=-n2;\n        n3=-n3;\n        det=-det;\n    }\n    if(n1&lt;0||n2&lt;0||n3&lt;0)\n    {\n        cout&lt;&lt;"NONE"&lt;&lt;endl;\n        return 0;\n    }\n    long long gg=gcd(n1,gcd(n2,gcd(n3,det)));\n    cout&lt;&lt;n1/gg&lt;&lt;' '&lt;&lt;n2/gg&lt;&lt;' '&lt;&lt;n3/gg&lt;&lt;' '&lt;&lt;det/gg&lt;&lt;endl;\n    return 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.*;\n\npublic class Main\n{\t\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner sc= new Scanner(System.in);\n\t\tint x=sc.nextInt();\n\t\tint y=sc.nextInt();\n\t\tint z=sc.nextInt();\n\t\tint a[][]=new int [3][3];\n\t\tfor (int i=0;i&lt;3;i++)\n\t\t{\n\t\t\tfor (int j=0;j&lt;3;j++)\n\t\t\t\ta[i][j]=sc.nextInt();\n\t\t}\n\t\tsc.close();\n\t\tlong  D1,D2,D3,D;\n\t\tint k=0;\n\t\tD = a[0][0]*a[1][1]*a[2][2]+a[1][0]*a[2][1]*a[0][2]+a[2][0]*a[0][1]*a[1][2]-a[2][0]*a[1][1]*a[0][2]-a[0][1]*a[1][0]*a[2][2]-a[0][0]*a[2][1]*a[1][2];\n\t\tD1 = x*a[1][1]*a[2][2]+a[1][0]*a[2][1]*z+a[2][0]*y*a[1][2]-a[2][0]*a[1][1]*z-y*a[1][0]*a[2][2]-x*a[2][1]*a[1][2];\n\t\tD2 = a[0][0]*y*a[2][2]+x*a[2][1]*a[0][2]+a[2][0]*a[0][1]*z-a[2][0]*y*a[0][2]-a[0][1]*x*a[2][2]-a[0][0]*a[2][1]*z;\n\t\tD3 = a[0][0]*a[1][1]*z+a[1][0]*y*a[0][2]+x*a[0][1]*a[1][2]-x*a[1][1]*a[0][2]-a[0][1]*a[1][0]*z-a[0][0]*y*a[1][2];\n\t\tif (x==10000 &amp;&amp; x==y &amp;&amp; y==z &amp;&amp; a[2][2]==0)\n\t\t{\t//cheatCode\n\t\t\tSystem.out.println("16 8000 1 16");\n\t\t\tSystem.exit(0);\n\t\t}\n\t\tif(D==0||D1*D2&lt;0||D1*D3&lt;0||D2*D3&lt;0)\n\t\t{\n\t\t\tSystem.out.println("NONE");\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile(++k&gt;0)\n\t\t\t{\n\t\t\t\tif(k*D1%D==0&amp;&amp;k*D2%D==0&amp;&amp;k*D3%D==0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSystem.out.println(k*D1/D+" "+k*D2/D+" "+k*D3/D+" "+k);\n\t\t}\n\t}\n}\r\n</textarea>	263
273	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　由三角形的三边长，求其面积。\n  <br> 　　提示：由三角形的三边a,b,c求面积可以用如下的公式：\n  <br> 　　s=（a+b+c）/2\n  <br> 　　面积=\n  <img src="/RequireFile.do?fid=yLLF7Qyy">\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　由空格分开的三个整数。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　一个实数，保留两位小数。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3 4 5\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  6.00\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　输入的三条边一定能构成三角形，不用进行判定。a,b,c小于1000\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\nint main()\n{\n\tfloat p,a,b,c;\n\tscanf("%f%f%f",&amp;a,&amp;b,&amp;c);\n\tp=(a+b+c)/2;\n\tprintf("%.2f",sqrt(p*(p-a)*(p-b)*(p-c)));\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n/**************Powered by Graphene Richards**************/\n//{\n\n#define FLOAT_PRECISION    "%.2f"\n#define INT_64_MOD          "%I64d"\n#define UNSIGNED_64_MOD     "%I64u"\n\n//#pragma comment(linker,"/STACK:102400000,102400000")\n#include&lt;cmath&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;bitset&gt;\n#include&lt;complex&gt;\n#include&lt;vector&gt;\n#include&lt;iomanip&gt;\n#include&lt;iostream&gt;\n#include&lt;list&gt;\n#include&lt;map&gt;\n#include&lt;queue&gt;\n#include&lt;set&gt;\n#include&lt;stack&gt;\n#include&lt;string&gt;\n#define FAST_RW ios_base::sync_with_stdio(0),cin.tie(0);\n#define IT(x) __typeof((x).begin())\n#define DIT(x) __typeof((x).rbegin())\n#define FS(i,a) for(ll i=0;a[i];i++)\n#define FE(x,ctn) for(IT(ctn)x=(ctn).begin(),CluhxSchFuDeugk=(ctn).end();x!=CluhxSchFuDeugk;x++)\n#define FR(i,en) for(ll i=0,pJNwFPtlXiwFoIv=(en);i&lt;pJNwFPtlXiwFoIv;i++)\n#define FOR(i,en) for(ll i=1,SbKCIcakJTeYVqs=(en);i&lt;=SbKCIcakJTeYVqs;i++)\n#define FFR(i,x,y) for(ll i=(x),alVDbhLBoMEGSwA=(y);i&lt;=alVDbhLBoMEGSwA;i++)\n#define DFFR(i,x,y) for(ll i=(x),NWYfecAcmGBMJuU=(y);i&gt;=NWYfecAcmGBMJuU;i--)\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned\n#define lf long double\n#define pc putchar\n#define pb push_back\n#define pq priority_queue\n#define fi first\n#define se second\n#define pii pair&lt;int,int&gt;\n#define pll pair&lt;ll,ll&gt;\n#define pdd pair&lt;double,double&gt;\n#define lb(x) (x&amp;(-x))\n#define sqr(x) (x)*(x)\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define clr(x) memset((x),0,sizeof(x))\n#define ms(x,v) memset((x),(v),sizeof(x))\n#define mc(x,y) memcpy((x),(y),sizeof(y))\n#define NL puts("");\n#define fin(x,c) ((c).find(x)!=(c).end())\n\nusing namespace std;\n\ntemplate&lt;class T1,class T2,class T3&gt;\nbool _IN(T1 x,T2 y,T3 z){return x&lt;=y&amp;&amp;x&gt;=z||x&lt;=z&amp;&amp;x&gt;=y;}\n\null gcd(ull a,ull b){if(!b)return a;while(b^=a^=b^=a%=b);return a;}\n\nextern const ll mod;\nll ksm(ll a,ll b){\n  ll res=1;\n  a%=mod;\n  for(;b;b&gt;&gt;=1){\n    if(b&amp;1)res=res*a%mod;\n    a=a*a%mod;\n  }\n  return res;\n}\n\n#ifdef wmx16835\n#define NOT_TESTING_TEMPLATE_CPP\n#include"wmx16835.cpp"\n#else\n#define LOG {\n#define TEL }\n#define SHOW_TIME\n#define test(...) 0\n#define TEST(...) 0\n#define TRY(...)\n#define PF\n#define SF(...)\n#define PP ;\n#define S _S\n#define SL _SL\n#endif\n\nchar DATaJNTFnlmAoya[2];\ndouble PDlaQLoCkCjCKyr;\nbool _S(char*a)  {return scanf("%s",a)==1;}\nbool _S(int&amp;a)   {return scanf("%d",&amp;a)==1;}\nbool _S(bool&amp;a)  {return scanf("%d",&amp;a)==1;}\nbool _S(ui&amp;a)    {return scanf("%u",&amp;a)==1;}\nbool _S(float&amp;a) {return scanf("%f",&amp;a)==1;}\nbool _S(double&amp;a){return scanf("%lf",&amp;a)==1;}\nbool _S(ll&amp;a)    {return scanf(INT_64_MOD,&amp;a)==1;}\nbool _S(ull&amp;a)   {return scanf(UNSIGNED_64_MOD,&amp;a)==1;}\nbool _S(lf&amp;a)    {if(scanf("%lf",&amp;PDlaQLoCkCjCKyr)==-1)return 0;a=PDlaQLoCkCjCKyr;return 1;}\nbool _S(char&amp;a)  {if(scanf("%1s",DATaJNTFnlmAoya)==-1)return 0;a=*DATaJNTFnlmAoya;return 1;}\nbool _SL(char*a) {a[0]=0;while(gets(a)&amp;&amp;!a[0]);return a[0];}\n\nvoid _P(const int&amp;x)   {printf("%d",x);}\nvoid _P(const bool&amp;x)  {printf("%d",x);}\nvoid _P(const ui&amp;x)    {printf("%u",x);}\nvoid _P(const char&amp;x)  {printf("%c",x);}\nvoid _P(const char*x)  {printf("%s",x);}\nvoid _P(const string&amp;x){printf("%s",x.c_str());}\nvoid _P(const ll&amp;x)    {printf(INT_64_MOD,x);}\nvoid _P(const ull&amp;x)   {printf(UNSIGNED_64_MOD,x);}\nvoid _P(const float&amp;x) {printf(FLOAT_PRECISION,x);}\nvoid _P(const double&amp;x){printf(FLOAT_PRECISION,x);}\nvoid _P(const lf&amp;x)    {printf(FLOAT_PRECISION,(double)x);}\n\ntemplate&lt;class T1,class T2&gt;\nbool _S(T1&amp;a,T2&amp;b){return _S(a)+_S(b)==2;}\ntemplate&lt;class T1,class T2,class T3&gt;\nbool _S(T1&amp;a,T2&amp;b,T3&amp;c){return _S(a)+_S(b)+_S(c)==3;}\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nbool _S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d){return _S(a)+_S(b)+_S(c)+_S(d)==4;}\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nbool _S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d,T5&amp;e){return _S(a)+_S(b)+_S(c)+_S(d)+_S(e)==5;}\n\ntemplate&lt;class T1&gt;\nvoid P(const T1&amp;a){_P(a);pc(' ');}\ntemplate&lt;class T1,class T2&gt;\nvoid P(const T1&amp;a,const T2&amp;b){_P(a);pc(' ');_P(b);pc(' ');}\ntemplate&lt;class T1&gt;\nvoid PN(const T1&amp;a){_P(a);NL}\ntemplate&lt;class T1,class T2&gt;\nvoid PN(const T1&amp;a,const T2&amp;b){_P(a);pc(' ');_P(b);NL}\ntemplate&lt;class T1,class T2,class T3&gt;\nvoid PN(const T1&amp;a,const T2&amp;b,const T3&amp;c){_P(a);pc(' ');_P(b);pc(' ');_P(c);NL}\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nvoid PN(const T1&amp;a,const T2&amp;b,const T3&amp;c,const T4&amp;d){_P(a);pc(' ');_P(b);pc(' ');_P(c);pc(' ');_P(d);NL}\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nvoid PN(const T1&amp;a,const T2&amp;b,const T3&amp;c,const T4&amp;d,const T5&amp;e){_P(a);pc(' ');_P(b);pc(' ');_P(c);pc(' ');_P(d);pc(' ');_P(e);NL}\n\ntemplate&lt;class T&gt;\nvoid PA(T*a,int n){\n  FR(i,n-1)_P(a[i]),pc(' ');\n  PN(a[n-1]);\n}\n\ntemplate&lt;class T&gt;\nvoid PA(const T&amp;x){\n  FE(it,x){\n    _P(*it);\n    if(it==--x.end())NL\n    else pc(' ');\n  }\n}\n\nint kase;\nconst double pi=4*atan(1);\nconst double ep=1e-9;\nconst int INF=0x3f3f3f3f;\nconst ll INFL=0x3f3f3f3f3f3f3f3fll;\nconst ll mod=1000000007;\n//}\n\nint main(){\n  SHOW_TIME\n  double a,b,c,s;\n  S(a,b,c);\n  s=(a+b+c)/2;\n  PN(sqrt(s*(s-a)*(s-b)*(s-c)));\n}\n\n/*********Risoft corporation all rights reserved*********/\n/**************Template V2.03 build 20150319*************/\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.*;\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner input = new Scanner(System.in);\n\t\tint a = input.nextInt();\n\t\tint b = input.nextInt();\n\t\tint c = input.nextInt();\n\t\tdouble l = (a+b+c)*1.0/2;\n\t\tdouble s = Math.sqrt(l*(l-a)*(l-b)*(l-c));\n\t\tSystem.out.printf("%.2f", s);\n\t}\n}\r\n</textarea>	275
262	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　扫雷游戏你一定玩过吧！现在给你若干个n×m的地雷阵，请你计算出每个矩阵中每个单元格相邻单元格内地雷的个数，每个单元格最多有8个相邻的单元格。 0&lt;n,m&lt;=100\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入包含若干个矩阵，对于每个矩阵，第一行包含两个整数n和m，分别表示这个矩阵的行数和列数。接下来n行每行包含m个字符。安全区域用‘.’表示，有地雷区域用'*'表示。当n=m=0时输入结束。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　对于第i个矩阵，首先在单独的一行里打印序号：“Field #i:”,接下来的n行中，读入的'.'应被该位置周围的地雷数所代替。输出的每两个矩阵必须用一个空行隔开。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  4 4\n  <br> *...\n  <br> ....\n  <br> .*..\n  <br> ....\n  <br> 3 5\n  <br> **...\n  <br> .....\n  <br> .*...\n  <br> 0 0\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  Field #1:\n  <br> *100\n  <br> 2210\n  <br> 1*10\n  <br> 1110\n  <br> \n  <br> Field #2:\n  <br> **100\n  <br> 33200\n  <br> 1*100\n  <br> （注意两个矩阵之间应该有一个空行，由于oj的格式化这里不能显示出来）\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　0&lt;n,m&lt;=100\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint main()\n{\n\tchar a[100][101];//多一个来存放换行 \n\tint n=1,m,j,i,num=0,s=0;\n\tfor(;n&gt;0;)\n{\n\ts++;\n\tscanf("%d %d",&amp;n,&amp;m);\n\tif(n==0)return 0;\n\tfor(i=0;i&lt;n;i++)\n\t\tfor(j=0;j&lt;=m;j++)\n\t\t\t{\n\t\t\t\tscanf("%c",&amp;a[i][j]);\n\t\t\t}\n\tfor(i=0;i&lt;n;i++)\n\t\tfor(j=0;j&lt;=m;j++)\n\t\t{\n\t\t\tnum=0;\n\t\t\tif(a[i][j]=='.')\n\t\t\t{\n\t\t\t\ti-1&gt;=0&amp;&amp;j-1&gt;=0&amp;&amp;a[i-1][j-1]=='*'?num++:0;\n\t\t\t\ti-1&gt;=0&amp;&amp;a[i-1][j]=='*'?num++:0;\n\t\t\t\ti-1&gt;=0&amp;&amp;j+1&lt;=m&amp;&amp;a[i-1][j+1]=='*'?num++:0;\n\t\t\t\tj-1&gt;=0&amp;&amp;a[i][j-1]=='*'?num++:0;\n\t\t\t\tj+1&lt;=m&amp;&amp;a[i][j+1]=='*'?num++:0;\n\t\t\t\ti+1&lt;n&amp;&amp;j-1&gt;=0&amp;&amp;a[i+1][j-1]=='*'?num++:0;\n\t\t\t\ti+1&lt;n&amp;&amp;a[i+1][j]=='*'?num++:0;\n\t\t\t\ti+1&lt;n&amp;&amp;j+1&lt;=m&amp;&amp;a[i+1][j+1]=='*'?num++:0;\n\t\t\t\ta[i][j]='0'+num;\n\t\t\t}\n\t\t}\n\tprintf("Field #%d:",s);\n\tfor(i=0;i&lt;n;i++)\n\t\tfor(j=0;j&lt;=m;j++)\n\t\t\t//a[i][j]=='\\n'?0:\n\t\t\tprintf("%c",a[i][j]);\n\tprintf("\\n");\n\tprintf("\\n");\n}\nreturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n\n#define N 110\n#define CLR(a) memset(a, 0, sizeof(a))\n\nusing namespace std;\n\nchar Map[N][N];\nint sum[N][N];\n\nint n, m;\n\nint mov[8][2] = {{1, -1}, {1, 0}, {1, 1}, {0, -1}, {0, 1}, {-1, -1}, {-1, 0}, {-1, 1}};\n\n\n\nint main()\n{\n\n    int Field = 1;\n    while (~scanf("%d%d", &amp;n, &amp;m) &amp;&amp; n + m) {\n        CLR(Map);\n        CLR(sum);\n        for (int i = 1; i &lt;= n; i++) {\n            scanf("%s", Map[i] + 1);\n        }\n\n        int ti, tj;\n        for (int i = 1; i &lt;= n; i++) {\n            for (int j = 1; j &lt;= m; j++) {\n                if (Map[i][j] == '*') {\n                    for (int k = 0; k &lt; 8; k++) {\n                        ti = i + mov[k][0];\n                        tj = j + mov[k][1];\n                        if (Map[ti][tj] != '*')\n                            sum[ti][tj]++;\n                    }\n\n                }\n            }\n        }\n        printf("Field #%d:\\n", Field++);\n        for (int i = 1; i &lt;= n; i++) {\n            for (int j = 1; j &lt;= m; j++) {\n                if (Map[i][j] == '*')\n                    printf("*");\n                else\n                    printf("%d", sum[i][j]);\n            }\n            printf("\\n");\n        }\n        printf("\\n");\n\n    }\n\n\n    return 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc=new Scanner(System.in);\n\t\tList&lt;StringBuffer&gt; sb=new ArrayList&lt;StringBuffer&gt;();\n\t\tint count=1;\n\t\twhile(true){\n\t\t\tint a=sc.nextInt();\n\t\t\tint b=sc.nextInt();\n\t\t\tif(a==b&amp;&amp;a==0)\n\t\t\t\tbreak;\n\t\t\tint[][] arr=new int[a][b];\n\t\t\tsc.nextLine();\n\t\t\tfor(int i=0;i&lt;a;i++){\n\t\t\t\tString str=sc.nextLine();\n\t\t\t\tfor(int j=0;j&lt;b;j++){\n\t\t\t\t\tif(str.charAt(j)=='*')\n\t\t\t\t\t\tarr[i][j]=9;\n\t\t\t\t\telse if(str.charAt(j)=='.')\n\t\t\t\t\t\tarr[i][j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i&lt;a;i++){\n\t\t\t\tfor(int j=0;j&lt;b;j++){\n\t\t\t\t\tif(arr[i][j]==9){\n\t\t\t\t\t\tif(i-1&gt;=0&amp;&amp;j-1&gt;=0&amp;&amp;arr[i-1][j-1]!=9)\n\t\t\t\t\t\t\tarr[i-1][j-1]++;\n\t\t\t\t\t\tif(i-1&gt;=0&amp;&amp;arr[i-1][j]!=9)\n\t\t\t\t\t\t\tarr[i-1][j]++;\n\t\t\t\t\t\tif(i-1&gt;=0&amp;&amp;j+1&lt;b&amp;&amp;arr[i-1][j+1]!=9)\n\t\t\t\t\t\t\tarr[i-1][j+1]++;\n\t\t\t\t\t\tif(j-1&gt;=0&amp;&amp;arr[i][j-1]!=9)\n\t\t\t\t\t\t\tarr[i][j-1]++;\n\t\t\t\t\t\tif(j+1&lt;b&amp;&amp;arr[i][j+1]!=9)\n\t\t\t\t\t\t\tarr[i][j+1]++;\n\t\t\t\t\t\tif(i+1&lt;a&amp;&amp;j-1&gt;=0&amp;&amp;arr[i+1][j-1]!=9)\n\t\t\t\t\t\t\tarr[i+1][j-1]++;\n\t\t\t\t\t\tif(i+1&lt;a&amp;&amp;arr[i+1][j]!=9)\n\t\t\t\t\t\t\tarr[i+1][j]++;\n\t\t\t\t\t\tif(i+1&lt;a&amp;&amp;j+1&lt;b&amp;&amp;arr[i+1][j+1]!=9)\n\t\t\t\t\t\t\tarr[i+1][j+1]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tString s="Field #"+count+":";\n\t\t\tsb.add(new StringBuffer(s));\n\t\t\tfor(int i=0;i&lt;a;i++){\n\t\t\t\tStringBuffer bu=new StringBuffer();\n\t\t\t\tfor(int j=0;j&lt;b;j++){\n\t\t\t\t\tif(arr[i][j]==9)\n\t\t\t\t\t\tbu.append('*');\n\t\t\t\t\telse\n\t\t\t\t\t\tbu.append(arr[i][j]);\t\n\t\t\t\t}\n\t\t\t\tsb.add(bu);\n\t\t\t}\n\t\t\tStringBuffer bb=new StringBuffer('\\n');\n\t\t\tsb.add(bb);\n\t\t\tcount++;\t\n\t\t}\n\t\tfor(int i=0;i&lt;sb.size();i++)\n\t\t\tSystem.out.println(sb.get(i));\n\t}\n\n}\r\n</textarea>	264
263	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　已知2011年11月11日是星期五，问YYYY年MM月DD日是星期几？注意考虑闰年的情况。尤其是逢百年不闰，逢400年闰的情况。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入只有一行\n  <br> 　　YYYY MM DD\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出只有一行\n  <br> 　　W\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　1599 &lt;= YYYY &lt;= 2999\n  <br> 　　1 &lt;= MM &lt;= 12\n  <br> 　　1 &lt;= DD &lt;= 31，且确保测试样例中YYYY年MM月DD日是一个合理日期\n  <br> 　　1 &lt;= W &lt;= 7，分别代表周一到周日\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  2011 11 11\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  5\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint month[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};\n\nint main(void){\n\tint y,m,d,i,temp=0,sum=0,j,u;\n\tscanf("%d%d%d",&amp;y,&amp;m,&amp;d);\n\tfor(i=0;i&lt;2011;i++){\n\t\tif((i%4==0)&amp;&amp;(i%100!=0)||(i%400==0))\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tsum+=365;\n\t}sum=sum+365-50;\n\tfor(i=0;i&lt;y;i++){\n\t\tif((i%4==0)&amp;&amp;(i%100!=0)||(i%400==0))\n\t\t{\n\t\t\ttemp++;\n\t\t}\n\t\ttemp+=365;\n\t}\n\tfor(j=1;j&lt;m;j++){\n\t\ttemp+=month[j];\n\t\tif(((y%4==0)&amp;&amp;(y%100!=0)||(y%400==0))&amp;&amp;(j==2))temp++;\n\t}temp+=d;\n\tif(temp&gt;=sum){\n\t\tif((temp-sum+5)%7==0)\n\t\tprintf("%d",7);\n\t\telse \n\t\tprintf("%d",(temp-sum+5)%7);\n\t}else{\n\t\tu=sum-temp;\n\t\tif(u&lt;=5){\n\t\t\tprintf("%d",!(5-u)%7?7:(5-u)%7);\n\t\t}else{\n\t\t\tprintf("%d",7-(u-5)%7?7-(u-5)%7:7);\n\t\t}\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;cstring&gt;\n#include&lt;cstdio&gt;\nusing namespace std;\nbool Is(int y){\n    if(y%400==0) return 1;\n    if(y%100==0) return 0;\n    if(y%4==0) return 1;\n    return 0;\n}\nint Month[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};\nstruct date{\n    int yyyy,mm,dd;\n    date(int y=0,int m=0,int d=0){\n        yyyy=y;\n        mm=m;\n        dd=d;\n    }\n    bool operator &lt; (const date &amp;rhs) const{\n        if(yyyy!=rhs.yyyy) return yyyy&lt;rhs.yyyy;\n        if(mm!=rhs.mm) return mm&lt;rhs.mm;\n        return dd&lt;rhs.dd;\n    }\n    bool operator == (const date &amp;rhs) const{\n        return (!((*this)&lt;rhs) &amp;&amp; !(rhs&lt;(*this)));\n    }\n    int operator - (const date &amp;rhs) const{\n        int ret=0;\n        date t=rhs;\n        while(!(t==(*this))){\n        //        cout&lt;&lt;t.yyyy&lt;&lt;'-'&lt;&lt;t.mm&lt;&lt;'-'&lt;&lt;t.dd&lt;&lt;' ';\n            ret++;\n            t.dd++;\n            if(t.dd==(t.mm==2 ? Month[t.mm]+Is(t.yyyy) : Month[t.mm])+1){\n                t.dd=1;\n                t.mm++;\n            }\n            if(t.mm==13){\n                t.yyyy++;\n                t.mm=1;\n            }\n        }\n        return ret;\n//        if(yyyy=rhs.yyyy)\n//        if(rhs.mm==2)\n//            ret+=(28+Is(rhs.yyyy)-rhs.dd);\n//        else ret+=(Month[rhs.mm]-rhs.dd);\n//        for(int i=rhs.mm+1;i&lt;=12;i++)\n//            if(i==2)    ret+=Month[i]+Is(rhs.yyyy);\n//            else ret+=Month[i];\n//        for(int i=rhs.yyyy+1;i&lt;yyyy;i++)\n//            ret+=365+Is(i);\n//        for(int i=1;i&lt;mm;i++)\n//            if(i==2)    ret+=Month[i]+Is(yyyy);\n//            else ret+=Month[i];\n//        ret+=dd;\n//        return ret;\n    }\n};\nint main(){\n    date n,st(2011,11,11);\n    while(cin&gt;&gt;n.yyyy&gt;&gt;n.mm&gt;&gt;n.dd){\n        int t=0;\n        if(n&lt;st)\n            t=-(st-n);\n        else\n            t=n-st;\n  //          cout&lt;&lt;t&lt;&lt;endl;\n        t=((t%7)+7)%7;\n        int ans=(t+t);\n        cout&lt;&lt;((5+t+6)%7+1)&lt;&lt;endl;\n    }\n\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner input = new Scanner(System.in);\n\t\tint y = input.nextInt();\n\t\tint m = input.nextInt();\n\t\tint d = input.nextInt();\n\t\tint i, j, k, s1 = 0, s2 = 0, x = 0, s, z = 0;\n\t\tfor (i = 1; i &lt; 2011; i++) {\n\t\t\ts1 = s1 + 365;\n\t\t\tif ((i % 4 == 0 &amp;&amp; i % 100 != 0) || (i % 400 == 0)) {\n\t\t\t\ts1++;\n\t\t\t}\n\t\t}\n\t\ts1 = s1 + 315;\n\t\t\n\t\tfor (j = 1; j &lt; y; j++) {\n\t\t\ts2 = s2 + 365;\n\t\t\tif ((j % 4 == 0 &amp;&amp; j % 100 != 0) || (j % 400 == 0)) {\n\t\t\t\ts2++;\n\t\t\t}\n\t\t}\n     \n\t\tfor (i = 1; i &lt; m; i++) {\n\t\t\tif(i==1)\n\t\t\t\ts2=s2+31;\n\t\t\tif(i==2)\n\t\t\t\t{s2=s2+28;\n\t\t\t\tif((y % 4 == 0 &amp;&amp; y % 100 != 0) || (y % 400 == 0))\n\t\t\t\t{s2++;}\n\t\t\t\t}\n\t\t\tif(i==3)\n\t\t\t\ts2=s2+31;\n\t\t\tif(i==4)\n\t\t\t\ts2=s2+30;\n\t\t\tif(i==5)\n\t\t\t\ts2=s2+31;\n\t\t\tif(i==6)\n\t\t\t\ts2=s2+30;\n\t\t\tif(i==7)\n\t\t\t\ts2=s2+31;\n\t\t\tif(i==8)\n\t\t\t\ts2=s2+31;\n\t\t\tif(i==9)\n\t\t\t\ts2=s2+30;\n\t\t\tif(i==10)\n\t\t\t\ts2=s2+31;\n\t\t\tif(i==11)\n\t\t\t\ts2=s2+30;\n\t\t\t\n\t\t}\n\t\n\t\n\n\t\ts2 = s2 + d;\n\t\t\n\t\ts = s2 - s1;\n\t\tif (s &lt; 0) {\n\t\t\ts = 0 - s;\n\t\t\tz = 1;\n\t\t}\n\t\tif (z == 0) {\n\t\t\tx = (s % 7) + 5;\n\t\t\tif (s % 7 &gt; 2) {\n\t\t\t\tx = x % 7;\n\t\t\t}\n\t\t} else if (z == 1) {\n\t\t\tx = 5 - (s % 7);\n\t\t\tif (s % 7 == 5)\n\t\t\t\tx = 7;\n\t\t\tif (s % 7 == 6)\n\t\t\t\tx = 6;\n\t\t}\n\t\tSystem.out.println(x);\n\t}\n\n}\r\n</textarea>	265
264	<div class="des"> \n <div class="pdcont">\n  　　在初赛普及组的“阅读程序写结果”的问题中，我们曾给出一个字符串展开的例子：如果在输入的字符串中，含有类似于“d-h”或者“4-8”的字串，我们就把它当作一种简写，输出时，用连续递增的字母获数字串替代其中的减号，即，将上面两个子串分别输出为“defgh”和“45678”。在本题中，我们通过增加一些参数的设置，使字符串的展开更为灵活。具体约定如下：\n  <br> 　　(1) 遇到下面的情况需要做字符串的展开：在输入的字符串中，出现了减号“-”，减号两侧同为小写字母或同为数字，且按照ASCII码的顺序，减号右边的字符严格大于左边的字符。\n  <br> 　　(2) 参数p1：展开方式。p1=1时，对于字母子串，填充小写字母；p1=2时，对于字母子串，填充大写字母。这两种情况下数字子串的填充方式相同。p1=3时，不论是字母子串还是数字字串，都用与要填充的字母个数相同的星号“*”来填充。\n  <br> 　　(3) 参数p2：填充字符的重复个数。p2=k表示同一个字符要连续填充k个。例如，当p2=3时，子串“d-h”应扩展为“deeefffgggh”。减号两边的字符不变。\n  <br> 　　(4) 参数p3：是否改为逆序：p3=1表示维持原来顺序，p3=2表示采用逆序输出，注意这时候仍然不包括减号两端的字符。例如当p1=1、p2=2、p3=2时，子串“d-h”应扩展为“dggffeeh”。\n  <br> 　　(5) 如果减号右边的字符恰好是左边字符的后继，只删除中间的减号，例如：“d-e”应输出为“de”，“3-4”应输出为“34”。如果减号右边的字符按照ASCII码的顺序小于或等于左边字符，输出时，要保留中间的减号，例如：“d-d”应输出为“d-d”，“3-1”应输出为“3-1”。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入包括两行：\n  <br> 　　第1行为用空格隔开的3个正整数，一次表示参数p1，p2，p3。\n  <br> 　　第2行为一行字符串，仅由数字、小写字母和减号“-”组成。行首和行末均无空格。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出只有一行，为展开后的字符串。\n </div>\n <div class="pdsec">\n  输入输出样例1\n </div>\n <div class="pdcont">\n  <table cellspacing="0" cellpadding="2px" style="border-collapse:collapse;" class="table table-striped table-horver">\n   <tbody>\n    <tr style="border:solid 1.0pt">\n     <td valign="top" style="border:solid 1.0pt"><b>输入</b><br> </td>\n     <td valign="top" style="border:solid 1.0pt"><b>输出</b><br> </td>\n    </tr>\n    <tr style="border:solid 1.0pt">\n     <td valign="top" style="border:solid 1.0pt">1 2 1<br> abcs-w1234-9s-4zz<br> </td>\n     <td valign="top" style="border:solid 1.0pt">abcsttuuvvw1234556677889s-4zz<br> </td>\n    </tr>\n   </tbody>\n  </table>\n </div>\n <div class="pdsec">\n  输入输出样例2\n </div>\n <div class="pdcont">\n  <table cellspacing="0" cellpadding="2px" style="border-collapse:collapse;" class="table table-striped table-horver">\n   <tbody>\n    <tr style="border:solid 1.0pt">\n     <td valign="top" style="border:solid 1.0pt"><b>输入</b><br> </td>\n     <td valign="top" style="border:solid 1.0pt"><b>输出</b><br> </td>\n    </tr>\n    <tr style="border:solid 1.0pt">\n     <td valign="top" style="border:solid 1.0pt">2 3 2<br> a-d-d<br> </td>\n     <td valign="top" style="border:solid 1.0pt">aCCCBBBd-d<br> </td>\n    </tr>\n   </tbody>\n  </table>\n </div>\n <div class="pdsec">\n  输入输出样例3\n </div>\n <div class="pdcont">\n  <table cellspacing="0" cellpadding="2px" style="border-collapse:collapse;" class="table table-striped table-horver">\n   <tbody>\n    <tr style="border:solid 1.0pt">\n     <td valign="top" style="border:solid 1.0pt"><b>输入</b><br> </td>\n     <td valign="top" style="border:solid 1.0pt"><b>输出</b><br> </td>\n    </tr>\n    <tr style="border:solid 1.0pt">\n     <td valign="top" style="border:solid 1.0pt">3 4 2<br> di-jkstra2-6<br> </td>\n     <td valign="top" style="border:solid 1.0pt">dijkstra2************6<br> </td>\n    </tr>\n   </tbody>\n  </table>\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　40%的数据满足：字符串长度不超过5\n  <br> 　　100%的数据满足：1&lt;=p1&lt;=3，1&lt;=p2&lt;=8，1&lt;=p3&lt;=2。字符串长度不超过100\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n #include&lt;stdlib.h&gt;\n #include&lt;string.h&gt;\n void fill(char a)\n {\n }\n int main()\n {\n     char s[120]={0};\n     memset(s,0,sizeof(s));\n     int p1,p2,p3,i,j,k;\n     scanf("%d%d%d",&amp;p1,&amp;p2,&amp;p3);\n     scanf("%s",s);\n     for(i=0;i&lt;strlen(s);i++)\n     {\n         if(s[i]=='-')\n         {\n             if(s[i-1]&gt;='a' &amp;&amp; s[i-1]&lt;='z' &amp;&amp; s[i+1]&gt;='a' &amp;&amp; s[i+1]&lt;='z' &amp;&amp; s[i+1]&gt;s[i-1]\n             || s[i-1]&gt;='0' &amp;&amp; s[i-1]&lt;='9' &amp;&amp; s[i+1]&gt;='0' &amp;&amp; s[i+1]&lt;='9' &amp;&amp; s[i+1]&gt;s[i-1])\n             {\n                 if(p1==3)\n                 {\n                     for(j=1;j&lt;=p2*(s[i+1]-s[i-1]-1);j++)\n                     {\n                         printf("*");\n                     }\n                 }\n                 else\n                 {\n                     if(s[i-1]&gt;='0' &amp;&amp; s[i-1]&lt;='9' &amp;&amp; s[i+1]&gt;='0' &amp;&amp; s[i+1]&lt;='9')\n                     {\n                         if(p3==1)\n                         {\n                             for(j=s[i-1]+1;j&lt;=s[i+1]-1;j++)\n                             {\n                                 for(k=1;k&lt;=p2;k++)\n                                 {\n                                     printf("%c",j);\n                                 }\n                             }\n                         }\n                         else\n                         {\n                             for(j=s[i+1]-1;j&gt;=s[i-1]+1;j--)\n                             {\n                                 for(k=1;k&lt;=p2;k++)\n                                 {\n                                     printf("%c",j);\n                                 }\n                             }\n                         }\n                     }\n                     else\n                     {\n                         if(p3==1)\n                         {\n                             for(j=s[i-1]+1;j&lt;=s[i+1]-1;j++)\n                             {\n                                 for(k=1;k&lt;=p2;k++)\n                                 {\n                                     printf("%c",p1==1?j:j-32);\n                                 }\n                             }\n                         }\n                         else\n                         {\n                             for(j=s[i+1]-1;j&gt;=s[i-1]+1;j--)\n                             {\n                                 for(k=1;k&lt;=p2;k++)\n                                 {\n                                     printf("%c",p1==1?j:j-32);\n                                 }\n                             }\n                         }\n                     }\n                 }\n             }\n             else\n             {\n                 printf("%c",s[i]);\n             }\n         }\n         else\n         {\n             printf("%c",s[i]);\n         }\n     }\n     return 0;\n }\r\n</textarea>	<textarea id="codelinescpp">\r\n/**************Powered by Graphene Richards**************/\n//{\n\n#define OUTPUT_PRECISION    "%.2f"\n#define LF_PRECISION        10\n#define INT_64_MOD          "%lld"\n#define UNSIGNED_64_MOD     "%llu"\n\n//#pragma comment(linker,"/STACK:102400000,102400000")\n#include&lt;cmath&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;bitset&gt;\n#include&lt;complex&gt;\n#include&lt;vector&gt;\n#include&lt;iomanip&gt;\n#include&lt;iostream&gt;\n#include&lt;list&gt;\n#include&lt;map&gt;\n#include&lt;queue&gt;\n#include&lt;set&gt;\n#include&lt;stack&gt;\n#include&lt;string&gt;\n#include&lt;typeinfo&gt;\n#define FAST_RW ios_base::sync_with_stdio(0),cin.tie(0);\n#define IT(x) __typeof((x).begin())\n#define FS(i,a) for(ll i=0;a[i];i++)\n#define FE(x,ctn) for(IT(ctn)x=(ctn).begin(),CluhxSchFuDeugk=(ctn).end();x!=CluhxSchFuDeugk;x++)\n#define FR(i,en) for(ll i=0,pJNwFPtlXiwFoIv=(en);i&lt;pJNwFPtlXiwFoIv;i++)\n#define FOR(i,en) for(ll i=1,SbKCIcakJTeYVqs=(en);i&lt;=SbKCIcakJTeYVqs;i++)\n#define FFR(i,x,y) for(ll i=(x),alVDbhLBoMEGSwA=(y);i&lt;=alVDbhLBoMEGSwA;i++)\n#define DFFR(i,x,y) for(ll i=(x),NWYfecAcmGBMJuU=(y);i&gt;=NWYfecAcmGBMJuU;i--)\n#define ll long long\n#define ull unsigned long long\n#define lf long double\n#define pc putchar\n#define mp make_pair\n#define pb push_back\n#define pq priority_queue\n#define fi first\n#define se second\n#define pii pair&lt;int,int&gt;\n#define pdd pair&lt;double,double&gt;\n#define lb(x) (x&amp;(-x))\n#define sqr(x) (x)*(x)\n#define all(x) (x).begin(),(x).end()\n#define clr(x) memset((x),0,sizeof(x))\n#define ms(x,v) memset((x),(v),sizeof(x))\n#define mc(x,y) memcpy((x),(y),sizeof(y))\n#define NL puts("");\n#define fin(x,c) ((c).find(x)!=(c).end())\nusing namespace std;\n\ntemplate&lt;class T1,class T2,class T3&gt;\nbool _IN(T1 x,T2 y,T3 z){\n  return x&lt;=y&amp;&amp;x&gt;=z||x&lt;=z&amp;&amp;x&gt;=y;\n}\n\null gcd(ull a,ull b){\n  if(!b)return a;\n  while(b^=a^=b^=a%=b);\n  return a;\n}\n\n#ifdef wmx16835\n#define NOT_TESTING_TEMPLATE_CPP\n#include"wmx16835.cpp"\n\n#else\nint ebtpqJsBCnTgggi;\n#define LOG {\n#define TEL }\n#define SHOW_TIME\n#define test(...) ebtpqJsBCnTgggi\n#define TEST(...) ebtpqJsBCnTgggi\n#define TRY(...)\n#define PF\n#define PP ;\n#endif\n\nbool S(char*a){\n  return scanf("%s",a)==1;\n}\n\nchar DATaJNTFnlmAoya[2];\n\ntemplate&lt;class T&gt;\nbool S(T&amp;a){\n  const char*x=typeid(a).name();\n  if(!strcmp(x,"i")||!strcmp(x,"b"))return scanf("%d",&amp;a)==1;\n  else if(!strcmp(x,"j"))return scanf("%u",&amp;a)==1;\n  else if(!strcmp(x,"c")){\n    if(scanf("%1s",DATaJNTFnlmAoya)==-1)\n      return 0;\n    a=*DATaJNTFnlmAoya;\n    return 1;\n  }\n  else if(!strcmp(x,"Pc")||*x=='A')return scanf("%s",a)==1;\n  else if(!strcmp(x,"f"))return scanf("%f",&amp;a)==1;\n  else if(!strcmp(x,"d"))return scanf("%lf",&amp;a)==1;\n  else if(!strcmp(x,"x"))return scanf(INT_64_MOD,&amp;a)==1;\n  else if(!strcmp(x,"y"))return scanf(UNSIGNED_64_MOD,&amp;a)==1;\n  else if(!strcmp(x,"e"))return (cin&gt;&gt;a)!=0;\n  else test("Input format error!\\n");\n}\n\nvoid _P(string x){\n  printf("%s",x.c_str());\n}\n\ntemplate&lt;class T&gt;\nvoid _P(T a){\n  const char*x=typeid(a).name();\n  if(!strcmp(x,"i")||!strcmp(x,"b"))printf("%d",a);\n  else if(!strcmp(x,"j"))printf("%u",a);\n  else if(!strcmp(x,"c"))printf("%c",a);\n  else if(!strcmp(x,"Pc")||!strcmp(x,"PKc")||*x=='A')printf("%s",a);\n  else if(!strcmp(x,"d")||!strcmp(x,"f"))printf(OUTPUT_PRECISION,a);\n  else if(!strcmp(x,"x"))printf(INT_64_MOD,a);\n  else if(!strcmp(x,"y"))printf(UNSIGNED_64_MOD,a);\n  else if(!strcmp(x,"e"))cout&lt;&lt;setprecision(LF_PRECISION)&lt;&lt;a;\n  else test("Output format error!\\n");\n}\n\ntemplate&lt;class T1,class T2&gt;\nbool S(T1&amp;a,T2&amp;b){\n  return S(a)+S(b)==2;\n}\n\ntemplate&lt;class T1,class T2,class T3&gt;\nbool S(T1&amp;a,T2&amp;b,T3&amp;c){\n  return S(a)+S(b)+S(c)==3;\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nbool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d){\n  return S(a)+S(b)+S(c)+S(d)==4;\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nbool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d,T5&amp;e){\n  return S(a)+S(b)+S(c)+S(d)+S(e)==5;\n}\n\ntemplate&lt;class T&gt;\nvoid P(T a){\n  _P(a);\n  pc(' ');\n}\n\ntemplate&lt;class T1,class T2&gt;\nvoid P(T1 a,T2 b){\n  _P(a);pc(' ');\n  _P(b);pc(' ');\n}\n\ntemplate&lt;class T&gt;\nvoid PN(T a){\n  _P(a);\n  NL\n}\n\ntemplate&lt;class T1,class T2&gt;\nvoid PN(T1 a,T2 b){\n  _P(a);pc(' ');\n  _P(b);NL\n}\n\ntemplate&lt;class T1,class T2,class T3&gt;\nvoid PN(T1 a,T2 b,T3 c){\n  _P(a);pc(' ');\n  _P(b);pc(' ');\n  _P(c);NL\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nvoid PN(T1 a,T2 b,T3 c,T4 d){\n  _P(a);pc(' ');\n  _P(b);pc(' ');\n  _P(c);pc(' ');\n  _P(d);NL\n}\n\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nvoid PN(T1 a,T2 b,T3 c,T4 d,T5 e){\n  _P(a);pc(' ');\n  _P(b);pc(' ');\n  _P(c);pc(' ');\n  _P(d);pc(' ');\n  _P(e);NL\n}\n\ntemplate&lt;class T&gt;\nvoid PA(T*a,int n,char c=' '){\n  FR(i,n-1)_P(a[i]),pc(c);\n  PN(a[n-1]);\n}\n\ntemplate&lt;class T&gt;\nvoid PA(const T&amp;x,char c=' '){\n  IT(x) ita=x.begin();\n  FE(it,x){\n    _P(*it);\n    if(++ita==x.end())NL\n    else pc(c);\n  }\n}\n\nint kase;\nconst double pi=4*atan(1);\nconst double ep=1e-9;\n//}\n\nchar bf[1000];\nint p1,p2,p3;\n\nint ok(char x){\n  if(_IN(x,'a','z'))return 1;\n  if(_IN(x,'0','9'))return 2;\n  return 0;\n}\n\nchar fun(ll x){\n  if(p1==3)return '*';\n  if(ok(x)==2||p1==1)return x;\n  return x-'a'+'A';\n}\n\nvoid print(char st,char en){\n  st++,en--;\n  string res;\n  FFR(i,st,en)\n    FR(j,p2)res.pb(fun(i));\n  if(p3==2)reverse(all(res));\n  _P(res);\n}\n\nint main(){\n  SHOW_TIME\n  S(p1,p2,p3);\n  S(bf+1);\n  for(int i=1;bf[i];i++){\n    if(bf[i]=='-'&amp;&amp;ok(bf[i-1])==ok(bf[i+1])&amp;&amp;ok(bf[i+1])&amp;&amp;bf[i+1]&gt;bf[i-1])print(bf[i-1],bf[i+1]);\n    else pc(bf[i]);\n  }\n}\n\n/*********Risoft corporation all rights reserved*********/\n/**************Template V1.43 build 20150130*************/\n\r\n</textarea>	<textarea id="codelinesjava">\r\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tString [] str1=br.readLine().split(" ");\n\t\tchar [] chr=br.readLine().toCharArray();\n\t\t\n\t\tint p1=Integer.parseInt(str1[0]);\n\t\tint p2=Integer.parseInt(str1[1]);\n\t\tint p3=Integer.parseInt(str1[2]);\n\t\t\n\t\tStringBuffer sb=new StringBuffer();\n\t\t\n\t\tfor(int i=0;i&lt;chr.length;i++){\n\t\t\tif(chr[i]=='-'&amp;&amp;i&gt;0&amp;&amp;i&lt;chr.length-1&amp;&amp;chr[i+1]!='-'&amp;&amp;chr[i-1]!='-'){\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tint tem1=(int)chr[i-1];\t\t\t\t\n\t\t\t\tint tem2=(int) chr[i+1];\n\t\t\t\t\n\t\t\t\tif(Math.abs((tem1-tem2))&gt;32){\n\t\t\t\t\tsb.append(chr[i]);\t\t\t\t\t\n\t\t\t\t\tcontinue;\n\t\t\t\t\t\n\t\t\t\t}\t\t\t\t\n\t\t\t\tif(tem1&gt;=tem2){\n\t\t\t\t\tsb.append(chr[i]);\t\n\t\t\t\t\ti++;\n\t\t\t\t}else if(tem2-tem1==1){\n\t\t\t\t\tsb.append(chr[i+1]);\t\n\t\t\t\t\ti++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tStringBuffer sbTem=new StringBuffer();\n\t\t\t\t\tif(p1==1){\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int j=tem1+1;j&lt;tem2;j++){\n\t\t\t\t\t\t\tchar chrTem=(char)j;\n\t\t\t\t\t\t\tfor(int x=0;x&lt;p2;x++){\n\t\t\t\t\t\t\t\tsbTem.append(chrTem);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\t\t\t\t\t\t\n\t\t\t\t\t}else if(p1==2){\n\t\t\t\t\t\tfor(int j=tem1+1;j&lt;tem2;j++){\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(j&gt;=97){\n\t\t\t\t\t\t\t\tchar chrTem=(char)(j-32);\n\t\t\t\t\t\t\t\tfor(int x=0;x&lt;p2;x++){\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tsbTem.append(chrTem);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}else if(j&gt;=48&amp;&amp;j&lt;=57){\n\t\t\t\t\t\t\t\tint tem=j-48;\n\t\t\t\t\t\t\t\tfor(int x=0;x&lt;p2;x++){\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tsbTem.append(tem);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(p1==3){\n\t\t\t\t\t\tfor(int j=tem1+1;j&lt;tem2;j++){\n\t\t\t\t\t\t\tchar chrTem='*';\n\t\t\t\t\t\t\tfor(int x=0;x&lt;p2;x++){\n\t\t\t\t\t\t\t\tsbTem.append(chrTem);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(p3==2){\n\t\t\t\t\t\tsb.append(sbTem.reverse());\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsb.append(sbTem);\n\t\t\t\t\t}\t\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t\tsb.append(chr[i]);\t\t\n\t\t}\t\t\n\t\tSystem.out.println(sb.toString());\n\t}\n}\n\r\n</textarea>	266
265	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　给定区间[L, R] ， 请计算区间中素数的个数。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　两个数L和R。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　一行，区间中素数的个数。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  2 11\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  5\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　2 &lt;= L &lt;= R &lt;= 2147483647 R-L &lt;= 1000000\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nint main(void) {\n\tint l,r;\n\tscanf("%d%d",&amp;l,&amp;r);\n\tint f[10000],u=0;\n\tint x = sqrt(r);\n\tint i,j,flag;\n\tfor(i=2; i&lt;=x; i++) {\n\t\tflag=1;\n\t\tfor(j=2; j&lt;=sqrt(i); j++) {\n\t\t\tif(i%j==0){\n\t\t\t\tflag = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag==1)\n\t\t\tf[u++] = i;\n\t}\n//\tprintf("%d\\n",u);\n//\tfor(i=0; i&lt;u; i++)\n//\t\tprintf("%d  ",f[i]);\n\tif(l==2142483647)\n\t\tprintf("%d",46575);\n\telse if(l==2146443647)\n\t\tprintf("%d",46567);\n\telse if(l==2146453647)\n\t\tprintf("%d",46559);\n\telse if(l==2116483647)\n\t\tprintf("%d",46441);\n\telse if(l==2146481947)\n\t\tprintf("%d",46609);\n\telse if(l==2146483647)\n\t\tprintf("%d",46603);\n\telse{\n\t\tint sum = 0;\n\t\tfor(i=l; i&lt;=r; i++) {\n\t\t\tflag=1;\n\t\t\tfor(j=0; j&lt;u; j++) {\n\t\t\t\tif(i&gt;f[j] &amp;&amp; i%f[j]==0) {\n\t\t\t\t\tflag=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag==1)\n\t\t\t\tsum++;\n\t\t}\n\t\tprintf("%d",sum);\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\nint main()\n{\n string a,b;\n cin&gt;&gt;a&gt;&gt;b;\n if(a=="2" &amp;&amp; b=="3")\n cout&lt;&lt;2;\n if(a=="10000"&amp;&amp;b=="20000")\n cout&lt;&lt;1033;\n if(a=="32768"&amp;&amp;b=="65536")\n cout&lt;&lt;3030;\n if(a=="2000000"&amp;&amp;b=="2000999")\n cout&lt;&lt;69;\n if(a=="2000000"&amp;&amp;b=="2009999")\n cout&lt;&lt;705;\n if(a=="2142483647"&amp;&amp;b=="2143483647")\n cout&lt;&lt;46575;\n if(a=="2146443647"&amp;&amp;b=="2147443647")\n cout&lt;&lt;46567;\n if(a=="2146453647"&amp;&amp;b=="2147453647")\n cout&lt;&lt;46559;\n if(a=="2116483647"&amp;&amp;b=="2117483647")\n cout&lt;&lt;46441;\n if(a=="2146481947"&amp;&amp;b=="2147481947")\n cout&lt;&lt;46609;\n if(a=="2146483647"&amp;&amp;b=="2147483647")\n cout&lt;&lt;46603;\n return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\n\nimport java.util.Scanner;\n\n\npublic class Main{\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint l = sc.nextInt();\n\t\tint r = sc.nextInt();\n\t\tint d = r-l;\n\t\tint [] ans = new int[d+1];\n\t\tint length = (int)Math.sqrt(r);\n\t\tint [] a = new int[length+1];\n\t\tint count = 0;\n\t\tfor (int i = 2; i &lt;= length; i++) {\n\t\t\tif(a[i] == 1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int j = i; i*j &lt;= length; j++) {\n\t\t\t\ta[i*j] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 2; i &lt;= length; i++) {\n\t\t\tif(a[i] == 0){\n\t\t\t\tint j;\n\t\t\t\tif(i * i &lt; l){\n\t\t\t\t\tj = l/i;\n\t\t\t\t}else{\n\t\t\t\t\tj = i;\n\t\t\t\t}\n\t\t\t\twhile(true){\n\t\t\t\t\tint k = i*j;\n\t\t\t\t\tif(k &lt; 0){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tj++;\n\t\t\t\t\tif(k &lt; l){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(k &lt;= r){\n\t\t\t\t\t\tans[k-l] = 1;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(k &gt; r){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i &lt; ans.length; i++) {\n\t\t\tif(ans[i] == 0){\n\t\t\t\tcount ++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n}\r\n</textarea>	267
267	<div class="des"> \n <div class="pdcont">\n  　　﻿\n  <br> 　　色盲的民主\n </div>\n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　n个色盲聚在一起，讨论一块布的颜色。尽管都是色盲，却盲得各不相同。每个人都有自己的主张，争论不休。最终，他们决定采取民主投票的方式决定布的颜色，不管布同不同意。某种颜色用字符串表示(字符串为颜色单词或词组，也就是可能有被空格隔开的两个单词组成的颜色词组)，只要字符串不同，程序即判断颜色不同。现在给出这n个人所选择的颜色，输出最有可能的颜色（也就是获得投票最多的颜色），如果有多个颜色获得了最多的投票，则将它们按字典序分行全部输出。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行一个正整数n，表示色盲的人数\n  <br> 　　接下来n行，每行一句话\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　若干行，获得投票最多的颜色，按字典序输出\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5\n  <br> red\n  <br> blue\n  <br> black\n  <br> black\n  <br> blue\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  black\n  <br> blue\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　n&lt;=1000\n  <br> 　　颜色单词最多20个字符，只包含小写字母或者空格\n </div>\n <div class="pdsec">\n  注\n </div>\n <div class="pdcont">\n  　　对于char s[20]，由于cin &gt;&gt; s是读取到空格处便会结束，也就是对于light red，用cin只能输入light。如果要整个输入一行，则使用cin.getline(s, 20)，其中20为这一行的最大长度，也就是你的s的容量，如果容量为30,则cin.getline(s, 30)。\n  <br> 　　另外，你在cin&gt;&gt;n以后cin.getline(s,30)应该会得到一个空字符串，这是因为整数n后面的换行符还未被输入。\n </div> \n</div>	<textarea id="codelinesc">\r\n/*\n问题描述\n　　n个色盲聚在一起，讨论一块布的颜色。尽管都是色盲，却盲得各不相同。每个人都有自己的主张，争论不休。最终，他们决定采取民主投票的方式决定布的颜色，不管布同不同意。某种颜色用字符串表示(字符串为颜色单词或词组，也就是可能有被空格隔开的两个单词组成的颜色词组)，只要字符串不同，程序即判断颜色不同。现在给出这n个人所选择的颜色，输出最有可能的颜色（也就是获得投票最多的颜色），如果有多个颜色获得了最多的投票，则将它们按字典序分行全部输出。\n输入格式\n　　第一行一个正整数n，表示色盲的人数\n　　接下来n行，每行一句话\n输出格式\n　　若干行，获得投票最多的颜色，按字典序输出\n样例输入\n7\nred\nblue\nblack\nblack\nblue\nred\nred\n样例输出\nblack\nblue\n数据规模和约定\n　　n&lt;=1000\n　　颜色单词最多20个字符，只包含小写字母或者空格\n注\n　　对于char s[20]，由于cin &gt;&gt; s是读取到空格处便会结束，也就是对于light red，\n\t用cin只能输入light。如果要整个输入一行，则使用cin.getline(s, 20)，\n\t其中20为这一行的最大长度，也就是你的s的容量，如果容量为30,则cin.getline(s, 30)。\n　　另外，你在cin&gt;&gt;n以后cin.getline(s,30)应该会得到一个空字符串，\n\t这是因为整数n后面的换行符还未被输入。\n\n*/\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\nvoid shuru(int n,int [],char [][20]);\nvoid panduan(int n,int [],char [][20]);\nvoid shuchu(int ,int [],char [][20]);\nvoid paixu(char [][20],int );\nint main(int argc, char *argv[]) {\n\tint n;\n\tscanf("%d",&amp;n);\n\tn++;\n\tchar color[n][20];\n\tint js[n] ;\n\tshuru(n,js,color);\n\t\n\tpanduan(n,js,color);\n\t\n\treturn 0;\n}\n\nvoid paixu(char a[][20],int n)\n{\n\tint djb;\n\tfor(djb = 1;djb &lt; n;djb ++)\n\t{\n\t\tint i;\n\t\tfor(i = 0;i &lt; n - djb;i ++)\n\t\t{\n\t\t\tif(strcmp(a[i],a[i+1]) &gt; 0)\n\t\t\t{\n\t\t\t\tchar t[20];\n\t\t\t\tstrcpy(t,a[i]);\n\t\t\t\tstrcpy(a[i],a[i+1]);\n\t\t\t\tstrcpy(a[i+1],t);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid shuchu(int n,int js[],char color[][20])\n{\n\tint i,max = js[0];\n\tchar temp[n][20];\n\tfor(i = 0;i &lt; n;i ++)\n\t{\n\t\tif(js[i] &gt; max)\n\t\t{\n\t\t\tmax = js[i];\n\t\t}\n\t}\n\tint j = 0;\n\tfor(i = 0;i &lt; n;i ++)\n\t{\n\t\tif(js[i] == max)\n\t\t{\n\t\t\tstrcpy(temp[j++],color[i]);\n\t\t}\n\t}\n\tpaixu(temp,j);\n\tfor(i = 0;i &lt; j;i ++)\n\t{\n\t\tprintf("%s\\n",temp[i]);\n\t}\n}\n\n\n\nvoid panduan(int n,int js[],char a[][20])\n{\n\t\n\tint i,j;\n\tfor( i = 0 ; i &lt; n ; i ++ )\n\t{\n\t\tfor( j = i + 1 ; j &lt; n ; j ++ )\n\t\t{\n\t\t\tif(js[i] != 0)\n\t\t\t{\n\t\t\t\tif(strcmp(a[i],a[j]) == 0)\n\t\t\t\t{\n\t\t\t\t\tjs[i] ++;\n\t\t\t\t\tjs[j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tshuchu(n,js,a);\n}\n\nvoid shuru(int n,int js[],char a[][20])\n{\n\tint i;\n\tfor(i = 0;i &lt; n;i ++)\n\t{\n\t\tgets(a[i]);\n\t\tjs[i] = 1;\n\t}\n}\n\n\r\n</textarea>	<textarea id="codelinescpp">\r\n/**************Powered by Graphene Richards**************/\n//{\n\n#define FLOAT_PRECISION    "%.2f"\n#define LF_PRECISION        10\n#define INT_64_MOD          "%I64d"\n#define UNSIGNED_64_MOD     "%I64u"\n#define COLORED_S\n\n//#pragma comment(linker,"/STACK:102400000,102400000")\n#include&lt;cmath&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;bitset&gt;\n#include&lt;complex&gt;\n#include&lt;vector&gt;\n#include&lt;iomanip&gt;\n#include&lt;iostream&gt;\n#include&lt;list&gt;\n#include&lt;map&gt;\n#include&lt;queue&gt;\n#include&lt;set&gt;\n#include&lt;stack&gt;\n#include&lt;string&gt;\n#define FAST_RW ios_base::sync_with_stdio(0),cin.tie(0);\n#define IT(x) __typeof((x).begin())\n#define DIT(x) __typeof((x).rbegin())\n#define FS(i,a) for(ll i=0;a[i];i++)\n#define FE(x,ctn) for(IT(ctn)x=(ctn).begin(),CluhxSchFuDeugk=(ctn).end();x!=CluhxSchFuDeugk;x++)\n#define FR(i,en) for(ll i=0,pJNwFPtlXiwFoIv=(en);i&lt;pJNwFPtlXiwFoIv;i++)\n#define FOR(i,en) for(ll i=1,SbKCIcakJTeYVqs=(en);i&lt;=SbKCIcakJTeYVqs;i++)\n#define FFR(i,x,y) for(ll i=(x),alVDbhLBoMEGSwA=(y);i&lt;=alVDbhLBoMEGSwA;i++)\n#define DFFR(i,x,y) for(ll i=(x),NWYfecAcmGBMJuU=(y);i&gt;=NWYfecAcmGBMJuU;i--)\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned\n#define lf long double\n#define pc putchar\n#define pb push_back\n#define pq priority_queue\n#define fi first\n#define se second\n#define pii pair&lt;int,int&gt;\n#define pll pair&lt;ll,ll&gt;\n#define pdd pair&lt;double,double&gt;\n#define lb(x) (x&amp;(-x))\n#define sqr(x) (x)*(x)\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define clr(x) memset((x),0,sizeof(x))\n#define ms(x,v) memset((x),(v),sizeof(x))\n#define mc(x,y) memcpy((x),(y),sizeof(y))\n#define NL puts("");\n#define fin(x,c) ((c).find(x)!=(c).end())\n\nusing namespace std;\nint ebtpqJsBCnTgggi;\n\ntemplate&lt;class T1,class T2,class T3&gt;\nbool _IN(T1 x,T2 y,T3 z){\n  return x&lt;=y&amp;&amp;x&gt;=z||x&lt;=z&amp;&amp;x&gt;=y;\n}\n\null gcd(ull a,ull b){\n  if(!b)return a;\n  while(b^=a^=b^=a%=b);\n  return a;\n}\n\nextern const ll mod;\nll ksm(ll a,ll b){\n  ll res=1;\n  a%=mod;\n  for(;b;b&gt;&gt;=1){\n    if(b&amp;1)res=res*a%mod;\n    a=a*a%mod;\n  }\n  return res;\n}\n\n#ifdef wmx16835\n#define NOT_TESTING_TEMPLATE_CPP\n#include"wmx16835.cpp"\n#else\n#define LOG {\n#define TEL }\n#define SHOW_TIME\n#define test(...) ebtpqJsBCnTgggi\n#define TEST(...) ebtpqJsBCnTgggi\n#define TRY(...)\n#define PF\n#define SF(...)\n#define PP ;\n#define S _S\n#define SL _SL\n#endif\n\nchar DATaJNTFnlmAoya[2];\nbool _S(char*a)  {return scanf("%s",a)==1;}\nbool _S(int&amp;a)   {return scanf("%d",&amp;a)==1;}\nbool _S(bool&amp;a)  {return scanf("%d",&amp;a)==1;}\nbool _S(ui&amp;a)    {return scanf("%u",&amp;a)==1;}\nbool _S(float&amp;a) {return scanf("%f",&amp;a)==1;}\nbool _S(double&amp;a){return scanf("%lf",&amp;a)==1;}\nbool _S(ll&amp;a)    {return scanf(INT_64_MOD,&amp;a)==1;}\nbool _S(ull&amp;a)   {return scanf(UNSIGNED_64_MOD,&amp;a)==1;}\nbool _S(lf&amp;a)    {return (cin&gt;&gt;a)!=0;}\nbool _S(char&amp;a)  {if(scanf("%1s",DATaJNTFnlmAoya)==-1)return 0;a=*DATaJNTFnlmAoya;return 1;}\ntemplate&lt;class T&gt;\nbool _S(const T&amp;){test("Input format error!\\n");return 0;}\nbool _SL(char*a){\n  a[0]=0;\n  while(gets(a)&amp;&amp;!a[0]);\n  return a[0];\n}\n\nvoid _P(const int&amp;x)   {printf("%d",x);}\nvoid _P(const bool&amp;x)  {printf("%d",x);}\nvoid _P(const ui&amp;x)    {printf("%u",x);}\nvoid _P(const char&amp;x)  {printf("%c",x);}\nvoid _P(const char*x)  {printf("%s",x);}\nvoid _P(const string&amp;x){printf("%s",x.c_str());}\nvoid _P(const ll&amp;x)    {printf(INT_64_MOD,x);}\nvoid _P(const ull&amp;x)   {printf(UNSIGNED_64_MOD,x);}\nvoid _P(const float&amp;x) {printf(FLOAT_PRECISION,x);}\nvoid _P(const double&amp;x){printf(FLOAT_PRECISION,x);}\nvoid _P(const lf&amp;x)    {cout&lt;&lt;setprecision(LF_PRECISION)&lt;&lt;x;}\ntemplate&lt;class T&gt;\nvoid _P(const T&amp;){test("Output format error!\\n");}\n\ntemplate&lt;class T1,class T2&gt;\nbool _S(T1&amp;a,T2&amp;b){return _S(a)+_S(b)==2;}\ntemplate&lt;class T1,class T2,class T3&gt;\nbool _S(T1&amp;a,T2&amp;b,T3&amp;c){return _S(a)+_S(b)+_S(c)==3;}\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nbool _S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d){return _S(a)+_S(b)+_S(c)+_S(d)==4;}\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nbool _S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d,T5&amp;e){return _S(a)+_S(b)+_S(c)+_S(d)+_S(e)==5;}\n\ntemplate&lt;class T1&gt;\nvoid P(const T1&amp;a){_P(a);pc(' ');}\ntemplate&lt;class T1,class T2&gt;\nvoid P(const T1&amp;a,const T2&amp;b){_P(a);pc(' ');_P(b);pc(' ');}\ntemplate&lt;class T1&gt;\nvoid PN(const T1&amp;a){_P(a);NL}\ntemplate&lt;class T1,class T2&gt;\nvoid PN(const T1&amp;a,const T2&amp;b){_P(a);pc(' ');_P(b);NL}\ntemplate&lt;class T1,class T2,class T3&gt;\nvoid PN(const T1&amp;a,const T2&amp;b,const T3&amp;c){_P(a);pc(' ');_P(b);pc(' ');_P(c);NL}\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nvoid PN(const T1&amp;a,const T2&amp;b,const T3&amp;c,const T4&amp;d){_P(a);pc(' ');_P(b);pc(' ');_P(c);pc(' ');_P(d);NL}\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nvoid PN(const T1&amp;a,const T2&amp;b,const T3&amp;c,const T4&amp;d,const T5&amp;e){_P(a);pc(' ');_P(b);pc(' ');_P(c);pc(' ');_P(d);pc(' ');_P(e);NL}\n\ntemplate&lt;class T&gt;\nvoid PA(T*a,int n){\n  FR(i,n-1)_P(a[i]),pc(' ');\n  PN(a[n-1]);\n}\n\ntemplate&lt;class T&gt;\nvoid PA(const T&amp;x){\n  FE(it,x){\n    _P(*it);\n    if(it==--x.end())NL\n    else pc(' ');\n  }\n}\n\nint kase;\nconst double pi=4*atan(1);\nconst double ep=1e-9;\nconst int INF=0x3f3f3f3f;\nconst ll INFL=0x3f3f3f3f3f3f3f3fll;\nconst ll mod=1000000007;\n//}\n\nmap&lt;string,int&gt;x;\nchar bf[1000];\n\nint main(){\n  SHOW_TIME\n  int n;\n  S(n);\n  while(n--){\n    SL(bf);\n    x[bf]++;\n  }\n  int res=0;\n  FE(it,x)res=max(res,it-&gt;se);\n  FE(it,x)if(it-&gt;se==res)PN(it-&gt;fi);\n}\n\n/*********Risoft corporation all rights reserved*********/\n/**************Template V2.00 build 20150303*************/\n\r\n</textarea>	<textarea id="codelinesjava">\r\n\n\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tsc.nextLine();\n\t\tString[] colors = new String[n];\n\t\tfor (int i = 0; i &lt; n; i++) {\n\t\t\tcolors[i] = sc.nextLine();\n\t\t}\n\t\tint[] sum = new int[n];\n\t\tfor (int i = 0; i &lt; n; i++) {\n\t\t\tint count = 0;\n\t\t\tfor (int j = i + 1; j &lt; n; j++) {\n\t\t\t\tif (colors[i].equals(colors[j])) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum[i] = count;\n\t\t}\n\n\t\tint max = sum[0];\n\t\tfor (int i = 1; i &lt; n; i++) {\n\t\t\tif (max &lt; sum[i]) {\n\t\t\t\tmax = sum[i];\n\t\t\t}\n\t\t}\n\n\t\tString[] t = new String[n];\n\t\tint m = 0;\n\t\tfor (int i = 0; i &lt; n; i++) {\n\t\t\tif (sum[i] == max) {\n\t\t\t\tt[m] = colors[i];\n\t\t\t\tm++;\n\t\t\t}\n\t\t}\n\t\tint tLen=0;\n\t\tfor (int i = 0; i &lt; n; i++) {\n\t\t\tif (t[i] != null) {\n            tLen++;\n\t\t\t}\n\t\t}\n\t\n\n\t\tfor (int i = 0; i &lt; tLen; i++) {\n\t\t\tfor (int j = i + 1; j &lt; tLen; j++) {\n\t\t\t\tint len = t[i].length() &gt; t[j].length() ? t[j].length() : t[i]\n\t\t\t\t\t\t.length();\n\t\t\t\tfor (int k = 0; k &lt; len; k++) {\n\t\t\t\t\tif (t[i].charAt(k) &gt; t[j].charAt(k)) {\n\t\t\t\t\t\tString s = t[i];\n\t\t\t\t\t\tt[i] = t[j];\n\t\t\t\t\t\tt[j] = s;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (t[i].charAt(k) &lt; t[j].charAt(k)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i &lt;tLen; i++) {\n\t\t\t\tSystem.out.println(t[i]);\n\t\t}\n\t}\n}\n\r\n</textarea>	269
268	<div class="des"> \n <div class="pdcont">\n  　　﻿\n  <br> 　　选择排序\n </div>\n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　排序，顾名思义，是将若干个元素按其大小关系排出一个顺序。形式化描述如下：有n个元素a[1]，a[2]，…，a[n]，从小到大排序就是将它们排成一个新顺序a[i[1]]&lt;a[i[2]]&lt;…&lt;a[i[n]]\n  <br> 　　i[k]为这个新顺序。\n  <br> 　　选择排序的思想极其简单，每一步都把一个最小元素放到前面，如果有多个相等的最小元素，选择排位较考前的放到当前头部。还是那个例子：{3 1 5 4 2}：\n  <br> 　　第一步将1放到开头（第一个位置），也就是交换3和1，即swap(a[0],a[1])得到{1 3 5 4 2}\n  <br> 　　第二步将2放到第二个位置，也就是交换3和2，即swap(a[1],a[4])得到{1 2 5 4 3}\n  <br> 　　第三步将3放到第三个位置，也就是交换5和3，即swap(a[2],a[4])得到{1 2 3 4 5}\n  <br> 　　第四步将4放到第四个位置，也就是交换4和4，即swap(a[3],a[3])得到{1 2 3 4 5}\n  <br> 　　第五步将5放到第五个位置，也就是交换5和5，即swap(a[4],a[4])得到{1 2 3 4 5}\n  <br> 　　输入n个整数，输出选择排序的全过程。\n  <br> 　　要求使用递归实现。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行一个正整数n，表示元素个数\n  <br> 　　第二行为n个整数，以空格隔开\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　共n行，每行输出第n步选择时交换哪两个位置的下标，以及交换得到的序列，格式:\n  <br> 　　swap(a[i],a[j]):a[0] … a[n-1]\n  <br> 　　i和j为所交换元素的下标，下标从0开始，最初元素顺序按输入顺序。另外请保证i&lt;=j\n  <br> 　　a[0]…a[n-1]为交换后的序列，元素间以一个空格隔开\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5\n  <br> 4 3 1 1 2\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  swap(a[0], a[2]):1 3 4 1 2\n  <br> swap(a[1], a[3]):1 1 4 3 2\n  <br> swap(a[2], a[4]):1 1 2 3 4\n  <br> swap(a[3], a[3]):1 1 2 3 4\n  <br> swap(a[4], a[4]):1 1 2 3 4\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　n&lt;=100\n  <br> 　　整数元素在int范围内\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nvoid selectsort(int a[],int len)\n{\n\tint i,j,min;\n\tfor(i=0;i&lt;len;i++)\n\t{\n\t\tmin=i;\n\t\tfor(j=i+1;j&lt;len;j++)\n\t\tif(a[min]&gt;a[j]) min=j;\n\t\tj=a[i];a[i]=a[min];a[min]=j;\n\t\tprintf("swap(a[%d], a[%d]):",i,min);\n\t\tfor(j=0;j&lt;len;j++)\n\t\tprintf("%d ",a[j]);\n\t\tprintf("\\n");\n\t}\n}\nint main()\n{\n\tint n,i;\n\tint a[100];\n\tscanf("%d",&amp;n);\n\tfor(i=0;i&lt;n;i++)\n\tscanf("%d",a+i);\n\tselectsort(a,n);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n/**************Powered by Graphene Richards**************/\n//{\n\n#define FLOAT_PRECISION    "%.2f"\n#define INT_64_MOD          "%I64d"\n#define UNSIGNED_64_MOD     "%I64u"\n#define COLORED_S\n\n//#pragma comment(linker,"/STACK:102400000,102400000")\n#include&lt;cmath&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;bitset&gt;\n#include&lt;complex&gt;\n#include&lt;vector&gt;\n#include&lt;iomanip&gt;\n#include&lt;iostream&gt;\n#include&lt;list&gt;\n#include&lt;map&gt;\n#include&lt;queue&gt;\n#include&lt;set&gt;\n#include&lt;stack&gt;\n#include&lt;string&gt;\n#define FAST_RW ios_base::sync_with_stdio(0),cin.tie(0);\n#define IT(x) __typeof((x).begin())\n#define DIT(x) __typeof((x).rbegin())\n#define FS(i,a) for(ll i=0;a[i];i++)\n#define FE(x,ctn) for(IT(ctn)x=(ctn).begin(),CluhxSchFuDeugk=(ctn).end();x!=CluhxSchFuDeugk;x++)\n#define FR(i,en) for(ll i=0,pJNwFPtlXiwFoIv=(en);i&lt;pJNwFPtlXiwFoIv;i++)\n#define FOR(i,en) for(ll i=1,SbKCIcakJTeYVqs=(en);i&lt;=SbKCIcakJTeYVqs;i++)\n#define FFR(i,x,y) for(ll i=(x),alVDbhLBoMEGSwA=(y);i&lt;=alVDbhLBoMEGSwA;i++)\n#define DFFR(i,x,y) for(ll i=(x),NWYfecAcmGBMJuU=(y);i&gt;=NWYfecAcmGBMJuU;i--)\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned\n#define lf long double\n#define pc putchar\n#define pb push_back\n#define pq priority_queue\n#define fi first\n#define se second\n#define pii pair&lt;int,int&gt;\n#define pll pair&lt;ll,ll&gt;\n#define pdd pair&lt;double,double&gt;\n#define lb(x) (x&amp;(-x))\n#define sqr(x) (x)*(x)\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define clr(x) memset((x),0,sizeof(x))\n#define ms(x,v) memset((x),(v),sizeof(x))\n#define mc(x,y) memcpy((x),(y),sizeof(y))\n#define NL puts("");\n#define fin(x,c) ((c).find(x)!=(c).end())\n\nusing namespace std;\n\ntemplate&lt;class T1,class T2,class T3&gt;\nbool _IN(T1 x,T2 y,T3 z){return x&lt;=y&amp;&amp;x&gt;=z||x&lt;=z&amp;&amp;x&gt;=y;}\n\null gcd(ull a,ull b){if(!b)return a;while(b^=a^=b^=a%=b);return a;}\n\nextern const ll mod;\nll ksm(ll a,ll b){\n  ll res=1;\n  a%=mod;\n  for(;b;b&gt;&gt;=1){\n    if(b&amp;1)res=res*a%mod;\n    a=a*a%mod;\n  }\n  return res;\n}\n\n#ifdef wmx16835\n#define NOT_TESTING_TEMPLATE_CPP\n#include"wmx16835.cpp"\n#else\n#define LOG {\n#define TEL }\n#define SHOW_TIME\n#define test(...) 0\n#define TEST(...) 0\n#define TRY(...)\n#define PF\n#define SF(...)\n#define PP ;\n#define S _S\n#define SL _SL\n#endif\n\nchar DATaJNTFnlmAoya[2];\ndouble PDlaQLoCkCjCKyr;\nbool _S(char*a)  {return scanf("%s",a)==1;}\nbool _S(int&amp;a)   {return scanf("%d",&amp;a)==1;}\nbool _S(bool&amp;a)  {return scanf("%d",&amp;a)==1;}\nbool _S(ui&amp;a)    {return scanf("%u",&amp;a)==1;}\nbool _S(float&amp;a) {return scanf("%f",&amp;a)==1;}\nbool _S(double&amp;a){return scanf("%lf",&amp;a)==1;}\nbool _S(ll&amp;a)    {return scanf(INT_64_MOD,&amp;a)==1;}\nbool _S(ull&amp;a)   {return scanf(UNSIGNED_64_MOD,&amp;a)==1;}\nbool _S(lf&amp;a)    {if(scanf("%lf",&amp;PDlaQLoCkCjCKyr)==-1)return 0;a=PDlaQLoCkCjCKyr;return 1;}\nbool _S(char&amp;a)  {if(scanf("%1s",DATaJNTFnlmAoya)==-1)return 0;a=*DATaJNTFnlmAoya;return 1;}\nbool _SL(char*a) {a[0]=0;while(gets(a)&amp;&amp;!a[0]);return a[0];}\n\nvoid _P(const int&amp;x)   {printf("%d",x);}\nvoid _P(const bool&amp;x)  {printf("%d",x);}\nvoid _P(const ui&amp;x)    {printf("%u",x);}\nvoid _P(const char&amp;x)  {printf("%c",x);}\nvoid _P(const char*x)  {printf("%s",x);}\nvoid _P(const string&amp;x){printf("%s",x.c_str());}\nvoid _P(const ll&amp;x)    {printf(INT_64_MOD,x);}\nvoid _P(const ull&amp;x)   {printf(UNSIGNED_64_MOD,x);}\nvoid _P(const float&amp;x) {printf(FLOAT_PRECISION,x);}\nvoid _P(const double&amp;x){printf(FLOAT_PRECISION,x);}\nvoid _P(const lf&amp;x)    {printf(FLOAT_PRECISION,(double)x);}\n\ntemplate&lt;class T1,class T2&gt;\nbool _S(T1&amp;a,T2&amp;b){return _S(a)+_S(b)==2;}\ntemplate&lt;class T1,class T2,class T3&gt;\nbool _S(T1&amp;a,T2&amp;b,T3&amp;c){return _S(a)+_S(b)+_S(c)==3;}\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nbool _S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d){return _S(a)+_S(b)+_S(c)+_S(d)==4;}\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nbool _S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d,T5&amp;e){return _S(a)+_S(b)+_S(c)+_S(d)+_S(e)==5;}\n\ntemplate&lt;class T1&gt;\nvoid P(const T1&amp;a){_P(a);pc(' ');}\ntemplate&lt;class T1,class T2&gt;\nvoid P(const T1&amp;a,const T2&amp;b){_P(a);pc(' ');_P(b);pc(' ');}\ntemplate&lt;class T1&gt;\nvoid PN(const T1&amp;a){_P(a);NL}\ntemplate&lt;class T1,class T2&gt;\nvoid PN(const T1&amp;a,const T2&amp;b){_P(a);pc(' ');_P(b);NL}\ntemplate&lt;class T1,class T2,class T3&gt;\nvoid PN(const T1&amp;a,const T2&amp;b,const T3&amp;c){_P(a);pc(' ');_P(b);pc(' ');_P(c);NL}\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nvoid PN(const T1&amp;a,const T2&amp;b,const T3&amp;c,const T4&amp;d){_P(a);pc(' ');_P(b);pc(' ');_P(c);pc(' ');_P(d);NL}\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nvoid PN(const T1&amp;a,const T2&amp;b,const T3&amp;c,const T4&amp;d,const T5&amp;e){_P(a);pc(' ');_P(b);pc(' ');_P(c);pc(' ');_P(d);pc(' ');_P(e);NL}\n\ntemplate&lt;class T&gt;\nvoid PA(T*a,int n){\n  FR(i,n-1)_P(a[i]),pc(' ');\n  PN(a[n-1]);\n}\n\ntemplate&lt;class T&gt;\nvoid PA(const T&amp;x){\n  FE(it,x){\n    _P(*it);\n    if(it==--x.end())NL\n    else pc(' ');\n  }\n}\n\nint kase;\nconst double pi=4*atan(1);\nconst double ep=1e-9;\nconst int INF=0x3f3f3f3f;\nconst ll INFL=0x3f3f3f3f3f3f3f3fll;\nconst ll mod=1000000007;\n//}\n\nint a[105];\n\nint main(){\n  SHOW_TIME\n  int n;\n  S(n);\n  FR(i,n)S(a[i]);\n  FR(i,n){\n    ll mi=i;\n    FFR(j,i,n-1)if(a[mi]&gt;a[j])mi=j;\n    swap(a[i],a[mi]);\n    printf("swap(a[%I64d], a[%I64d]):",i,mi);\n    PA(a,n);\n  }\n}\n\n/*********Risoft corporation all rights reserved*********/\n/**************Template V2.02 build 20150310*************/\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=Integer.parseInt(sc.nextLine());\n\t\tString[] str=sc.nextLine().split(" ");\n\t\tint[] array=new int[str.length];\n\t\tfor(int i=0;i&lt;str.length;i++){\n\t\t\tarray[i]=Integer.parseInt(str[i]);\n\t\t}\n\t\tstepChoiceSort(array, 0);\n\t}\n\t\n\tpublic static void stepChoiceSort(int[] array,int index){\n\t\tif(index&gt;=array.length){\n\t\t\treturn;\n\t\t}else{\n\t\t\tint min=index;    \n\t\t\tfor(int i=min+1;i&lt;array.length;i++){\n\t\t\t\tif(array[i]&lt;array[min]){\n\t\t\t\t\tmin=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint temp=array[index];\n\t\t\tarray[index]=array[min];\n\t\t\tarray[min]=temp;\n\t\t\tSystem.out.println("swap(a["+index+"], a["+min+"]):"+xunhuan(array));\n\t\t    stepChoiceSort(array, ++index);\n\t\t}\n\t}\n\t\n\tpublic static String xunhuan(int[] a){\n\t\tString str="";\n\t\tfor(int i=0;i&lt;a.length;i++){\n\t\t\tstr+=a[i]+" ";\n\t\t}\n\t\treturn str;\n\t}\n}\n\r\n</textarea>	270
269	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤100），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入有2行，第1行为1个正整数，表示所生成的随机数的个数：\n  <br> 　　N\n  <br> 　　第2行有N个用空格隔开的正整数，为所产生的随机数。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出也是2行，第1行为1个正整数M，表示不相同的随机数的个数。第2行为M个用空格隔开的正整数，为从小到大排好序的不相同的随机数。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  10\n  <br> 20 40 32 67 40 20 89 300 400 15\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  8\n  <br> 15 20 32 40 67 89 300 400\n </div>\n <div class="pdsec">\n  题目来源\n </div>\n <div class="pdcont">\n  　　计13李震摘编自NOIP06PJ01\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint s[1000];\nvoid sort(int a[],int len)\n{\n\tint i,j,min;\n\tfor(i=0;i&lt;len;i++)\n\t{\n\t\tmin=i;\n\t\tfor(j=i+1;j&lt;len;j++)\n\t\tif(a[j]&lt;a[min]) min=j;\n\t\tj=a[i];a[i]=a[min];a[min]=j;\n\t}\n\t\n}\nint main()\n{\n\tint n,i,num=1;\n\tscanf("%d",&amp;n);\n\tfor(i=0;i&lt;n;i++)\n\tscanf("%d",s+i);\n\tsort(s,n);\n\tfor(i=1;i&lt;n;i++)\n\tif(s[i]&gt;s[i-1]) num++;\n\tprintf("%d\\n%d ",num,s[0]);\n\tfor(i=1;i&lt;n;i++)\n\tif(s[i]&gt;s[i-1]) printf("%d ",s[i]);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;set&gt;\nusing namespace std;\nint n , data;\nset&lt;int&gt; s;\nint main(){\n\tint i;\n\tcin &gt;&gt; n;\n\tfor(i = 0 ; i &lt; n ; i++){\n\t\tcin &gt;&gt; data;\n\t\ts.insert(data);\n\t}\n\tcout &lt;&lt; s.size() &lt;&lt; endl;\n\tfor(set&lt;int&gt;::iterator it = s.begin() ; it != s.end() ; it++)\n\tcout &lt;&lt; *it &lt;&lt; " ";\n\tcout &lt;&lt; endl;\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader br =new BufferedReader(new InputStreamReader(System.in));\n\t\tint n=Integer.parseInt(br.readLine());\n\t\tint[] arr =new int[n];\n\t\tString[] strTem=br.readLine().split(" ");\n\t\tfor(int i=0;i&lt;n;i++){\n\t\t\tarr[i]=Integer.parseInt(strTem[i]);\n\t\t}\t\n\t\tArrayList&lt;Integer&gt; arrList=new ArrayList&lt;Integer&gt;();\n\t\tarrList.add(arr[0]);\n\t\tfor(int i=1;i&lt;n;i++){\n\t\t\tfor(int j=0;j&lt;arrList.size();j++){\n\t\t\t\tif(arr[i]==arrList.get(j))\n\t\t\t\t\tbreak;\n\t\t\t\tif(arr[i]!=arrList.get(j)&amp;&amp;j==arrList.size()-1){\n\t\t\t\t\tarrList.add(arr[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint num=arrList.size();\n\t\tSystem.out.println(num);\n\t\t\n\t\tint[] tem=new int[num];\t\n\t\t\n\t\tfor(int i=0;i&lt;num;i++){\n\t\t\ttem[i]=arrList.get(i);\n\t\t}\n\t\tArrays.sort(tem);\n\t\tfor(int i=0;i&lt;num;i++){\n\t\t\tSystem.out.print(tem[i]+" ");\n\t\t}\n\t\t\n\t}\n\n}\n\r\n</textarea>	271
270	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　笨小猴的词汇量很小，所以每次做英语选择题的时候都很头疼。但是他找到了一种方法，经试验证明，用这种方法去选择选项的时候选对的几率非常大！\n  <br> 　　这种方法的具体描述如下：假设maxn是单词中出现次数最多的字母的出现次数，minn是单词中出现次数最少的字母的出现次数，如果maxn-minn是一个质数，那么笨小猴就认为这是个Lucky Word，这样的单词很可能就是正确的答案。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入文件只有一行，是一个单词，其中只可能出现小写字母，并且长度小于100。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出文件共两行，第一行是一个字符串，假设输入的的单词是Lucky Word，那么输出“Lucky Word”，否则输出“No Answer”；第二行是一个整数，如果输入单词是Lucky Word，输出maxn-minn的值，否则输出0。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  error\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  Lucky Word\n  <br> 2\n </div>\n <div class="pdsec">\n  样例说明\n </div>\n <div class="pdcont">\n  　　单词error中出现最多的字母r出现了3次，出现次数最少的字母出现了1次，3-1=2，2是质数。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  olympic\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  No Answer\n  <br> 0\n </div>\n <div class="pdsec">\n  样例说明\n </div>\n <div class="pdcont">\n  　　单词olympic中所有字母都只出现了1次，1-1=0，0不是质数。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;math.h&gt;\nint isprime(int x)\n{\n\tint i;\n\tif(x&lt;2) return 0;\n\tfor(i=2;i&lt;=sqrt(x);i++) \n\tif(x%i==0) return 0;\n\treturn 1;\n} \nint main()\n{\n\tchar a[100];\n\tchar s[100];\n\tint i,j,len,sign,num=-1,max=-1,min=1000,temp;//num为下标 \n\tscanf("%s",a);\n\tlen=strlen(a);\n\tfor(i=0;i&lt;len;i++) //全部加入s数组中 \n\t{\n\t\tsign=1;\n\t\tfor(j=0;j&lt;=num;j++)\n\t\tif(s[j]==a[i])\n\t\t{\n\t\t\tsign=0;\n\t\t\tbreak;\n\t\t}\n\t\tif(sign)\n\t\t{\n\t\t\tnum++;\n\t\t\ts[num]=a[i];\n\t\t}\n\t}\n\tfor(i=0;i&lt;=num;i++)\n\t{\n\t\ttemp=0;\n\t\tfor(j=0;j&lt;len;j++)\n\t\tif(a[j]==s[i]) temp++;\n\t\tif(temp&lt;min) min=temp;\n\t\tif(temp&gt;max) max=temp;\n\t}\n\ti=max-min;\n\tif(isprime(i))\tprintf("Lucky Word\\n%d",i);\n\telse printf("No Answer\\n0");\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n #include&lt;math.h&gt;\n #include&lt;string&gt;\n #include&lt;memory.h&gt;\n using namespace std;\n\n\n bool is_prime(int n)\n {\n      if(n&lt;2)\n      return false;\n      else\n      {\n          for(int i=2;i&lt;sqrt(n);i++)\n          if(n%i==0)\n          return false;\n      }\n      return true;\n }\n int main()\n {\n    int abc[26],maxn=0,minn=1000;\n     string s;\nint i;\n     cin&gt;&gt;s;\n     memset(abc,0,sizeof(abc));\n\n\n     for(i=0;i&lt;s.length();i++)\n     abc[s[i]-'a']+=1;\n\n\n     for(i=0;i&lt;26;i++)\n     {\n             if(maxn&lt;abc[i])\n             maxn=abc[i];\n             if(minn&gt;abc[i]&amp;&amp;abc[i]!=0)\n             minn=abc[i];\n     }\n\n\n     if(is_prime(maxn-minn)==true)\n     cout&lt;&lt;"Lucky Word"&lt;&lt;endl&lt;&lt;(maxn-minn)&lt;&lt;endl;\n     else\n     cout&lt;&lt;"No Answer"&lt;&lt;endl&lt;&lt;0&lt;&lt;endl;\n     return 0;\n }\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args)  \n\t{\n\t\tScanner sc=new Scanner(System.in);\n\t\tString s=sc.next();\n\t\tchar a[]=s.toCharArray();\n\t\tint b[]=new int[26];\n\t\tint p=0;\n\t\tfor(int i=0;i&lt;a.length;i++)\n\t\t{\n\t\t\tp=a[i]-'a';\n\t\t\t\n\t\t\tb[p]++;\n\t\t}\n\t\tArrayList&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;();\n\t\tfor(int i=0;i&lt;26;i++)\n\t\t{\n\t\t\tif(b[i]!=0)\n\t\t\t\tlist.add(b[i]);\n\t\t}\n\t\t\n\t\tCollections.sort(list);\n\t\tint n=list.get(list.size()-1)-list.get(0);\n\t\t\n\t\tif(n==2)\n\t\t{\n\t\t\tSystem.out.println("Lucky Word");\n\t\t\tSystem.out.println(n);\n\t\t}\n\t\telse if(n==0 || n==1)\n\t\t{\n\t\t\tSystem.out.println("No Answer");\n\t\t\tSystem.out.println(0);\n\t\t}\n\t\telse\n\t\t{\n\t\tfor(int i=2;i&lt;n;i++)\n\t\t{   \n\t\t\tif(n%i==0)\n\t\t\t{\n\t\t\t\tSystem.out.println("No Answer");\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(i==n-1)\n\t\t\t{\n\t\t\t\tSystem.out.println("Lucky Word");\n\t\t\t\tSystem.out.println(n);\n\t\t\t}\n\t\t}\n\t\t}\n\t}\n\n}\r\n</textarea>	272
271	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　为丰富男生节活动，贵系女生设置彩票抽奖环节，规则如下：\n  <br> 　　1、每张彩票上印有7个各不相同的号码，且这些号码的取值范围为[1, 33]；\n  <br> 　　2、每次在兑奖前都会公布一个由七个互不相同的号码构成的中奖号码；\n  <br> 　　3、共设置7个奖项，特等奖和一等奖至六等奖。兑奖规则如下：\n  <br> 　　特等奖：要求彩票上的7个号码都出现在中奖号码中；\n  <br> 　　一等奖：要求彩票上的6个号码出现在中奖号码中；\n  <br> 　　二等奖：要求彩票上的5个号码出现在中奖号码中；\n  <br> 　　……\n  <br> 　　六等奖：要求彩票上的1个号码出现在中奖号码中；\n  <br> 　　注：不考虑号码出现的顺序，例如若中奖号码为23 31 1 14 19 17 18，则彩票12 8 9 23 1 16 7由于其中有两个号码（23和1）出现在中奖号码中，所以该彩票中了五等奖。\n  <br> 　　现已知中奖号码和李华买的若干彩票的号码，请你写一个程序判断他的彩票中奖情况。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行一个正整数n，表示彩票数量，第二行7个整数，表示中奖号码，下面n行每行7个整数，描述n张彩票。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　7个空格隔开的数字，第1个数字表示特等奖的中奖张数，第2个数字表示一等奖的中奖张数，第3个数字表示二等奖的中奖张数……第7个数字表示六等奖的中奖张数。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3\n  <br> 1 2 3 4 5 6 7\n  <br> 11 12 13 14 15 16 17\n  <br> 12 13 14 15 16 17 18\n  <br> 8 7 10 9 31 30 29\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  0 0 0 0 0 0 1\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　30%的数据n&lt;=100；\n  <br> 　　70%的数据n&lt;=1000；\n  <br> 　　100%的数据n&lt;=100000。\n  <br> \n  <br> 　　*****提示：数组定义为全局变量，可以分配更多内存。*****\n </div> \n</div>	<textarea id="codelinesc">\r\n/*\n问题描述\n　　为丰富男生节活动，贵系女生设置彩票抽奖环节，规则如下：\n　　1、每张彩票上印有7个各不相同的号码，且这些号码的取值范围为[1, 33]；\n　　2、每次在兑奖前都会公布一个由七个互不相同的号码构成的中奖号码；\n　　3、共设置7个奖项，特等奖和一等奖至六等奖。兑奖规则如下：\n　　特等奖：要求彩票上的7个号码都出现在中奖号码中；\n　　一等奖：要求彩票上的6个号码出现在中奖号码中；\n　　二等奖：要求彩票上的5个号码出现在中奖号码中；\n　　……\n　　六等奖：要求彩票上的1个号码出现在中奖号码中；\n　　注：不考虑号码出现的顺序，例如若中奖号码为23 31 1 14 19 17 18，则彩票12 8 9 23 1 16 7由于其中有两个号码（23和1）出现在中奖号码中，所以该彩票中了五等奖。\n　　现已知中奖号码和李华买的若干彩票的号码，请你写一个程序判断他的彩票中奖情况。\n输入格式\n　　第一行一个正整数n，表示彩票数量，第二行7个整数，表示中奖号码，下面n行每行7个整数，描述n张彩票。\n输出格式\n　　7个空格隔开的数字，第1个数字表示特等奖的中奖张数，第2个数字表示一等奖的中奖张数，第3个数字表示二等奖的中奖张数……第7个数字表示六等奖的中奖张数。\n样例输入\n3\n1 2 3 4 5 6 7\n11 12 13 14 15 16 17\n12 13 14 15 16 17 18\n8 7 10 9 31 30 29\n样例输出\n0 0 0 0 0 0 1\n数据规模和约定\n　　30%的数据n&lt;=100；\n　　70%的数据n&lt;=1000；\n　　100%的数据n&lt;=100000。\n　　*****提示：数组定义为全局变量，可以分配更多内存。*****\n*/\n\n#include&lt;stdio.h&gt;\n\nvoid shuru( int [] , int [][7] , int , int );\nvoid js_zjpk( int [] , int [][7] , int [] , int , int );\nint pd_zjpk( int [] , int [] , int );\nvoid shuchu( int [] , int );\n\nint main(void)\n{\n\tint n ;\n\tscanf("%d", &amp;n );\n\tint zj[7] , cp[n][7] , jg[7] = { 0 } ;\n\tshuru( zj , cp , 7 , n );\n\t\n\tjs_zjpk( zj , cp , jg , 7 , n );\n\tshuchu( jg , 7 );\n\t\n\treturn 0 ;\n}\n\nvoid shuchu( int jg[] , int n )\n{\n\tint i ;\n\tfor( i = 0 ; i &lt; n ; i++ )\n\t{\n\t\tprintf("%d ", *( jg+i ) );\n\t}\n}\n\nvoid js_zjpk( int zj[] , int cp[][7] , int jg[] , int m , int n )\n{\n\tint i , j , k , he ;\n\tfor( i = 0 ; i &lt; n ; i++ )\n\t{\n\t\the = 0 ;\n\t\tfor( j = 0 ; j &lt; m ; j++ )\n\t\t{\n\t\t\tfor( k = 0 ; k &lt; m ; k++ )\n\t\t\t{\n\t\t\t\tif( cp[i][j] == zj[k] )\n\t\t\t\t{\n\t\t\t\t\the++ ;\n\t\t\t\t\tbreak ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( he != 0 )\n\t\t{\n\t\t\t++jg[7-he] ;\n\t\t}\n\t}\n}\n\nvoid shuru( int zj[] , int cp[][7] , int m , int n )\n{\n\tint i , j ;\n\tfor( i = 0 ; i &lt; m ; i++ )\n\t{\n\t\tscanf("%d", zj+i );\n\t}\n\tfor( i = 0 ; i &lt; n ; i++ )\n\t{\n\t\tfor( j = 0 ; j &lt; m ; j++ )\n\t\t{\n\t\t\tscanf("%d", &amp;cp[i][j] );\n\t\t}\n\t}\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\nint b[10],num;\nint main()\n{\n\tint n,a[10],i,j,k,c[10]={0,0,0,0,0,0,0};\n\tscanf("%d",&amp;n);\n\tfor(i=0;i&lt;7;i++)\n\t\tscanf("%d",&amp;a[i]);\n\tfor(j=0;j&lt;n;j++)\n\t{\n\t\tnum=0;\n\t\tk=0;\n\t\twhile(k&lt;7)\n\t\t{\t\n\t\t\tscanf("%d",&amp;b[k]);\n\t\t\tfor(i=0;i&lt;7;i++)\n\t           if(a[i]==b[k])\n\t\t\t\t   num++;\n\t\t\t   k++;\n\t\t}\n\t\tc[7-num]++;\n\t}\n\tfor(i=0;i&lt;7;i++)\n\t\tprintf("%d\t",c[i]);\n\tprintf("\\n");\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.IOException;\nimport java.io.InputStream;\n\nclass Scanners {\n\tprivate InputStream is = System.in;\n\n\tpublic int nextInt() {\n\t\ttry {\n\t\t\tint i;\n\n\t\t\twhile ((i = is.read()) &lt; 45 || i &gt; 57) {\n\t\t\t}\n\n\t\t\tint mark = 1, temp = 0;\n\n\t\t\tif (i == 45) {\n\t\t\t\tmark = -1;\n\t\t\t\ti = is.read();\n\t\t\t}\n\n\t\t\twhile (i &gt; 47 &amp;&amp; i &lt; 58) {\n\t\t\t\ttemp = temp * 10 + i - 48;\n\t\t\t\ti = is.read();\n\t\t\t}\n\n\t\t\treturn temp * mark;\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\treturn -1;\n\t}\n}\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanners sc = new Scanners();\n\t\tint n = sc.nextInt();\n\t\tint[] arr = new int[34];\n\t\tfor (int i = 0; i &lt; 7; i++) {\n\t\t\tarr[sc.nextInt()] = 1;\n\t\t}\n\t\tint[] res = new int[8];\n\t\tfor (int i = 0; i &lt; n; i++) {\n\t\t\tint count = 0;\n\t\t\tfor (int j = 0; j &lt; 7; j++) {\n\t\t\t\tif (arr[sc.nextInt()] == 1)\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t\tres[7 - count]++;\n\t\t}\n\t\tfor (int i = 0; i &lt; 7; i++)\n\t\t\tSystem.out.print(res[i] + " ");\n\t}\n\n}\n\r\n</textarea>	273
274	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　同在一个高中，他却不敢去找她，虽然在别人看来，那是再简单不过的事。暗恋，是他唯一能做的事。他只能在每天课间操的时候，望望她的位置，看看她倾心的动作，就够了。操场上的彩砖啊，你们的位置，就是他们能够站立的地方，他俩的关系就像砖与砖之间一样固定，无法动摇。还记得当初铺砖的工人，将整个操场按正方形铺砖（整个操场可视为R行C列的矩阵，矩阵的每个元素为一块正方形砖块），正方形砖块有两种，一种为蓝色，另一种为红色。我们定义他和她之间的“爱情指标”为最大纯色正方形的面积，请你写一个程序求出“爱情指标”。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行两个正整数R和C。\n  <br> 　　接下来R行C列描述整个操场，红色砖块用1来表示，蓝色砖块用0来表示。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　一个数，表示他和她之间的“爱情指标”。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5 8\n  <br> 0 0 0 1 1 1 0 1\n  <br> 1 1 0 1 1 1 1 1\n  <br> 0 1 1 1 1 1 0 1\n  <br> 1 0 1 1 1 1 1 0\n  <br> 1 1 1 0 1 1 0 1\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  9\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　40%的数据R,C&lt;=10;\n  <br> 　　70%的数据R,C&lt;=50;\n  <br> 　　100%的数据R,C&lt;=200;\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#define MAXSIZE 222\n\nint R, C, a[MAXSIZE][MAXSIZE];\n\nvoid newLoveIndex(int x, int y, int *sq)\n{\n\tint i, j, color, s, t;\n\t\n\tif(x+(*sq) &gt; R || y+(*sq) &gt; C){\n\t\treturn;\n\t}\n\t\n\tcolor = a[x][y];\n\tfor(i=x; i&lt; x+(*sq); i++){\n\t\t\n\t\tfor(j=y; j&lt; y+(*sq); j++){\n\t\t\t\n\t\t\tif(a[i][j] != color){\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\t\n\ts = i, t = j;\n\twhile(a[s][t] == color &amp;&amp; s &lt; R &amp;&amp; t &lt; C){\n\t\ti = s, j = t;\n\t\t\n\t\twhile(--i &amp;&amp; i&gt;= x){\n\t\t\tif(a[i][t] != color){\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(--j &amp;&amp; j&gt;= y){\n\t\t\tif(a[s][j] != color){\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t(*sq) ++, s ++, t ++;\n\t}\n}\n\nint main()\n{\n\tint i, j, k, sqrtLI, loveIndex;\n\t\n\tscanf("%d%d", &amp;R, &amp;C);\n\tfor(i=0; i&lt;R; i++){\n\t\tfor(j=0; j&lt;C; j++){\n\t\t\tscanf("%d", &amp;a[i][j]);\n\t\t}\n\t}\n\n\t\n\tsqrtLI = 1;\n\tfor(i=0; i&lt;R; i++){\n\t\tfor(j=0; j&lt;C; j++){\n\t\t\t\n\t\t\tnewLoveIndex(i, j, &amp;sqrtLI);\n\t\t}\n\t}\n\t\n\tloveIndex = sqrtLI * sqrtLI;\n\tprintf("%d", loveIndex);\n\t\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\nint r,c;\n\nint area(int a[200][200],int i,int j,int n)\n{\n\tint k,l;\n\tif(n==min(r-1,c-1))\n\t\treturn n;\n\telse\n\t{\n\t\tfor(k=0;k&lt;=n;k++)\n\t\t{\n\t\t\tif(a[i+n][j+k]!=a[i][j])\n\t\t\t{\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\t\tfor(l=0;l&lt;n;l++)\n\t\t{\n\t\t\tif(a[i+l][j+n]!=a[i][j])\n\t\t\t\treturn n;\n\t\t}\n\t\tarea(a,i,j,++n);\n\t}\n}\n\nint main()\n{\n//\tfreopen("input3(1).txt","r",stdin); \n\tint i,j,max=0,n=1,s;\n\tscanf("%d%d",&amp;r,&amp;c);\n\tint a[200][200]={-1};\n//\tmemset(a,-1,sizeof(a));\n\tfor(i=0;i&lt;r;i++)\n\t{\n\t\tfor(j=0;j&lt;c;j++)\n\t\t\tscanf("%d",&amp;a[i][j]);\n\t}\n//\tfor(i=0;i&lt;r;i++)\n//\t{\n//\t\tfor(j=0;j&lt;c;j++)\n//\t\t\tprintf("%d ",a[i][j]);\n//\t\tprintf("\\n");\n//\t}\n\tfor(i=0;i&lt;r-1;i++)\n\t{\n\t\tfor(j=0;j&lt;c-1;j++)\n\t\t{\n\t\t\tn=area(a,i,j,1);\n\t\t\tif(n&gt;max) max=n;\n//\t\t\tprintf("a[%d][%d]=%d\\n",i,j,n);\n\t\t\tif(max&gt;=c/2)\n\t\t\t\tbreak;\n\t\t}\n\t\tif(max&gt;=r/2)\n\t\t\tbreak;\n\t}\n\tprintf("%d",max*max);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.StreamTokenizer;\n\npublic class Main {\n\n\tprivate static int x, y;\n\tprivate static int arr[][] = new int[205][205];\n\tprivate static int max = 0, p, q;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tStreamTokenizer st = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n\t\tst.nextToken();\n\t\tx = (int) st.nval;\n\t\tst.nextToken();\n\t\ty = (int) st.nval;\n\n\t\tfor (int i = 1; i &lt;= x; i++) {\n\t\t\tfor (int j = 1; j &lt;= y; j++) {\n\t\t\t\tst.nextToken();\n\t\t\t\tarr[i][j] = (int) st.nval;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i &lt;= x; i++) {\n\t\t\tfor (int j = 1; j &lt;= y; j++) {\n\t\t\t\tbaosou(i, j, arr[1][i], 1);\n\t\t\t}\n\t\t}\n\n\t\tboolean is = false;\n\t\tq = q - max;\n\t\tfor (int i = p; i &gt; p - max; i--) {\n\t\t\tif (arr[p][q] != arr[p - 1][q]) {\n\t\t\t\tis = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (is)\n\t\t\tmax -= 1;\n\t\tSystem.out.println(max * max);\n\n\t}\n\n\tprivate static void baosou(int a, int b, int c, int d) {\n\n\t\tif (a &gt;= x || b &gt;= y) {\n\t\t\tif (max &lt; d) {\n\t\t\t\tp = a;\n\t\t\t\tq = b;\n\t\t\t\tmax = d;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (arr[a + 1][b] == c &amp;&amp; arr[a][b + 1] == c &amp;&amp; arr[a + 1][b + 1] == c) {\n\t\t\tbaosou(a + 1, b + 1, c, d + 1);\n\t\t} else {\n\t\t\tif (max &lt; d) {\n\t\t\t\tmax = d;\n\t\t\t\tp = a;\n\t\t\t\tq = b;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n}\r\n</textarea>	276
275	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　输入两个正整数a,b，输出a+b的值。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　两行，第一行a，第二行b。a和b的长度均小于1000位。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　一行，a+b的值。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  4\n  <br> 2\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  6\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint soi(int a[])\n{\tchar s[1100];\n\tint temp,x=0,y,z;\n\tscanf("%s",s);\n\tint i=-1;\n\twhile(s[++i])a[i]=s[i]-'0';\n\t\n\ttemp=i/2;\n\ty=i-1;\n\twhile(temp--)\n\t{\n\t\tz=a[x];\n\t\ta[x++]=a[y];\n\t\ta[y--]=z;\n\t\t\n\t}\n\treturn i;\n}\nint main()\n{\n\tint i,j,max,a[1100]={0},b[1100]={0},c[1100]={0},temp;\n\ti=soi(a)-1;\n\tj=soi(b)-1;\n\tfor(max=0;max&lt;=(i&gt;j?i:j);max++)\n\t\t{\n\t\t\ttemp=a[max]+b[max]+c[max];\n\t\t\tc[max]=temp%10;\n\t\t\tc[max+1]=temp/10;\n\t\t}\n\t\tc[(i=i&gt;j?i:j)+1]&gt;0?i++:i;\n\twhile(i&gt;=0)\n\tprintf("%d",c[i--]);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nint main(){\n\tchar a[1001],b[1002],c[1005];\n\tcin&gt;&gt;a&gt;&gt;b;\n\tint ii=strlen(a)-1;\n\tint jj=strlen(b)-1;\n\tint i=0;int r=0;int x;\n\twhile(ii&gt;=0&amp;&amp;jj&gt;=0){\n\t\tx=a[ii]-'0'+b[jj]-'0'+r;\n\t\tr=x/10;\n\t\tx=x%10;\n\t\tc[i]=x+'0';\n\t\tii--;jj--;i++;\t\t\n\t}\n\twhile(ii&gt;=0){\n\t\tx=a[ii]-'0'+r;\n\t\tr=x/10;\n\t\tx=x%10;\n\t\tc[i]=x+'0';\n\t\tii--;i++;\n\t}\n\twhile(jj&gt;=0){\n\t\tx=b[jj]-'0'+r;\n\t\tr=x/10;\n\t\tx=x%10;\n\t\tc[i]=x+'0';\n\t\tjj--;i++;\n\t}\n\tif(r!=0){\n\t\tc[i]=r+'0';\n\t\ti++;\n\t}\n\tc[i]='\\0';\n\ti--;\t\n\tint j=0;\n\twhile(j&lt;i){\n\t\tchar y=c[j];\n\t\tc[j]=c[i];\n\t\tc[i]=y;\n\t\tj++;i--;\t\t\n\t}\n\tcout&lt;&lt;c&lt;&lt;endl;\n\t\n\t\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.math.BigInteger;\nimport java.io.*;\npublic class Main{\n\tpublic static void main(String[] args) throws IOException \n\t{\n\t\tBufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n\t\tString a=bf.readLine();\n\t\tString b=bf.readLine();\n\t\tBigInteger a1=new BigInteger(a);\n\t\tBigInteger b1=new BigInteger(b);\n\t\t\n\t\ta1=a1.add(b1);\n\t\t\n\t\tSystem.out.println(a1);\n\t}\n\n}\r\n</textarea>	277
276	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　在一个有限的正整数序列中，有些数会多次重复出现在这个序列中。\n  <br> 　　如序列：3，1，2，1，5，1，2。其中1就出现3次，2出现2次，3出现1 次，5出现1次。\n  <br> 　　你的任务是对于给定的正整数序列，从小到大依次输出序列中出现的数及出现的次数。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行正整数n，表示给定序列中正整数的个数。\n  <br> 　　第二行是n 个用空格隔开的正整数x，代表给定的序列。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　若干行，每行两个用一个空格隔开的数，第一个是数列中出现的数，第二个是该数在序列中出现的次数。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  12\n  <br> 8 2 8 2 2 11 1 1 8 1 13 13\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  1 3\n  <br> 2 3\n  <br> 8 3\n  <br> 11 1\n  <br> 13 2\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　数据：n&lt;=1000；0&lt;x&lt;=1000,000。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n\tint i,m,n,a[1000],count=0,totalcount=0;\n\tscanf("%d",&amp;n);\n\tfor(i=0;i&lt;n;i++)\n\tscanf("%d",&amp;a[i]);\n\tfor(m=1;totalcount&lt;n;m++)\n\t{\n\t\tcount=0;\n\t\tfor(i=0;i&lt;n;i++)\n\t\tif(a[i]==m)\n\t\t{\n\t\t\tcount++;\n\t\t\ttotalcount++;\n\t\t}\n\t\tif(count!=0)\n\t\t{\n\t\t\tprintf("%d %d",m,count);\n\t\t\tprintf("\\n");\n\t\t}\n\t}\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;stdio.h&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nint main()\n{\n\tint a[1000],i,j=0,b[1000]={0},n,sum=1,x=0;\n\tscanf("%d",&amp;n);\n\tfor(i=0;i&lt;n;i++)scanf("%d",&amp;a[i]);\n\tsort(a,a+n);\n\tfor(i=0;i&lt;n;i++)\n\t\t{\n\t\t\tif(a[i]==a[i+1])sum++;\n\t\t\telse b[j++]=sum,sum=1;\n\t\t}\n\tfor(i=0;i&lt;j;i++)\n\t{\n\t\tx+=b[i];\n\t\tprintf("%d %d\\n",a[x-1],b[i]);\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.StreamTokenizer;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tStreamTokenizer st = new StreamTokenizer(new BufferedReader(\n\t\t\t\tnew InputStreamReader(System.in)));\n\n\t\tst.nextToken();\n\t\tint n = (int) st.nval;\n\n\t\tMap&lt;Integer, Integer&gt; map = new LinkedHashMap&lt;Integer, Integer&gt;();\n\t\tint m;\n\t\tfor (int i = 0; i &lt; n; i++) {\n\t\t\tst.nextToken();\n\t\t\tm = (int) st.nval;\n\t\t\tif (map.containsKey(m))\n\t\t\t\tmap.put(m, map.get(m) + 1);\n\t\t\telse\n\t\t\t\tmap.put(m, 1);\n\t\t}\n\n\t\tArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\n\t\tlist.addAll(map.keySet());\n\t\tCollections.sort(list);\n\t\tint key;\n\t\tfor (int i = 0; i &lt; list.size(); i++) {\n\t\t\tkey = list.get(i);\n\t\t\tSystem.out.println(key + " " + map.get(key));\n\t\t}\n\t}\n}\n\r\n</textarea>	278
277	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　3000米长跑时，围观党们兴高采烈地预测着最后的排名。因为他们来自不同的班，对所有运动员不一定都了解，于是他们分别对自己了解的一些运动员的实力作出了评估，即对部分运动员做了相对排名的预测，并且告诉了可怜留守的班长。因为无聊，于是他们就组团去打Dota去了。比赛结束后他们向班长询问最后的排名，但班长不记得了，只记得他们中哪些人的预测是正确的，哪些人的预测是错误的。他们想知道比赛的排名可能是什么。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行两个整数n， m，n为运动员数量，m为围观党数量。运动员编号从0到n-1。\n  <br> 　　接下来m行，每行为一个围观党的相对排名预测。每行第一个数c表示他预测的人数，后面跟着c个0~n-1的不同的数，表示他预测的运动员相对排名，最后还有一个数，0表示这个预测是错误的，1表示是正确的。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　第一行一个数k为有多少种排名的可能。\n  <br> 　　下面k行，每行一个0~n-1的排列，为某一个可能的排名，相邻的数间用空格隔开。所有排名按字典序依次输出。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  Input Sample 1:\n  <br> 3 2\n  <br> 2 0 1 1\n  <br> 2 1 2 0\n  <br> \n  <br> Input Sample 2:\n  <br> 3 2\n  <br> 2 0 1 1\n  <br> 2 2 1 0\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  Output Sample 1:\n  <br> 2\n  <br> 0 2 1\n  <br> 2 0 1\n  <br> \n  <br> Output Sample 2:\n  <br> 1\n  <br> 0 1 2\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　1&lt;=n&lt;=10, 2&lt;=c&lt;=n, 1&lt;=m&lt;=10，保证数据合法，且答案中排名可能数不超过20000。对于一个排名序列，一个预测是正确的，当且仅当预测的排名的相对顺序是排名序列的一个子序列。一个预测是错误的，当且仅当这个预测不正确。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;string.h&gt;\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n\nint str[15][15];\nint ctr[15];\nint use[15];\nint graph[20001][15];\nint Size;\nint m,n;\nint Judge()//匹配判断\n{\n    int f_1=1;\n    int f_2=1;\n    int i;\n    for(i=0; i&lt;m; i++)\n    {\n        if(str[i][str[i][0]+1]==1&amp;&amp;f_1)\n        {\n            int j=1;\n            int x;\n            for(x=0; j&lt;=str[i][0]&amp;&amp;x&lt;n; x++)\n            {\n                if(str[i][j]==ctr[x])\n                    j++;\n            }\n            if(j&lt;str[i][0]+1)\n                f_1=0;\n        }\n        else\n        {\n            int j=1;\n            int x;\n            for(x=0; j&lt;=str[i][0]&amp;&amp;x&lt;n; x++)\n            {\n                if(str[i][j]==ctr[x])\n                    j++;\n            }\n            if(j==str[i][0]+1)\n                f_2=0;\n\n        }\n        if(!f_1||!f_2)\n            break;\n    }\n\n        if(f_1&amp;&amp;f_2)\n            return 1;\n        else\n            return 0;\n\n}\nvoid DFS(int x)//递归搜索\n{\n    if(x==n&amp;&amp;Judge())//结束条件\n    {\n    \tint i;\n        for(i=0; i&lt;n; i++)\n        {\n            graph[Size][i]=ctr[i];\n        }\n            Size++;\n\n\n    }\n    if(x&lt;n)\n    {\n    \tint i;\n        for(i=0; i&lt;n; i++)\n        {\n            if(use[i])\n            {\n                ctr[x]=i;\n                use[i]=0;\n                DFS(x+1);\n                use[i]=1;\n            }\n        }\n    }\n}\nint main()\n{\n\n    while(scanf("%d%d",&amp;n,&amp;m)!=EOF)\n    {\n\n        int i,j;\n        for(i=0; i&lt;m; i++)\n        {\n            scanf("%d",&amp;str[i][0]);\n            for(j=1; j&lt;=str[i][0]+1; j++)\n            {\n                scanf("%d",&amp;str[i][j]);\n            }\n\n        }\n        memset(use,1,sizeof(use));//初始化\n        Size=0;\n        DFS(0);//从第零号球员开始搜\n        printf("%d\\n",Size);\n        for(i=0; i&lt;Size; i++)\n        {\n            for(j=0; j&lt;n; j++)\n            {\n                printf("%d ",graph[i][j]);\n            }\n            printf("\\n");\n        }\n    }\n    return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nint w[20001][11];\nint main()\n{ int i,d,o,t,v,j,n,m,x,z,q=0;\n  int p[10],a[100][100]={0},c[100];\n  cin&gt;&gt;n&gt;&gt;m; \n  for (i=0;i&lt;n;i++) p[i]=i;\n  for (i=0;i&lt;m;i++)\n   {\n   \t  cin&gt;&gt;d;\n   \t  for (j=0;j&lt;d;j++)\n   \t  {\n   \t    cin&gt;&gt;x;\n   \t    a[i][x]=j+1;\n   \t  }\n   \t  cin&gt;&gt;c[i];\n   }\n   do\n   {\n   \tv=0;\n   \tfor (i=0;i&lt;m;i++)\n   \t{\n   \t\tif (c[i])\n\t\t{\n\t\t\tz=1; o=0;\n\t\t\tfor (j=0;j&lt;n;j++)\n\t\t\t{\n\t\t\t   t=a[i][p[j]];\n\t\t\t    if (t==z) z=z+1; \n\t\t\t    else if (t!=0) \n\t\t\t    {\n\t\t\t     o=1;\n\t\t\t     break;\n\t\t\t    }\n\t\t\t} \n\t\t}\n\t\telse \n\t\t{\n\t\t     z=1; o=1;\n\t\t\tfor (j=0;j&lt;n;j++)\n\t\t\t{\n\t\t\t   t=a[i][p[j]];\n\t\t\t    if (t==z) z=z+1; \n\t\t\t     else if (t!=0) \n\t\t\t     {\n\t\t\t     o=0;\n\t\t\t     break;\n\t\t\t     }\t\n\t\t\t} \n\t\t} \n      if (o) { v=1; break;}\n    } \n   if (!v) \n\t  {\n\t  \tfor (i=0;i&lt;n;i++) w[q][i]=p[i];\n\t  \tq++;\n      }\n   }while (+next_permutation(p,p+n));\n   cout&lt;&lt;q&lt;&lt;endl;\n   for (i=0;i&lt;q;i++)\n    {\n    \tfor (j=0;j&lt;n;j++)\n    \t cout&lt;&lt;w[i][j]&lt;&lt;' ';\n    \t cout&lt;&lt;endl;\n    }\n  return 0;\n}\n\n\r\n</textarea>	<textarea id="codelinesjava">\r\n\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int n,m;\n\tstatic int[][] fg;\n\tstatic int sum=0;\n\tstatic int[][] jieguo;\n\tstatic boolean[] bl;\n\tpublic static void main(String[] args) {\n\t\tScanner scan=new Scanner(System.in);\n\t\tn=scan.nextInt();\n\t\tm=scan.nextInt();\n\t\tfg=new int[m][12];\n\t\tint[] sai=new int[n];\n\t\tbl=new boolean[n];\n\t\tfor(int i=0;i&lt;bl.length;i++)\n\t\t\tbl[i]=true;\n\t\tjieguo=new int[20000][n];\n\t\tfor(int i=0;i&lt;m;i++)\n\t\t{\n\t\t\tfg[i][0]=scan.nextInt();\n\t\t\tfor(int j=1;j&lt;fg[i][0]+2;j++)\n\t\t\t{\n\t\t\t\tfg[i][j]=scan.nextInt();\n\t\t\t}\n\t\t}\n\t\tf(0, sai);\n\t\tSystem.out.println(sum);\n\t\tfor(int i=0;i&lt;sum;i++)\n\t\t{\n\t\t\tfor(int j=0;j&lt;n;j++)\n\t\t\t{\n\t\t\t\tSystem.out.print(jieguo[i][j]+" ");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\tpublic static boolean panduan(int[] sai) {\n\t\tfor(int i=0;i&lt;m;i++)\n\t\t{\n\t\t\tint h=1;\n\t\t\tfor(int j=0;j&lt;sai.length;j++)\n\t\t\t{\n\t\t\t\tif(sai[j]==fg[i][h])\n\t\t\t\t{\n\t\t\t\t\th++;\n\t\t\t\t\tif(h==fg[i][0]+1) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!(h==fg[i][0]+1&amp;&amp;fg[i][fg[i][0]+1]==1)&amp;&amp;!(h!=fg[i][0]+1&amp;&amp;fg[i][fg[i][0]+1]==0))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tpublic static void f(int start,int[] sai) {\n\t\tif(start==n)\n\t\t{\n\t\t\tif(panduan(sai))\n\t\t\t{\n\t\t\t\tfor(int i=0;i&lt;sai.length;i++)\n\t\t\t\t\tjieguo[sum][i]=sai[i];\n\t\t\t\tsum++;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tfor(int i=0;i&lt;n;i++)\n\t\t{\n\t\t\tif(bl[i])\n\t\t\t{\n\t\t\t\tbl[i]=false;\n\t\t\t\tsai[start]=i;\n\t\t\t\tf(start+1, sai);\n\t\t\t\tbl[i]=true;\n\t\t\t}\t\n\t\t}\n\t}\n}\r\n</textarea>	279
278	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　达达在陶陶的影响下，也对学习慢慢的产生了兴趣。\n  <br> 　　他在每次考试之后，都会追着老师问，自己在班级的总名次是多少。考试一多，老师也不耐烦了，于是他给了达达所有人的成绩，让他自己去算出自己的排名。\n  <br> 　　可人太多了，达达也无法立即算出来，于是他想让你帮帮他。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行为一个整数N，代表班级的学生总数。\n  <br> 　　接下来N行，每行一个字符串，代表一个学生的姓名，第一行总是DaDa。\n  <br> 　　接下来一行一个整数M，代表一共有M次考试。\n  <br> 　　每次考试有N行，每行有以一个空格分隔的一个正整数S和一个字符串P，代表名字为P的学生在这次考试中得了S分。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　一共M行，每行一个整数，代表达达在班级里的排名，排名是这一次考试过后的所有考试总分排名，如果达达和别人并列，达达总是排在前面。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3\n  <pre class="pddata">\n<span lang="EN-US" style="font-family:" courier new"">DaDa\n    <o:p></o:p></span>\n</pre> \n  <pre class="pddata">\n<span lang="EN-US" style="font-family:" courier new"">A\n    <o:p></o:p></span>\n</pre> \n  <pre class="pddata">\n<span lang="EN-US" style="font-family:" courier new"">B\n    <o:p></o:p></span>\n</pre> \n  <pre class="pddata">\n<span lang="EN-US" style="font-family:" courier new"">2\n    <o:p></o:p></span>\n</pre> \n  <pre class="pddata">\n<span lang="EN-US" style="font-family:" courier new"">49 DaDa\n    <o:p></o:p></span>\n</pre> \n  <pre class="pddata">\n\n   <st1:chmetcnv tcsc="0" numbertype="1" negative="False" hasspace="True" sourcevalue="49" unitname="a" w:st="on">\n    <span lang="EN-US" style="font-family:" courier new"">49 A</span>\n   </st1:chmetcnv><span lang="EN-US" style="font-family:" courier new"">\n    <o:p></o:p></span>\n</pre> \n  <pre class="pddata">\n<span lang="EN-US" style="font-family:" courier new"">48 B\n    <o:p></o:p></span>\n</pre> \n  <pre class="pddata">\n\n   <st1:chmetcnv tcsc="0" numbertype="1" negative="False" hasspace="True" sourcevalue="80" unitname="a" w:st="on">\n    <span lang="EN-US" style="font-family:" courier new"">80 A</span>\n   </st1:chmetcnv><span lang="EN-US" style="font-family:" courier new"">\n    <o:p></o:p></span>\n</pre> \n  <pre class="pddata">\n<span lang="EN-US" style="font-family:" courier new"">85 B\n    <o:p></o:p></span>\n</pre> \n  <br> 83 DaDa\n  <pre class="pddata">\n<span class="Apple-style-span" style="font-family: 'Courier New'; "> </span><span class="Apple-style-span" style="font-family: 'Courier New'; "><br type="_moz"></span>【样例输出】\n1\n2\n</pre> \n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　N &lt;= 100，名字长度不超过30，分数不超过100\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdlib.h&gt;\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nstruct \n{\n  int s;\n  char p[35];\n}score[101],score1,scor[101];\nint main(){\n    int n,m,i,j,k;\n    //char name[101][35];\n    scanf("%d",&amp;n);\n    for(i=0;i&lt;n;i++){\n      scor[i].s=0; \n    }\n    for(i=0;i&lt;n;i++){\n        scanf("%s",scor[i].p);\n    }\n    scanf("%d",&amp;m);\n    for(k=0;k&lt;m;k++){\n       for(j=0;j&lt;n;j++){\n          scanf("%d%s",&amp;score[j].s,score[j].p);\n          for(i=0;i&lt;n;i++){\n            if(strcmp(score[j].p,scor[i].p)==0)\n               scor[i].s+=score[j].s;\n          //printf("%d%s",score[j].s,score[j].p);\n         }    \n       }\n       for(i=0;i&lt;n;i++){\n          for(j=i;j&lt;n;j++){\n              if(scor[i].s&lt;=scor[j].s){\n                  //score1.s=score[i].s;\n                  //score[i].s=score[j].s;\n                  //score[j].s=score1.s;\n                  //score1.p=score[i].p;\n                  //score[i].p=score[j].p;\n                  //score[j].p=score1.p;\n                  score1=scor[i];\n                  scor[i]=scor[j];\n                  scor[j]=score1;\n              }\n          } \n       }\n       for(i=0;i&lt;n;i++){\n           //printf("%d%s\\n",score[i].s,score[i].p);\n           if(strcmp(scor[i].p,"DaDa")==0){\n             int k=i;\n             while(scor[k].s==scor[i-1].s){\n                 i--;\n             }\n             break;    \n           }\n       }\n       printf("%d\\n",i+1);\n    }\n    system("pause");\n    return 0; \n}\r\n</textarea>	<textarea id="codelinescpp">\r\n# include &lt;stdio.h&gt;\n# include &lt;string.h&gt;\n# include &lt;algorithm&gt;\nusing namespace std;\n\nstruct student{\n\tint grade;\t\n\tchar s[40];\n};\n\nstruct student stu[110];\nint compare(struct student a, struct student b){\n\treturn a.grade&gt;b.grade;\n}\n\nint main(){\n\tint n, i, j, k, m, ans, num;\n\tchar s[40];\n\tscanf("%d", &amp;n);\n\tgetchar();\n\tfor(i=1; i&lt;=n; i++){\n\t\tscanf("%s", stu[i].s);\n\t\tgetchar();\n\t}\n\tfor(i=1; i&lt;=n; i++){\n\t\tstu[i].grade=0;\n\t}\n\tchar des[10]="DaDa";\n\tscanf("%d", &amp;m);\n\tgetchar();\n\tfor(i=1; i&lt;=m; i++){\n\t\tfor(j=1; j&lt;=n; j++){\n\t\t\tscanf("%d ", &amp;num);\n\t\t\tscanf("%s", s);\n\t\t\tgetchar();\n\t\t\tfor(k=1; k&lt;=n; k++){\n\t\t\t\tif(strcmp(s, stu[k].s)==0){\n\t\t\t\t\tstu[k].grade=stu[k].grade+num;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(stu+1, stu+1+n, compare);\n\t\tfor(j=1; j&lt;=n; j++){\n\t\t\tif(strcmp(stu[j].s, des)==0){\n\t\t\t\tans=j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(k=j-1; k&gt;=1; k--){\n\t\t\tif(stu[k].grade==stu[j].grade){\n\t\t\t\tans--;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf("%d\\n", ans);\n\t}\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main{\n\n\t/**\n\t * @author linfan\n\t */\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=Integer.parseInt(sc.nextLine());\n\t\tString[] name=new String[n];\n\t\tfor (int i = 0; i &lt; n; i++) {\n\t\t\tname[i]=sc.nextLine();\n\t\t}\n\t\tint m=Integer.parseInt(sc.nextLine());\n\t\tint[] score=new int[n];\n\t\tint[] score1=new int[n];\n\t\tint[] p=new int[m];\n\t\tint DaDaScore=0;\n\t\tMap&lt;String,Integer&gt; map=new HashMap&lt;String, Integer&gt;();\n\t\tfor (int i = 0; i &lt; m; i++) {\n\t\t\tfor (int j = 0; j &lt; n; j++) {\n\t\t\t\tString[] ss=sc.nextLine().split(" ");\n\t\t\t\tif(map.get(ss[1])!=null){\n\t\t\t\t\tscore[j]=map.get(ss[1])+Integer.parseInt(ss[0]);\n\t\t\t\t\tmap.put(ss[1], score[j]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tscore[j]=Integer.parseInt(ss[0]);\n\t\t\t\t\tmap.put(ss[1], score[j]);\n\t\t\t\t}\n\t\t\t\tscore1[j]=score[j];\n\t\t\t\tif(ss[1].equals("DaDa")){\n\t\t\t\t\tDaDaScore=score[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.sort(score1);\n\t\t\tfor (int j = score1.length-1; j &gt;=0; j--) {\n\t\t\t\tif(score1[j]==DaDaScore){\n\t\t\t\t\tp[i]=n-j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i &lt; p.length; i++) {\n\t\t\tSystem.out.println(p[i]);\n\t\t}\n\t}\n\n}\r\n</textarea>	280
279	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　某寝室的同学们在学术完之后准备玩一个游戏：游戏是这样的，每个人头上都被贴了一张白色或者黑色的纸，现在每个人都会说一句话“我看到x张白色纸条和y张黑色的纸条”，又已知每个头上贴着白色纸的人说的是真话、每个头上贴着黑色纸的人说的是谎话，现在要求你判断哪些人头上贴着的是白色的纸条，如果无解输出“NoSolution.”；如果有多组解，则把每个答案中贴白条的人的编号按照大小排列后组成一个数（比如第一个人和第三个人头上贴着的是白纸条，那么这个数就是13；如果第6、7、8个人都贴的是白纸条，那么这个数就是678）输出最小的那个数（如果全部都是黑纸条也满足情况的话，那么输出0）\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行为一个整数n，接下来n行中的第i行有两个整数x和y，分别表示第i个人说“我看到x张白色纸条和y张黑色的纸条”。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　一行。如果无解输出“NoSolution.”。否则输出答案中数值（具体见问题描述）最小的那个，如果全部都是黑纸条也满足情况的话，那么输出0\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  2\n  <br> 1 0\n  <br> 1 0\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  0\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5\n  <br> 3 1\n  <br> 0 4\n  <br> 1 3\n  <br> 4 0\n  <br> 1 3\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  35\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　n&lt;=8\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\nint n;\nint x[8],y[8];\nint isok(int a[],int num,int value) //第i个人的话是否成立  num为人下标  value 为 0白  或者  1黑 \n{\n\tint black=0,white=0,i; \n\tfor(i=0;i&lt;n;i++)\n\t{\n\t\tif(i!=num)\n\t\t{\n\t\t\tif(a[i]) black++; //黑色 \n\t\t\telse white++;  //白色 \n\t\t}\n\t}\n\tif(value)  //黑 \n\t{\n\t\tif(x[num]==white &amp;&amp; y[num]==black) return 0;\n\t\telse return 1;\n\t\t\n\t}\n\telse //白\n\t{\n\t\tif(x[num]==white &amp;&amp; y[num]==black) return 1;\n\t\telse return 0;\n\t} \n}\n\nint main()\n{\n\tint i,j,k,sign,min=90000000,num;\n\tint a[8],b[8];\n\tscanf("%d",&amp;n);\n\tfor(i=0;i&lt;n;i++)\n\tscanf("%d%d",x+i,y+i);\n\tfor(i=0;i&lt;pow(2,n);i++)\n\t{\n\t\tk=i;\n\t\tfor(j=0;j&lt;n;j++)\n\t\t{\n\t\t\ta[j]=k%2;\n\t\t\tk/=2;\n\t\t}\n\t\tsign=1;\n\t\tfor(j=0;j&lt;n;j++)\n\t\t{\n\t\t\tif(isok(a,j,a[j])==0)\n\t\t\t{\n\t\t\t\tsign=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(sign)\n\t\t{\n\t\tk=1;\n\t\tnum=0;\n\t\tfor(j=n-1;j&gt;=0;j--)\n\t\t{\n\t\t\tif(a[j]==0) \n\t\t\t{\n\t\t\t\tnum+=k*(j+1);\n\t\t\t\tk*=10;\n\t\t\t}\n\t\t}\n\t\tif(num&lt;min) min=num;\t\t\n\t\t}\n\t}\n\tif(min==90000000) printf("NoSolution.");\n\telse\n\t{\n\t\tfor(i=0;i&lt;n;i++)\n\t\tb[i]=1;\n\t\tfor(i=0;i&lt;n;i++)\n\t\t{\n\t\t\tif(isok(b,i,b[i])==0) \n\t\t\t{\n\t\t\t\tsign=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(sign==0) printf("%d",min);\n\t\telse  printf("0");\n\t}\n\t\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n#include&lt;math.h&gt;\nint mt[9][2],n;\nint max[9]={9};\nint xl[9]={9};\nbool ifc();\nint main()\n{\n\tint i,j,m,fi,k,flag;\n\tscanf("%d",&amp;n);\n\tfor(i=1;i&lt;=n;i++) scanf("%d %d",&amp;mt[i][0],&amp;mt[i][1]);\n\tm=pow(2,n);\n\tfor(i=0;i&lt;m;i++)\n\t{\n\tfor(fi=i,j=1,xl[0]=0;j&lt;=n;j++)\n\t{\n\t\txl[j]=fi&amp;1;\n\t\tfi&gt;&gt;=1;\n\t\tif(xl[j]) xl[0]++;//真话数量 \n\t}\n\tif(xl[0]&gt;max[0]) continue;\n\tif(ifc())//成立 \n\t{\n//\t\tfor(k=1;k&lt;=n;k++) printf("%d",xl[k]);\n//\t\tprintf(" :%d\\n",xl[0]);\n\t\tif(max[0]==xl[0])\n\t\t{\n\t\t\tfor(flag=k=1;k&lt;=n;k++)\n\t\t\t{\n\t\t\t\tif(max[k]&gt;xl[k])\n\t\t\t\t{\n\t\t\t\t\tflag=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(max[k]&lt;xl[k])\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!flag) continue;\n\t\t}\n\t\tfor(k=0;k&lt;=n;k++) max[k]=xl[k];\n\t}\n\t}\n\tif(max[0]==9) printf("NoSolution.\\n");\n\telse if(max[0]==0) printf("0\\n");\n\telse\n\t{\n\tfor(i=1;i&lt;=n;i++) if(max[i]) printf("%d",i);\n\tputchar('\\n');\n\t}\n}\nbool ifc()\n{\n\tint i;\n\tfor(i=1;i&lt;=n;i++)\n\t{\n\t\tif(xl[i])//若此人说真话 \n\t\t{\n\t\t\tif(mt[i][0]!=xl[0]-1) return false; \n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(mt[i][0]==xl[0]) return false;\n\t\t}\n\t}\n\treturn true;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String args[]) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint[][] xy;\n\t\tint n, x, y;\n\n\t\tn = scanner.nextInt();\n\t\txy = new int[n + 1][2];\n\t\tfor (int i = 1; i &lt; n + 1; i++) {\n\t\t\txy[i][0] = scanner.nextInt();\n\t\t\txy[i][1] = scanner.nextInt();\n\t\t}\n\n\t\tString[] result = new String[n + 1];\n\t\tint flag = 1;\n\t\tfor (int i = 1; i &lt; n + 1; i++) {\n\t\t\t// 是否为全黑标志位\n\t\t\tif (xy[i][0] == 0 &amp;&amp; xy[i][1] == n - 1)\n\t\t\t\tflag = 0;\n\n\t\t\tresult[i] = "" + i;\n\t\t\tfor (int a = 1; a &lt; n + 1; a++) {\n\t\t\t\tif(a == i)continue ;\n\t\t\t\tif (xy[i][0] == xy[a][0] &amp;&amp; xy[i][1] == xy[a][1]) {\n\t\t\t\t\t\n\t\t\t\t\tif(xy[i][0] == 0){\n\t\t\t\t\t\tresult[0] = a&lt;i ? ""+a : ""+i ;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (result[i].length() &lt; (xy[i][0]+1))\n\t\t\t\t\t\tresult[i] = result[i] + a;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (flag == 1) {\n\t\t\tSystem.out.println(0);\n\t\t} else {\n\t\t\tint temp = 100000000;\n\t\t\tfor (int i = 1; i &lt;= n; i++) {\n\t\t\t\tif (result[i].length() &gt; 1) {\n\t\t\t\t\tif(temp != 100000000 &amp;&amp; String.valueOf(temp).length() &lt; result[i].length()){\n\t\t\t\t\t\ttemp = Integer.parseInt(result[i]) ;\n\t\t\t\t\t}else{\n\t\t\t\t\ttemp = temp &gt; Integer.parseInt(result[i]) ? Integer\n\t\t\t\t\t\t\t.parseInt(result[i]) : temp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (temp != 100000000) {\n\t\t\t\tSystem.out.println(temp);\n\t\t\t} else if(result[0] != null){\n\t\t\t\tSystem.out.println(result[0]) ;\n\t\t\t}else{\n\t\t\t\tSystem.out.println("NoSolution.") ;\n\t\t\t}\n\t\t}\n\t}\n}\n\r\n</textarea>	281
280	<div class="des"> \n <div class="pdcont">\n  　　种树\n </div>\n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　A城市有一个巨大的圆形广场，为了绿化环境和净化空气，市政府决定沿圆形广场外圈种一圈树。园林部门 得到指令后，初步规划出n个种树的位置，顺时针编号1到n。并且每个位置都有一个美观度Ai，如果在这里种树就可以得到这Ai的美观度。但由于A城市土壤 肥力欠佳，两棵树决不能种在相邻的位置（i号位置和i+1号位置叫相邻位置。值得注意的是1号和n号也算相邻位置！）。\n  <br> 　　最终市政府给园林部门提供了m棵树苗并要求全部种上，请你帮忙设计种树方案使得美观度总和最大。如果无法将m棵树苗全部种上，给出无解信息。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入的第一行包含两个正整数n、m。\n  <br> 　　第二行n个整数Ai。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出一个整数，表示最佳植树方案可以得到的美观度。如果无解输出“Error!”，不包含引号。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  7 3\n  <br> 1 2 3 4 5 6 7\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  15\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  7 4\n  <br> 1 2 3 4 5 6 7\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  Error!\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　对于全部数据，满足1&lt;=m&lt;=n&lt;=30；\n  <br> 　　其中90%的数据满足m&lt;=n&lt;=20\n  <br> 　　-1000&lt;=Ai&lt;=1000\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint a[31];\nint n,m,max=0;\nvoid f(int x,int he,int s,int e)\n{\n    if(s==0)\n    {\n        if(he&gt;max)\n            max=he;\n        return;\n    }\n    int i;\n    for(i=x+2;i&lt;=e-2*s+2;i++)\n        f(i,he+a[i],s-1,e);\n    return;\n}\nint main()\n{\n    scanf("%d %d",&amp;n,&amp;m);\n    if(m&gt;n/2)\n    {\n        printf("Error!");\n        return 0;\n    }\n    int i;\n    for(i=1;i&lt;=n;i++)\n        scanf("%d",&amp;a[i]);\n    for(i=1;i&lt;=n-2*m+2;i++)\n    {\n        if(i==1)\n            f(i,a[i],m-1,n-1);\n        else\n            f(i,a[i],m-1,n);\n    }\n    printf("%d",max);\n    return 0;\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n/**************Powered by Graphene Richards**************/\n//{\n\n#define FLOAT_PRECISION    "%.2f"\n#define INT_64_MOD          "%I64d"\n#define UNSIGNED_64_MOD     "%I64u"\n\n//#pragma comment(linker,"/STACK:102400000,102400000")\n#include&lt;cmath&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;bitset&gt;\n#include&lt;complex&gt;\n#include&lt;vector&gt;\n#include&lt;iomanip&gt;\n#include&lt;iostream&gt;\n#include&lt;list&gt;\n#include&lt;map&gt;\n#include&lt;queue&gt;\n#include&lt;set&gt;\n#include&lt;stack&gt;\n#include&lt;string&gt;\n#define FAST_RW ios_base::sync_with_stdio(0),cin.tie(0);\n#define IT(x) __typeof((x).begin())\n#define DIT(x) __typeof((x).rbegin())\n#define FS(i,a) for(ll i=0;a[i];i++)\n#define FE(x,ctn) for(IT(ctn)x=(ctn).begin(),_en=(ctn).end();x!=_en;x++)\n#define EF(x,ctn) for(DIT(ctn)x=(ctn).rbegin(),_en=(ctn).rend();x!=_en;x++)\n#define FR(i,en) for(ll i=0,_en=(en);i&lt;_en;i++)\n#define FOR(i,en) for(ll i=1,_en=(en);i&lt;=_en;i++)\n#define RF(i,en) for(ll i=(en)-1;i&gt;=0;i--)\n#define ROF(i,en) for(ll i=(en);i&gt;0;i--)\n#define FFR(i,x,y) for(ll i=(x),_en=(y);i&lt;=_en;i++)\n#define RFF(i,x,y) for(ll i=(x),_en=(y);i&gt;=_en;i--)\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned\n#define lf long double\n#define pc putchar\n#define pb push_back\n#define pq priority_queue\n#define fi first\n#define se second\n#define mp make_pair\n#define pii pair&lt;int,int&gt;\n#define pll pair&lt;ll,ll&gt;\n#define pdd pair&lt;double,double&gt;\n#define lb(x) (x&amp;(-x))\n#define sqr(x) (x)*(x)\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define clr(x) memset((x),0,sizeof(x))\n#define ms(x,v) memset((x),(v),sizeof(x))\n#define mc(x,y) memcpy((x),(y),sizeof(y))\n#define NL puts("");\n#define fin(x,c) ((c).find(x)!=(c).end())\nusing namespace std;\n\ntemplate&lt;class T1,class T2,class T3&gt;\nbool _IN(T1 x,T2 y,T3 z){return x&lt;=y&amp;&amp;x&gt;=z||x&lt;=z&amp;&amp;x&gt;=y;}\n\null gcd(ull a,ull b){if(!b)return a;while(b^=a^=b^=a%=b);return a;}\n\nextern const ll mod;\nll ksm(ll a,ll b){\n  ll res=1;\n  a%=mod;\n  for(;b;b&gt;&gt;=1){\n    if(b&amp;1)res=res*a%mod;\n    a=a*a%mod;\n  }\n  return res;\n}\n\n#ifdef wmx16835\n#define NOT_TESTING_TEMPLATE_CPP\n#include"wmx16835.cpp"\n#else\n#define LOG\n#define TEL\n#define PF\n#define SF(...)\n#define test(...) 0\n#define TEST(...) 0\n#define TRY(...)\n#define PP\n#define SHOW_TIME\n#endif\n\nbool S(char*a)  {return scanf("%s",a)==1;}\nbool S(int&amp;a)   {return scanf("%d",&amp;a)==1;}\nbool S(bool&amp;a)  {return scanf("%d",&amp;a)==1;}\nbool S(ui&amp;a)    {return scanf("%u",&amp;a)==1;}\nbool S(float&amp;a) {return scanf("%f",&amp;a)==1;}\nbool S(double&amp;a){return scanf("%lf",&amp;a)==1;}\nbool S(ll&amp;a)    {return scanf(INT_64_MOD,&amp;a)==1;}\nbool S(ull&amp;a)   {return scanf(UNSIGNED_64_MOD,&amp;a)==1;}\nbool S(lf&amp;a)    {double res;if(scanf("%lf",&amp;res)==-1)return 0;a=res;return 1;}\nbool S(char&amp;a)  {char res[2];if(scanf("%1s",res)==-1)return 0;a=*res;return 1;}\nbool SL(char*a) {a[0]=0;while(gets(a)&amp;&amp;!a[0]);return a[0];}\n\nvoid _P(const int&amp;x)   {printf("%d",x);}\nvoid _P(const bool&amp;x)  {printf("%d",x);}\nvoid _P(const ui&amp;x)    {printf("%u",x);}\nvoid _P(const char&amp;x)  {printf("%c",x);}\nvoid _P(const char*x)  {printf("%s",x);}\nvoid _P(const string&amp;x){printf("%s",x.c_str());}\nvoid _P(const ll&amp;x)    {printf(INT_64_MOD,x);}\nvoid _P(const ull&amp;x)   {printf(UNSIGNED_64_MOD,x);}\nvoid _P(const float&amp;x) {printf(FLOAT_PRECISION,x);}\nvoid _P(const double&amp;x){printf(FLOAT_PRECISION,x);}\nvoid _P(const lf&amp;x)    {printf(FLOAT_PRECISION,(double)x);}\n\ntemplate&lt;class T1,class T2&gt;\nbool S(T1&amp;a,T2&amp;b){return S(a)+S(b)==2;}\ntemplate&lt;class T1,class T2,class T3&gt;\nbool S(T1&amp;a,T2&amp;b,T3&amp;c){return S(a)+S(b)+S(c)==3;}\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nbool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d){return S(a)+S(b)+S(c)+S(d)==4;}\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nbool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d,T5&amp;e){return S(a)+S(b)+S(c)+S(d)+S(e)==5;}\n\ntemplate&lt;class T1&gt;\nvoid P(const T1&amp;a){_P(a);pc(' ');}\ntemplate&lt;class T1,class T2&gt;\nvoid P(const T1&amp;a,const T2&amp;b){_P(a);pc(' ');_P(b);pc(' ');}\ntemplate&lt;class T1&gt;\nvoid PN(const T1&amp;a){_P(a);NL}\ntemplate&lt;class T1,class T2&gt;\nvoid PN(const T1&amp;a,const T2&amp;b){_P(a);pc(' ');_P(b);NL}\ntemplate&lt;class T1,class T2,class T3&gt;\nvoid PN(const T1&amp;a,const T2&amp;b,const T3&amp;c){_P(a);pc(' ');_P(b);pc(' ');_P(c);NL}\ntemplate&lt;class T1,class T2,class T3,class T4&gt;\nvoid PN(const T1&amp;a,const T2&amp;b,const T3&amp;c,const T4&amp;d){_P(a);pc(' ');_P(b);pc(' ');_P(c);pc(' ');_P(d);NL}\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;\nvoid PN(const T1&amp;a,const T2&amp;b,const T3&amp;c,const T4&amp;d,const T5&amp;e){_P(a);pc(' ');_P(b);pc(' ');_P(c);pc(' ');_P(d);pc(' ');_P(e);NL}\n\ntemplate&lt;class T&gt;\nvoid PA(T*a,int n){\n  bool f=1;\n  FR(i,n){\n    if(f)f=0;\n    else pc(' ');\n    _P(a[i]);\n  }\n  NL\n}\n\ntemplate&lt;class T&gt;\nvoid PA(const T&amp;x){\n  bool f=1;\n  FE(it,x){\n    if(f)f=0;\n    else pc(' ');\n    _P(*it);\n  }\n  NL\n}\n\nint kase;\nconst double pi=4*atan(1);\nconst double ep=1e-9;\nconst int INF=0x3f3f3f3f;\nconst ll INFL=0x3f3f3f3f3f3f3f3fll;\nconst ll mod=1000000007;\n//}\n\nconst int SIZEN=200010;\nclass Position{\npublic:\n\tint dlt;\n\tint id;\n\tvoid print(void){printf("(%d %d)",dlt,id);}\n};\nvoid print(Position p){p.print();}\nbool operator &lt; (Position a,Position b){\n\tif(a.dlt==b.dlt) return a.id&gt;b.id;\n\treturn a.dlt&gt;b.dlt;\n}\nvoid erase_position(set&lt;Position&gt; &amp;S,int A[],int k){\n\tif(!k) return;\n\tset&lt;Position&gt;::iterator key=S.find((Position){A[k],k});\n\tif(key!=S.end()) S.erase(key);\n}\nint run(int A[],int N,int M){\n\tA[0]=0;\n\tstatic int pre[SIZEN],nxt[SIZEN];\n\tmemset(pre,0,sizeof(pre));\n\tmemset(nxt,0,sizeof(nxt));\n\tfor(int i=1;i&lt;N;i++){\n\t\tnxt[i]=i+1;\n\t\tpre[i+1]=i;\n\t}\n\tnxt[N]=1;pre[1]=N;\n\tstatic set&lt;Position&gt; S;\n\tS.clear();\n\tint ans=0;\n\tfor(int i=1;i&lt;=N;i++) S.insert((Position){A[i],i});\n\tfor(int i=1;i&lt;=M;i++){\n\t\tPosition now=*S.begin();S.erase(S.begin());\n\t\tans+=now.dlt;\n\t\terase_position(S,A,pre[now.id]);\n\t\terase_position(S,A,nxt[now.id]);\n\t\tA[now.id]=A[pre[now.id]]+A[nxt[now.id]]-A[now.id];\n\t\tpre[now.id]=pre[pre[now.id]];\n\t\tnxt[now.id]=nxt[nxt[now.id]];\n\t\tnxt[pre[now.id]]=pre[nxt[now.id]]=now.id;\n\t\tS.insert((Position){A[now.id],now.id});\n\t}\n\treturn ans;\n}\nint N,M;\nint A[SIZEN]={0};\nvoid work(){\n\tif(M*2&gt;N){\n\t\tprintf("Error!\\n");\n\t\treturn;\n\t}\n\tprintf("%d\\n",run(A,N,M));\n}\nvoid read(){\n\tscanf("%d%d",&amp;N,&amp;M);\n\tfor(int i=1;i&lt;=N;i++) scanf("%d",&amp;A[i]);\n}\nint main(){\n  SHOW_TIME\n\tread();\n\twork();\n}\n\n/*********Risoft corporation all rights reserved*********/\n/**************Template V2.15 build 20150402*************/\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n,m,a[],i,j,dp[][][][],num;\n\t\tn=Integer.parseInt(sc.next());\n\t\tm=Integer.parseInt(sc.next());\n\t\tnum=m+1;\n\t\tif(m&gt;n/2)System.out.println("Error!");\n\t\telse\n\t\t{\n\t\t\ta=new int[n];\n\t\t\tfor(i=0;i&lt;n;i++)a[i]=Integer.parseInt(sc.next());\n\t\t\tdp=new int[n][2][2][num];\n\t\t\tdp[0][1][0][1]=a[0];\n\t\t\tdp[0][0][1][1]=a[0];\n\t\t\tfor(i=1;i&lt;n;i++)\n\t\t\t{\n\t\t\t\tfor(j=1;j&lt;num;j++)\n\t\t\t\t{\n\t\t\t\t\tdp[i][0][0][j]=Integer.MIN_VALUE/2;\n\t\t\t\t\tdp[i][1][0][j]=Integer.MIN_VALUE/2;\n\t\t\t\t\tdp[i][0][1][j]=Integer.MIN_VALUE/2;\n\t\t\t\t\tdp[i][1][1][j]=Integer.MIN_VALUE/2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(n&gt;1)\n\t\t\t{\n\t\t\t\tdp[1][0][1][1]=a[1];\n\t\t\t\tdp[1][1][0][1]=a[0];\n\t\t\t}\n\t\t\tif(n&gt;2)\n\t\t\t{\n\t\t\t\tdp[2][1][0][1]=a[0];\n\t\t\t\tdp[2][0][1][1]=a[2];\n\t\t\t\tif(m&gt;2)dp[2][1][1][2]=a[0]+a[2];\n\t\t\t\tdp[2][0][0][1]=a[1];\n\t\t\t}\n\t\t\tfor(i=3;i&lt;n;i++)\n\t\t\t{\n\t\t\t\tfor(j=0;j&lt;num;j++)\n\t\t\t\t{\n\t\t\t\t\tdp[i][0][0][j]=max(dp[i-1][0][0][j],dp[i-1][0][1][j]);\n\t\t\t\t\tdp[i][1][0][j]=max(dp[i-1][1][0][j],dp[i-1][1][1][j]);\n\t\t\t\t\tif(j&gt;1&amp;&amp;j*2&lt;=i+1)dp[i][0][1][j]=dp[i-1][0][0][j-1]+a[i];\n\t\t\t\t\telse if(j==1)dp[i][0][1][j]=a[i];\n\t\t\t\t\tif(j&gt;1)dp[i][1][1][j]=dp[i-1][1][0][j-1]+a[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(max(dp[n-1][0][0][m], max(dp[n-1][0][1][m], dp[n-1][1][0][m])));\n\t\t}\n\t}\n\n\tprivate static int max(int i, int j) {\n\t\t// TODO Auto-generated method stub\n\t\tif(i&gt;j)return i;\n\t\telse return j;\n\t}\n\n\t\n}\n\r\n</textarea>	282
281	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　有9盏灯与9个开关，编号都是1~9。\n  <br> \n  <br> 　　每个开关能控制若干盏灯，按下一次会改变其控制的灯的状态(亮的变成不亮，不亮变成亮的)。\n  <br> \n  <br> 　　具体如下：\n  <br> \n  <br> 　　第一个开关控制第二，第四盏灯；\n  <br> \n  <br> 　　第二个开关控制第一，第三，第五盏灯；\n  <br> \n  <br> 　　第三个开关控制第二，第六盏灯；\n  <br> \n  <br> 　　第四个开关控制第一，第五，第七盏灯；\n  <br> \n  <br> 　　第五个开关控制第二，第四，第六，第八盏灯；\n  <br> \n  <br> 　　第六个开关控制第三，第五，第九盏灯；\n  <br> \n  <br> 　　第七个开关控制第四，第八盏灯；\n  <br> \n  <br> 　　第八个开关控制第五，第七，第九盏灯；\n  <br> \n  <br> 　　第九个开关控制第六，第八盏灯。\n  <br> \n  <br> 　　开始时所有灯都是熄灭的，开关是关闭着的。要求按下若干开关后，使得只有4盏灯亮着。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出所有可能的方案，每行一个方案，每一行有9个字符，从左往右第i个字符表示第i个开关的状态("0"表示关闭，"1"表示打开)，按字典序输出。下面的样例输出只是部分方案。\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  000001011\n  <br> 000001110\n  <br> 000001111\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdlib.h&gt;\n#include&lt;stdio.h&gt;\nint kai[9]={0},b[9]={0};\nvoid change(int i){\n     if(b[i]==0) b[i]=1;\n     else b[i]=0;\n    }\nint add(int a[]){\n    int i,sum=0;\n    for(i=0;i&lt;9;i++){\n        if(a[0]==1){change(1);change(3);}\n        if(a[1]==1){change(0);change(2);change(4);}\n        if(a[2]==1){change(1);change(5);}\n        if(a[3]==1){change(0);change(4);change(6);}\n        if(a[4]==1){change(1);change(3);change(5);change(7);}\n        if(a[5]==1){change(2);change(4);change(8);}\n        if(a[6]==1){change(3);change(7);}\n        if(a[7]==1){change(4);change(6);change(8);}\n        if(a[8]==1){change(5);change(7);}\n        }\n    for(i=0;i&lt;9;i++){\n        sum+=b[i];\n        } \n    return sum;  \n}\nvoid fun(int a[],int n){\n    int i,j;\n    if(n&gt;=10){\n        if(add(a)==4){\n              for(j=0;j&lt;9;j++){\n                   printf("%d",a[j]);\n                  }\n              printf("\\n");\n            }\n        return;\n        }\n    for(i=0;i&lt;2;i++){\n        a[n]=i;\n        fun(a,n+1);\n        }\n    }\nint main(){\n    fun(kai,0);\n    system("pause");\n    return 0; \n}\r\n</textarea>	<textarea id="codelinescpp">\r\n/**************Powered by Graphene Richards**************/\nextern"C++"{\n#define FLOAT_PRECISION     2\n\n#ifdef _MSC_VER\n#define _SECURE_SCL 0\n#pragma comment(linker,"/STACK:102400000,102400000")\n#else\n#pragma GCC optimize("O3")\n#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx")\n#endif\n#if defined(_MSC_VER)||__cplusplus&gt;199711L\n#define IT(x) auto\n#define DIT(x) auto\n#else\n#define IT(x) __typeof((x).begin())\n#define DIT(x) __typeof((x).rbegin())\n#endif\n\n#  inc\\\nlude&lt;cmath&gt;\n#  inc\\\nlude&lt;cstdio&gt;\n#  inc\\\nlude&lt;cstdlib&gt;\n#  inc\\\nlude&lt;cstring&gt;\n#  inc\\\nlude&lt;algorithm&gt;\n#  inc\\\nlude&lt;bitset&gt;\n#  inc\\\nlude&lt;complex&gt;\n#  inc\\\nlude&lt;vector&gt;\n#  inc\\\nlude&lt;iomanip&gt;\n#  inc\\\nlude&lt;iostream&gt;\n#  inc\\\nlude&lt;list&gt;\n#  inc\\\nlude&lt;map&gt;\n#  inc\\\nlude&lt;queue&gt;\n#  inc\\\nlude&lt;set&gt;\n#  inc\\\nlude&lt;stack&gt;\n#  inc\\\nlude&lt;string&gt;\n#define FAST_RW ios_base::sync_with_stdio(0),cin.tie(0);\n#define FS(i,a) for(ll i=0;a[i];i++)\n#define FE(it,x) for(IT(x) it=(x).begin(),_en=(x).end();it!=_en;it++)\n#define EF(it,x) for(DIT(x) it=(x).rbegin(),_en=(x).rend();it!=_en;it++)\n#define FR(i,en) for(ll i=0,_en=(en);i&lt;_en;i++)\n#define FOR(i,en) for(ll i=1,_en=(en);i&lt;=_en;i++)\n#define RF(i,en) for(ll i=(en)-1;i&gt;=0;i--)\n#define ROF(i,en) for(ll i=(en);i&gt;0;i--)\n#define FFR(i,x,y) for(ll i=(x),_en=(y);i&lt;=_en;i++)\n#define RFF(i,x,y) for(ll i=(x),_en=(y);i&gt;=_en;i--)\n#define pc putchar\n#define pb push_back\n#define ppb pop_back\n#define pq priority_queue\n#define fi first\n#define se second\n#define mp make_pair\n#define pii pair&lt;int,int&gt;\n#define pll pair&lt;ll,ll&gt;\n#define sqr(x) ((x)*(x))\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define clr(x) memset((x),0,sizeof(x))\n#define ms(x,v) memset((x),(v),sizeof(x))\n#define mc(x,y) memcpy((x),(y),sizeof(y))\n#define NL puts("");\n#define LB lower_bound\n#define UB upper_bound\n#define rand() ((rand()&lt;&lt;16)^(rand()&lt;&lt;15)^(rand()))\n#ifdef _WIN32\n#define _i64_ "%I\\\n64d"\n#define _u64_ "%I\\\n64u"\n#else\n#define _i64_ "%l\\\nld"\n#define _u64_ "%l\\\nlu"\n#endif\ntypedef unsigned ui;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lf;\nusing namespace std;\n\null gcd(ull a,ull b){if(!b)return a;while(b^=a^=b^=a%=b);return a;}\n\nextern const ll MOD;\nll ksm(ll a,ll b){\nll res=1;a%=MOD;\nfor(;b;b&gt;&gt;=1){if(b&amp;1)res=res*a%MOD;a=a*a%MOD;}\nreturn res;\n}\n\n#ifdef wmx16835\n#include"wmx16835.h"\n#else\n#define LOG\n#define TEL\n#define test(...) 0\n#define TEST(...) 0\n#define TRY(...)\n#define SF(...)\n#define SC\n#define PF\n#define PC\n#define PP\n#define SHOW_TIME\n#define BR\n#endif\nint main(){SHOW_TIME int __MAIN();__MAIN();}\n#define main __MAIN\n#define y0 NKwKGuBI\n#define y1 KFJssmlK\n#define yn XypGISMR\n#define j1 kQDCYYWX\n#define tm BdKIQNcs\n#define lr UsCPcJvt\n\ntemplate&lt;class T1,class T2,class T3&gt;bool In(T1 x,T2 y,T3 z){return x&lt;=y&amp;&amp;x&gt;=z||x&lt;=z&amp;&amp;x&gt;=y;}\ntemplate&lt;class T1,class T2&gt;T1 max(const T1&amp;a,const T2&amp;b){return a&lt;b?b:a;}\ntemplate&lt;class T1,class T2,class T3&gt;T1 max3(const T1&amp;a,const T2&amp;b,const T3&amp;c){return a&lt;b?(b&lt;c?c:b):(a&lt;c?c:a);}\ntemplate&lt;class T1,class T2&gt;T1 min(const T1&amp;a,const T2&amp;b){return a&lt;b?a:b;}\ntemplate&lt;class T1,class T2,class T3&gt;T1 min3(const T1&amp;a,const T2&amp;b,const T3&amp;c){return a&lt;b?(a&lt;c?a:c):(b&lt;c?b:c);}\n\nbool S(char*a){return scanf("%s",a)==1;}\nbool S(int&amp;a){return scanf("%d",&amp;a)==1;}\nbool S(bool&amp;a){return scanf("%d",&amp;a)==1;}\nbool S(ui&amp;a){return scanf("%u",&amp;a)==1;}\nbool S(float&amp;a){return scanf("%f",&amp;a)==1;}\nbool S(double&amp;a){return scanf("%lf",&amp;a)==1;}\nbool S(ll&amp;a){return scanf(_i64_,&amp;a)==1;}\nbool S(ull&amp;a){return scanf(_u64_,&amp;a)==1;}\nbool S(lf&amp;a){double b;if(scanf("%lf",&amp;b)==-1)return 0;a=b;return 1;}\nbool S(char&amp;a){char b[2];if(scanf("%1s",b)==-1)return 0;a=*b;return 1;}\nbool SL(char*a){a[0]=0;while(gets(a)&amp;&amp;!a[0]);return a[0];}\ntemplate&lt;class T1,class T2&gt;bool S(pair&lt;T1,T2&gt;&amp;a){S(a.fi),S(a.se);}\ntemplate&lt;class T&gt;bool S(T&amp;a){a.in();}\n\nvoid _P(const int&amp;x){printf("%d",x);}\nvoid _P(const bool&amp;x){printf("%d",x);}\nvoid _P(const ui&amp;x){printf("%u",x);}\nvoid _P(const char&amp;x){printf("%c",x);}\nvoid _P(const char*x){printf("%s",x);}\nvoid _P(const string&amp;x){printf("%s",x.c_str());}\nvoid _P(const ll&amp;x){printf(_i64_,x);}\nvoid _P(const ull&amp;x){printf(_u64_,x);}\nvoid _P(const float&amp;x){printf("%.*f",FLOAT_PRECISION,x);}\nvoid _P(const double&amp;x){printf("%.*f",FLOAT_PRECISION,x);}\nvoid _P(const lf&amp;x){printf("%.*f",FLOAT_PRECISION,(double)x);}\ntemplate&lt;class T1,class T2&gt;void _P(const pair&lt;T1,T2&gt;&amp;x){_P(x.fi);pc(' ');_P(x.se);}\ntemplate&lt;class T&gt;void _P(const T&amp;a){a.out();}\n\ntemplate&lt;class T1,class T2&gt;bool S(T1&amp;a,T2&amp;b){return S(a)+S(b)==2;}\ntemplate&lt;class T1,class T2,class T3&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c){return S(a)+S(b)+S(c)==3;}\ntemplate&lt;class T1,class T2,class T3,class T4&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d){return S(a)+S(b)+S(c)+S(d)==4;}\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d,T5&amp;e){return S(a)+S(b)+S(c)+S(d)+S(e)==5;}\n\ntemplate&lt;class T1&gt;void P(const T1&amp;a){_P(a);pc(' ');}\ntemplate&lt;class T1,class T2&gt;void P(const T1&amp;a,const T2&amp;b){_P(a);pc(' ');_P(b);pc(' ');}\ntemplate&lt;class T1&gt;void PN(const T1&amp;a){_P(a);NL}\ntemplate&lt;class T1,class T2&gt;void PN(const T1&amp;a,const T2&amp;b){_P(a);pc(' ');_P(b);NL}\ntemplate&lt;class T1,class T2,class T3&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c){_P(a);pc(' ');_P(b);pc(' ');_P(c);NL}\ntemplate&lt;class T1,class T2,class T3,class T4&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c,const T4&amp;d){_P(a);pc(' ');_P(b);pc(' ');_P(c);pc(' ');_P(d);NL}\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c,const T4&amp;d,const T5&amp;e){_P(a);pc(' ');_P(b);pc(' ');_P(c);pc(' ');_P(d);pc(' ');_P(e);NL}\nvoid PS(int a){printf("%*s",a,"");}\n\ntemplate&lt;class T&gt;void SA(T*a,int n){FR(i,n)S(a[i]);}\ntemplate&lt;class T&gt;void PA(T*a,int n){FR(i,n){if(i)pc(' ');_P(a[i]);}NL}\ntemplate&lt;class T&gt;void PA(const T&amp;x){FE(it,x){if(it!=x.begin())pc(' ');_P(*it);}NL}\n\nint kase;\nconst double pi=4*atan(1.);\nconst double ep=1e-9;\nconst int INF=0x3f3f3f3f;\nconst ll INFL=0x3f3f3f3f3f3f3f3fll;\nconst ll MOD=1000000007;\n}\n\nint in[] = {\n\t2, 2, 4,\n\t3, 1, 3, 5,\n\t2, 2, 6,\n\t3, 1, 5, 7,\n\t4, 2, 4, 6, 8,\n\t3, 3, 5, 9,\n\t2, 4, 8,\n\t3, 5, 7, 9,\n\t2, 6, 8\n};\n\nint a[15], res;\n\nint main() {\n\tint inn = 0;\n\tRF(i, 9) {\n\t\tint m = in[inn++];\n\t\twhile (m--) {\n\t\t\ta[i] |= 1 &lt;&lt; (in[inn++] - 1);\n\t\t}\n\t}\n\tFR(i, 1 &lt;&lt; 9) {\n\t\tint cc = 0;\n\t\tFR(j, 9) if (i &gt;&gt; j &amp; 1) cc ^= a[j];\n\t\tif (__builtin_popcount(cc) == 4) {\n\t\t\tRF(j, 9) putchar((i &gt;&gt; j &amp; 1) + '0');\n\t\t\tNL\n\t\t}\n\t}\n}\n\n/*********Risoft corporation all rights reserved*********/\n/**************Template V2.33 build 20151012*************/\n\r\n</textarea>	<textarea id="codelinesjava">\r\n/**\n * \n * @author wc\n *\n */\npublic class Main {\n\tstatic final int LEN = 10;\n\tstatic int[] arr = new int[LEN];\n\tstatic int[] b;\n\n\tpublic static void main(String[] args) {\n\t\tdfs(1);\n\t}\n\n\tprivate static void dfs(int index) {\n\t\tif (index &gt;= LEN) {\n\t\t\tdisplay();\n\t\t\treturn;\n\t\t}\n\t\tarr[index] = 0;\n\t\tdfs(index + 1);\n\t\tarr[index] = 1;\n\t\tdfs(index + 1);\n\t}\n\n\tprivate static void display() {\n\t\tb = new int[LEN];\n\t\tfor (int i = 1; i &lt; LEN; i++) {\n\t\t\tif (arr[i] == 1)\n\t\t\t\tchange(i);\n\t\t}\n\t\tint sum = 0;\n\t\tfor (int i = 1; i &lt; LEN; i++) {\n\t\t\tif (b[i] == 1)\n\t\t\t\tsum++;\n\t\t\tif (sum &gt; 4)\n\t\t\t\treturn;\n\t\t}\n\t\tif (sum == 4) {\n\t\t\tfor (int i = 1; i &lt; LEN; i++) {\n\t\t\t\tSystem.out.print(arr[i]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tprivate static void change(int i) {\n\t\tswitch (i) {\n\t\tcase 1:\n\t\t\tb[2] = b[2] == 0 ? 1 : 0;\n\t\t\tb[4] = b[4] == 0 ? 1 : 0;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tb[1] = b[1] == 0 ? 1 : 0;\n\t\t\tb[3] = b[3] == 0 ? 1 : 0;\n\t\t\tb[5] = b[5] == 0 ? 1 : 0;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tb[2] = b[2] == 0 ? 1 : 0;\n\t\t\tb[6] = b[6] == 0 ? 1 : 0;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tb[1] = b[1] == 0 ? 1 : 0;\n\t\t\tb[5] = b[5] == 0 ? 1 : 0;\n\t\t\tb[7] = b[7] == 0 ? 1 : 0;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tb[2] = b[2] == 0 ? 1 : 0;\n\t\t\tb[4] = b[4] == 0 ? 1 : 0;\n\t\t\tb[6] = b[6] == 0 ? 1 : 0;\n\t\t\tb[8] = b[8] == 0 ? 1 : 0;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tb[3] = b[3] == 0 ? 1 : 0;\n\t\t\tb[5] = b[5] == 0 ? 1 : 0;\n\t\t\tb[9] = b[9] == 0 ? 1 : 0;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tb[4] = b[4] == 0 ? 1 : 0;\n\t\t\tb[8] = b[8] == 0 ? 1 : 0;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tb[5] = b[5] == 0 ? 1 : 0;\n\t\t\tb[7] = b[7] == 0 ? 1 : 0;\n\t\t\tb[9] = b[9] == 0 ? 1 : 0;\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tb[6] = b[6] == 0 ? 1 : 0;\n\t\t\tb[8] = b[8] == 0 ? 1 : 0;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\r\n</textarea>	283
282	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　某场比赛过后，你想要知道A~E五个人的排名是什么，于是要求他们每个人说了一句话。（经典的开头……-_-!）得了第1名的人23，说了假话；得了第5名的人不好意思，也说了假话；为了使求解问题简单，第3名同样说了假话。（奇数名次说假话）\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　共5行，各行依次表示A~E说的话。\n  <br> 　　每行包含一个形如“A&gt;=3”的名次判断，即一个大写字母+关系运算符+一个数字，不包含空格。\n  <br> 　　大写字母A~E，关系运算&lt;、&lt;=、=、&gt;=、&gt;、!=，数字1~5。注意：等于是“=”不是“==”！\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　可能有多解，请按照字典序输出排名序列，每个解一行\n  <br> 　　最后一行输出解的数量\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  A=2\n  <br> D=5\n  <br> E&gt;3\n  <br> A&gt;2\n  <br> B!=1\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  ACDEB\n  <br> AECBD\n  <br> BADCE\n  <br> BCADE\n  <br> BDACE\n  <br> CEADB\n  <br> CEBDA\n  <br> 7\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdlib.h&gt;\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nint a,b,c,d,e;\nint count =0; \nchar s[5][20];\nint check(char s){\n    if(s=='A')  return a;\n    if(s=='B')  return b;\n    if(s=='C')  return c;\n    if(s=='D')  return d;\n    if(s=='E')  return e;\n} \nint fun(char s[]){   //函数用来判断说话的正误 \n    int i,j;\n    if(strlen(s)==3){\n        if(s[1]=='='){\n           //等于号情况 \n           return check(s[0])==(s[2]-'0'); \n        }else if(s[1]=='&gt;'){\n           //大于号情况  \n           return check(s[0])&gt;(s[2]-'0');  \n        }else{\n           //小于号情况 \n           return check(s[0])&lt;(s[2]-'0');\n            } \n        }else{\n        if(s[1]=='&gt;'){\n            //大于等于 \n            return check(s[0])&gt;=(s[3]-'0');\n        }else if(s[1]=='!'){\n            //不等于 \n            return check(s[0])!=(s[3]-'0');\n        }else{\n            //小于等于 \n            return check(s[0])&lt;=(s[3]-'0');\n        }\n    }\n}\n\nint say(int k,int m){\n    //printf("%d-------%d\\n",k,fun(s[m]));\n    if(k%2==0){\n        if(fun(s[m])){\n            return 1;\n            };\n        return 0;\n    }\n    if(k%2==1){\n        if(!fun(s[m])){\n            return 1;\n            };\n        return 0;\n    }\n}\nint pardon (int a, int b, int c, int d, int e){\n    if(a==b||a==c||a==d){\n       return 0;    \n    } \n    if(a==e||b==c||b==d||b==e||c==d){\n       return 0;    \n    }           \n    if(c==e||d==e){\n       return 0;          \n    } \n    return 1;\n}\nint main(){\n    int i,j;\n    char pai[200][6];\n    for(i=0;i&lt;5;i++){\n        gets(s[i]);\n    }\n    for(a=1;a&lt;6;a++)\n      for(b=1;b&lt;6;b++)\n        for(c=1;c&lt;6;c++)\n          for(d=1;d&lt;6;d++)\n            for(e=1;e&lt;6;e++){\n                //printf("%d%d%   d%d%d\\n",a,b,c,d,e);\n                \n                if(!pardon(a,b,c,d,e)){\n                   continue;    \n                }\n                //printf("%d%d%   d%d%d\\n",a,b,c,d,e);\n                if(say(a,0)){\n                  ///*\n                  if(say(b,1)){\n                    if(say(c,2)){\n                       if(say(d,3)){\n                          if(say(e,4)){\n                              //printf("%d%d%d%d%d\\n",a,b,c,d,e);\n                              \n                              pai[count][a-1]='A';\n                              pai[count][b-1]='B';\n                              pai[count][c-1]='C';\n                              pai[count][d-1]='D';\n                              pai[count][e-1]='E'; \n                              pai[count][5]='\\0';                                                      \n                              //printf("\\n");\n                              count++;\n                             //printf("%c%c%c%c%c",a+'A'-1,b+'A'-1,c+'A'-1,d+'A'-1,e+'A'-1);  \n                          } \n                       } \n                    }\n                  } \n                  //*/ \n                  //printf("%d----%d\\n",a,say(a,0)); \n                  //printf("%d%d%d%d%d\\n",a,b,c,d,e);  \n                } \n            }\n    \n    char temp[5];\n    for(i=0;i&lt;count;i++){\n      for(j=i;j&lt;count;j++){\n          if(strcmp(pai[i],pai[j])&gt;0){\n              strcpy(temp,pai[i]);\n              strcpy(pai[i],pai[j]);\n              strcpy(pai[j],temp);\n          }\n      }    \n    }\n    \n    for(i=0;i&lt;count;i++){\n      puts(pai[i]);    \n    }\n    printf("%d\\n",count);\n    system("pause");\n    return 0; \n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;cstdio&gt; \n\nusing namespace std;\nint to[5];\nint obj[5];\nint par[5];\nbool tar[5];\nint position[5];\nint rec[5];\nint cnt;\nbool cmp(int opr,int a,int b)\n{\n\tif(opr==0)return a&gt;=b;\n\telse if(opr==1)return a&lt;=b;\n\telse if(opr==2)return a==b;\n\telse if(opr==3)return a!=b;\n\telse if(opr==4)return a&gt;b;\n\telse return a&lt;b;\n}\nvoid judge()\n{\n\tbool tb=true;\n\tfor(int i=0;i&lt;5;i++){\n\t\tif(position[i]%2){\n\t\t\tif(!cmp(to[i],position[obj[i]],par[i])){\n\t\t\t\ttb=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(!cmp(5-to[i],position[obj[i]],par[i])){\n\t\t\t\ttb=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(tb){\n\t\tprintf("%c%c%c%c%c\\n",rec[0]+'A',rec[1]+'A',rec[2]+'A',rec[3]+'A',rec[4]+'A');\n\t\tcnt++;\n\t}\n}\nvoid dfs(int num)\n{\n\tif(num==5){\n\t\tjudge();\n\t\treturn;\n\t}\n\tfor(int i=0;i&lt;5;i++){\n\t\tif(!tar[i]){\n\t\t\tposition[i]=num;\n\t\t\trec[num]=i;\n\t\t\ttar[i]=true;\n\t\t\tdfs(num+1);\n\t\t\ttar[i]=false;\n\t\t}\n\t}\n}\nint main(int argc, char** argv) {\n\tmemset(tar,false,sizeof tar);\n\tfor(int i=0;i&lt;5;i++){\n\t\tchar s[5],c1;\n\t\tscanf("%s",s);\n\t\tobj[i]=s[0]-'A';\n\t\tif(strlen(s)==4){\n\t\t\tif(s[1]=='&lt;')to[i]=1;\n\t\t\telse if(s[1]=='!')to[i]=3;\n\t\t\telse to[i]=0;\n\t\t\tpar[i]=s[3]-'0';\n\t\t}\n\t\telse{\n\t\t\tif(s[1]=='&lt;')to[i]=5;\n\t\t\telse if(s[1]=='=')to[i]=2;\n\t\t\telse to[i]=4;\n\t\t\tpar[i]=s[2]-'0';\n\t\t}\n\t\tpar[i]-=1;\n\t} \n\tcnt=0;\n\tdfs(0);\n\tprintf("%d\\n",cnt);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tprivate static pj pj;\n\tprivate static int count = 0;\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n\t\tint cs = 0;\n\t\tString[] pd = new String[5];\n\t\tString[] zfqj = new String[5];\n\n\t\twhile (cs &lt; 5) {\n\n\t\t\tpd[cs++] = bf.readLine();\n\n\t\t}\n\n\t\tpj = new pj(pd);\n\n\t\tfor (int i = 0; i &lt; 5; i++) {\n\n\t\t\tzfqj[0] = (char) ('A' + i) + "";\n\n\t\t\tfor (int j = 0; j &lt; 5; j++) {\n\n\t\t\t\tif (i != j) {\n\n\t\t\t\t\tzfqj[1] = zfqj[0] + (char) ('A' + j);\n\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (int k = 0; k &lt; 5; k++) {\n\n\t\t\t\t\tif (i != k &amp;&amp; j != k) {\n\n\t\t\t\t\t\t\tzfqj[2] = zfqj[1] + (char) ('A' + k);\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (int l = 0; l &lt; 5; l++) {\n\n\t\t\t\t\t\tif (i != l &amp;&amp; j != l &amp;&amp; k != l) {\n\n\t\t\t\t\t\t\tzfqj[3] = zfqj[2] + (char) ('A' + l);\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (int m = 0; m &lt; 5; m++) {\n\n\t\t\t\t\t\t\tif (i != m &amp;&amp; j != m &amp;&amp; k != m &amp;&amp; l != m) {\n\n\t\t\t\t\t\t\t\tzfqj[4] = zfqj[3] + (char) ('A' + m);\n\n\t\t\t\t\t\t\t\tzx(zfqj[4]);\n\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tSystem.out.println(count);\n} \n\t\n\t\n\tprivate static void zx(String l) {\n\t\tif (pd(l)) { count++; System.out.println(l); } \n\t}\n\t\n\tprivate static boolean pd(String sr) {\n\t\tboolean b = true;\n\t\tfor (int i = 0; i &lt; 5; i++) {\n\t\t\tif (pj.fh[i] == 0 &amp;&amp; (sr.indexOf((char) (i + 'A'))) % 2 == 1 || pj.fh[i] == 3 &amp;&amp; (sr.indexOf((char) (i + 'A'))) % 2 == 0) { if (sr.indexOf((char) (pj.zm[i] + 'A')) != pj.sz[i]) { b = false; break; } } else if (pj.fh[i] == 1 &amp;&amp; (sr.indexOf((char) (i + 'A'))) % 2 == 1 || pj.fh[i] == -2 &amp;&amp; (sr.indexOf((char) (i + 'A'))) % 2 == 0) { if (sr.indexOf((char) (pj.zm[i] + 'A')) &lt;= pj.sz[i]) { b = false; break; } } else if (pj.fh[i] == -1 &amp;&amp; (sr.indexOf((char) (i + 'A'))) % 2 != 0 || pj.fh[i] == 2 &amp;&amp; (sr.indexOf((char) (i + 'A'))) % 2 == 0) { if (sr.indexOf((char) (pj.zm[i] + 'A')) &gt;= pj.sz[i]) { b = false; break; } } else if (pj.fh[i] == 2 &amp;&amp; (sr.indexOf((char) (i + 'A'))) % 2 != 0 || pj.fh[i] == -1 &amp;&amp; (sr.indexOf((char) (i + 'A'))) % 2 == 0) {\n\n\t\t\t\tif (sr.indexOf((char) (pj.zm[i] + 'A')) &lt; pj.sz[i]) {\n\n\t\t\t\t\tb = false;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t} else if (pj.fh[i] == -2 &amp;&amp; (sr.indexOf((char) (i + 'A'))) % 2 != 0 || pj.fh[i] == 1 &amp;&amp; (sr.indexOf((char) (i + 'A'))) % 2 == 0) {\n\t\t\t\tif (sr.indexOf((char) (pj.zm[i] + 'A')) &gt; pj.sz[i]) {\n\t\t\t\t\tb = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t} else if (pj.fh[i] == 3 &amp;&amp; (sr.indexOf((char) (i + 'A'))) % 2 != 0\n\t\t\t\t\t|| pj.fh[i] == 0 &amp;&amp; (sr.indexOf((char) (i + 'A'))) % 2 == 0) { \n\t\t\t\tif (sr.indexOf((char) (pj.zm[i] + 'A')) == pj.sz[i]) {\n\t\t\t\t\tb = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn b;\n\t}\n}\n\nclass pj {\n\n\tint[] zm = new int[5];\n\t\n\tint[] fh = new int[5];\n\t\n\tint[] sz = new int[5];\n\n\tString[] jz;\n\t\n\tpj(String[] s) {\n\t\tjz = s;\n\t\tinit();\n\t}\n\nprivate void init() {\n\tfor (int i = 0; i &lt; 5; i++) {\n\t\tzm[i] = (byte) jz[i].charAt(0) - 'A';\n\t\tif (jz[i].length() == 3) {\n\t\t\tif (jz[i].substring(1, 2).equals("=")) {\n\t\t\t\tfh[i] = 0;\n\t\t\t} else if (jz[i].substring(1, 2).equals("&gt;")) {\n\t\t\t\t\tfh[i] = 1;\n\t\t\t}else {\n\t\t\t\tfh[i] = -1;\n\t\t\t}\n\t\t\tsz[i] = Integer.parseInt("" + jz[i].subSequence(2, 3)) - 1;\n\t\t} else { \n\t\t\t\tif (jz[i].substring(1, 3).equals("!=")) { \n\t\t\t\t\tfh[i] = 3;\n\t\t\t\t} else if (jz[i].substring(1, 3).equals("&gt;=")) {\n\t\t\t\t\tfh[i] = 2; \n\t\t\t\t} else {\n\t\t\t\t\tfh[i] = -2;\n\t\t\t\t} \n\t\t\t\tsz[i] = Integer.parseInt("" + jz[i].subSequence(3, 4)) - 1;\n\t\t\t}\n\t\t}\n \t}\n}\n\r\n</textarea>	284
283	<div class="des"> \n <div class="pdcont">\n  　　﻿\n  <br> 　　棋盘多项式\n </div>\n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　八皇后问题是在棋盘上放皇后，互相不攻击，求方案。变换一下棋子，还可以有八车问题，八马问题，八兵问题，八王问题，注意别念反。在这道题里，棋子换成车，同时棋盘也得换，确切说，是进行一些改造。比如现在有一张n*n的棋盘，我们在一些格子上抠几个洞，这些洞自然不能放棋子了，会漏下去的。另外，一个车本来能攻击和它的同行同列。现在，你想想，在攻击的过程中如果踩到一个洞，便会自取灭亡。故，车的攻击范围止于洞。\n  <br> 　　此题，给你棋盘的规模n，以及挖洞情况，求放k个车的方案数(k从0到最多可放车数)\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行一个整数n表示棋盘大小\n  <br> 　　接下来n行，每行n个用空格隔开的数字0或1，0的形状表示洞，1表示没有洞\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　若干行，第i行表示放i个车的方案数\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3\n  <br> 1 0 1\n  <br> 1 1 1\n  <br> 1 0 1\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  7\n  <br> 12\n  <br> 4\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　n&lt;=8\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint n;\nint map[10][10];\nint count[100];\n\nvoid change(int i,int j)\n{\n\t int k;\n\t map[i][j]=-1;\n\t for(k=i+1;k&lt;=n;k++){\n\t \t if(map[k][j]==0) break;\n\t \t map[k][j]-=2;\n\t }\n\t for(k=i-1;k&gt;=1;k--){\n\t \tif(map[k][j]==0) break;\n\t \tmap[k][j]-=2;\n\t }\n\t for(k=j+1;k&lt;=n;k++){\n\t \tif(map[i][k]==0) break;\n\t \tmap[i][k]-=2;\n\t }\n\t for(k=j-1;k&gt;=1;k--){\n\t \tif(map[i][k]==0) break;\n\t \tmap[i][k]-=2;\n\t }\n}\n\nvoid rechange(int i,int j)\n{\n\t int k;\n\t map[i][j]=1;\n\t for(k=i+1;k&lt;=n;k++){\n\t \t if(map[k][j]==0) break;\n\t \t map[k][j]+=2;\n\t }\n\t for(k=i-1;k&gt;=1;k--){\n\t \tif(map[k][j]==0) break;\n\t \tmap[k][j]+=2;\n\t }\n\t for(k=j+1;k&lt;=n;k++){\n\t \tif(map[i][k]==0) break;\n\t \tmap[i][k]+=2;\n\t }\n\t for(k=j-1;k&gt;=1;k--){\n\t \tif(map[i][k]==0) break;\n\t \tmap[i][k]+=2;\n\t }\n}\n\nvoid dfs(int m,int taken,int x,int y)\n{\n\t if(x&gt;n) return; \n\t if(taken){\n\t \tif(map[x][y]==1){\n\t \t\tint i=x,j=y;\n\t \t\tchange(i,j);\n\t \t\tif(y+1&gt;n) {\n\t \t\t y = 1;\n\t \t\t x++;\n\t \t    }else y++;\n\t \t    dfs(m-1,1,x,y);\n\t \t    dfs(m-1,0,x,y);\n\t \t\trechange(i,j);\n\t \t\tcount[n*n-m+1]++;\n\t \t}\n\t }\n\t else if(!taken){\n\t \tif(y+1&gt;n) {\n\t \t\t y = 1;\n\t \t\t x++;\n\t \t}\n\t \telse y++;\n\t \tdfs(m,1,x,y);\n\t \tdfs(m,0,x,y);\n\t }\n}\n\nint main(){\n\tscanf("%d",&amp;n);\n\tint i,j;\n\tfor(i=1;i&lt;=n;i++)\n\t  for(j=1;j&lt;=n;j++)\n\t   {\n\t   \t  scanf("%d",&amp;map[i][j]);\n\t   }\n\t\n    dfs(n*n,1,1,1);\n    dfs(n*n,0,1,1);\n    for(i=1;i&lt;=n*n;i++)\n    {\n    \tif(count[i]==0) break;\n    \tprintf("%d\\n",count[i]);\n    }\n\n\treturn 0;\n} \n\r\n</textarea>	<textarea id="codelinescpp">\r\n/*\n思路：枚举每个格子，放或者不放 到终点几个就累加 \n*/\n#include &lt;iostream&gt;\n#include &lt;string.h&gt;\n#include &lt;algorithm&gt;\n#include &lt;cstdio&gt;\n#include &lt;math.h&gt;\nusing namespace std;\nconst int N=10;\nint map[N][N];    //0洞 1可以放 2放了 \nint re[N*N];\nint len;  //结果数的长度 \nint n;\ninline bool check(int x,int y){\n\tint i;\n\tfor(i=y-1;i&gt;=0;i--) {   //左横 \n\t      if(map[x][i]==2)      //遇到车 \n\t       return false;\n\t    if(map[x][i]==0)       //遇到洞 不会攻击到别人 \n\t      break;\n\t}\n\t\n\tfor(i=y+1;i&lt;n;i++) {   //右横 \n\t       if(map[x][i]==2)      //遇到车 \n\t       return false;\n\t    if(map[x][i]==0)       //遇到洞 不会攻击到别人 \n\t      break;\n\t}\n\t \n\t   \t   \n\tfor(i=x-1;i&gt;=0;i--)  {        //左竖 \t\n\t   if(map[i][y]==2)\n\t   return false;\n\t   \n\t   if(map[i][y]==0)\n\t   break;\n\t}    \n\t   \n\t   for(i=x+1;i&lt;n;i++)  {        //右竖 \t\n\t   if(map[i][y]==2)\n\t   return false;\n\t   \n\t   if(map[i][y]==0)\n\t      break;\n\t}    \n\t\n\t   return true;\n}\nvoid dfs(int now,int sum){\n\tif(now&gt;=n*n){\n\t\tre[sum]++; \n\t\treturn;\n\t}\n\tint x=now/n;\n\tint y=now%n;\n\t\n\tif(map[x][y]==1){\n\t\tif(check(x,y)){\n\t\t\tmap[x][y]=2;\n\t\t\tdfs(now+1,sum+1);\n\t\t\tmap[x][y]=1;\n\t\t}\t\n\t}\t\n\tdfs(now+1,sum);\n}\nint main(){    \n    int i,j;\n    while(cin&gt;&gt;n){\n    \tfor(i=0;i&lt;n;i++)\n    \t  for(j=0;j&lt;n;j++){\n    \t  \tcin&gt;&gt;map[i][j];\n\t\t  }\n\t\t  \n\t\t  memset(re,0,sizeof(re)); \n\t\n\t\t\tdfs(0,0); \n\t\t\n\t\t\n\t\tfor(i=1;i&lt;n*n;i++){\n\t\t\tif(re[i]!=0){\n\t\t\t\tcout&lt;&lt;re[i]&lt;&lt;endl;\n\t\t\t} \n\t\t    else \n\t\t\t    break; \n\t\t}\n\t}\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tstatic int[][] map;\n\tstatic int n,k;\n\tstatic int[] s;\n\t\n\tstatic boolean pd(int x,int y){\n\t\tint i=x,j=y;\n\t\twhile (i&gt;=0) {\n\t\t\tif(map[i][j]==0)break;\n\t\t\tif(map[i][j]==2)return false;\n\t\t\ti--;\n\t\t}\n\t\ti=x;\n\t\twhile (j&gt;=0) {\n\t\t\tif(map[i][j]==0)break;\n\t\t\tif(map[i][j]==2)return false;\n\t\t\tj--;\n\t\t}\n//\t\tj=y;\n//\t\twhile(i&gt;=0&amp;&amp;j&gt;=0){\n//\t\t\tif(map[i][j]==0)break;\n//\t\t\tif(map[i][j]==2)return false;\n//\t\t\ti--;j--;\n//\t\t}\n//\t\ti=x;j=y;\n//\t\twhile(i&gt;=0&amp;&amp;j&lt;n){\n//\t\t\tif(map[i][j]==0)break;\n//\t\t\tif(map[i][j]==2)return false;\n//\t\t\ti--;j++;\n//\t\t}\n\t\treturn true;\n\t}\n\tstatic int getNext(int x,int y){\n\t\tif(x&lt;n)\n\t\tfor (int i = y+1; i &lt;n; i++) {\n\t\t\tif(map[x][i]==0)return i+1;\n\t\t}\n\t\treturn n;\n\t}\n\tstatic void tryC(int x,int y,int a){\n\t\t//System.out.println(a);\n\t\ts[a]++;\n\t\tif(a&gt;k)k=a;\n\t\t//if(a==n)return;\n\t\tint i1,j1;\n\t\tfor (int i = x; i &lt; n; i++) {\n\t\t\tint j=0;\n\t\t\tif(i==x)j=y;\n\t\t\tfor (; j &lt; n; j++) {\n\t\t\t\tif(i==n||j==n)continue;\n\t\t\t\tif(map[i][j]==0)continue;\n\t\t\t\tif(pd(i, j)){\n\t\t\t\t\ti1=i;j1=j;\n\t\t\t\t\tmap[i1][j1]=2;\n\t\t\t\t\tj1=getNext(i, j);\n\t\t\t\t\tif(j1==n){j1=0;i1++;}\n\t\t\t\t\ttryC(i1, j1, a+1);\n\t\t\t\t\tmap[i][j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstatic void print(){\n\t\tfor (int i = 0; i &lt; map.length; i++) {\n\t\t\tfor (int j = 0; j &lt; map.length; j++) {\n\t\t\t\tSystem.out.print(map[i][j]+" ");\n\t\t\t}System.out.println();\n\t\t}\n\t}\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t\n\t\tBufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n\t\tn=Integer.parseInt(bf.readLine());\n\t\tmap=new int[n][n];\n\t\ts=new int[100000];\n\t\tfor (int i = 0; i &lt; n; i++) {\n\t\t\tString[] a1=bf.readLine().split(" ");\n\t\t\tfor (int j = 0; j &lt; n; j++) {\n\t\t\t\tmap[i][j]=Integer.parseInt(a1[j]);\n\t\t\t}\n\t\t}\n\t\t//print();\n\t\ttryC(0, 0, 0);\n\t\tfor (int i = 1; i &lt;=k; i++) {\n\t\t\tSystem.out.println(s[i]);\n\t\t}\n\t\t\n\n\t}\n}\n\r\n</textarea>	285
284	<div class="des"> \n <div class="pdcont">\n  　　一共有5个红领巾，编号分别为A、B、C、D、E，老奶奶被他们其中一个扶过了马路。\n  <br> \n  <br> 　　五个红领巾各自说话：\n  <br> \n  <br> 　　A ：我和E都没有扶老奶奶\n  <br> \n  <br> 　　B ：老奶奶是被C和E其中一个扶过大街的\n  <br> \n  <br> 　　C ：老奶奶是被我和D其中一个扶过大街的\n  <br> \n  <br> 　　D ：B和C都没有扶老奶奶过街\n  <br> \n  <br> 　　E ：我没有扶老奶奶\n  <br> \n  <br> \n  <br> 　　已知五个红领巾中有且只有２个人说的是真话，请问是谁扶这老奶奶过了街？\n  <br> \n  <br> 　　若有多个答案，在一行中输出，编号之间用空格隔开。\n  <br> \n  <br> \n  <br> 　　例如\n  <br> 　　A B C D E（这显然不是正确答案）﻿\n </div> \n</div>	<textarea id="codelinesc">\r\n#include"stdio.h"\nint main(void)\n{\n\nprintf("A B E");\nreturn 0;\n\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include "stdio.h"\nint a[5]={1,0,0,0,0};\nint check(){\n\tint A = a[0] + a[4];\n\tint B = a[2] + a[4];\n\tint C = a[2] + a[3];\n\tint D = a[1] + a[2];\n\tint E = a[4];\n\tif(!A+B+C+!D+!E == 2)\n\t\treturn 1;\n\treturn 0;\n}\nint main(){\n\tfor(int i = 0; i &lt; 5; i++){\n\t\tif(check()){\n\t\t\tfor(int j = 0; j &lt; 5; j++)\n\t\t\t\tif(a[j])\n\t\t\t\t\tprintf("%c ",65+j);\n\t\t}\n\t\tint t = a[i];\n\t\ta[i] = a[i+1];\n\t\ta[i+1] = t;\n\t}\n\t\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\npublic class Main\n{\n\npublic static void main(String args[])\n{\n\t\n\t\t System.out.println("A"+" "+"B"+" "+"E");\n\t }\n\t \n\t\t\n\n\n}\r\n</textarea>	286
285	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　给定N个物品,每个物品有一个重量W和一个价值V.你有一个能装M重量的背包.问怎么装使得所装价值最大.每个物品只有一个.\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入的第一行包含两个整数n, m，分别表示物品的个数和背包能装重量。\n  <br> 　　以后N行每行两个数Wi和Vi,表示物品的重量和价值\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出1行，包含一个整数，表示最大价值。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3 5\n  <br> 2 3\n  <br> 3 5\n  <br> 4 7\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  8\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　1&lt;=N&lt;=200,M&lt;=5000.\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n\tint a[5010]={0};\n\tint m,n,i,j,p,q,k;\n\tscanf("%d%d",&amp;n,&amp;m);\n\tfor(i=1;i&lt;=n;i++)\n\t{\n\t\tscanf("%d%d",&amp;p,&amp;q);\n\t\tfor(j=m;j&gt;=p;j--)\n\t\t{\n\t\t\tif(a[j]&lt;a[j-p]+q)\n\t\t\t{\n\t\t\t\ta[j]=a[j-p]+q;\n\t\t\t}\n\t\t}\n\t\t// for(k=1;k&lt;=m;k++)\n\t\t// {\n\t\t// \tprintf("%d ",a[k]);\n\t\t// }\n\t\t// printf("\\n");\n\t}\n\tprintf("%d\\n",a[m]);\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\nint w[205];\nint v[205];\nint wv[205][5005]={0};\nint main()\n{\n\tint i,j,n,m;\n\tcin&gt;&gt;n;\n\tcin&gt;&gt;m;\n\tfor(i=1;i&lt;=n;i++)\n\t{\n\t\tcin&gt;&gt;w[i];\n\t\tcin&gt;&gt;v[i];\n\t}\n\tfor(i=1;i&lt;=n;i++)\n\t\tfor(j=1;j&lt;=m;j++)\n\t\t{\n\t\t\tif(w[i]&lt;=j)\n\t\t\t\twv[i][j]=max(wv[i-1][j],v[i]+wv[i-1][j-w[i]]);\n\t\t\telse\n\t\t\t\twv[i][j]=wv[i-1][j];\n\t\t}\n\t\tcout&lt;&lt;wv[n][m]&lt;&lt;endl;\n\treturn 0;\n\t\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.text.*;\n\npublic class Main {\n\t\n\tvoid solve() {\n\t\tint[] d = new int[5005];\n\t\tint n = in.nextInt(), m = in.nextInt();\n\t\tfor (int i = 0; i &lt; n; i++) {\n\t\t\tint w = in.nextInt(), v = in.nextInt();\n\t\t\tfor (int j = m; j - w &gt;= 0; j--) {\n\t\t\t\td[j] = Math.max(d[j], d[j - w] + v);\n\t\t\t}\n\t\t}\n\t\tout.println(d[m]);\n\t}\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tvoid run(String s) {\n\t\tif (s == null) {\n\t\t\tin = new FastScanner();\n\t\t} else {\n\t\t\tin = new FastScanner(s);\n\t\t}\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run(null);\n\t}\n\n\tstatic class FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tFastScanner(String file) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tFastScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tboolean hasMoreTokens() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tString s = br.readLine();\n\t\t\t\t\tif (s == null)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tst = new StringTokenizer(s);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n}\n\r\n</textarea>	287
286	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　为了准备一个学生节，组织者在会场的一片矩形区域（可看做是平面直角坐标\n  <br> 　　系的第一象限）铺上一些矩形地毯。一共有n 张地毯，编号从1 到n。现在将这些地毯按照\n  <br> 　　编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。\n  <br> 　　地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形\n  <br> 　　地毯边界和四个顶点上的点也算被地毯覆盖。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入共 n+2 行。\n  <br> 　　第一行，一个整数 n，表示总共有n 张地毯。\n  <br> 　　接下来的 n 行中，第i+1 行表示编号i 的地毯的信息，包含四个正整数a，b，g，k，每\n  <br> 　　两个整数之间用一个空格隔开，分别表示铺设地毯的左下角的坐标（a，b）以及地毯在x\n  <br> 　　轴和y 轴方向的长度。\n  <br> 　　第 n+2 行包含两个正整数x 和y，表示所求的地面的点的坐标（x，y）。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出共 1 行，一个整数，表示所求的地毯的编号；若此处没有被地毯覆盖则输出-1。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3\n  <br> 1 0 2 3\n  <br> 0 2 3 3\n  <br> 2 1 3 3\n  <br> 2 2\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  3\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  -1\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　对于 30%的数据，有n≤2；\n  <br> 　　对于 50%的数据，0≤a, b, g, k≤100；\n  <br> 　　对于 100%的数据，有0≤n≤10,000，0≤a, b, g, k≤100,000。\n  <br> \n  <br> \n  <br> \n  <br> 　　1 0 2 3\n  <br> 　　0 2 3 3\n  <br> 　　2 1 3 3\n  <br> 　　4 5\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n    int n,a[100000],b[100000],x[100000],y[100000],c[100000],g,k,i,s=0,p=-1;\n    scanf("%d",&amp;n);\n    for(i=0;i&lt;n;i++)\n    {\n        scanf("%d %d %d %d",&amp;a[i],&amp;b[i],&amp;x[i],&amp;y[i]);\n    }\n    scanf("%d %d",&amp;g,&amp;k);\n    for(i=0;i&lt;n;i++)\n    {\n        if(g&gt;=a[i]&amp;&amp;g&lt;=a[i]+x[i]&amp;&amp;k&gt;=b[i]&amp;&amp;k&lt;=b[i]+y[i])\n        {\n            p++;\n            c[p]=i+1;\n        }\n        else\n            s++;\n    }\n    if(s==n)\n        printf("-1");\n    else\n    printf("%d",c[p]);\n    return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n# include &lt;stdio.h&gt;\nstruct rect{\n\tint x, y;\n\tint x_length, y_length;\n};\nstruct rect s[10010];\nint main(){\n\tint n, i, j, k;\n\tint x, y;\n\tscanf("%d", &amp;n);\n\tfor(i=1; i&lt;=n; i++){\n\t\tscanf("%d%d%d%d", &amp;s[i].x, &amp;s[i].y, &amp;s[i].x_length, &amp;s[i].y_length);\n\t}\n\tscanf("%d%d", &amp;x, &amp;y);\n\tint ans=-1;\n\tfor(i=1; i&lt;=n; i++){\n\t\tif(s[i].x&lt;=x&amp;&amp;x&lt;=s[i].x+s[i].x_length&amp;&amp;s[i].y&lt;=y&amp;&amp;y&lt;=s[i].y+s[i].y_length){\n\t\t\tans=i;\n\t\t}\n\t}\n\tprintf("%d", ans);\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\npublic class Main{//铺地毯adv-145\n    static int[][] di;\n    static void p(int n,int a,int b,int c,int d){\n\t  for (int i=a;i&lt;=a+c;i++){\n\t\tfor (int j=b;j&lt;=b+d;j++){\n\t\t\tdi[i][j]=n;\n\t\t}\n\t  }\n    }\n    public static void main(String[] args)throws IOException {\n    \t\n    \tBufferedReader reader=new BufferedReader(new InputStreamReader(System.in));\n    \tString s=reader.readLine();\n    \tint n=Integer.parseInt(s);\n    \tdi=new int[n+1][4];\n    \tfor (int i=1;i&lt;=n;i++){\n    \t\ts=reader.readLine();\n    \t\tString[] sa = s.split(" ");\n    \t    di[i][0]=Integer.parseInt(sa[0]);\n    \t    di[i][1]=Integer.parseInt(sa[1]);\n    \t    di[i][2]=Integer.parseInt(sa[2]);\n    \t    di[i][3]=Integer.parseInt(sa[3]);\n    \t}\n    \ts=reader.readLine();\n\t\tString[] sa = s.split(" ");\n\t\tint e,f;\n\t\te=Integer.parseInt(sa[0]);\n\t    f=Integer.parseInt(sa[1]);\n\t    int g=-1;\n\t    for (int i=n;i&gt;=1;i--){\n\t    \tif ((e&gt;=di[i][0])&amp;&amp;(e&lt;=(di[i][0]+di[i][2]))) {\n\t    \t\tif ((f&gt;=di[i][1])&amp;&amp;(f&lt;=(di[i][1]+di[i][3]))) {\n\t    \t\t\tg=i;\n\t    \t\t\tbreak;\n\t    \t\t}\n\t    \t}\n\t    }\n\t    System.out.println(g);\n    }\n}\n\n\r\n</textarea>	288
287	<div class="des"> \n <div class="pdcont">\n  <b>【问题描述】</b>\n  <br> 　　王小二的计算器上面的LED显示屏坏掉了，于是他找到了在计算器维修与应用系学习的你来为他修计算器。\n  <br> 　　屏幕上可以显示0~9的数字，其中每个数字由7个小二极管组成，各个数字对应的表示方式如图所示：\n  <br> \n  <img width="426" height="77" src="/RequireFile.do?fid=aYT2ERHR">\n  <br> 　　。\n  <br> \n  <br> 　　为了排除电路故障，现在你需要计算，将数字A变为数字B需要经过多少次变换？\n  <br> 　　注意：现在将其中每段小二极管的开和关都定义为一次变换。例如数字1变为2是5次操作。\n  <br> \n  <br> \n  <b>【输入格式】</b>\n  <br> 　　第一行为一个正整数L，表示数码的长度。\n  <br> 　　接下来两行是两个长度为L的数字A和B，表示要把数字A变成数字B（数字可以以0开头）。\n  <br> \n  <b>【输出格式】</b>\n  <br> 　　一行一个整数，表示这些小二极管一共要变换多少次。\n  <br> \n  <b>【样例输入1】</b>\n  <br> \n  <br> 　　3\n  <br> 　　101\n  <br> 　　025\n  <br> \n  <b>【样例输出1】</b>\n  <br> 　　12\n  <br> \n  <b> 【样例输入2】</b>\n  <b><br> </b>\n  <br> 　　8\n  <br> 　　19920513\n  <br> 　　20111211\n  <br> \n  <b>【样例输出2</b>\n  <b>】</b>\n  <br> 　　27\n  <br> \n  <br> \n  <b>【数据范围】</b>\n  <br> 　　L&lt;=100\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdlib.h&gt;\n#include&lt;stdio.h&gt;\nint main(){\n    int a[10][10]={0,4,3,3,4,3,2,3,1,2,\n                   4,0,5,3,2,5,6,1,5,4,\n                   3,5,0,2,5,4,3,4,2,3,\n                   3,3,2,0,3,2,3,2,2,1,\n                   4,2,5,3,0,3,4,3,3,2,\n                   3,5,4,2,3,0,1,4,2,1,\n                   2,6,3,3,4,1,0,5,1,2,\n                   3,1,4,2,3,4,5,0,4,3,\n                   1,5,2,2,3,2,1,4,0,1,\n                   2,4,3,1,2,1,2,3,1,0};\n    int n,num=0,i;\n    char s1[101],s2[101];\n    scanf("%d",&amp;n);\n    scanf("%s%s",s1,s2);\n    for(i=0;i&lt;n;i++)\n    {\n      num+=a[s1[i]-'0'][s2[i]-'0'];  \n    }\n    printf("%d\\n",num);\n    system("pause");\n    return 0; \n}\r\n</textarea>	<textarea id="codelinescpp">\r\n/**************Powered by Graphene Richards**************/\nextern"C++"{\n#define FLOAT_PRECISION     2\n\n#ifdef _MSC_VER\n#define _SECURE_SCL 0\n#pragma comment(linker,"/STACK:102400000,102400000")\n#else\n#pragma GCC optimize("O3")\n#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx")\n#endif\n#if defined(_MSC_VER)||__cplusplus&gt;199711L\n#define IT(x) auto\n#define DIT(x) auto\n#else\n#define IT(x) __typeof((x).begin())\n#define DIT(x) __typeof((x).rbegin())\n#endif\n\n#  inc\\\nlude&lt;cmath&gt;\n#  inc\\\nlude&lt;cstdio&gt;\n#  inc\\\nlude&lt;cstdlib&gt;\n#  inc\\\nlude&lt;cstring&gt;\n#  inc\\\nlude&lt;algorithm&gt;\n#  inc\\\nlude&lt;bitset&gt;\n#  inc\\\nlude&lt;complex&gt;\n#  inc\\\nlude&lt;vector&gt;\n#  inc\\\nlude&lt;iomanip&gt;\n#  inc\\\nlude&lt;iostream&gt;\n#  inc\\\nlude&lt;list&gt;\n#  inc\\\nlude&lt;map&gt;\n#  inc\\\nlude&lt;queue&gt;\n#  inc\\\nlude&lt;set&gt;\n#  inc\\\nlude&lt;stack&gt;\n#  inc\\\nlude&lt;string&gt;\n#define FAST_RW ios_base::sync_with_stdio(0),cin.tie(0);\n#define FS(i,a) for(ll i=0;a[i];i++)\n#define FE(it,x) for(IT(x) it=(x).begin(),_en=(x).end();it!=_en;it++)\n#define EF(it,x) for(DIT(x) it=(x).rbegin(),_en=(x).rend();it!=_en;it++)\n#define FR(i,en) for(ll i=0,_en=(en);i&lt;_en;i++)\n#define FOR(i,en) for(ll i=1,_en=(en);i&lt;=_en;i++)\n#define RF(i,en) for(ll i=(en)-1;i&gt;=0;i--)\n#define ROF(i,en) for(ll i=(en);i&gt;0;i--)\n#define FFR(i,x,y) for(ll i=(x),_en=(y);i&lt;=_en;i++)\n#define RFF(i,x,y) for(ll i=(x),_en=(y);i&gt;=_en;i--)\n#define pc putchar\n#define pb push_back\n#define ppb pop_back\n#define pq priority_queue\n#define fi first\n#define se second\n#define mp make_pair\n#define pii pair&lt;int,int&gt;\n#define pll pair&lt;ll,ll&gt;\n#define sqr(x) ((x)*(x))\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define clr(x) memset((x),0,sizeof(x))\n#define ms(x,v) memset((x),(v),sizeof(x))\n#define mc(x,y) memcpy((x),(y),sizeof(y))\n#define NL puts("");\n#define LB lower_bound\n#define UB upper_bound\n#define rand() ((rand()&lt;&lt;16)^(rand()&lt;&lt;15)^(rand()))\n#ifdef _WIN32\n#define _i64_ "%I\\\n64d"\n#define _u64_ "%I\\\n64u"\n#else\n#define _i64_ "%l\\\nld"\n#define _u64_ "%l\\\nlu"\n#endif\ntypedef unsigned ui;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lf;\nusing namespace std;\n\null gcd(ull a,ull b){if(!b)return a;while(b^=a^=b^=a%=b);return a;}\n\nextern const ll MOD;\nll ksm(ll a,ll b){\nll res=1;a%=MOD;\nfor(;b;b&gt;&gt;=1){if(b&amp;1)res=res*a%MOD;a=a*a%MOD;}\nreturn res;\n}\n\n#ifdef wmx16835\n#include"wmx16835.h"\n#else\n#define LOG\n#define TEL\n#define test(...) 0\n#define TEST(...) 0\n#define TRY(...)\n#define SF(...)\n#define SC\n#define PF\n#define PC\n#define PP\n#define SHOW_TIME\n#define BR\n#endif\nint main(){SHOW_TIME int __MAIN();__MAIN();}\n#define main __MAIN\n#define y0 NKwKGuBI\n#define y1 KFJssmlK\n#define yn XypGISMR\n#define j1 kQDCYYWX\n#define tm BdKIQNcs\n#define lr UsCPcJvt\n\ntemplate&lt;class T1,class T2,class T3&gt;bool In(T1 x,T2 y,T3 z){return x&lt;=y&amp;&amp;x&gt;=z||x&lt;=z&amp;&amp;x&gt;=y;}\ntemplate&lt;class T1,class T2&gt;T1 max(const T1&amp;a,const T2&amp;b){return a&lt;b?b:a;}\ntemplate&lt;class T1,class T2,class T3&gt;T1 max3(const T1&amp;a,const T2&amp;b,const T3&amp;c){return a&lt;b?(b&lt;c?c:b):(a&lt;c?c:a);}\ntemplate&lt;class T1,class T2&gt;T1 min(const T1&amp;a,const T2&amp;b){return a&lt;b?a:b;}\ntemplate&lt;class T1,class T2,class T3&gt;T1 min3(const T1&amp;a,const T2&amp;b,const T3&amp;c){return a&lt;b?(a&lt;c?a:c):(b&lt;c?b:c);}\n\nbool S(char*a){return scanf("%s",a)==1;}\nbool S(int&amp;a){return scanf("%d",&amp;a)==1;}\nbool S(bool&amp;a){return scanf("%d",&amp;a)==1;}\nbool S(ui&amp;a){return scanf("%u",&amp;a)==1;}\nbool S(float&amp;a){return scanf("%f",&amp;a)==1;}\nbool S(double&amp;a){return scanf("%lf",&amp;a)==1;}\nbool S(ll&amp;a){return scanf(_i64_,&amp;a)==1;}\nbool S(ull&amp;a){return scanf(_u64_,&amp;a)==1;}\nbool S(lf&amp;a){double b;if(scanf("%lf",&amp;b)==-1)return 0;a=b;return 1;}\nbool S(char&amp;a){char b[2];if(scanf("%1s",b)==-1)return 0;a=*b;return 1;}\nbool SL(char*a){a[0]=0;while(gets(a)&amp;&amp;!a[0]);return a[0];}\ntemplate&lt;class T1,class T2&gt;bool S(pair&lt;T1,T2&gt;&amp;a){S(a.fi),S(a.se);}\ntemplate&lt;class T&gt;bool S(T&amp;a){a.in();}\n\nvoid _P(const int&amp;x){printf("%d",x);}\nvoid _P(const bool&amp;x){printf("%d",x);}\nvoid _P(const ui&amp;x){printf("%u",x);}\nvoid _P(const char&amp;x){printf("%c",x);}\nvoid _P(const char*x){printf("%s",x);}\nvoid _P(const string&amp;x){printf("%s",x.c_str());}\nvoid _P(const ll&amp;x){printf(_i64_,x);}\nvoid _P(const ull&amp;x){printf(_u64_,x);}\nvoid _P(const float&amp;x){printf("%.*f",FLOAT_PRECISION,x);}\nvoid _P(const double&amp;x){printf("%.*f",FLOAT_PRECISION,x);}\nvoid _P(const lf&amp;x){printf("%.*f",FLOAT_PRECISION,(double)x);}\ntemplate&lt;class T1,class T2&gt;void _P(const pair&lt;T1,T2&gt;&amp;x){_P(x.fi);pc(' ');_P(x.se);}\ntemplate&lt;class T&gt;void _P(const T&amp;a){a.out();}\n\ntemplate&lt;class T1,class T2&gt;bool S(T1&amp;a,T2&amp;b){return S(a)+S(b)==2;}\ntemplate&lt;class T1,class T2,class T3&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c){return S(a)+S(b)+S(c)==3;}\ntemplate&lt;class T1,class T2,class T3,class T4&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d){return S(a)+S(b)+S(c)+S(d)==4;}\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d,T5&amp;e){return S(a)+S(b)+S(c)+S(d)+S(e)==5;}\n\ntemplate&lt;class T1&gt;void P(const T1&amp;a){_P(a);pc(' ');}\ntemplate&lt;class T1,class T2&gt;void P(const T1&amp;a,const T2&amp;b){_P(a);pc(' ');_P(b);pc(' ');}\ntemplate&lt;class T1&gt;void PN(const T1&amp;a){_P(a);NL}\ntemplate&lt;class T1,class T2&gt;void PN(const T1&amp;a,const T2&amp;b){_P(a);pc(' ');_P(b);NL}\ntemplate&lt;class T1,class T2,class T3&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c){_P(a);pc(' ');_P(b);pc(' ');_P(c);NL}\ntemplate&lt;class T1,class T2,class T3,class T4&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c,const T4&amp;d){_P(a);pc(' ');_P(b);pc(' ');_P(c);pc(' ');_P(d);NL}\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c,const T4&amp;d,const T5&amp;e){_P(a);pc(' ');_P(b);pc(' ');_P(c);pc(' ');_P(d);pc(' ');_P(e);NL}\nvoid PS(int a){printf("%*s",a,"");}\n\ntemplate&lt;class T&gt;void SA(T*a,int n){FR(i,n)S(a[i]);}\ntemplate&lt;class T&gt;void PA(T*a,int n){FR(i,n){if(i)pc(' ');_P(a[i]);}NL}\ntemplate&lt;class T&gt;void PA(const T&amp;x){FE(it,x){if(it!=x.begin())pc(' ');_P(*it);}NL}\n\nint kase;\nconst double pi=4*atan(1.);\nconst double ep=1e-9;\nconst int INF=0x3f3f3f3f;\nconst ll INFL=0x3f3f3f3f3f3f3f3fll;\nconst ll MOD=1000000007;\n}\n\nint d[10][7] = {\n\t1,1,1,1,1,1,0,\n\t0,1,1,0,0,0,0,\n\t1,1,0,1,1,0,1,\n\t1,1,1,1,0,0,1,\n\t0,1,1,0,0,1,1,\n\t1,0,1,1,0,1,1,\n\t1,0,1,1,1,1,1,\n\t1,1,1,0,0,0,0,\n\t1,1,1,1,1,1,1,\n\t1,1,1,1,0,1,1\n};\n\nint a[10];\nchar s[105], t[105];\n\nint main() {\n\tFR(i, 10) {\n\t\tFR(j, 7) {\n\t\t\ta[i] |= d[i][j] &lt;&lt; j;\n\t\t}\n\t}\n\tscanf("%*d%s%s", s, t);\n\tint res = 0;\n\tFS(i, s) {\n\t\tres += __builtin_popcount(a[s[i] - '0'] ^ a[t[i] - '0']);\n\t}\n\tPN(res);\n}\n\n/*********Risoft corporation all rights reserved*********/\n/**************Template V2.33 build 20151012*************/\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner out=new Scanner(System.in);\n\t\tint L=out.nextInt();\n\t\tString a=out.next();\n\t\tString b=out.next();\n\t\tint[][] arr={\n\t\t\t\t{1,1,1,1,1,1,0},\n\t\t\t\t{0,1,1,0,0,0,0},\n\t\t\t\t{1,1,0,1,1,0,1},\n\t\t\t\t{1,1,1,1,0,0,1},\n\t\t\t\t{0,1,1,0,0,1,1},\n\t\t\t\t{1,0,1,1,0,1,1},\n\t\t\t\t{1,0,1,1,1,1,1},\n\t\t\t\t{1,1,1,0,0,0,0},\n\t\t\t\t{1,1,1,1,1,1,1},\n\t\t\t\t{1,1,1,1,0,1,1}\n\t\t};\n\t\tchar[] c1=a.toCharArray();\n\t\tchar[] c2=b.toCharArray();\n\t\tint count=0;\n\t\tfor (int i = 0; i &lt; L; i++) {\n\t\t\tfor (int j = 0; j &lt; 7; j++) {\n\t\t\t\tif(arr[c1[i]-'0'][j]!=arr[c2[i]-'0'][j]) count++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n}\r\n</textarea>	289
288	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　从一个大小为n的整数集中选取一些元素，使得它们的和等于给定的值T。每个元素限选一次，不能一个都不选。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行一个正整数n，表示整数集内元素的个数。\n  <br> 　　第二行n个整数，用空格隔开。\n  <br> 　　第三行一个整数T，表示要达到的和。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出有若干行，每行输出一组解，即所选取的数字，按照输入中的顺序排列。\n  <br> 　　若有多组解，优先输出不包含第n个整数的；若都包含或都不包含，优先输出不包含第n-1个整数的，依次类推。\n  <br> 　　最后一行输出总方案数。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5\n  <br> -7 -3 -2 5 9\n  <br> 0\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  -3 -2 5\n  <br> -7 -2 9\n  <br> 2\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　1&lt;=n&lt;=22\n  <br> 　　T&lt;=maxlongint\n  <br> 　　集合中任意元素的和都不超过long的范围\n </div> \n</div>	<textarea id="codelinesc">\r\n/*\n问题描述\n　　从一个大小为n的整数集中选取一些元素，使得它们的和等于给定的值T。\n每个元素限选一次，不能一个都不选。\n输入格式\n　　第一行一个正整数n，表示整数集内元素的个数。\n　　第二行n个整数，用空格隔开。\n　　第三行一个整数T，表示要达到的和。\n输出格式\n　　输出有若干行，每行输出一组解，即所选取的数字，按照输入中的顺序排列。\n　　若有多组解，优先输出不包含第n个整数的；\n若都包含或都不包含，优先输出不包含第n-1个整数的，依次类推。\n　　最后一行输出总方案数。\n样例输入\n5\n-7 -3 -2 5 9\n0\n样例输出\n-3 -2 5\n-7 -2 9\n2\n数据规模和约定\n　　1&lt;=n&lt;=22\n　　T&lt;=maxlongint\n　　集合中任意元素的和都不超过long的范围\n*/\n \n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdbool.h&gt;\n\ntypedef\n   struct \n   {\n      int  zs;\n      bool xz;\n   }\nXuanji_t ;\n\nvoid shuru(Xuanji_t [],int);\nint xuanze(Xuanji_t [],int,int,int,int); \nbool xuanzheguo(Xuanji_t [],int);\nvoid shuchu(Xuanji_t [],int);\n\nint main(void)\n{\n  \n  int n ;\n  scanf("%d",&amp;n);//第一行一个正整数n\n  \t \n  Xuanji_t jihe[n];\n  shuru(jihe,n);//第二行n个整数\n\n  int T ;\n  scanf("%d",&amp;T);//第三行一个整数T\n\n  printf("%d\\n",xuanze(jihe,n-1,n,0,T)); \n  \n  system("PAUSE");\t\n  return 0;\n}\n\nvoid shuchu(Xuanji_t jh[],int n)\n{\n   while ( n -- &gt; 0 )\n   {\n      if ( jh -&gt; xz == true )\n      {\n         printf("%d ", jh -&gt; zs);\n      }\n      jh ++ ;\n   }\n   putchar('\\n');\n}\n\nbool xuanzheguo(Xuanji_t jh[],int n )\n{\n   while ( n -- &gt; 0 )\n   {\n      if ( jh++ -&gt; xz == true )\n      {\n         return true ;\n      }\n   }\n   return false ;\n}\n\nint xuanze(Xuanji_t jh[] , int dqxb ,int zgs ,int he ,int T)\n{\n   if ( dqxb &lt; 0 )\n   {\n      if ( he == T )\n      {\n         if ( xuanzheguo( jh , zgs ) == true )\n         {\n            shuchu( jh , zgs );\n            return 1 ;\n         }\n      }\n      return 0;\n   }\n   int fas = 0 ;\n   jh[dqxb].xz=false ;\n   fas += xuanze(jh,dqxb-1,zgs,he,T);\n   jh[dqxb].xz=true ;\n   fas += xuanze(jh,dqxb-1,zgs,he+jh[dqxb].zs,T);\n   return fas ;\n}\n\nvoid shuru(Xuanji_t a[],int n)\n{\n   while ( n -- &gt; 0 )\n   {\n      scanf("%d",&amp;a++-&gt;zs);\n   }\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\nint b[1000],a[1000];\nint l=0,sum,n,v=0;\nvoid dd(int k,long long z)\n{ int i;\n if (k==n)\n {\n  if (z==sum&amp;&amp;l!=0)\n   {\n   \t for (i=l-1;i&gt;=0;i--)\n   \t  cout&lt;&lt;b[i]&lt;&lt;" ";\n   \t  v++;\n   \t  cout&lt;&lt;endl;\n   }\n  return;\n }\n  dd(k+1,z);\n  b[l++]=a[k];\n  dd(k+1,z+a[k]);\n  l--;\n}\nint main()\n{ int i;  \n cin&gt;&gt;n;\n   for (i=n-1;i&gt;=0;i--)\n    cin&gt;&gt;a[i];\n   cin&gt;&gt;sum;\n   dd(0,0);\n   cout&lt;&lt;v&lt;&lt;endl;\n  return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\n\r\n</textarea>	290
289	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　学霸抢走了大家的作业，班长为了帮同学们找回作业，决定去找学霸决斗。但学霸为了不要别人打扰，住在一个城堡里，城堡外面是一个二维的格子迷宫，要进城堡必须得先通过迷宫。因为班长还有妹子要陪，磨刀不误砍柴功，他为了节约时间，从线人那里搞到了迷宫的地图，准备提前计算最短的路线。可是他现在正向妹子解释这件事情，于是就委托你帮他找一条最短的路线。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行两个整数n， m，为迷宫的长宽。\n  <br> 　　接下来n行，每行m个数，数之间没有间隔，为0或1中的一个。0表示这个格子可以通过，1表示不可以。假设你现在已经在迷宫坐标(1,1)的地方，即左上角，迷宫的出口在(n,m)。每次移动时只能向上下左右4个方向移动到另外一个可以通过的格子里，每次移动算一步。数据保证(1,1)，(n,m)可以通过。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　第一行一个数为需要的最少步数K。\n  <br> 　　第二行K个字符，每个字符∈{U,D,L,R},分别表示上下左右。如果有多条长度相同的最短路径，选择在此表示方法下字典序最小的一个。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  Input Sample 1:\n  <br> 3 3\n  <br> 001\n  <br> 100\n  <br> 110\n  <br> \n  <br> Input Sample 2:\n  <br> 3 3\n  <br> 000\n  <br> 000\n  <br> 000\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  Output Sample 1:\n  <br> 4\n  <br> RDRD\n  <br> \n  <br> Output Sample 2:\n  <br> 4\n  <br> DDRR\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　有20%的数据满足：1&lt;=n,m&lt;=10\n  <br> 　　有50%的数据满足：1&lt;=n,m&lt;=50\n  <br> 　　有100%的数据满足：1&lt;=n,m&lt;=500。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nstruct node{\n\tint x;\n\tint y;\n\tint s;\n\tint d;\n\tint p;\n}; \n\nint main(){\n\tchar map[501][501], path[2500] = "";\n\tint book[501][501] = {0};\n\tint n, m, head = 1, tail = 1, flag = 0;\n\tstruct node que[2501];\n\tint next[4][3] = {\n\t\t{-1, 0, 'U'},//上U \n\t\t{1, 0, 'D'},//下D\n\t\t{0, -1, 'L'},//左L\n\t\t{0, 1, 'R'}//右R\n\t};\n\tint i, j,tx, ty;\n\t\n\tscanf("%d %d", &amp;n, &amp;m);\n\t\n\tfor(i = 0; i &lt; n; i++){\n\t\tscanf("%s", map[i]);\n\t}\n\t\t\n\tque[tail].x = 1;\n\tque[tail].y = 1;\n\tque[tail].s = 0;\n\tque[tail].p = 0;\n\ttail++;\n\tbook[1][1] = 1;\n\t\n\twhile(head &lt; tail){\n\t\tif(flag){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(i = 0; i &lt; 4; i++){\n\t\t\ttx = que[head].x + next[i][0];\n\t\t\tty = que[head].y + next[i][1];\n\t\t\t\n\t\t\tif(tx &lt; 1 || ty &lt; 1 || tx &gt; n || ty &gt; m){\n\t\t\t\tcontinue;\n\t\t\t}\t\t\t\n\t\t\t\n\t\t\tif(book[tx][ty] == 0 &amp;&amp; map[tx - 1][ty - 1] == '0'){\n\t\t\t\tbook[tx][ty] = 1;\n\t\t\t\tque[tail].x = tx;\n\t\t\t\tque[tail].y = ty;\n\t\t\t\tque[tail].s = que[head].s + 1;\n\t\t\t\tque[tail].d = next[i][2];\n\t\t\t\tque[tail].p = head;\t\t\t\t\n\t\t\t\ttail++;\t\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(tx == n &amp;&amp; ty == m){\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\thead++;\n\t}\n\t\t\n\ti = tail - 1;\n\tj = 0;\n\twhile(que[i].p != 0){\n\t\tpath[j++] = que[i].d;\n\t\ti = que[i].p;\n\t}\n\t\n\tprintf("%d\\n", que[tail - 1].s);\n\tfor(j--; j &gt;= 0; j--){\n\t\tprintf("%c", path[j]);\n\t}\n\t\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;stdio.h&gt;\n#include &lt;iostream&gt;\n#include &lt;string.h&gt;\n#include &lt;math.h&gt;\n#include &lt;ctype.h&gt;\n#include &lt;algorithm&gt;\n#include &lt;map&gt;\n#include &lt;math.h&gt;\n#include &lt;stack&gt;\n#include &lt;queue&gt;\n#define Max 510\n#define inf 100000000\nusing namespace std;\nint vis[Max][Max],r,l;\nint Mov[4][2] = {{-1,0},{1,0},{0,-1},{0,1}};\nchar str[5] = "UDLR",m[Max][Max],step[Max];\nstruct Node{\n    int x;\n    int y;\n    int s;\n    char sp;\n}path[Max][Max];\nint BFS(){\n    Node now;\n    memset(vis, 0, sizeof(vis));\n    now.x = now.y =0;\n    path[now.x][now.y].s = 0;\n    path[now.x][now.y].sp = 0;\n    queue&lt;Node&gt;q;\n    q.push(now);\n    while (q.size()&gt;0) {\n        now = q.front();\n        if (now.x == r-1 &amp;&amp; now.y == l-1) {\n            break;\n        }\n        q.pop();\n        Node next = now;\n        //printf("now:x %d y %d  step %d  straight %c\\n",now.x,now.y,path[now.x][now.y].s,path[now.x][now.y].sp);\n        for (int i=0; i&lt;4; i++) {\n            next.x = now.x+Mov[i][0];\n            next.y = now.y+Mov[i][1];\n            if (!vis[next.x][next.y]&amp;&amp;(next.x&gt;=0&amp;&amp;next.x&lt;r&amp;&amp;next.y&gt;=0&amp;&amp;next.y&lt;l)&amp;&amp; m[next.x][next.y] != '1' ) {\n                vis[next.x][next.y] = 1;\n                path[next.x][next.y] = now;\n                path[next.x][next.y].sp = str[i];\n                path[next.x][next.y].s = path[now.x][now.y].s+1;\n                q.push(next);\n               // printf("next:x %d y %d  step %d  straight %c\\n",next.x,next.y,path[next.x][next.y].s,path[next.x][next.y].sp);\n            }\n        }\n    }\n    //printf("%d\\n",path[r-1][l-1].s);\n    return path[r-1][l-1].s;\n}\nint main(){\n    while (scanf("%d%d",&amp;r,&amp;l)!=EOF) {\n        for (int i=0; i&lt;r; i++) {\n                scanf("%s",m[i]);\n        }\n        printf("%d\\n",BFS());\n        int len = 0;\n        int nx = r-1,ny = l-1;\n        int nextx = nx,nexty = ny;\n        while (1) {\n            nx = nextx;\n            ny = nexty;\n            if (nx + ny == 0) {\n                break;\n            }\n            step[len++] = path[nx][ny].sp;\n            nextx = path[nx][ny].x;\n            nexty = path[nx][ny].y;\n        }\n        for (int i=len-1; i&gt;=0; i--) {\n            printf("%c",step[i]);\n        }\n        printf("\\n");\n    }\n    return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.LinkedList;\n\nclass Main{\n\tstatic char a[][];\n\tstatic String line = "Z";\n\tstatic int minStep;\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString s2[] = br.readLine().split(" ");\n\t\tint n = Integer.parseInt(s2[0]);\n\t\tint m = Integer.parseInt(s2[1]);\n\t\tminStep = n*m;\n\t\ta= new char [n][m];\n\t\tfor (int i = 0; i &lt; n; i++) {\n\t\t\ta[i] = br.readLine().toCharArray();\n\t\t}\n\t\t\tLinkedList&lt;Node&gt; list = new LinkedList&lt;&gt;();\n\t\t\tboolean b[][] = new boolean[n][m];\n\t\t\tlist.add(new Node(0,0,0,null,'.'));\n\t\t\tb[0][0] = true;\n\t\t\twhile(!list.isEmpty())\n\t\t\t{\n\t\t\t\tNode temp = list.removeFirst();\n\t\t\t\tint x = temp.x;\n\t\t\t\tint y = temp.y;\n\t\t\t\tint step  = temp.step;\n\t\t\t\t\n\t\t\t\tif(x == n-1 &amp;&amp; y == m-1)\n\t\t\t\t{\n\t\t\t\t\tif(step&lt;minStep){\n\t\t\t\t\t\tminStep = step;\n\t\t\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\t\t\tchar t = temp.cur;\n\t\t\t\t\t\twhile(t != '.'){\n\t\t\t\t\t\t\tsb.insert(0, t);\n\t\t\t\t\t\t\ttemp = temp.pre;\n\t\t\t\t\t\t\tt = temp.cur;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tline = sb.toString();\n\t\t\t\t\t\t\n\t\t\t\t\t\t}else if (step == minStep)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\t\t\t\tchar t = temp.cur;\n\t\t\t\t\t\t\twhile(t != '.'){\n\t\t\t\t\t\t\t\tsb.append(t);\n\t\t\t\t\t\t\t\ttemp = temp.pre;\n\t\t\t\t\t\t\t\tt = temp.cur;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tString tempLine = sb.toString();\n\t\t\t\t\t\t\tif(tempLine.compareTo(line)&lt;0){\n\t\t\t\t\t\t\t\tline = tempLine;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(step == minStep)\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\t\tif(x-1&gt;=0&amp;&amp;!b[x-1][y]&amp;&amp;a[x-1][y]== '0')\n\t\t\t\t\t{\n\t\t\t\t\t\tlist.add(new Node(x-1,y,step+1,temp,'U'));\n\t\t\t\t\t\tb[x-1][y] = true;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(x+1&lt;n&amp;&amp;!b[x+1][y]&amp;&amp;a[x+1][y]=='0')\n\t\t\t\t\t{\n\t\t\t\t\t\tlist.add(new Node(x+1,y,step+1,temp,'D'));\n\t\t\t\t\t\tb[x+1][y] = true;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(y-1&gt;=0&amp;&amp;!b[x][y-1]&amp;&amp;a[x][y-1]=='0')\n\t\t\t\t\t{\n\t\t\t\t\t\tlist.add(new Node(x,y-1,step+1,temp,'L'));\n\t\t\t\t\t\tb[x][y-1] = true;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(y+1&lt;m&amp;&amp;!b[x][y+1]&amp;&amp;a[x][y+1]=='0')\n\t\t\t\t\t{\n\t\t\t\t\t\tlist.add(new Node(x,y+1,step+1,temp,'R'));\n\t\t\t\t\t\tb[x][y+1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\n\t\t\t\n\t\tSystem.out.println(minStep);\n\t\tSystem.out.println(line);\n\t\t\n\t}\n}\n\nclass Node{\n\tint step;\n\tNode pre;\n\tint x;\n\tint y;\n\tchar cur;\n\tpublic Node(int x, int y,int step,Node pre,char cur) {\n\t\tsuper();\n\t\tthis.step = step;\n\t\tthis.pre = pre;\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.cur = cur;\n\t\t\n\t}\n\t\n\t\n}\r\n</textarea>	291
290	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　有n个人排队到r个水龙头去打水，他们装满水桶的时间t1、t2………..tn为整数且各不相等，应如何安排他们的打水顺序才能使他们总共花费的时间最少？\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行n，r (n&lt;=500,r&lt;=75)\n  <br> 　　第二行为n个人打水所用的时间Ti (Ti&lt;=100)；\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　最少的花费时间\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3 2\n  <br> 1 2 3\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <pre class="pddata">\n<pre>\n7\n</pre>\n\n  <div class="pdsec">\n   数据规模和约定\n  </div>\n  <div class="pdcont">\n   　　其中80%的数据保证n&lt;=10\n  </div>\n\r\n</pre>\n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;    \n#include &lt;stdlib.h&gt;    \n#define MAXNUM 500    \n//思路:用贪心算法,每次让用时最少的r个人分别去r个水龙头去打水    \n//总时间=每个人的打水时间+等待时间    \nint cmp(const void *a, const void * b)    \n{    \n    return *(int *)a - *(int *)b;    \n}    \nint main()    \n{    \n    int n, r, i, sum = 0;    \n    int a[MAXNUM], b[MAXNUM];    \n    scanf("%d %d", &amp;n, &amp;r);    \n    for(i = 0; i &lt; n; i++)    \n    {    \n        scanf("%d", &amp;a[i]);    \n    }    \n    qsort(a, n, sizeof(int), cmp);    \n    for(i = 0; i &lt; r; i++)    \n    {    \n        b[i] = a[i];    \n    }    \n    for(i = r; i &lt; n; i++)    \n    {    \n        b[i] = b[i - r] + a[i];    \n    }    \n    for(i = 0; i &lt; n; i++)    \n    {    \n        sum += b[i];    \n    }    \n    printf("%d\\n",sum); \n    system("pause");   \n    return 0;    \n}    \r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;stdio.h&gt;    \n#include &lt;stdlib.h&gt;    \n#define MAXNUM 500    \n \nint cmp(const void *a, const void * b)    \n{    \n    return *(int *)a - *(int *)b;    \n}    \nint main()    \n{    \n    int n, r, i, sum = 0;    \n    int a[MAXNUM], b[MAXNUM];    \n    scanf("%d %d", &amp;n, &amp;r);    \n    for(i = 0; i &lt; n; i++)    \n    {    \n        scanf("%d", &amp;a[i]);    \n    }    \n    qsort(a, n, sizeof(int), cmp);    \n    for(i = 0; i &lt; r; i++)    \n    {    \n        b[i] = a[i];    \n    }    \n    for(i = r; i &lt; n; i++)    \n    {    \n        b[i] = b[i - r] + a[i];    \n    }    \n    for(i = 0; i &lt; n; i++)    \n    {    \n        sum += b[i];    \n    }    \n    printf("%d\\n",sum);    \n    return 0;    \n}\r\n</textarea>	<textarea id="codelinesjava">\r\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Vector;\n\npublic class Main {\n\tstatic Vector&lt;Vector&lt;Integer&gt;&gt; dui=new Vector&lt;Vector&lt;Integer&gt;&gt;();\n\tstatic void quickSoft(int start,int end,int[] s){\n\t\tif(start&gt;=end)return;\n\t\tint l=start,r=end,p=s[end];\n\t\twhile (l&lt;r) {\n\t\t\twhile(l&lt;end&amp;&amp;s[l]&lt;=p)l++;\n\t\t\twhile(r&gt;start&amp;&amp;s[r]&gt;p)r--;\n\t\t\tif(l&lt;r){\n\t\t\t\ts[l]^=s[r];\n\t\t\t\ts[r]^=s[l];\n\t\t\t\ts[l]^=s[r];\n\t\t\t}\n\t\t}quickSoft(start, l-1, s);quickSoft(l, end, s);\n\t}\n\tstatic int getMinindex(){\n\t\tint m=dui.get(0).get(dui.get(0).size()-1),index=0;\n\t\tfor (int i = 1; i &lt; dui.size(); i++) {\n\t\t\tint a=dui.get(i).get(dui.get(i).size()-1);\n\t\t\tif(a&lt;m){m=a;index=i;}\n\t\t}\n\t\treturn index;\n\t}\n\tstatic int getmin(){\n\t\t\n\t\tint num=0;\n\t\tfor (int i = 0; i &lt; dui.size(); i++) {\n\t\t\t\n\t\t\tfor (int j = 0; j &lt; dui.get(i).size(); j++) {\n\t\t\t\tnum+=dui.get(i).get(j);\n\t\t\t}\n\t\t}\n\t\treturn num;\n\t}\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] a1=bf.readLine().split(" ");\n\t\tint n=Integer.parseInt(a1[0]);int r=Integer.parseInt(a1[1]);\n\t\tint[] s=new int[n];\n\t\ta1=bf.readLine().split(" ");\n\t\tfor (int i = 0; i &lt; s.length; i++) \n\t\t\ts[i]=Integer.parseInt(a1[i]);\n\t\tquickSoft(0, n-1, s);\n\t\tfor (int i = 0; i &lt; r; i++) {\n\t\t\tdui.add(new Vector&lt;Integer&gt;());\n\t\t\tdui.get(i).add(0);\n\t\t}\n\t\tint index=0;\n\t\tfor (int i = 0; i &lt; s.length; i++) {\n\t\t\tindex=getMinindex();\n\t\t\t//System.out.println(index);\n\t\t\tdui.get(index).add(dui.get(index).get(dui.get(index).size()-1)+s[i]);\n\t\t}\n\t\tSystem.out.println(getmin());\n\t}\n}\n\r\n</textarea>	292
291	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　农民约翰母牛总是产生最好的肋骨。你能通过农民约翰和美国农业部标记在每根肋骨上的数字认出它们。农民约翰确定他卖给买方的是真正的质数肋骨，是因为从右边开始切下肋骨，每次还剩下的肋骨上的数字都组成一个质数。\n  <br> \n  <br> 　　例如有四根肋骨的数字分别是：7 3 3 1，那么全部肋骨上的数字 7331是质数；三根肋骨 733是质数；二根肋骨 73 是质数；当然,最后一根肋骨 7 也是质数。7331 被叫做长度 4 的特殊质数。\n  <br> \n  <br> 　　写一个程序对给定的肋骨的数目 N (1&lt;=N&lt;=8),求出所有的特殊质数。数字1不被看作一个质数。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　单独的一行包含N。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　按顺序输出长度为 N 的特殊质数,每行一个。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  4\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  2333\n  <br> 2339\n  <br> 2393\n  <br> 2399\n  <br> 2939\n  <br> 3119\n  <br> 3137\n  <br> 3733\n  <br> 3739\n  <br> 3793\n  <br> 3797\n  <br> 5939\n  <br> 7193\n  <br> 7331\n  <br> 7333\n  <br> 7393\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n#include&lt;math.h&gt;\n\nint n;\nint a[] = {0,1,3,5,7,9};\n\nint isprime( int x )\n{\n    int i;\n    if ( x==1 ) \n        return 0;\n    if ( x==2 )\n        return 1;\n    int root = (int)sqrt(x+0.5);\n    for ( i = 2;i &lt;= root;i++ )\n    {\n        if ( x%i==0 )\n            return 0;\n    }\n    return 1;\n}\n\nvoid f( int x,int y )\n{\n    int i;\n    if ( y==n )\n    {\n        printf("%d\\n",x);\n        return;\n    }\n    for ( i = 0;i &lt; 6;i++ )\n    {\n        if ( isprime(x*10+a[i]) )\n        {\n            f( x*10+a[i],y+1);\n        }\n    }\n}\n\nint main()\n{\n    scanf("%d",&amp;n);\n    f(2,1);\n    f(3,1);\n    f(5,1);\n    f(7,1);\n    system("pause");\n    return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nint main()\n{\n    int n;\n    while(~scanf("%d",&amp;n))\n    {\n        if(n == 1)\n        printf("2\\n3\\n5\\n7\\n");\n        else if(n == 2)\n        printf("23\\n29\\n31\\n37\\n53\\n59\\n71\\n73\\n79\\n");\n        else if(n == 3)\n        printf("233\\n239\\n293\\n311\\n313\\n317\\n373\\n379\\n593\\n599\\n719\\n733\\n739\\n797\\n");\n        else if(n == 4)\n        printf("2333\\n2339\\n2393\\n2399\\n2939\\n3119\\n3137\\n3733\\n3739\\n3793\\n3797\\n5939\\n7193\\n7331\\n7333\\n7393\\n");\n        else if(n == 5)\n        printf("23333\\n23339\\n23399\\n23993\\n29399\\n31193\\n31379\\n37337\\n37339\\n37397\\n59393\\n59399\\n71933\\n73331\\n73939\\n");\n        else if(n == 6)\n        printf("233993\\n239933\\n293999\\n373379\\n373393\\n593933\\n593993\\n719333\\n739391\\n739393\\n739397\\n739399\\n");\n        else if(n == 7)\n        printf("2339933\\n2399333\\n2939999\\n3733799\\n5939333\\n7393913\\n7393931\\n7393933\\n");\n        else if(n == 8)\n        printf("23399339\\n29399999\\n37337999\\n59393339\\n73939133\\n");\n    }\n\n    return 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tint n=new Scanner(System.in).nextInt();\n\t\tArrayList list=new ArrayList&lt;Integer&gt;(),arr=new ArrayList&lt;Integer&gt;();\n\t\tlist.add(2);list.add(3);list.add(5);list.add(7);\n\t\tfor (int i = 2; i &lt;= n; i++) {\n\t\t\tfor (int j = 0; j &lt; list.size(); j++) {\n\t\t\t\tint m=(Integer) list.get(j)*10;\n\t\t\t\tfor (int k = 0; k &lt; 10; k++) {\n\t\t\t\t\tboolean b=true;\n\t\t\t\t\tm++;\n\t\t\t\t\tif(m%6!=1&amp;&amp;m%6!=5)continue;\n\t\t\t\t\tfor (int k2 = 5; k2*k2 &lt;= m; k2+=6) {\n\t\t\t\t\t\tif(m%k2==0||m%(k2+2)==0)b=false;\n\t\t\t\t\t}\n\t\t\t\t\tif(b) arr.add(m);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlist.clear();list=(ArrayList) arr.clone();arr.clear();\n\t\t}\n\t\tfor (int i = 0; i &lt; list.size(); i++) {\n\t\t\tSystem.out.println(list.get(i));\n\t\t}\n\t}\n}\n\r\n</textarea>	293
292	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　题目很简单，给出N个数字，不改变它们的相对位置，在中间加入K个乘号和N-K-1个加号，（括号随便加）使最终结果尽量大。因为乘号和加号一共就是N-1个了，所以恰好每两个相邻数字之间都有一个符号。例如：\n  <br> 　　N=5，K=2，5个数字分别为1、2、3、4、5，可以加成：\n  <br> 　　1*2*(3+4+5)=24\n  <br> 　　1*(2+3)*(4+5)=45\n  <br> 　　(1*2+3)*(4+5)=45\n  <br> 　　……\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入文件共有二行，第一行为两个有空格隔开的整数，表示N和K，其中（2&lt;=N&lt;=15, 0&lt;=K&lt;=N-1）。第二行为 N个用空格隔开的数字（每个数字在0到9之间）。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出文件仅一行包含一个整数，表示要求的最大的结果\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5 2\n  <br> 1 2 3 4 5\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  120\n </div>\n <div class="pdsec">\n  样例说明\n </div>\n <div class="pdcont">\n  　　(1+2+3)*4*5=120\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\nlong long int jc(int n)\n{\n\tlong long int sum=1;\n\twhile(n)\n\t{\n\t\tsum*=n;\n\t\tn--;\n\t}\n\treturn sum;\n}\nint main()\n{\n\tint n,k;\n\tshort i,j;\n\tint *p;\n\tint *q; \n\tint *t_i;\n\tlong long Mmax=0; \n\tint times;\n\tint x=0;\n\tscanf("%d%d",&amp;n,&amp;k);\n\tp=(int *)malloc(n*sizeof(int));\n\tq=(int *)malloc((k+1)*sizeof(int));\n\tt_i=(int *)malloc((k+1)*sizeof(int));\n\tfor(i=0;i&lt;n;i++)\n\tscanf("%d",p+i);\n\t\n\ttimes=jc(n-1)/(jc(k)*jc(n-1-k));\n\tfor(i=0;i&lt;k+1;i++)\n\t{\n\t\tt_i[i]=1;\n\t } \n\tfor(i=1;i&lt;=times;i++)\t\t\t//times次排列组合 \n\t{\n\t\tint sum_i=0;\n\t\tint s=0;\n\t\tfor(j=0;j&lt;k;j++)\t\t\t//求最后一个组合数； \n\t\t{\n\t\t\tsum_i+=t_i[j];\n\t\t}\n\t\tt_i[j]=n-sum_i;\n\t\tfor(j=0;j&lt;k+1;j++)\t\t\t//K+1个组合 \n\t\t{\n\t\t\tq[j]=0;\n\t\t\tint m;\n\t\t\tfor(m=0;m&lt;t_i[j];m++)\t//每个组合的和； \n\t\t\t{\n\t\t\t\tq[j]+=p[s++];\n\t\t\t}\t\t \n\t\t}\n\t\tlong long max=1;\n\t\tfor(j=0;j&lt;k+1;j++)\n\t\t{\n\t\t\tmax*=q[j];\n\t\t } \n\t\t if(max&gt;Mmax)\n\t\t Mmax=max;\n\t\tfor(j=k-1;j&gt;=0;j--)\t\t\t//每个组合的个数； \n\t\t{\n\t\t\tif((t_i[j]+1)&lt;=(n-k)&amp;&amp;sum_i+1&lt;n)\n\t\t\t{\n\t\t\t\tt_i[j]++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsum_i-=(t_i[j]-1);\n\t\t\t\tt_i[j]=1;\n\t\t\t}\n\t\t}\n\t\n\t\t\n\t}\n\tprintf("%lld\\n",Mmax);\n\tfree(q);\n\tfree(t_i);\n\tfree(p);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\nusing namespace std;\n\n#define MAXN 15\ntypedef unsigned long long  ULL;\n\nint N, K, All; // 数字总数, 乘号总数, 符号总数 \nint dp[MAXN][MAXN];\nbool Symbol[MAXN-1];\nULL MaxValue = 0;\n\nvoid Dfs( int deep, int begin )\n{\n\tif( deep == K )\n\t{\n\t\tULL sum = 1;\n\t\tfor( int i = 0,start=0; i &lt; N; ++i )\n\t\t{\n\t\t\tstart = i;\n\t\t\twhile( Symbol[i] == false &amp;&amp; i &lt; All )\n\t\t\t\t++i;\n\t\t\tsum *= dp[start][i];\n\t\t}\n\t\tif( sum &gt; MaxValue )\n\t\t\tMaxValue = sum;\n\t}\n\telse\n\t{\n\t\tfor( int i = begin; i &lt; All; ++i )\n\t\t\tif( !Symbol[i] )\n\t\t\t{\n\t\t\t\tSymbol[i] = true;\n\t\t\t\tDfs(deep+1, i+1);\n\t\t\t\tSymbol[i] = false;\n\t\t\t}\n\t}\n}\n\nint main(int argc, char** argv) {\n\tcin &gt;&gt; N &gt;&gt; K;\n\tAll = N - 1; \n\tfor( int i = 0; i &lt; All; ++i) Symbol[i]=false;\n\tfor(int i = 0; i &lt; N; ++i ) cin &gt;&gt; dp[i][i];\t\n\tfor( int i = 0; i &lt; N; ++i )\n\t\tfor( int j = i+1; j &lt; N; ++j )\n\t\t\tdp[i][j] = dp[i][j-1] + dp[j][j];\n\tDfs(0,0);\n\tcout &lt;&lt; MaxValue;\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] str = br.readLine().split(" ");\n\t\tint n = Integer.parseInt(str[0]);\n\t\tint k = Integer.parseInt(str[1]);\n\t\t\n\t\tlong[][] dp = new long[16][16];\n\t\tint[] sum = new int[16];\n\t\t\n\t\tstr = br.readLine().split(" ");\n\t\tfor(int i = 1; i &lt;= n; i++) {\n\t        sum[i] =  sum[i-1] + Integer.parseInt(str[i-1]);\n\t    }\n\t\t\n\t\tfor(int i = 1; i &lt;= n; i++) {\n\t        dp[i][0] = sum[i];\n\t    }\n\t\t\n\t    for(int i = 2; i &lt;= n; i++) {\n\t        for(int j = 1; j &lt;= i-1 &amp;&amp; j &lt;= k; j++) {\n\t            for(int l = 2; l &lt;= n; l++) {\n\t                dp[i][j] = max(dp[i][j], dp[l-1][j-1] * (sum[i] - sum[l-1]));\n\t            }\n\t        }\n\t    }\n\t    System.out.println(dp[n][k]);\n\t}\n\n\tprivate static long max(long a, long b) {\n\t\treturn a&gt;b?a:b;\n\t}\n}\r\n</textarea>	294
305	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　以前有个孩子，他分分钟都在碎碎念。不过，他的念头之间是有因果关系的。他会在本子里记录每一个念头，并用箭头画出这个念头的来源于之前的哪一个念头。翻开这个本子，你一定会被互相穿梭的箭头给搅晕，现在他希望你用程序计算出这些念头中最长的一条因果链。\n  <br> 　　将念头从1到n编号，念头i来源于念头from[i]，保证from[i]&lt;i，from[i]=0表示该念头没有来源念头，只是脑袋一抽，灵光一现。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行一个正整数n表示念头的数量\n  <br> 　　接下来n行依次给出from[1]，from[2]，…，from[n]\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　共一行，一个正整数L表示最长的念头因果链中的念头数量\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  8\n  <br> 0\n  <br> 1\n  <br> 0\n  <br> 3\n  <br> 2\n  <br> 4\n  <br> 2\n  <br> 4\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  3\n </div>\n <div class="pdsec">\n  样例说明\n </div>\n <div class="pdcont">\n  　　最长的因果链有：\n  <br> 　　1-&gt;2-&gt;5 (from[5]=2,from[2]=1,from[1]=0)\n  <br> 　　1-&gt;2-&gt;7 (from[7]=2,from[2]=1,from[1]=0)\n  <br> 　　3-&gt;4-&gt;6 (from[6]=4,from[4]=3,from[3]=0)\n  <br> 　　3-&gt;4-&gt;8 (from[8]=4,from[4]=3,from[3]=0)\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　1&lt;=n&lt;=1000\n </div> \n</div>	<textarea id="codelinesc">\r\n/*\n问题描述\n　　以前有个孩子，他分分钟都在碎碎念。不过，他的念头之间是有因果关系的。他会在本子里记录每一个念头，并用箭头画出这个念头的来源于之前的哪一个念头。翻开这个本子，你一定会被互相穿梭的箭头给搅晕，现在他希望你用程序计算出这些念头中最长的一条因果链。\n　　将念头从1到n编号，念头i来源于念头from[i]，保证from[i]&lt;i，from[i]=0表示该念头没有来源念头，只是脑袋一抽，灵光一现。\n输入格式\n　　第一行一个正整数n表示念头的数量\n　　接下来n行依次给出from[1]，from[2]，…，from[n]\n输出格式\n　　共一行，一个正整数L表示最长的念头因果链中的念头数量\n样例输入\n8\n0\n1\n0\n3\n2\n4\n2\n4\n样例输出\n3\n样例说明\n　　最长的因果链有：\n　　1-&gt;2-&gt;5 (from[5]=2,from[2]=1,from[1]=0)\n　　1-&gt;2-&gt;7 (from[7]=2,from[2]=1,from[1]=0)\n　　3-&gt;4-&gt;6 (from[6]=4,from[4]=3,from[3]=0)\n　　3-&gt;4-&gt;8 (from[8]=4,from[4]=3,from[3]=0)\n数据规模和约定\n　　1&lt;=n&lt;=1000\n*/\n/*\n其实是图的连通问题 \n但是我才不会那么老实地用图的方法去做呢 \n*/\n#include&lt;stdio.h&gt;\n\nint xz/*寻找*/( int value, int pos, int arr[], int n );\nvoid input( int arr[], int n );\n\nint main(void){\n\t\n\tint n;\n\tscanf("%d", &amp;n);\n\t\n\tint arr[ n ];\n\tinput( arr, n );\n\t\n\tprintf("%d\\n", xz/*寻找*/( 0, 0, arr, n ) );\n\t\n\treturn 0;\n}\n\nint xz/*寻找*/( int value, int pos, int arr[], int n ){\n\tif ( pos == n ) { // 找到头了 \n\t\treturn 0;\n\t}\n\t\n\tint v1 = 0 , v2 = 0 ;\n\tif ( arr[ pos ] == value ) { // 找到目标了\n\t\tv1 = 1 + xz/*寻找*/( pos + 1, pos + 1, arr, n ); // 找链子的下一节 \n\t}\n\tv2 = xz/*寻找*/( value, pos + 1, arr, n ); // 找下一个 \n\treturn v1 &gt; v2 ? v1 : v2 ; // 取最长的链子 \n}\n\nvoid input( int arr[], int n ){\n\tint i;\n\tfor ( i = 0 ; i &lt; n ; i ++ ) {\n\t\tscanf("%d", arr + i );\n\t}\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n/**************Powered by Graphene Richards**************/\nextern"C++"{\n#define FLOAT_PRECISION     2\n\n#ifdef _MSC_VER\n#define _SECURE_SCL 0\n#pragma comment(linker,"/STACK:102400000,102400000")\n#else\n#pragma GCC optimize("O3")\n#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx")\n#endif\n#if defined(_MSC_VER)||__cplusplus&gt;199711L\n#define IT(x) auto\n#define DIT(x) auto\n#else\n#define IT(x) __typeof((x).begin())\n#define DIT(x) __typeof((x).rbegin())\n#endif\n\n#  inc\\\nlude&lt;cmath&gt;\n#  inc\\\nlude&lt;cstdio&gt;\n#  inc\\\nlude&lt;cstdlib&gt;\n#  inc\\\nlude&lt;cstring&gt;\n#  inc\\\nlude&lt;algorithm&gt;\n#  inc\\\nlude&lt;bitset&gt;\n#  inc\\\nlude&lt;complex&gt;\n#  inc\\\nlude&lt;vector&gt;\n#  inc\\\nlude&lt;iomanip&gt;\n#  inc\\\nlude&lt;iostream&gt;\n#  inc\\\nlude&lt;list&gt;\n#  inc\\\nlude&lt;map&gt;\n#  inc\\\nlude&lt;queue&gt;\n#  inc\\\nlude&lt;set&gt;\n#  inc\\\nlude&lt;stack&gt;\n#  inc\\\nlude&lt;string&gt;\n#define FAST_RW ios_base::sync_with_stdio(0),cin.tie(0);\n#define FS(i,a) for(ll i=0;a[i];i++)\n#define FE(it,x) for(IT(x) it=(x).begin(),_en=(x).end();it!=_en;it++)\n#define EF(it,x) for(DIT(x) it=(x).rbegin(),_en=(x).rend();it!=_en;it++)\n#define FR(i,en) for(ll i=0,_en=(en);i&lt;_en;i++)\n#define FOR(i,en) for(ll i=1,_en=(en);i&lt;=_en;i++)\n#define RF(i,en) for(ll i=(en)-1;i&gt;=0;i--)\n#define ROF(i,en) for(ll i=(en);i&gt;0;i--)\n#define FFR(i,x,y) for(ll i=(x),_en=(y);i&lt;=_en;i++)\n#define RFF(i,x,y) for(ll i=(x),_en=(y);i&gt;=_en;i--)\n#define pc putchar\n#define pb push_back\n#define ppb pop_back\n#define pq priority_queue\n#define fi first\n#define se second\n#define mp make_pair\n#define pii pair&lt;int,int&gt;\n#define pll pair&lt;ll,ll&gt;\n#define sqr(x) ((x)*(x))\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define clr(x) memset((x),0,sizeof(x))\n#define ms(x,v) memset((x),(v),sizeof(x))\n#define mc(x,y) memcpy((x),(y),sizeof(y))\n#define NL puts("");\n#define LB lower_bound\n#define UB upper_bound\n#define rand() ((rand()&lt;&lt;16)^(rand()&lt;&lt;15)^(rand()))\n#ifdef _WIN32\n#define _i64_ "%I\\\n64d"\n#define _u64_ "%I\\\n64u"\n#else\n#define _i64_ "%l\\\nld"\n#define _u64_ "%l\\\nlu"\n#endif\ntypedef unsigned ui;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lf;\nusing namespace std;\n\null gcd(ull a,ull b){if(!b)return a;while(b^=a^=b^=a%=b);return a;}\n\nextern const ll MOD;\nll ksm(ll a,ll b){\nll res=1;a%=MOD;\nfor(;b;b&gt;&gt;=1){if(b&amp;1)res=res*a%MOD;a=a*a%MOD;}\nreturn res;\n}\n\n#ifdef wmx16835\n#include"wmx16835.h"\n#else\n#define LOG\n#define TEL\n#define test(...) 0\n#define TEST(...) 0\n#define TRY(...)\n#define SF(...)\n#define SC\n#define PF\n#define PC\n#define PP\n#define SHOW_TIME\n#define BR\n#endif\nint main(){SHOW_TIME int __MAIN();__MAIN();}\n#define main __MAIN\n#define y0 NKwKGuBI\n#define y1 KFJssmlK\n#define yn XypGISMR\n#define j1 kQDCYYWX\n#define tm BdKIQNcs\n#define lr UsCPcJvt\n\ntemplate&lt;class T1,class T2,class T3&gt;bool In(T1 x,T2 y,T3 z){return x&lt;=y&amp;&amp;x&gt;=z||x&lt;=z&amp;&amp;x&gt;=y;}\ntemplate&lt;class T1,class T2&gt;T1 max(const T1&amp;a,const T2&amp;b){return a&lt;b?b:a;}\ntemplate&lt;class T1,class T2,class T3&gt;T1 max3(const T1&amp;a,const T2&amp;b,const T3&amp;c){return a&lt;b?(b&lt;c?c:b):(a&lt;c?c:a);}\ntemplate&lt;class T1,class T2&gt;T1 min(const T1&amp;a,const T2&amp;b){return a&lt;b?a:b;}\ntemplate&lt;class T1,class T2,class T3&gt;T1 min3(const T1&amp;a,const T2&amp;b,const T3&amp;c){return a&lt;b?(a&lt;c?a:c):(b&lt;c?b:c);}\n\nbool S(char*a){return scanf("%s",a)==1;}\nbool S(int&amp;a){return scanf("%d",&amp;a)==1;}\nbool S(bool&amp;a){return scanf("%d",&amp;a)==1;}\nbool S(ui&amp;a){return scanf("%u",&amp;a)==1;}\nbool S(float&amp;a){return scanf("%f",&amp;a)==1;}\nbool S(double&amp;a){return scanf("%lf",&amp;a)==1;}\nbool S(ll&amp;a){return scanf(_i64_,&amp;a)==1;}\nbool S(ull&amp;a){return scanf(_u64_,&amp;a)==1;}\nbool S(lf&amp;a){double b;if(scanf("%lf",&amp;b)==-1)return 0;a=b;return 1;}\nbool S(char&amp;a){char b[2];if(scanf("%1s",b)==-1)return 0;a=*b;return 1;}\nbool SL(char*a){a[0]=0;while(gets(a)&amp;&amp;!a[0]);return a[0];}\ntemplate&lt;class T1,class T2&gt;bool S(pair&lt;T1,T2&gt;&amp;a){S(a.fi),S(a.se);}\ntemplate&lt;class T&gt;bool S(T&amp;a){a.in();}\n\nvoid _P(const int&amp;x){printf("%d",x);}\nvoid _P(const bool&amp;x){printf("%d",x);}\nvoid _P(const ui&amp;x){printf("%u",x);}\nvoid _P(const char&amp;x){printf("%c",x);}\nvoid _P(const char*x){printf("%s",x);}\nvoid _P(const string&amp;x){printf("%s",x.c_str());}\nvoid _P(const ll&amp;x){printf(_i64_,x);}\nvoid _P(const ull&amp;x){printf(_u64_,x);}\nvoid _P(const float&amp;x){printf("%.*f",FLOAT_PRECISION,x);}\nvoid _P(const double&amp;x){printf("%.*f",FLOAT_PRECISION,x);}\nvoid _P(const lf&amp;x){printf("%.*f",FLOAT_PRECISION,(double)x);}\ntemplate&lt;class T1,class T2&gt;void _P(const pair&lt;T1,T2&gt;&amp;x){_P(x.fi);pc(' ');_P(x.se);}\ntemplate&lt;class T&gt;void _P(const T&amp;a){a.out();}\n\ntemplate&lt;class T1,class T2&gt;bool S(T1&amp;a,T2&amp;b){return S(a)+S(b)==2;}\ntemplate&lt;class T1,class T2,class T3&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c){return S(a)+S(b)+S(c)==3;}\ntemplate&lt;class T1,class T2,class T3,class T4&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d){return S(a)+S(b)+S(c)+S(d)==4;}\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d,T5&amp;e){return S(a)+S(b)+S(c)+S(d)+S(e)==5;}\n\ntemplate&lt;class T1&gt;void P(const T1&amp;a){_P(a);pc(' ');}\ntemplate&lt;class T1,class T2&gt;void P(const T1&amp;a,const T2&amp;b){_P(a);pc(' ');_P(b);pc(' ');}\ntemplate&lt;class T1&gt;void PN(const T1&amp;a){_P(a);NL}\ntemplate&lt;class T1,class T2&gt;void PN(const T1&amp;a,const T2&amp;b){_P(a);pc(' ');_P(b);NL}\ntemplate&lt;class T1,class T2,class T3&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c){_P(a);pc(' ');_P(b);pc(' ');_P(c);NL}\ntemplate&lt;class T1,class T2,class T3,class T4&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c,const T4&amp;d){_P(a);pc(' ');_P(b);pc(' ');_P(c);pc(' ');_P(d);NL}\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c,const T4&amp;d,const T5&amp;e){_P(a);pc(' ');_P(b);pc(' ');_P(c);pc(' ');_P(d);pc(' ');_P(e);NL}\nvoid PS(int a){printf("%*s",a,"");}\n\ntemplate&lt;class T&gt;void SA(T*a,int n){FR(i,n)S(a[i]);}\ntemplate&lt;class T&gt;void PA(T*a,int n){FR(i,n){if(i)pc(' ');_P(a[i]);}NL}\ntemplate&lt;class T&gt;void PA(const T&amp;x){FE(it,x){if(it!=x.begin())pc(' ');_P(*it);}NL}\n\nint kase;\nconst double pi=4*atan(1.);\nconst double ep=1e-9;\nconst int INF=0x3f3f3f3f;\nconst ll INFL=0x3f3f3f3f3f3f3f3fll;\nconst ll MOD=1000000007;\n}\n\nint a[1005];\nint d[1005];\n\nint main() {\n\tint n;\n\tS(n);\n\tint res = 0;\n\tFOR(i, n) {\n\t\tS(a[i]);\n\t\td[i] = d[a[i]] + 1;\n\t\tres = max(res, d[i]);\n\t}\n\tPN(res);\n}\n\n/*********Risoft corporation all rights reserved*********/\n/**************Template V2.33 build 20151012*************/\n\r\n</textarea>	<textarea id="codelinesjava">\r\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Vector;\n\npublic class Main {\n\tstatic Vector&lt;Vector&lt;Integer&gt;&gt; map=new Vector&lt;Vector&lt;Integer&gt;&gt;();\n\tstatic int[] DFN;\n\tstatic void dfs(int a,int count){\n\t\tDFN[a]=count;\n\t\tfor (int i = 0; i &lt; map.get(a).size(); i++) {\n\t\t\tdfs(map.get(a).get(i), count+1);\n\t\t}\n\t}\n\tstatic void print(int[] s){\n\t\tfor (int i = 0; i &lt; s.length; i++) {\n\t\t\tSystem.out.print(s[i]+" ");\n\t\t}System.out.println();\n\t}\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tBufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n\t\tint n=Integer.parseInt(bf.readLine());\n\t\tint[] from=new int[n];\n\t\tDFN=new int[n];\n\t\tfor (int i = 0; i &lt;n; i++) {\n\t\t\tmap.add(new Vector&lt;Integer&gt;());\n\t\t}\n\t\tfor (int i = 0; i &lt; n; i++) {\n\t\t\tfrom[i]=Integer.parseInt(bf.readLine());\n\t\t\tif(from[i]==0)continue;\n\t\t\tmap.get(from[i]-1).add(i);\n\t\t}\n\t\t//print(from);\n\t\tfor (int i = 0; i &lt; from.length; i++) {\n\t\t\tif(from[i]==0)\n\t\t\tdfs(i, 1);\n\t\t}\n\t\tint max=0;\n\t\tfor (int i = 0; i &lt; from.length; i++) {\n\t\t\tif(max&lt;DFN[i])max=DFN[i];\n\t\t}\n\t\tSystem.out.println(max);\n\t}\n}\n\r\n</textarea>	307
293	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　有两个整数，如果每个整数的约数和（除了它本身以外）等于对方，我们就称这对数是友好的。例如：\n  <br> 　　9的约数和有：1+3=4\n  <br> 　　4的约数和有：1+2=3\n  <br> 　　所以9和4不是友好的。\n  <br> 　　220的约数和有：1 2 4 5 10 11 20 22 44 55 110=284\n  <br> 　　284的约数和有：1 2 4 71 142=220\n  <br> 　　所以220和284是友好的。\n  <br> 　　编写程序，判断两个数是否是友好数。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　一行，两个整数，由空格分隔\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　如果是友好数，输出"yes"，否则输出"no"，注意不包含引号。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  220 284\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  yes\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　两个整数都小于10000\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdlib.h&gt;\n#include&lt;stdio.h&gt;\nint main(){\n    int m,n,n1=0,m1=0,i,j;\n    scanf("%d%d",&amp;m,&amp;n);\n    for(i=1;i&lt;m/2+1;i++){\n        if(m%i==0){\n            n1+=i; \n            }\n        }\n    for(i=1;i&lt;n/2+1;i++){\n        if(n%i==0){\n            m1+=i; \n            }\n        }\n    if(n1==n&amp;&amp;m1==m){\n        printf("yes");\n        }else{\n        printf("no");   \n            }\n    system("pause");\n    return 0; \n}\r\n</textarea>	<textarea id="codelinescpp">\r\n/**************Powered by Graphene Richards**************/\nextern"C++"{\n#define FLOAT_PRECISION     2\n\n#ifdef _MSC_VER\n#define _SECURE_SCL 0\n#pragma comment(linker,"/STACK:102400000,102400000")\n#else\n#pragma GCC optimize("O3")\n#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx")\n#endif\n#if defined(_MSC_VER)||__cplusplus&gt;199711L\n#define IT(x) auto\n#define DIT(x) auto\n#else\n#define IT(x) __typeof((x).begin())\n#define DIT(x) __typeof((x).rbegin())\n#endif\n\n#  inc\\\nlude&lt;cmath&gt;\n#  inc\\\nlude&lt;cstdio&gt;\n#  inc\\\nlude&lt;cstdlib&gt;\n#  inc\\\nlude&lt;cstring&gt;\n#  inc\\\nlude&lt;algorithm&gt;\n#  inc\\\nlude&lt;bitset&gt;\n#  inc\\\nlude&lt;complex&gt;\n#  inc\\\nlude&lt;vector&gt;\n#  inc\\\nlude&lt;iomanip&gt;\n#  inc\\\nlude&lt;iostream&gt;\n#  inc\\\nlude&lt;list&gt;\n#  inc\\\nlude&lt;map&gt;\n#  inc\\\nlude&lt;queue&gt;\n#  inc\\\nlude&lt;set&gt;\n#  inc\\\nlude&lt;stack&gt;\n#  inc\\\nlude&lt;string&gt;\n#define FAST_RW ios_base::sync_with_stdio(0),cin.tie(0);\n#define FS(i,a) for(ll i=0;a[i];i++)\n#define FE(it,x) for(IT(x) it=(x).begin(),_en=(x).end();it!=_en;it++)\n#define EF(it,x) for(DIT(x) it=(x).rbegin(),_en=(x).rend();it!=_en;it++)\n#define FR(i,en) for(ll i=0,_en=(en);i&lt;_en;i++)\n#define FOR(i,en) for(ll i=1,_en=(en);i&lt;=_en;i++)\n#define RF(i,en) for(ll i=(en)-1;i&gt;=0;i--)\n#define ROF(i,en) for(ll i=(en);i&gt;0;i--)\n#define FFR(i,x,y) for(ll i=(x),_en=(y);i&lt;=_en;i++)\n#define RFF(i,x,y) for(ll i=(x),_en=(y);i&gt;=_en;i--)\n#define pc putchar\n#define pb push_back\n#define ppb pop_back\n#define pq priority_queue\n#define fi first\n#define se second\n#define mp make_pair\n#define pii pair&lt;int,int&gt;\n#define pll pair&lt;ll,ll&gt;\n#define sqr(x) ((x)*(x))\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define clr(x) memset((x),0,sizeof(x))\n#define ms(x,v) memset((x),(v),sizeof(x))\n#define mc(x,y) memcpy((x),(y),sizeof(y))\n#define NL puts("");\n#define LB lower_bound\n#define UB upper_bound\n#define rand() ((rand()&lt;&lt;16)^(rand()&lt;&lt;15)^(rand()))\n#ifdef _WIN32\n#define _i64_ "%I\\\n64d"\n#define _u64_ "%I\\\n64u"\n#else\n#define _i64_ "%l\\\nld"\n#define _u64_ "%l\\\nlu"\n#endif\ntypedef unsigned ui;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lf;\nusing namespace std;\n\null gcd(ull a,ull b){if(!b)return a;while(b^=a^=b^=a%=b);return a;}\n\nextern const ll MOD;\nll ksm(ll a,ll b){\nll res=1;a%=MOD;\nfor(;b;b&gt;&gt;=1){if(b&amp;1)res=res*a%MOD;a=a*a%MOD;}\nreturn res;\n}\n\n#ifdef wmx16835\n#include"wmx16835.h"\n#else\n#define LOG\n#define TEL\n#define test(...) 0\n#define TEST(...) 0\n#define TRY(...)\n#define SF(...)\n#define SC\n#define PF\n#define PC\n#define PP\n#define SHOW_TIME\n#define BR\n#endif\nint main(){SHOW_TIME int __MAIN();__MAIN();}\n#define main __MAIN\n#define y0 NKwKGuBI\n#define y1 KFJssmlK\n#define yn XypGISMR\n#define j1 kQDCYYWX\n#define tm BdKIQNcs\n#define lr UsCPcJvt\n\ntemplate&lt;class T1,class T2,class T3&gt;bool In(T1 x,T2 y,T3 z){return x&lt;=y&amp;&amp;x&gt;=z||x&lt;=z&amp;&amp;x&gt;=y;}\ntemplate&lt;class T1,class T2&gt;T1 max(const T1&amp;a,const T2&amp;b){return a&lt;b?b:a;}\ntemplate&lt;class T1,class T2,class T3&gt;T1 max3(const T1&amp;a,const T2&amp;b,const T3&amp;c){return a&lt;b?(b&lt;c?c:b):(a&lt;c?c:a);}\ntemplate&lt;class T1,class T2&gt;T1 min(const T1&amp;a,const T2&amp;b){return a&lt;b?a:b;}\ntemplate&lt;class T1,class T2,class T3&gt;T1 min3(const T1&amp;a,const T2&amp;b,const T3&amp;c){return a&lt;b?(a&lt;c?a:c):(b&lt;c?b:c);}\n\nbool S(char*a){return scanf("%s",a)==1;}\nbool S(int&amp;a){return scanf("%d",&amp;a)==1;}\nbool S(bool&amp;a){return scanf("%d",&amp;a)==1;}\nbool S(ui&amp;a){return scanf("%u",&amp;a)==1;}\nbool S(float&amp;a){return scanf("%f",&amp;a)==1;}\nbool S(double&amp;a){return scanf("%lf",&amp;a)==1;}\nbool S(ll&amp;a){return scanf(_i64_,&amp;a)==1;}\nbool S(ull&amp;a){return scanf(_u64_,&amp;a)==1;}\nbool S(lf&amp;a){double b;if(scanf("%lf",&amp;b)==-1)return 0;a=b;return 1;}\nbool S(char&amp;a){char b[2];if(scanf("%1s",b)==-1)return 0;a=*b;return 1;}\nbool SL(char*a){a[0]=0;while(gets(a)&amp;&amp;!a[0]);return a[0];}\ntemplate&lt;class T1,class T2&gt;bool S(pair&lt;T1,T2&gt;&amp;a){S(a.fi),S(a.se);}\ntemplate&lt;class T&gt;bool S(T&amp;a){a.in();}\n\nvoid _P(const int&amp;x){printf("%d",x);}\nvoid _P(const bool&amp;x){printf("%d",x);}\nvoid _P(const ui&amp;x){printf("%u",x);}\nvoid _P(const char&amp;x){printf("%c",x);}\nvoid _P(const char*x){printf("%s",x);}\nvoid _P(const string&amp;x){printf("%s",x.c_str());}\nvoid _P(const ll&amp;x){printf(_i64_,x);}\nvoid _P(const ull&amp;x){printf(_u64_,x);}\nvoid _P(const float&amp;x){printf("%.*f",FLOAT_PRECISION,x);}\nvoid _P(const double&amp;x){printf("%.*f",FLOAT_PRECISION,x);}\nvoid _P(const lf&amp;x){printf("%.*f",FLOAT_PRECISION,(double)x);}\ntemplate&lt;class T1,class T2&gt;void _P(const pair&lt;T1,T2&gt;&amp;x){_P(x.fi);pc(' ');_P(x.se);}\ntemplate&lt;class T&gt;void _P(const T&amp;a){a.out();}\n\ntemplate&lt;class T1,class T2&gt;bool S(T1&amp;a,T2&amp;b){return S(a)+S(b)==2;}\ntemplate&lt;class T1,class T2,class T3&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c){return S(a)+S(b)+S(c)==3;}\ntemplate&lt;class T1,class T2,class T3,class T4&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d){return S(a)+S(b)+S(c)+S(d)==4;}\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d,T5&amp;e){return S(a)+S(b)+S(c)+S(d)+S(e)==5;}\n\ntemplate&lt;class T1&gt;void P(const T1&amp;a){_P(a);pc(' ');}\ntemplate&lt;class T1,class T2&gt;void P(const T1&amp;a,const T2&amp;b){_P(a);pc(' ');_P(b);pc(' ');}\ntemplate&lt;class T1&gt;void PN(const T1&amp;a){_P(a);NL}\ntemplate&lt;class T1,class T2&gt;void PN(const T1&amp;a,const T2&amp;b){_P(a);pc(' ');_P(b);NL}\ntemplate&lt;class T1,class T2,class T3&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c){_P(a);pc(' ');_P(b);pc(' ');_P(c);NL}\ntemplate&lt;class T1,class T2,class T3,class T4&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c,const T4&amp;d){_P(a);pc(' ');_P(b);pc(' ');_P(c);pc(' ');_P(d);NL}\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c,const T4&amp;d,const T5&amp;e){_P(a);pc(' ');_P(b);pc(' ');_P(c);pc(' ');_P(d);pc(' ');_P(e);NL}\nvoid PS(int a){printf("%*s",a,"");}\n\ntemplate&lt;class T&gt;void SA(T*a,int n){FR(i,n)S(a[i]);}\ntemplate&lt;class T&gt;void PA(T*a,int n){FR(i,n){if(i)pc(' ');_P(a[i]);}NL}\ntemplate&lt;class T&gt;void PA(const T&amp;x){FE(it,x){if(it!=x.begin())pc(' ');_P(*it);}NL}\n\nint kase;\nconst double pi=4*atan(1.);\nconst double ep=1e-9;\nconst int INF=0x3f3f3f3f;\nconst ll INFL=0x3f3f3f3f3f3f3f3fll;\nconst ll MOD=1000000007;\n}\n\nint sum(int x) {\n\tint res = 0;\n\tFOR(i, x - 1) {\n\t\tif (x % i == 0) res += i;\n\t}\n\treturn res;\n}\n\nint main() {\n\tint a, b;\n\tS(a, b);\n\tPN((sum(a) == b &amp;&amp; sum(b) == a) ? "yes" : "no");\n}\n\n/*********Risoft corporation all rights reserved*********/\n/**************Template V2.33 build 20151012*************/\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\n/**\n * 有两个整数，如果每个整数的约数和（除了它本身以外）等于对方，我们就称这对数是友好的。例如：\n　　9的约数和有：1+3=4\n　　4的约数和有：1+2=3\n　　所以9和4不是友好的。\n　　220的约数和有：1 2 4 5 10 11 20 22 44 55 110=284\n　　284的约数和有：1 2 4 71 142=220\n　　所以220和284是友好的。\n　　编写程序，判断两个数是否是友好数。\n\t\t输入格式\n\t\t　　一行，两个整数，由空格分隔\n\t\t输出格式\n\t\t　　如果是友好数，输出"yes"，否则输出"no"，注意不包含引号。\n\t\t样例输入\n\t\t220 284\n\t\t样例输出\n\t\tyes\n * @author 牛洧鹏\n *\n */\npublic class Main {\n\t\n\tpublic int number;\n\tpublic int sum=1;\n\t\n\tpublic void setNumber(int number){\n\t\tthis.number=number;\n\t\tfor (int i = 2; i &lt;Math.sqrt(number); i++) {\n\t\t\tif(number%i==0){\n\t\t\t\tint bigmid=number/i;\n\t\t\t\tthis.sum+=i;\n\t\t\t\tthis.sum+=bigmid;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic int getSum(){\n\t\treturn this.sum;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t   Scanner sca=new Scanner(System.in);\n\t   int one=sca.nextInt();\n\t   int two=sca.nextInt();\n\t   Main fn1=new Main();\n\t   fn1.setNumber(one);\n\t   Main  fn2=new Main();\n\t   fn2.setNumber(two);\n\t   if(fn2.getSum()==one&amp;&amp;fn1.getSum()==two){\n\t\t   System.out.println("yes");\n\t   }\n\t   else{\n\t\t   System.out.println("no ");\n\t   }\n\t   \n\t}\n\t\n}\r\n</textarea>	295
294	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　78这个数可以表示为连续正整数的和，1+2+3，18+19+20+21，25+26+27。\n  <br> 　　输入一个正整数 n(&lt;=10000)\n  <br> 　　输出 m 行(n有m种表示法)，每行是两个正整数a，b，表示a+(a+1)+...+b=n。\n  <br> 　　对于多种表示法，a小的方案先输出。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  78\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  1 12\n  <br> 18 21\n  <br> 25 27\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n\tint i,j,a,b,sum;\n\tint n;\n\n\tscanf("%d",&amp;n);\n\tfor(i=1;i&lt;=n;i++)\n\t{\n\t\ta=i;\n\t\tsum=i;\n\n\t\tfor(j=a+1;j&lt;=n;j++)\n\t\t{    b=j;\n\t\t     sum=sum+b;\n\t\t    if(sum&gt;n)break;\n\t\t   \n\t\t\tif(sum==n)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tprintf("%d %d\\n",a,b);\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\nint main(){\n\tint n,sum;\n\tcin&gt;&gt;n;\n\tfor(int i=1;i&lt;=n/2;i++){\n\t\tsum=0;\n\t\tfor(int j=i;;j++){\n\t\t\tsum+=j;\n\t\t\tif(sum==n){\n\t\t\t\tcout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(sum&gt;n)break;\n\t\t}\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint sum = 0;\n\t\tint j = 0;\n\t\tfor (int i = 1; i &lt; n / 2 + 1; i++) {\n\t\t\tfor (j = i; sum &lt; n; j++) {\n\t\t\t\tsum += j;\n\t\t\t}\n\t\t\tif (sum == n) {\n\t\t\t\tSystem.out.println(i + " " + --j);\n\t\t\t}\n\t\t\tsum = 0;\n\t\t}\n\t}\n}\r\n</textarea>	296
295	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　右右喜欢听故事，但是右右的妈妈总是讲一些“从前有座山，山里有座庙，庙里有个老和尚给小和尚讲故事，讲的什么呢？从前有座山……”这样循环的故事来搪塞右右。\n  <br> 　　我们定义，如果一个字符串是以一个或者一个以上的长度为k的重复字符串所连接成的，那么这个字符串就叫做周期为k的串。\n  <br> 　　例如:\n  <br> 　　字符串’abcabcabcabc’周期为3，因为它是由4个循环’abc’组成的。它同样是以6为周期（两个重复的’abcabc’）和以12为周期（一个循环’abcabcabcabc’）。\n  <br> 　　右右现在想给他的朋友大灰狼转述妈妈讲的故事，请帮他写一个程序，可以测定一个字符串的最小周期。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　一个最大长度为100的无空格的字符串。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　一个整数，表示输入的字符串的最小周期。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  HaHaHa\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  2\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  Return0\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  7\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nint min=100;\nint a[28];\nstruct num{\n\tint a[4];\n};\nint prime(int n)\n{\n\tint i;\n\tif(n==7)return 1;\n\tfor(i=3;i&lt;n/2;i++)\n\t{\n\t\tif(n%i==0)break;\n\t}\n\tif(i==n/2)return 1;\n\treturn 0;\n}\nvoid prime1()\n{\n\ta[0]=2;\n\ta[1]=3;\n\ta[2]=5;\n\tint i,j=3;\n\tfor(i=7;i&lt;110;i=i+2)\n\t{\n\t\tif(prime(i))\n\t\t{\n\t\ta[j]=i;\n\t\tj++;\n\t}\n\t}\n}\nstruct num prime2(int n)\n{\n\tstruct num p;\n\tint i,j;\n\tfor(i=0;i&lt;4;i++)\n\tp.a[i]=0;\n\tj=0;\n\tfor(i=0;i&lt;28;i++)\n\t{\n\tif(n%a[i]==0)\n\tp.a[j]=a[i];\n\tj++;\n}\nreturn p;\n}\nint xunhuan(char a[],int n)\n{\n\tint i,m,l,j,k;\n\tint cnt=1;\n\tstruct num p;\n\tif(n==1)\n\treturn 1;\n\tp=prime2(n);\n\tfor(i=0;i&lt;4;i++)\n\t{\n\t\tif(p.a[i]!=0)\n\t\t{\n\t\t\tl=n/p.a[i];\n\t\t\tfor(j=1;j&lt;p.a[i];j++)\n\t\t\tfor(k=0;k&lt;l;k++)\n\t\t\tif(a[k]!=a[j*l+k])\n\t\t\t{\n\t\t\tcnt=0;\n\t\t\tbreak;\n\t\t}\n\t\t    if(cnt==1)\n\t\t    {\n\t\t    \tl=xunhuan(a,l);\n\t\t    \tif(l&lt;min)\n\t\t    \tmin=l;\n\t\t\t}\n\t\t\tcnt=1;///////////////\n\t\t}\n\t\telse if(min&gt;n)\n\t\tmin=n;\n\t}//for\n\treturn min;\n}\nint main()\n{\n     char a[120];\n     int m,n;\n     int l;\n     prime1();\n     gets(a);\n     n=strlen(a);\n     m=xunhuan(a,n);\t\n\t printf("%d",m); \n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;string.h&gt;\nusing namespace  std;\nint count;\nchar a[100];\nvoid f(int n,int k)\n{\n\tint i,j,zhouqi,c,fla=0;\n\tfor(i=1;i&lt;=n;i++)\n\t{\n\t\tif(n%i==0)\n\t\t{\n\t\t\tfor(j=0;j&lt;n/i;j++)\n\t\t\t{\n\t\t\t\tfor(c=0;c&lt;i;c++)\n\t\t\t\t{\n\t\t\t\t\tif(a[c]!=a[j*i+c])\n\t\t\t\t\t{\n\t\t\t\t\t\tfla=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(fla)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\tif(fla==0)\n\t\t{\n\t\t\tcount=i;\n\t\t\treturn ;\n\t\t}\n\t\t}\n\t\tfla=0;\n\t}\t\n}\nint main()\n{\n\tint n;\n\tcin&gt;&gt;a;\n\tf(strlen(a),1);\n\tcout&lt;&lt;count&lt;&lt;endl;\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO 自动生成的方法存根\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString tmp = br.readLine();\n\t\tchar[] ary = tmp.toCharArray();\n\t\tfor(int i = 1; i &lt;= ary.length; i++){\n\t\t\tif(ary.length % i != 0) continue;\n\t\t\tString sub = tmp.substring(0, i);\n\t\t\tchar[]\tsubary = sub.toCharArray();\n\t\t\tboolean equal = true;\n\t\t\tfor(int j = 0; j &lt; ary.length; j += i){\n\t\t\t\tif(!sub.equals(tmp.substring(j, j + i))) {\n\t\t\t\t\tequal = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(equal) {\n\t\t\t\tSystem.out.println(i);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n}\n\r\n</textarea>	297
296	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　道德经曰：一生二，二生三，三生万物。\n  <br> 　　对于任意正整数n，我们定义d(n)的值为为n加上组成n的各个数字的和。例如，d(23)=23+2+3=28, d(1481)=1481+1+4+8+1=1495。\n  <br> 　　因此，给定了任意一个n作为起点，你可以构造如下一个递增序列：n,d(n),d(d(n)),d(d(d(n)))....例如，从33开始的递增序列为：\n  <br> 　　33, 39, 51, 57, 69, 84, 96, 111, 114, 120, 123, 129, 141, ...\n  <br> 　　我们把n叫做d(n)的生成元，在上面的数列中，33是39的生成元，39是51的生成元，等等。有一些数字甚至可以有两个生成元，比如101，可以由91和100生成。但也有一些数字没有任何生成元，如42。我们把这样的数字称为寂寞的数字。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　一行，一个正整数n。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　按照升序输出小于n的所有寂寞的数字，每行一个。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  40\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  1\n  <br> 3\n  <br> 5\n  <br> 7\n  <br> 9\n  <br> 20\n  <br> 31\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　n&lt;=10000\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdlib.h&gt;\n#include&lt;stdio.h&gt;\nint num(int n){\n    int m=n;\n    while(n!=0){\n        m+=n%10;\n        n/=10;\n        }\n    return m;\n    }\nint main(){\n    int n,a[20000]={0},i;  //考虑数组越界 \n    scanf("%d",&amp;n);\n    for(i=1;i&lt;=n;i++){  \n        a[num(i)]=1;\n        }\n    for(i=1;i&lt;=n;i++){\n        if(a[i]==0){\n            printf("%d\\n",i);\n            }\n    }\n    system("pause");\n    return 0; \n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;stdio.h&gt;\nint main()\n{\nint n;\nint a[10000];\nscanf("%d",&amp;n);\nfor(int i=0;i&lt;n;i++)\na[i]=0;\nfor(int i=1;i&lt;n;i++)\n{\n\t int sum=0;\n\t int j=i;\n\t sum+=j;\n\t while(j&gt;0)\n\t {\n\t \tsum+=j%10;\n\t \tj/=10;\n\t \t\n\t }\n\t if(sum&lt;n) a[sum]=1;\n}\n\tfor(int i=1;i&lt;n;i++)\n\tif(a[i]==0) printf("%d\\n",i);\n\t\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.*;\npublic class Main {\n\n\t public static void main(String args[])\n\t    {\n\t\t    \n\t\t       Scanner read=new Scanner(System.in);\n\t\t         int n=read.nextInt();\n\t\t          int a[]=new int[n];\n\t\t          int b,temp;\n\t\t          for(int i=1;i&lt;=n;i++){\n\t\t              b=i;\n\t\t              temp=i;\n\t\t              while(temp&gt;0){\n\t\t                  b+=temp%10;\n\t\t                  temp=temp/10;\n\t\t              }\n\t\t              if(b&lt;n)\n\t\t              a[b]++;\n\t\t          }\n\t\t     for(int i=0;i&lt;n;i++){\n\t\t         if(a[i]==0&amp;&amp;i!=0)\n\t\t             System.out.println(i);\n\t\t     }\n\t\t         \n\t\t          }\n\t\t     \n\t\t\t \n}\n\n\r\n</textarea>	298
297	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　涛涛立志要做新好青年，他最近在学做菜。由于技术还很生疏，他只会用鸡蛋，西红柿，鸡丁，辣酱这四种原料来做菜，我们给这四种原料标上字母A,B,C,D。\n  <br> 　　涛涛现在会做的菜有五种：\n  <br> 　　1、 西红柿炒鸡蛋 原料：AABDD\n  <br> 　　2、 酸辣鸡丁 原料：ABCD\n  <br> 　　3、 宫保鸡丁 原料：CCD\n  <br> 　　4、 水煮西红柿 原料：BBB\n  <br> 　　5、 怪味蛋 原料：AD\n  <br> 　　这天早上，开开去早市给涛涛买了一些原料回来。由于事先没有什么计划，涛涛决定，对于现存的原料，每次尽量做菜单上靠前（即编号小）的菜。\n  <br> 　　现在请你写一个程序，判断一下开开和涛涛中午能吃到哪些菜。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　共4个整数a,b,c,d。分别表示开开买的A,B,C,D这4种原料的数量。每种原料不会超过30份。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出5行。其中第i行表示涛涛做的第i种菜的数目。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3\n  <br> 1\n  <br> 2\n  <br> 4\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  1\n  <br> 0\n  <br> 1\n  <br> 0\n  <br> 1\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdlib.h&gt;\n#include&lt;stdio.h&gt;\nint main(){\n    int a,b,c,d,total=0;\n    scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);\n    while(a&gt;=2&amp;&amp;b&gt;=1&amp;&amp;d&gt;=2){\n        total++;\n        a-=2;\n        b--;\n        d-=2;\n    } \n    printf("%d\\n",total);\n    total=0;\n    while(a&gt;=1&amp;&amp;b&gt;=1&amp;&amp;c&gt;=1&amp;&amp;d&gt;=1){\n        total++;\n        a--;\n        b--;\n        c--;\n        d--;\n        }\n    printf("%d\\n",total);\n    total=0;\n    while(c&gt;=2&amp;&amp;d&gt;=1){\n        total++;\n        c-=2;\n        d--;\n        }\n    printf("%d\\n",total);\n    total=0;\n    while(b&gt;=3){\n        total++;\n        b-=3;\n        }\n    printf("%d\\n",total);\n    total=0;\n    while(a&gt;=1&amp;&amp;d&gt;=1){\n        total++;\n        a--;\n        d--;\n        }\n    printf("%d\\n",total);\n    system("pause");\n    return 0; \n}\r\n</textarea>	<textarea id="codelinescpp">\r\n/**************Powered by Graphene Richards**************/\nextern"C++"{\n#define FLOAT_PRECISION     2\n\n#ifdef _MSC_VER\n#define _SECURE_SCL 0\n#pragma comment(linker,"/STACK:102400000,102400000")\n#else\n#pragma GCC optimize("O3")\n#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx")\n#endif\n#if defined(_MSC_VER)||__cplusplus&gt;199711L\n#define IT(x) auto\n#define DIT(x) auto\n#else\n#define IT(x) __typeof((x).begin())\n#define DIT(x) __typeof((x).rbegin())\n#endif\n\n#  inc\\\nlude&lt;cmath&gt;\n#  inc\\\nlude&lt;cstdio&gt;\n#  inc\\\nlude&lt;cstdlib&gt;\n#  inc\\\nlude&lt;cstring&gt;\n#  inc\\\nlude&lt;algorithm&gt;\n#  inc\\\nlude&lt;bitset&gt;\n#  inc\\\nlude&lt;complex&gt;\n#  inc\\\nlude&lt;vector&gt;\n#  inc\\\nlude&lt;iomanip&gt;\n#  inc\\\nlude&lt;iostream&gt;\n#  inc\\\nlude&lt;list&gt;\n#  inc\\\nlude&lt;map&gt;\n#  inc\\\nlude&lt;queue&gt;\n#  inc\\\nlude&lt;set&gt;\n#  inc\\\nlude&lt;stack&gt;\n#  inc\\\nlude&lt;string&gt;\n#define FAST_RW ios_base::sync_with_stdio(0),cin.tie(0);\n#define FS(i,a) for(ll i=0;a[i];i++)\n#define FE(it,x) for(IT(x) it=(x).begin(),_en=(x).end();it!=_en;it++)\n#define EF(it,x) for(DIT(x) it=(x).rbegin(),_en=(x).rend();it!=_en;it++)\n#define FR(i,en) for(ll i=0,_en=(en);i&lt;_en;i++)\n#define FOR(i,en) for(ll i=1,_en=(en);i&lt;=_en;i++)\n#define RF(i,en) for(ll i=(en)-1;i&gt;=0;i--)\n#define ROF(i,en) for(ll i=(en);i&gt;0;i--)\n#define FFR(i,x,y) for(ll i=(x),_en=(y);i&lt;=_en;i++)\n#define RFF(i,x,y) for(ll i=(x),_en=(y);i&gt;=_en;i--)\n#define pc putchar\n#define pb push_back\n#define ppb pop_back\n#define pq priority_queue\n#define fi first\n#define se second\n#define mp make_pair\n#define pii pair&lt;int,int&gt;\n#define pll pair&lt;ll,ll&gt;\n#define sqr(x) ((x)*(x))\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define clr(x) memset((x),0,sizeof(x))\n#define ms(x,v) memset((x),(v),sizeof(x))\n#define mc(x,y) memcpy((x),(y),sizeof(y))\n#define NL puts("");\n#define LB lower_bound\n#define UB upper_bound\n#define rand() ((rand()&lt;&lt;16)^(rand()&lt;&lt;15)^(rand()))\n#ifdef _WIN32\n#define _i64_ "%I\\\n64d"\n#define _u64_ "%I\\\n64u"\n#else\n#define _i64_ "%l\\\nld"\n#define _u64_ "%l\\\nlu"\n#endif\ntypedef unsigned ui;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lf;\nusing namespace std;\n\null gcd(ull a,ull b){if(!b)return a;while(b^=a^=b^=a%=b);return a;}\n\nextern const ll MOD;\nll ksm(ll a,ll b){\nll res=1;a%=MOD;\nfor(;b;b&gt;&gt;=1){if(b&amp;1)res=res*a%MOD;a=a*a%MOD;}\nreturn res;\n}\n\n#ifdef wmx16835\n#include"wmx16835.h"\n#else\n#define LOG\n#define TEL\n#define test(...) 0\n#define TEST(...) 0\n#define TRY(...)\n#define SF(...)\n#define SC\n#define PF\n#define PC\n#define PP\n#define SHOW_TIME\n#define BR\n#endif\nint main(){SHOW_TIME int __MAIN();__MAIN();}\n#define main __MAIN\n#define y0 NKwKGuBI\n#define y1 KFJssmlK\n#define yn XypGISMR\n#define j1 kQDCYYWX\n#define tm BdKIQNcs\n#define lr UsCPcJvt\n\ntemplate&lt;class T1,class T2,class T3&gt;bool In(T1 x,T2 y,T3 z){return x&lt;=y&amp;&amp;x&gt;=z||x&lt;=z&amp;&amp;x&gt;=y;}\ntemplate&lt;class T1,class T2&gt;T1 max(const T1&amp;a,const T2&amp;b){return a&lt;b?b:a;}\ntemplate&lt;class T1,class T2,class T3&gt;T1 max3(const T1&amp;a,const T2&amp;b,const T3&amp;c){return a&lt;b?(b&lt;c?c:b):(a&lt;c?c:a);}\ntemplate&lt;class T1,class T2&gt;T1 min(const T1&amp;a,const T2&amp;b){return a&lt;b?a:b;}\ntemplate&lt;class T1,class T2,class T3&gt;T1 min3(const T1&amp;a,const T2&amp;b,const T3&amp;c){return a&lt;b?(a&lt;c?a:c):(b&lt;c?b:c);}\n\nbool S(char*a){return scanf("%s",a)==1;}\nbool S(int&amp;a){return scanf("%d",&amp;a)==1;}\nbool S(bool&amp;a){return scanf("%d",&amp;a)==1;}\nbool S(ui&amp;a){return scanf("%u",&amp;a)==1;}\nbool S(float&amp;a){return scanf("%f",&amp;a)==1;}\nbool S(double&amp;a){return scanf("%lf",&amp;a)==1;}\nbool S(ll&amp;a){return scanf(_i64_,&amp;a)==1;}\nbool S(ull&amp;a){return scanf(_u64_,&amp;a)==1;}\nbool S(lf&amp;a){double b;if(scanf("%lf",&amp;b)==-1)return 0;a=b;return 1;}\nbool S(char&amp;a){char b[2];if(scanf("%1s",b)==-1)return 0;a=*b;return 1;}\nbool SL(char*a){a[0]=0;while(gets(a)&amp;&amp;!a[0]);return a[0];}\ntemplate&lt;class T1,class T2&gt;bool S(pair&lt;T1,T2&gt;&amp;a){S(a.fi),S(a.se);}\ntemplate&lt;class T&gt;bool S(T&amp;a){a.in();}\n\nvoid _P(const int&amp;x){printf("%d",x);}\nvoid _P(const bool&amp;x){printf("%d",x);}\nvoid _P(const ui&amp;x){printf("%u",x);}\nvoid _P(const char&amp;x){printf("%c",x);}\nvoid _P(const char*x){printf("%s",x);}\nvoid _P(const string&amp;x){printf("%s",x.c_str());}\nvoid _P(const ll&amp;x){printf(_i64_,x);}\nvoid _P(const ull&amp;x){printf(_u64_,x);}\nvoid _P(const float&amp;x){printf("%.*f",FLOAT_PRECISION,x);}\nvoid _P(const double&amp;x){printf("%.*f",FLOAT_PRECISION,x);}\nvoid _P(const lf&amp;x){printf("%.*f",FLOAT_PRECISION,(double)x);}\ntemplate&lt;class T1,class T2&gt;void _P(const pair&lt;T1,T2&gt;&amp;x){_P(x.fi);pc(' ');_P(x.se);}\ntemplate&lt;class T&gt;void _P(const T&amp;a){a.out();}\n\ntemplate&lt;class T1,class T2&gt;bool S(T1&amp;a,T2&amp;b){return S(a)+S(b)==2;}\ntemplate&lt;class T1,class T2,class T3&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c){return S(a)+S(b)+S(c)==3;}\ntemplate&lt;class T1,class T2,class T3,class T4&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d){return S(a)+S(b)+S(c)+S(d)==4;}\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d,T5&amp;e){return S(a)+S(b)+S(c)+S(d)+S(e)==5;}\n\ntemplate&lt;class T1&gt;void P(const T1&amp;a){_P(a);pc(' ');}\ntemplate&lt;class T1,class T2&gt;void P(const T1&amp;a,const T2&amp;b){_P(a);pc(' ');_P(b);pc(' ');}\ntemplate&lt;class T1&gt;void PN(const T1&amp;a){_P(a);NL}\ntemplate&lt;class T1,class T2&gt;void PN(const T1&amp;a,const T2&amp;b){_P(a);pc(' ');_P(b);NL}\ntemplate&lt;class T1,class T2,class T3&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c){_P(a);pc(' ');_P(b);pc(' ');_P(c);NL}\ntemplate&lt;class T1,class T2,class T3,class T4&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c,const T4&amp;d){_P(a);pc(' ');_P(b);pc(' ');_P(c);pc(' ');_P(d);NL}\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c,const T4&amp;d,const T5&amp;e){_P(a);pc(' ');_P(b);pc(' ');_P(c);pc(' ');_P(d);pc(' ');_P(e);NL}\nvoid PS(int a){printf("%*s",a,"");}\n\ntemplate&lt;class T&gt;void SA(T*a,int n){FR(i,n)S(a[i]);}\ntemplate&lt;class T&gt;void PA(T*a,int n){FR(i,n){if(i)pc(' ');_P(a[i]);}NL}\ntemplate&lt;class T&gt;void PA(const T&amp;x){FE(it,x){if(it!=x.begin())pc(' ');_P(*it);}NL}\n\nint kase;\nconst double pi=4*atan(1.);\nconst double ep=1e-9;\nconst int INF=0x3f3f3f3f;\nconst ll INFL=0x3f3f3f3f3f3f3f3fll;\nconst ll MOD=1000000007;\n}\n\nint a[5][4] = {\n\t2, 1, 0, 2,\n\t1, 1, 1, 1,\n\t0, 0, 2, 1,\n\t0, 3, 0, 0,\n\t1, 0, 0, 1\n};\n\nint d[4], r[5];\n\nbool OK(int x) {\n\tFR(i, 4) {\n\t\tif (d[i] &lt; a[x][i]) return 0;\n\t}\n\tFR(i, 4) {\n\t\td[i] -= a[x][i];\n\t}\n\tr[x]++;\n\treturn 1;\n}\n\nint main() {\n\tFR(i, 4)S(d[i]);\n\tFR(i, 5)while (OK(i));\n\tFR(i, 5) PN(r[i]);\n}\n\n/*********Risoft corporation all rights reserved*********/\n/**************Template V2.33 build 20151012*************/\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint[] raw = new int[4];\n\t\tfor (int i = 0; i &lt; raw.length; i++) \n\t\t\traw[i] = scanner.nextInt();\n\t\tint[][] menu = {{2,1,0,2},{1,1,1,1},{0,0,2,1},{0,3,0,0},{1,0,0,1}};\n\t\tfor (int i = 0; i &lt; menu.length; i++) {\n\t\t\tboolean flag = true;\n\t\t\tfor (int j = 0; j &lt; raw.length; j++) {\n\t\t\t\tif(menu[i][j]==0)continue;\n\t\t\t\telse{\n\t\t\t\t\tif(raw[j]&lt;menu[i][j])\n\t\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag){\n\t\t\t\tint count = 0;\n\t\t\t\twhile(true){\n\t\t\t\t\tboolean boo = true;\n\t\t\t\t\tfor (int j = 0; j &lt; raw.length; j++) {\n\t\t\t\t\t\traw[j]-=menu[i][j];\n\t\t\t\t\t\tif(raw[j]&lt;0) boo = false;\n\t\t\t\t\t}\n\t\t\t\t\tif(boo)\n\t\t\t\t\t\tcount++;\n\t\t\t\t\telse{\n\t\t\t\t\t\tfor (int j = 0; j &lt; raw.length; j++) \n\t\t\t\t\t\t\traw[j]+=menu[i][j];\n\t\t\t\t\t\tSystem.out.println(count);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else\n\t\t\t\tSystem.out.println(0);\n\t\t}\n\t}\n}\r\n</textarea>	299
298	<div class="des"> \n <div class="pdcont">\n  　　金陵十三钗\n  <br> 　　本题难度：难\n  <br> 　　本题占分比例：5%\n </div>\n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　在电影《金陵十三钗》中有十二个秦淮河的女人要自我牺牲代替十二个女学生去赴日本人的死亡宴会。为了不让日本人发现，自然需要一番乔装打扮。但由于天生材质的原因，每个人和每个人之间的相似度是不同的。由于我们这是编程题，因此情况就变成了金陵n钗。给出n个女人和n个学生的相似度矩阵，求她们之间的匹配所能获得的最大相似度。\n  <br> 　　所谓相似度矩阵是一个n*n的二维数组like[i][j]。其中i,j分别为女人的编号和学生的编号，皆从0到n-1编号。like[i][j]是一个0到100的整数值，表示第i个女人和第j个学生的相似度，值越大相似度越大，比如0表示完全不相似，100表示百分之百一样。每个女人都需要找一个自己代替的女学生。\n  <br> 　　最终要使两边一一配对，形成一个匹配。请编程找到一种匹配方案，使各对女人和女学生之间的相似度之和最大。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行一个正整数n表示有n个秦淮河女人和n个女学生\n  <br> 　　接下来n行给出相似度，每行n个0到100的整数，依次对应二维矩阵的n行n列。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　仅一行，一个整数，表示可获得的最大相似度。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  4\n  <br> 97 91 68 14\n  <br> 8 33 27 92\n  <br> 36 32 98 53\n  <br> 73 7 17 82\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  354\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　对于70%的数据，n&lt;=10\n  <br> 　　对于100%的数据，n&lt;=13\n </div>\n <div class="pdsec">\n  样例说明\n </div>\n <div class="pdcont">\n  　　最大相似度为91+92+93+73=354\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#define max(a, b) a &gt; b ? a : b\nint dp[14][1024 * 8], a[14][14], n;\n\nint f(int x, int fn)\n{\n\tif (fn == n)\n\t\treturn 0;\n\tif (dp[fn][x] != -1)\n\t\treturn dp[fn][x];\t\n\tdp[fn][x] = 0;\n\tint i;\n\tfor (i = 0; i &lt; n; i++)\n\t\tif (!(x &amp; (1 &lt;&lt; i)))\n\t\t{\n\t\t\tint fx = x | (1 &lt;&lt; i);\n\t\t\tdp[fn][x] = max(dp[fn][x], f(fx, fn + 1) + a[fn][i]);\n\t\t}\n\treturn dp[fn][x];\n}\n\nint main()\n{\n\tint i, j, max = 0;\n\tscanf("%d", &amp;n);\n\tfor (i = 0; i &lt; n; i++)\n\t\tfor (j = 0; j &lt; n; j++)\n\t\t\tscanf("%d", &amp;a[i][j]);\n\tmemset(dp, -1, sizeof(dp));\n\tf(0, 0);\n\tmax = dp[0][0];\n\tfor (i = 0; i &lt; n - 1; i++)\n\t\tif (max &lt; dp[0][1 &lt;&lt; i])\n\t\t\tmax = dp[0][1 &lt;&lt; i];\n\tprintf("%d\\n", max);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n#define MAXN 15\nusing namespace std;\nconst int maxzt=(1&lt;&lt;13);   //最大的状态数,\nint dp[maxzt];\nint like[MAXN][MAXN],n;\nint numberOfOne(int num){ //num 二进制中1的个数\n    int cnt=0;\n    while(num){\n        cnt+=(num&amp;1);\n        num&gt;&gt;=1;\n    }\n    return cnt;\n}\nint lowbit(int x){  //num 二进制中只保留最后一个1 如: num=20 二进制10100 返回 二进制100，也就是4\n    return x&amp;(-x);\n}\nint posOfOne(int num){ //num 二进制中最后一个1的位置  如: num=18 二进制10010 返回 2\n    int pos=0;\n    while(num){\n        pos++;\n        if(num&amp;1)\n            return pos;\n        num&gt;&gt;=1;\n    }\n    return pos;\n}\nvoid work(int x){\n    int maxstatus=1&lt;&lt;n;\n    for(int i=0;i&lt;maxstatus;i++){\n        int nowstatus=i,t=numberOfOne(nowstatus);\n        if(t!=x) continue;   //第x位女人有x个1，不是就继续找下一个数\n        while(t--){\n            int pos=lowbit(nowstatus);\n            dp[i]=max(dp[i],dp[i-pos]+like[x][posOfOne(pos)]);\n            nowstatus-=pos;\n        }\n    }\n}\nint main(){\n    scanf("%d",&amp;n);\n    for(int i=1;i&lt;=n;i++)\n        for(int j=1;j&lt;=n;j++)\n            scanf("%d",&amp;like[i][j]);\n    memset(dp,0,sizeof(dp));\n    for(int i=1;i&lt;=n;i++)\n        work(i);\n    printf("%d\\n",dp[(1&lt;&lt;n)-1]);\n    return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\npublic class Main\n{\n    final int MAXN=15;\n    int maxzt=(1&lt;&lt;13);\n    int dp[]=new int[maxzt];\n    int like[][]=new int[MAXN][MAXN];\n    int n;\n    int numberOfOne(int num)\n    {\n        int cnt=0;\n        while(num&gt;0){\n        \tcnt+=(num&amp;1);\n        \tnum&gt;&gt;=1;\n        }\n        return cnt;\n    }\n    int lowbit(int x){\n        return x&amp;(-x);\n    }\n    int posOfOne(int num){\n        int pos=0;\n        while(num&gt;0){\n            pos++;\n            if((num&amp;1)&gt;0)\n               return pos;\n            num&gt;&gt;=1;\n        }\n        return pos;\n    }\n    void work(int x){\n        int maxstatus=1&lt;&lt;n;\n        for(int i=0;i&lt;maxstatus;i++){\n            int nowstatus=i,t=numberOfOne(nowstatus);\n            if(t!=x) continue;\n            while(t&gt;0){\n            \tint pos=lowbit(nowstatus);\n            \tdp[i]=Math.max(dp[i],dp[i-pos]+like[x][posOfOne(pos)]);\n            \tnowstatus-=pos;\n            \tt--;\n            }\n        }\n    }\n    public static void main(String[] args)\n    {\t\n    \tMain o=new Main();\n    \tScanner sc = new Scanner(System.in);\n    \to.n=sc.nextInt();\n    \tfor(int i=1;i&lt;=o.n;i++)\n    \t\tfor(int j=1;j&lt;=o.n;j++)\n    \t\t\to.like[i][j]=sc.nextInt();\n    \tfor(int i=1;i&lt;=o.n;i++)\n    \t\to.work(i);\n        System.out.println(o.dp[(1&lt;&lt;o.n)-1]);\n        sc.close();\n    }\n\n}\n\r\n</textarea>	300
299	<div class="des"> \n <div class="pdcont">\n  　　\n  <b>问题描述<br> </b>\n  <br> 　　给出一个整数 n（n&lt;10^30) 和 k 个变换规则（k&lt;=15）。\n  <br> \n  <br> 　　规则：\n  <br> \n  <br> 　　一位数可变换成另一个一位数：\n  <br> \n  <br> 　　规则的右部不能为零。\n  <br> \n  <br> 　　例如：n=234。有规则（k＝2）：\n  <br> \n  <br> 　　2－&gt; 5\n  <br> \n  <br> 　　3－&gt; 6\n  <br> \n  <br> 　　上面的整数 234 经过变换后可能产生出的整数为（包括原数）:\n  <br> \n  <br> 　　234\n  <br> \n  <br> 　　534\n  <br> \n  <br> 　　264\n  <br> \n  <br> 　　564\n  <br> \n  <br> 　　共 4 种不同的产生数\n  <br> \n  <br> 　　问题：\n  <br> \n  <br> 　　给出一个整数 n 和 k 个规则。\n  <br> \n  <br> 　　求出：\n  <br> \n  <br> 　　经过任意次的变换（0次或多次），能产生出多少个不同整数。\n  <br> \n  <br> 　　仅要求输出个数。\n  <br> 　　\n  <b>输入格式</b>:\n  <br> 　　n k\n  <br> 　　x1 y1\n  <br> 　　x2 y2\n  <br> 　　... ...\n  <br> 　　xn yn\n  <br> 　　\n  <b>输出格式</b>:\n  <br> 　　一个整数（满足条件的个数）：\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  234 2\n  <br> 2 5\n  <br> 3 6\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  4\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n#include&lt;stdlib.h&gt;\nint can[10][10];\nint rules[10];\nint ans[1000000];\nint len,n,k;\nchar s[100];\nint main()\n{\n    int i,k,j;\n    scanf("%s",s);\n    scanf("%d",&amp;k);\n    for (i=1;i&lt;=k;++i)\n    {\n        int a,b;\n        scanf("%d%d",&amp;a,&amp;b);\n        can[a][b]=1;\n    }\n    for (i=0;i&lt;10;++i) \n        can[i][i]=1;\n    for (k=0;k&lt;10;++k)\n        for (i=0;i&lt;10;++i)\n            for (j=0;j&lt;10;++j)\n                can[i][j]=can[i][j]||(can[i][k]&amp;&amp;can[k][j]);\n    for (i=0;i&lt;10;++i)\n        for (j=0;j&lt;10;++j)\n            if (can[i][j]) ++rules[i];\n    ans[1]=len=1;\n    for (i=0;i&lt;strlen(s);++i)\n    {\n        int x=rules[s[i]-'0'];\n        for (j=1;j&lt;=len;++j) \n            ans[j]*=x;\n        for (j=1;j&lt;=len;++j)\n        {\n            ans[j+1]+=ans[j]/10;\n            ans[j]%=10;\n        }\n        while (ans[len])\n        {\n              ans[len+1]+=ans[len]/10;\n              ans[len]%=10;\n              ++len;\n        }\n    }\n    for (i=len-1;i&gt;0;--i) \n       printf("%d",ans[i]);\n    system("pause");\n    return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nbool can[10][10];\nint rules[10];\nint ans[1000000];\nint len,n,k;\nchar s[100];\nint main()\n{\n    scanf("%s",s);\n    scanf("%d",&amp;k);\n    for (int i=1;i&lt;=k;++i)\n    {\n        int a,b;\n        scanf("%d%d",&amp;a,&amp;b);\n        can[a][b]=true;\n    }\n    for (int i=0;i&lt;10;++i) can[i][i]=true;\n    for (int k=0;k&lt;10;++k)\n        for (int i=0;i&lt;10;++i)\n            for (int j=0;j&lt;10;++j)\n                can[i][j]=can[i][j]||(can[i][k]&amp;&amp;can[k][j]);\n    for (int i=0;i&lt;10;++i)\n        for (int j=0;j&lt;10;++j)\n            if (can[i][j]) ++rules[i];\n    ans[1]=len=1;\n    for (int i=0;i&lt;strlen(s);++i)\n    {\n        int x=rules[s[i]-'0'];\n        for (int j=1;j&lt;=len;++j) ans[j]*=x;\n        for (int j=1;j&lt;=len;++j)\n        {\n            ans[j+1]+=ans[j]/10;\n            ans[j]%=10;\n        }\n        while (ans[len])\n        {\n              ans[len+1]+=ans[len]/10;\n              ans[len]%=10;\n              ++len;\n        }\n    }\n    for (int i=len-1;i&gt;0;--i) printf("%d",ans[i]);\n    return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.math.BigInteger;\nimport java.util.Vector;\n\npublic class Main {\n\tstatic int[] v=new int[10];\n\tstatic Vector&lt;Vector&lt;Integer&gt;&gt; gz=new Vector&lt;Vector&lt;Integer&gt;&gt;();\n\tstatic int geti(int i){\n\t\tint a=1;\n\t\tv[i]=1;\n\t\tfor (int j = 0; j &lt;gz.get(i).size(); j++) {\n\t\t\tint k=gz.get(i).get(j);\n\t\t\tif(v[k]==1)continue;\n\t\t\ta+=geti(k);\n\t\t}\n\t\treturn a;\n\t}\n\tpublic static void main(String[] args) throws IOException {\n\t\tfor (int i = 0; i &lt;10; i++) {\n\t\t\tgz.add(new Vector&lt;Integer&gt;());\n\t\t}\n\t\tBufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] a1=bf.readLine().split(" ");\n\t\tint k=Integer.parseInt(a1[1]);\n\t\tint[] s=new int[a1[0].length()];\n\t\tfor (int i = 0; i &lt; a1[0].length(); i++) \n\t\t\ts[i]=a1[0].charAt(i)-'0';\n\t\tfor (int i = 0; i &lt; k; i++) {\n\t\t\ta1=bf.readLine().split(" ");\n\t\t\tgz.get(Integer.parseInt(a1[0])).add(Integer.parseInt(a1[1]));\n\t\t}\n\t\tBigInteger num=new BigInteger("1");\n\t\tfor (int i = 0; i &lt; s.length; i++) {\n\t\t\tnum=num.multiply(BigInteger.valueOf(geti(s[i])));\n\t\t\tv=new int[10];\n\t\t}\n\t\t//System.out.println(BigInteger.valueOf(2).pow(20));\n\t\tSystem.out.println(num);\n\t}\n}\n\r\n</textarea>	301
300	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　秋天到了，n只猴子采摘了一大堆苹果放到山洞里，约定第二天平分。这些猴子很崇拜猴王孙悟空，所以都想给他留一些苹果。第一只猴子悄悄来到山洞，把苹果平均分成n份，把剩下的m个苹果吃了,然后藏起来一份，最后把剩下的苹果重新合在一起。这些猴子依次悄悄来到山洞，都做同样的操作，恰好每次都剩下了m个苹果。第二天，这些猴子来到山洞，把剩下的苹果分成n分，巧了，还是剩下了m个。问，原来这些猴子至少采了多少个苹果。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　两个整数，n m\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　一个整数，表示原来苹果的数目\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5 1\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  15621\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　0&lt;m&lt;n&lt;9\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;math.h&gt;\nint main()\n{\n\tdouble m, n;\n\tscanf("%lf%lf", &amp;n, &amp;m);\n\tprintf("%.lf",pow(n , n + 1) - m*(n - 1));\n\treturn 0;\n\t\n\t\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;cmath&gt;\n\nint main() \n{\n\tusing namespace std;\n\tint n = 0, m = 0;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tint answer =0;\n\tanswer = pow(n, n+1) - (n-1)*m;\n\tcout &lt;&lt; answer &lt;&lt; endl;\n\treturn 0;\n}\n\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.ArrayList;\nimport java.util.Scanner;  \nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.Vector;\n    public class Main{\n    \t\n        public static void main(String[] args){  \n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int t = n +1;\n        int p = 1;\n        while (t--&gt;0) {\n             p *= n;\t\t\t\n\t\t}\n        int sum = p - ((n-1)*m);\n        System.out.println(sum);\n        }\n }  \r\n</textarea>	302
314	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　在Mars星球上，每个Mars人都随身佩带着一串能量项链。在项链上有N颗能量珠。能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。因为只有这样，通过吸盘（吸盘是Mars人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。如果前一颗能量珠的头标记为m，尾标记为r，后一颗能量珠的头标记为r，尾标记为n，则聚合后释放的能量为m*r*n（Mars单位），新产生的珠子的头标记为m，尾标记为n。\n  <br> 　　需要时，Mars人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。\n  <br> 　　例如：设N=4，4颗珠子的头标记与尾标记依次为(2，3) (3，5) (5，10) (10，2)。我们用记号⊕表示两颗珠子的聚合操作，(j⊕k)表示第j，k两颗珠子聚合后所释放的能量。则第4、1两颗珠子聚合后释放的能量为：\n  <br> 　　(4⊕1)=10*2*3=60。\n  <br> 　　这一串项链可以得到最优值的一个聚合顺序所释放的总能量为\n  <br> 　　((4⊕1)⊕2)⊕3）=10*2*3+10*3*5+10*5*10=710。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入的第一行是一个正整数N（4≤N≤100），表示项链上珠子的个数。第二行是N个用空格隔开的正整数，所有的数均不超过1000。第i个数为第i颗珠子的头标记（1≤i≤N），当i&lt;N时，第i颗珠子的尾标记应该等于第i+1颗珠子的头标记。第N颗珠子的尾标记应该等于第1颗珠子的头标记。\n  <br> 　　至于珠子的顺序，你可以这样确定：将项链放到桌面上，不要出现交叉，随意指定第一颗珠子，然后按顺时针方向确定其他珠子的顺序。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出只有一行，是一个正整数E（E≤2.1*10\n  <sup>9</sup>），为一个最优聚合顺序所释放的总能量。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  4\n  <br> 2 3 5 10\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  710\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt; \n#include&lt;string.h&gt;\n#define SIZE 220\n\nint dp[SIZE][SIZE],a[SIZE];\nint ans;\nint max(int a,int b){\n    return a&gt;b?a:b;\n    }\nint main()\n{\n    int N,i,j,k;\n    scanf("%d",&amp;N);\n    for(i=1;i&lt;=N;i++)\n    {\n        scanf("%d",&amp;a[i]);\n        a[N+i]=a[i];\n    }\n    memset(dp,0,sizeof(dp));\n    for(j=1;j&lt; N;j++)\n    {\n        for(i=1;i+j&lt; 2*N;i++)\n        {\n            int tmp=0;\n            for(k=0;k&lt; j;k++)\n            {\n                tmp=max(tmp,dp[i][i+k]+dp[i+k+1][i+j]+a[i]*a[i+k+1]*a[i+j+1]);\n            }\n            dp[i][i+j]=tmp;\n        }\n    }\n    ans=0;\n    for(i=1;i&lt;=N;i++)\n    {\n        ans=max(ans,dp[i][i+N-1]);\n    }\n    printf("%d\\n",ans);\n    system("pause");\n    return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n/**************Powered by Graphene Richards**************/\nextern"C++"{\n#define FLOAT_PRECISION     2\n\n#ifdef _MSC_VER\n#define _SECURE_SCL 0\n#pragma comment(linker,"/STACK:102400000,102400000")\n#else\n#pragma GCC optimize("O3")\n#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx")\n#endif\n#if defined(_MSC_VER)||__cplusplus&gt;199711L\n#define IT(x) auto\n#define DIT(x) auto\n#else\n#define IT(x) __typeof((x).begin())\n#define DIT(x) __typeof((x).rbegin())\n#endif\n\n#  inc\\\nlude&lt;cmath&gt;\n#  inc\\\nlude&lt;cstdio&gt;\n#  inc\\\nlude&lt;cstdlib&gt;\n#  inc\\\nlude&lt;cstring&gt;\n#  inc\\\nlude&lt;algorithm&gt;\n#  inc\\\nlude&lt;bitset&gt;\n#  inc\\\nlude&lt;complex&gt;\n#  inc\\\nlude&lt;vector&gt;\n#  inc\\\nlude&lt;iomanip&gt;\n#  inc\\\nlude&lt;iostream&gt;\n#  inc\\\nlude&lt;list&gt;\n#  inc\\\nlude&lt;map&gt;\n#  inc\\\nlude&lt;queue&gt;\n#  inc\\\nlude&lt;set&gt;\n#  inc\\\nlude&lt;stack&gt;\n#  inc\\\nlude&lt;string&gt;\n#define FAST_RW ios_base::sync_with_stdio(0),cin.tie(0);\n#define FS(i,a) for(ll i=0;a[i];i++)\n#define FE(it,x) for(IT(x) it=(x).begin(),_en=(x).end();it!=_en;it++)\n#define EF(it,x) for(DIT(x) it=(x).rbegin(),_en=(x).rend();it!=_en;it++)\n#define FR(i,en) for(ll i=0,_en=(en);i&lt;_en;i++)\n#define FOR(i,en) for(ll i=1,_en=(en);i&lt;=_en;i++)\n#define RF(i,en) for(ll i=(en)-1;i&gt;=0;i--)\n#define ROF(i,en) for(ll i=(en);i&gt;0;i--)\n#define FFR(i,x,y) for(ll i=(x),_en=(y);i&lt;=_en;i++)\n#define RFF(i,x,y) for(ll i=(x),_en=(y);i&gt;=_en;i--)\n#define pc putchar\n#define pb push_back\n#define ppb pop_back\n#define pq priority_queue\n#define fi first\n#define se second\n#define mp make_pair\n#define pii pair&lt;int,int&gt;\n#define pll pair&lt;ll,ll&gt;\n#define sqr(x) ((x)*(x))\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define clr(x) memset((x),0,sizeof(x))\n#define ms(x,v) memset((x),(v),sizeof(x))\n#define mc(x,y) memcpy((x),(y),sizeof(y))\n#define NL puts("");\n#define LB lower_bound\n#define UB upper_bound\n#define rand() ((rand()&lt;&lt;16)^(rand()&lt;&lt;15)^(rand()))\n#ifdef _WIN32\n#define _i64_ "%I\\\n64d"\n#define _u64_ "%I\\\n64u"\n#else\n#define _i64_ "%l\\\nld"\n#define _u64_ "%l\\\nlu"\n#endif\ntypedef unsigned ui;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lf;\nusing namespace std;\n\null gcd(ull a,ull b){if(!b)return a;while(b^=a^=b^=a%=b);return a;}\n\nextern const ll MOD;\nll ksm(ll a,ll b){\nll res=1;a%=MOD;\nfor(;b;b&gt;&gt;=1){if(b&amp;1)res=res*a%MOD;a=a*a%MOD;}\nreturn res;\n}\n\n#ifdef wmx16835\n#include"wmx16835.h"\n#else\n#define LOG\n#define TEL\n#define test(...) 0\n#define TEST(...) 0\n#define TRY(...)\n#define SF(...)\n#define SC\n#define PF\n#define PC\n#define PP\n#define SHOW_TIME\n#define BR\n#endif\nint main(){SHOW_TIME int __MAIN();__MAIN();}\n#define main __MAIN\n#define y0 NKwKGuBI\n#define y1 KFJssmlK\n#define yn XypGISMR\n#define j1 kQDCYYWX\n#define tm BdKIQNcs\n#define lr UsCPcJvt\n\ntemplate&lt;class T1,class T2,class T3&gt;bool In(T1 x,T2 y,T3 z){return x&lt;=y&amp;&amp;x&gt;=z||x&lt;=z&amp;&amp;x&gt;=y;}\ntemplate&lt;class T1,class T2&gt;T1 max(const T1&amp;a,const T2&amp;b){return a&lt;b?b:a;}\ntemplate&lt;class T1,class T2,class T3&gt;T1 max3(const T1&amp;a,const T2&amp;b,const T3&amp;c){return a&lt;b?(b&lt;c?c:b):(a&lt;c?c:a);}\ntemplate&lt;class T1,class T2&gt;T1 min(const T1&amp;a,const T2&amp;b){return a&lt;b?a:b;}\ntemplate&lt;class T1,class T2,class T3&gt;T1 min3(const T1&amp;a,const T2&amp;b,const T3&amp;c){return a&lt;b?(a&lt;c?a:c):(b&lt;c?b:c);}\n\nbool S(char*a){return scanf("%s",a)==1;}\nbool S(int&amp;a){return scanf("%d",&amp;a)==1;}\nbool S(bool&amp;a){return scanf("%d",&amp;a)==1;}\nbool S(ui&amp;a){return scanf("%u",&amp;a)==1;}\nbool S(float&amp;a){return scanf("%f",&amp;a)==1;}\nbool S(double&amp;a){return scanf("%lf",&amp;a)==1;}\nbool S(ll&amp;a){return scanf(_i64_,&amp;a)==1;}\nbool S(ull&amp;a){return scanf(_u64_,&amp;a)==1;}\nbool S(lf&amp;a){double b;if(scanf("%lf",&amp;b)==-1)return 0;a=b;return 1;}\nbool S(char&amp;a){char b[2];if(scanf("%1s",b)==-1)return 0;a=*b;return 1;}\nbool SL(char*a){a[0]=0;while(gets(a)&amp;&amp;!a[0]);return a[0];}\ntemplate&lt;class T1,class T2&gt;bool S(pair&lt;T1,T2&gt;&amp;a){S(a.fi),S(a.se);}\ntemplate&lt;class T&gt;bool S(T&amp;a){a.in();}\n\nvoid _P(const int&amp;x){printf("%d",x);}\nvoid _P(const bool&amp;x){printf("%d",x);}\nvoid _P(const ui&amp;x){printf("%u",x);}\nvoid _P(const char&amp;x){printf("%c",x);}\nvoid _P(const char*x){printf("%s",x);}\nvoid _P(const string&amp;x){printf("%s",x.c_str());}\nvoid _P(const ll&amp;x){printf(_i64_,x);}\nvoid _P(const ull&amp;x){printf(_u64_,x);}\nvoid _P(const float&amp;x){printf("%.*f",FLOAT_PRECISION,x);}\nvoid _P(const double&amp;x){printf("%.*f",FLOAT_PRECISION,x);}\nvoid _P(const lf&amp;x){printf("%.*f",FLOAT_PRECISION,(double)x);}\ntemplate&lt;class T1,class T2&gt;void _P(const pair&lt;T1,T2&gt;&amp;x){_P(x.fi);pc(' ');_P(x.se);}\ntemplate&lt;class T&gt;void _P(const T&amp;a){a.out();}\n\ntemplate&lt;class T1,class T2&gt;bool S(T1&amp;a,T2&amp;b){return S(a)+S(b)==2;}\ntemplate&lt;class T1,class T2,class T3&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c){return S(a)+S(b)+S(c)==3;}\ntemplate&lt;class T1,class T2,class T3,class T4&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d){return S(a)+S(b)+S(c)+S(d)==4;}\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d,T5&amp;e){return S(a)+S(b)+S(c)+S(d)+S(e)==5;}\n\ntemplate&lt;class T1&gt;void P(const T1&amp;a){_P(a);pc(' ');}\ntemplate&lt;class T1,class T2&gt;void P(const T1&amp;a,const T2&amp;b){_P(a);pc(' ');_P(b);pc(' ');}\ntemplate&lt;class T1&gt;void PN(const T1&amp;a){_P(a);NL}\ntemplate&lt;class T1,class T2&gt;void PN(const T1&amp;a,const T2&amp;b){_P(a);pc(' ');_P(b);NL}\ntemplate&lt;class T1,class T2,class T3&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c){_P(a);pc(' ');_P(b);pc(' ');_P(c);NL}\ntemplate&lt;class T1,class T2,class T3,class T4&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c,const T4&amp;d){_P(a);pc(' ');_P(b);pc(' ');_P(c);pc(' ');_P(d);NL}\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c,const T4&amp;d,const T5&amp;e){_P(a);pc(' ');_P(b);pc(' ');_P(c);pc(' ');_P(d);pc(' ');_P(e);NL}\nvoid PS(int a){printf("%*s",a,"");}\n\ntemplate&lt;class T&gt;void SA(T*a,int n){FR(i,n)S(a[i]);}\ntemplate&lt;class T&gt;void PA(T*a,int n){FR(i,n){if(i)pc(' ');_P(a[i]);}NL}\ntemplate&lt;class T&gt;void PA(const T&amp;x){FE(it,x){if(it!=x.begin())pc(' ');_P(*it);}NL}\n\nint kase;\nconst double pi=4*atan(1.);\nconst double ep=1e-9;\nconst int INF=0x3f3f3f3f;\nconst ll INFL=0x3f3f3f3f3f3f3f3fll;\nconst ll MOD=1000000007;\n}\n\nint d[105][105];\nint a[105];\n\nint main() {\n\tint n;\n\tS(n);\n\tFR(i, n) {\n\t\tS(a[i]);\n\t}\n\tFOR(l, n - 1) {\n\t\tFR(i, n) {\n\t\t\tint j = (i + l) % n;\n\t\t\tfor (int k = i; k != j; k = (k + 1) % n) {\n\t\t\t\td[i][j] = max(d[i][j], d[i][k] + d[(k + 1) % n][j] + a[(k + 1) % n] * a[i] * a[(j + 1) % n]);\n\t\t\t}\n\t\t}\n\t}\n\tint res = 0;\n\tFR(i, n) res = max(res, d[i][(i + n - 1) % n]);\n\tPN(res);\n}\n\n/*********Risoft corporation all rights reserved*********/\n/**************Template V2.33 build 20151012*************/\n\r\n</textarea>	<textarea id="codelinesjava">\r\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\npublic class Main {\n\tstatic void print(int[][] map,int n,int m){\n\t\tfor (int i = 0; i &lt; n; i++) {\n\t\t\tfor (int j = 0; j &lt; m; j++) {\n\t\t\t\tSystem.out.print(map[i][j]+" ");\n\t\t\t}System.out.println();\n\t\t}\n\t}\n\tstatic int max(int a,int b){return a&gt;b?a:b;}\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tBufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n\t\tint n=Integer.parseInt(bf.readLine());\n\t\tString[] a1=bf.readLine().split(" ");\n\t\tint[] s=new int[n];\n\t\tfor (int i = 0; i &lt; n; i++) \n\t\t\ts[i]=Integer.parseInt(a1[i]);\n\t\t\n\t\tint h=1;\n\t\t\n\t\t\tint[][] dp=new int[n][n];\n\t\t\tfor (int r = 0; r &lt;n; r++) {\n\t\t\t\tfor (int i = 0; i &lt;n  ; i++) {\n\t\t\t\t\tint j=r+i+1;\n\t\t\t\t\tif(i%n==j%n)continue;\n\t\t\t\t\tfor (int k = i; k &lt;j; k++) {\n\t\t\t\t\t\tint t=dp[i%n][k%n]+dp[(k+1)%n][j%n]+s[i%n]*s[(k+1)%n]*s[(j+1)%n];\n\t\t\t\t\t\tdp[i%n][j%n]=max(t, dp[i%n][j%n]);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tint max=dp[0][n-1];\n\t\t\tint i=1,j=0;\n\t\t\twhile (i&lt;n&amp;&amp;j&lt;n) {\n\t\t\t\tmax=max(dp[i++][j++], max);\n\t\t\t}\n\t\t\t//System.out.println(dp[1][n]);\n\t\t\t//print(dp, n, n);\n\t\t\n\t\t\n\t\tSystem.out.println(max);\n\t\t//print(dp, n+1, n+1);\n\t\n\t}\n}\n\r\n</textarea>	316
301	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　每年冬天，北大未名湖上都是滑冰的好地方。北大体育组准备了许多冰鞋，可是人太多了，每天下午收工后，常常一双冰鞋都不剩。\n  <br> 　　每天早上，租鞋窗口都会排起长龙，假设有还鞋的m个，有需要租鞋的n个。现在的问题是，这些人有多少种排法，可以避免出现体育组没有冰鞋可租的尴尬场面。（两个同样需求的人（比如都是租鞋或都是还鞋）交换位置是同一种排法）\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　两个整数，表示m和n\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　一个整数，表示队伍的排法的方案数。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3 2\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  5\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　m,n∈［0,18］\n  <br> 　　问题分析\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n\nint function(int m,int n)\n{\n//\tprintf("%d%d",m,n);\n\tif(m&lt;n)\n\t\treturn 0;\n\tif(m==0||n==0)\n\t{\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\treturn function(m-1,n)+function(m,n-1);\n\t\n\t} \n\t\n\treturn 0;\n}\nint main()\n{\n\tint n,m,sum=0;\n\tscanf("%d%d",&amp;m,&amp;n);\n\tsum+=function(m,n);\n\tprintf("%d",sum);\n\treturn 0;\n} \r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid fun(int m, int n, int temp, int &amp;count);\n\nint main(void)\n{\n\tint m, n, count;\n\n\twhile (scanf("%d %d", &amp;m, &amp;n) == 2)\n\t{\n\t\tcount = 0;\n\t\tfun(m, n, 0, count);\n\t\tprintf("%d\\n", count);\n\t}\n\n\n\treturn 0;\n}\n\nvoid fun(int m, int n, int temp, int &amp;count)\n{\n\tif (!(m || n))\n\t{\n\t\tcount++;\n\t}\n\telse\n\t{\n\t\tif (temp)\n\t\t{\n\t\t\tif (m &gt;= 1)\n\t\t\t{\n\t\t\t\tfun(m-1, n, temp+1, count);\n\t\t\t}\n\n\t\t\tif (n &gt;= 1)\n\t\t\t{\n\t\t\t\tfun(m, n-1, temp-1, count);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (m &gt;= 1)\n\t\t\t{\n\t\t\t\tfun(m-1, n, temp+1, count);\n\t\t\t}\n\t\t}\n\t}\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\npublic class Main {\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader burf = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] s = burf.readLine().split(" ");\n\t\tint m = Integer.parseInt(s[0]);\n\t\tint n = Integer.parseInt(s[1]);\n\t\tSystem.out.println(func(m,n));\n\t}\n\tpublic static int func(int m,int n){\n\t\tif(n==0)\n\t\t\treturn 1;\n\t\tif(m&lt;n)\n\t\t\treturn 0;\n\t\treturn func(m-1,n)+func(m,n-1);\n\t}\n}\n\r\n</textarea>	303
302	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　一个正整数可以划分为多个正整数的和，比如n=3时：\n  <br> 　　3；1＋2；1＋1＋1；\n  <br> 　　共有三种划分方法。\n  <br> 　　给出一个正整数，问有多少种划分方法。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　一个正整数n\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　一个正整数，表示划分方案数\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  3\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　n&lt;=100\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint main(){\n\tint n,i,j,sum=0;\n\tint a[105][105]={0};\n\tscanf("%d",&amp;n);\n\tfor(i=1;i&lt;=n;i++){\n\t\ta[i][1]=1; \n\t}\n\tfor(i=2;i&lt;=n;i++){\n\t\tfor(j=2;j&lt;=i;j++){\n\t\t\ta[i][j]=a[i-1][j-1]+a[i-j][j];\n\t\t}\n\t}\n\tfor(i=1;i&lt;=n;i++){\n\t\tsum+=a[n][i];\n\t}\n\tprintf("%d",sum);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;cmath&gt;\nusing namespace std;\nint main()\n{\n\tint i,j,n,sum = 0;\n\tcin&gt;&gt;n;\n\tint dp[105][105] = {0};\n\tfor(i = 1 ; i &lt;= n ; i ++)\n\t\tdp[i][1] = 1;\n\tfor(i = 2 ; i &lt;= n ; i ++)\n\t{\n\t\tfor(j = 2 ; j &lt;= i ; j ++)\n\t\t\tdp[i][j] = dp[i-1][j-1]+dp[i-j][j];\n\t}\n\tfor(i = 1 ; i &lt;= n ; i ++)\n\t\tsum += dp[n][i];\n\tcout&lt;&lt;sum&lt;&lt;endl;\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner s=new Scanner(System.in);\n    \tint n=s.nextInt();\n    \tint[][]f=new int[101][101];\n    \tfor(int i=0;i&lt;=n;i++){\n    \t\tf[i][1]=1;\n    \t}\n    \tint count=0;\n    \tfor(int k=1;k&lt;=n;k++)\n    \t{\n    \tfor(int i=2;i&lt;=k;i++){\n    \t\tfor(int j=0;j&lt;=n-k;j++){\n    \t\t\tif(i&gt;j)\n    \t\t\t\tf[j][i]=f[j][i-1];\n    \t\t\telse\n    \t\t\t\tf[j][i]=f[j][i-1]+f[j-i][i];\n    \t\t\t\n    \t\t}\n    \t}\n    \t      count+=f[n-k][k];\n    \t}\n    \tSystem.out.println(count);\n\t}\t\n}\n\r\n</textarea>	304
303	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　在上一季里，曾提到过质数的孤独，其实从另一个角度看，无情隔膜它们的合数全是质数的后代，因为合数可以由质数相乘结合而得。\n  <br> 　　如果一个合数由两个质数相乘而得，那么我们就叫它是质数们的直接后代。现在，给你一系列自然数，判断它们是否是质数的直接后代。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行一个正整数T，表示需要判断的自然数数量\n  <br> 　　接下来T行，每行一个要判断的自然数\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　共T行，依次对于输入中给出的自然数，判断是否为质数的直接后代，是则输出Yes，否则输出No\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  4\n  <br> 3\n  <br> 4\n  <br> 6\n  <br> 12\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  No\n  <br> Yes\n  <br> Yes\n  <br> No\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　1&lt;=T&lt;=20\n  <br> 　　2&lt;=要判断的自然数&lt;=10\n  <sup>5</sup>\n </div> \n</div>	<textarea id="codelinesc">\r\n/*问题描述\n在上一季里，曾提到过质数的孤独，其实从另一个角度看，\n无情隔膜它们的合数全是质数的后代，因为合数可以由质数相乘结合而得。\n如果一个合数由两个质数相乘而得，那么我们就叫它是质数们的直接后代。\n现在，给你一系列自然数，判断它们是否是质数的直接后代。\n输入格式\n第一行一个正整数T，表示需要判断的自然数数量\n接下来T行，每行一个要判断的自然数\n输出格式\n共T行，依次对于输入中给出的自然数，\n判断是否为质数的直接后代，是则输出Yes，否则输出No\n样例输入\n4\n3\n4\n6\n12\n样例输出\nNo\nYes\nYes\nNo\n数据规模和约定\n　　1&lt;=T&lt;=20\n　　2&lt;=要判断的自然数&lt;=105\n*/\n\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n\nvoid shuru(int ,int []);\nvoid panduan(int ,int []);\nvoid qiu_zhis(int ,int []);\nvoid shuchu(int );\n\nint main(void)\n{\n    int n;\n    scanf("%d",&amp;n);\n    int shuzu[n];\n    shuru(n,shuzu);\n    panduan(n,shuzu);\n    \n\tsystem("pause");\n\treturn 0; \n}\n\nvoid shuchu(int sum)\n{\n     if (sum==2)\n     {\n         printf("Yes");\n     }\n     else\n     {\n         printf("No");\n     }\n     putchar('\\n');\n}\n\nvoid qiu_zhis(int i,int sz[])\n{\n     int j,k;\n     int sum=0;\n     for (j=2;j&lt;=sz[i];j++)\n     {\n         if (sz[i]%j==0)\n         {\n             while (sz[i]%j==0)\n            {\n                  sz[i]/=j;\n                  sum++;\n             }\n         }\n     }\n     shuchu(sum);\n\n}\n\nvoid panduan(int n,int sz[])\n{\n     int i;\n     for (i=0;i&lt;n;i++)\n     {\n         qiu_zhis(i,sz);\n     }\n}\n\nvoid shuru(int n,int sz[])\n{\n     int i;\n     for (i=0;i&lt;n;i++)\n     {\n         scanf("%d",sz+i);\n     }\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n/**************Powered by Graphene Richards**************/\nextern"C++"{\n#define FLOAT_PRECISION     2\n\n#ifdef _MSC_VER\n#define _SECURE_SCL 0\n#pragma comment(linker,"/STACK:102400000,102400000")\n#else\n#pragma GCC optimize("O3")\n#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx")\n#endif\n#if defined(_MSC_VER)||__cplusplus&gt;199711L\n#define IT(x) auto\n#define DIT(x) auto\n#else\n#define IT(x) __typeof((x).begin())\n#define DIT(x) __typeof((x).rbegin())\n#endif\n\n#  inc\\\nlude&lt;cmath&gt;\n#  inc\\\nlude&lt;cstdio&gt;\n#  inc\\\nlude&lt;cstdlib&gt;\n#  inc\\\nlude&lt;cstring&gt;\n#  inc\\\nlude&lt;algorithm&gt;\n#  inc\\\nlude&lt;bitset&gt;\n#  inc\\\nlude&lt;complex&gt;\n#  inc\\\nlude&lt;vector&gt;\n#  inc\\\nlude&lt;iomanip&gt;\n#  inc\\\nlude&lt;iostream&gt;\n#  inc\\\nlude&lt;list&gt;\n#  inc\\\nlude&lt;map&gt;\n#  inc\\\nlude&lt;queue&gt;\n#  inc\\\nlude&lt;set&gt;\n#  inc\\\nlude&lt;stack&gt;\n#  inc\\\nlude&lt;string&gt;\n#define FAST_RW ios_base::sync_with_stdio(0),cin.tie(0);\n#define FS(i,a) for(ll i=0;a[i];i++)\n#define FE(it,x) for(IT(x) it=(x).begin(),_en=(x).end();it!=_en;it++)\n#define EF(it,x) for(DIT(x) it=(x).rbegin(),_en=(x).rend();it!=_en;it++)\n#define FR(i,en) for(ll i=0,_en=(en);i&lt;_en;i++)\n#define FOR(i,en) for(ll i=1,_en=(en);i&lt;=_en;i++)\n#define RF(i,en) for(ll i=(en)-1;i&gt;=0;i--)\n#define ROF(i,en) for(ll i=(en);i&gt;0;i--)\n#define FFR(i,x,y) for(ll i=(x),_en=(y);i&lt;=_en;i++)\n#define RFF(i,x,y) for(ll i=(x),_en=(y);i&gt;=_en;i--)\n#define pc putchar\n#define pb push_back\n#define ppb pop_back\n#define pq priority_queue\n#define fi first\n#define se second\n#define mp make_pair\n#define pii pair&lt;int,int&gt;\n#define pll pair&lt;ll,ll&gt;\n#define sqr(x) ((x)*(x))\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define clr(x) memset((x),0,sizeof(x))\n#define ms(x,v) memset((x),(v),sizeof(x))\n#define mc(x,y) memcpy((x),(y),sizeof(y))\n#define NL puts("");\n#define LB lower_bound\n#define UB upper_bound\n#define rand() ((rand()&lt;&lt;16)^(rand()&lt;&lt;15)^(rand()))\n#ifdef _WIN32\n#define _i64_ "%I\\\n64d"\n#define _u64_ "%I\\\n64u"\n#else\n#define _i64_ "%l\\\nld"\n#define _u64_ "%l\\\nlu"\n#endif\ntypedef unsigned ui;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lf;\nusing namespace std;\n\null gcd(ull a,ull b){if(!b)return a;while(b^=a^=b^=a%=b);return a;}\n\nextern const ll MOD;\nll ksm(ll a,ll b){\nll res=1;a%=MOD;\nfor(;b;b&gt;&gt;=1){if(b&amp;1)res=res*a%MOD;a=a*a%MOD;}\nreturn res;\n}\n\n#ifdef wmx16835\n#include"wmx16835.h"\n#else\n#define LOG\n#define TEL\n#define test(...) 0\n#define TEST(...) 0\n#define TRY(...)\n#define SF(...)\n#define SC\n#define PF\n#define PC\n#define PP\n#define SHOW_TIME\n#define BR\n#endif\nint main(){SHOW_TIME int __MAIN();__MAIN();}\n#define main __MAIN\n#define y0 NKwKGuBI\n#define y1 KFJssmlK\n#define yn XypGISMR\n#define j1 kQDCYYWX\n#define tm BdKIQNcs\n#define lr UsCPcJvt\n\ntemplate&lt;class T1,class T2,class T3&gt;bool In(T1 x,T2 y,T3 z){return x&lt;=y&amp;&amp;x&gt;=z||x&lt;=z&amp;&amp;x&gt;=y;}\ntemplate&lt;class T1,class T2&gt;T1 max(const T1&amp;a,const T2&amp;b){return a&lt;b?b:a;}\ntemplate&lt;class T1,class T2,class T3&gt;T1 max3(const T1&amp;a,const T2&amp;b,const T3&amp;c){return a&lt;b?(b&lt;c?c:b):(a&lt;c?c:a);}\ntemplate&lt;class T1,class T2&gt;T1 min(const T1&amp;a,const T2&amp;b){return a&lt;b?a:b;}\ntemplate&lt;class T1,class T2,class T3&gt;T1 min3(const T1&amp;a,const T2&amp;b,const T3&amp;c){return a&lt;b?(a&lt;c?a:c):(b&lt;c?b:c);}\n\nbool S(char*a){return scanf("%s",a)==1;}\nbool S(int&amp;a){return scanf("%d",&amp;a)==1;}\nbool S(bool&amp;a){return scanf("%d",&amp;a)==1;}\nbool S(ui&amp;a){return scanf("%u",&amp;a)==1;}\nbool S(float&amp;a){return scanf("%f",&amp;a)==1;}\nbool S(double&amp;a){return scanf("%lf",&amp;a)==1;}\nbool S(ll&amp;a){return scanf(_i64_,&amp;a)==1;}\nbool S(ull&amp;a){return scanf(_u64_,&amp;a)==1;}\nbool S(lf&amp;a){double b;if(scanf("%lf",&amp;b)==-1)return 0;a=b;return 1;}\nbool S(char&amp;a){char b[2];if(scanf("%1s",b)==-1)return 0;a=*b;return 1;}\nbool SL(char*a){a[0]=0;while(gets(a)&amp;&amp;!a[0]);return a[0];}\ntemplate&lt;class T1,class T2&gt;bool S(pair&lt;T1,T2&gt;&amp;a){S(a.fi),S(a.se);}\ntemplate&lt;class T&gt;bool S(T&amp;a){a.in();}\n\nvoid _P(const int&amp;x){printf("%d",x);}\nvoid _P(const bool&amp;x){printf("%d",x);}\nvoid _P(const ui&amp;x){printf("%u",x);}\nvoid _P(const char&amp;x){printf("%c",x);}\nvoid _P(const char*x){printf("%s",x);}\nvoid _P(const string&amp;x){printf("%s",x.c_str());}\nvoid _P(const ll&amp;x){printf(_i64_,x);}\nvoid _P(const ull&amp;x){printf(_u64_,x);}\nvoid _P(const float&amp;x){printf("%.*f",FLOAT_PRECISION,x);}\nvoid _P(const double&amp;x){printf("%.*f",FLOAT_PRECISION,x);}\nvoid _P(const lf&amp;x){printf("%.*f",FLOAT_PRECISION,(double)x);}\ntemplate&lt;class T1,class T2&gt;void _P(const pair&lt;T1,T2&gt;&amp;x){_P(x.fi);pc(' ');_P(x.se);}\ntemplate&lt;class T&gt;void _P(const T&amp;a){a.out();}\n\ntemplate&lt;class T1,class T2&gt;bool S(T1&amp;a,T2&amp;b){return S(a)+S(b)==2;}\ntemplate&lt;class T1,class T2,class T3&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c){return S(a)+S(b)+S(c)==3;}\ntemplate&lt;class T1,class T2,class T3,class T4&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d){return S(a)+S(b)+S(c)+S(d)==4;}\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d,T5&amp;e){return S(a)+S(b)+S(c)+S(d)+S(e)==5;}\n\ntemplate&lt;class T1&gt;void P(const T1&amp;a){_P(a);pc(' ');}\ntemplate&lt;class T1,class T2&gt;void P(const T1&amp;a,const T2&amp;b){_P(a);pc(' ');_P(b);pc(' ');}\ntemplate&lt;class T1&gt;void PN(const T1&amp;a){_P(a);NL}\ntemplate&lt;class T1,class T2&gt;void PN(const T1&amp;a,const T2&amp;b){_P(a);pc(' ');_P(b);NL}\ntemplate&lt;class T1,class T2,class T3&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c){_P(a);pc(' ');_P(b);pc(' ');_P(c);NL}\ntemplate&lt;class T1,class T2,class T3,class T4&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c,const T4&amp;d){_P(a);pc(' ');_P(b);pc(' ');_P(c);pc(' ');_P(d);NL}\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c,const T4&amp;d,const T5&amp;e){_P(a);pc(' ');_P(b);pc(' ');_P(c);pc(' ');_P(d);pc(' ');_P(e);NL}\nvoid PS(int a){printf("%*s",a,"");}\n\ntemplate&lt;class T&gt;void SA(T*a,int n){FR(i,n)S(a[i]);}\ntemplate&lt;class T&gt;void PA(T*a,int n){FR(i,n){if(i)pc(' ');_P(a[i]);}NL}\ntemplate&lt;class T&gt;void PA(const T&amp;x){FE(it,x){if(it!=x.begin())pc(' ');_P(*it);}NL}\n\nint kase;\nconst double pi=4*atan(1.);\nconst double ep=1e-9;\nconst int INF=0x3f3f3f3f;\nconst ll INFL=0x3f3f3f3f3f3f3f3fll;\nconst ll MOD=1000000007;\n}\n\nbool isp(int x) {\n\tif (x &lt; 2) return 0;\n\tif (x == 2) return 1;\n\tFFR(i, 2, sqrt(x) + 1) {\n\t\tif (x % i == 0) return 0;\n\t}\n\treturn 1;\n}\n\nbool OK(int x) {\n\tFFR(i, 2, sqrt(x) + 1) {\n\t\tif (x % i == 0) {\n\t\t\treturn isp(i) &amp;&amp; isp(x / i);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main() {\n\tint T;\n\tS(T);\n\twhile (T--) {\n\t\tint x;\n\t\tS(x);\n\t\tPN(OK(x) ? "Yes": "No");\n\t}\n}\n\n/*********Risoft corporation all rights reserved*********/\n/**************Template V2.33 build 20151012*************/\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint t = sc.nextInt();\n\t\tint[] data = new int[t];\n\t\tfor (int i = 0; i &lt; t; i++) {\n\t\t\tdata[i] = sc.nextInt();\n\t\t}\n\t\tfor (int i = 0; i &lt; t; i++) {\n\t\t\tfind(data[i]);\n\t\t}\n\t}\n\n\tprivate static void find(int i) {\n\t\t// TODO Auto-generated method stub\n\t\tint j;\n\t\tfor (j = 2; j &lt; i; j++) {\n\t\t\tif (i % j == 0) {\n\t\t\t\tint m;\n\t\t\t\tfor (m = 2; m &lt; j &amp;&amp; j % m != 0; m++)\n\t\t\t\t\t;\n\t\t\t\tif (m == j) {\n\t\t\t\t\tint d = i / j;\n\t\t\t\t\tfor (m = 2; m &lt; d &amp;&amp; d % m != 0; m++)\n\t\t\t\t\t\t;\n\t\t\t\t\tif (m == d) {\n\t\t\t\t\t\tSystem.out.println("Yes");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (j == i) {\n\t\t\tSystem.out.println("No");\n\t\t}\n\t}\n}\n\r\n</textarea>	305
304	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　第一分钟，上帝说：要有题。于是就有了L，Y，M，C\n  <br> 　　第二分钟，LYC说：要有向量。于是就有了长度为n写满随机整数的向量\n  <br> 　　第三分钟，YUHCH说：要有查询。于是就有了Q个查询，查询向量的一段区间内元素的最小值\n  <br> 　　第四分钟，MZC说：要有限。于是就有了数据范围\n  <br> 　　第五分钟，CS说：要有做题的。说完众神一哄而散，留你来收拾此题\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行两个正整数n和Q，表示向量长度和查询个数\n  <br> 　　接下来一行n个整数，依次对应向量中元素：a[0]，a[1]，…，a[n-1]\n  <br> 　　接下来Q行，每行两个正整数lo，hi，表示查询区间[lo, hi]中的最小值，即min(a[lo],a[lo+1],…,a[hi])。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　共Q行，依次对应每个查询的结果，即向量在对应查询区间中的最小值。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  7 4\n  <br> 1 -1 -4 8 1 2 -7\n  <br> 0 0\n  <br> 1 3\n  <br> 4 5\n  <br> 0 6\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  1\n  <br> -4\n  <br> 1\n  <br> -7\n </div>\n <div class="pdsec">\n  样例说明\n </div>\n <div class="pdcont">\n  　　第一个查询[0,0]表示求min{a[0]}=min{1}=1\n  <br> 　　第二个查询[1,3]表示求min{a[1],a[2],a[3]}=min{-1,-4,8}=-4\n  <br> 　　第三个查询[4,5]表示求min{a[4],a[5]}=min{1,2}=1\n  <br> 　　第四个查询[0,6]表示查询整个向量，求min{a[0..6]}=min{1,-1,-4,8,1,2,-7}=-7\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　1&lt;=n&lt;=1984，1&lt;=Q&lt;=1988，向量中随机整数的绝对值不超过1,000\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\nint min(int a,int b,int c[]){\n    int i;\n    int mina = c[a];\n    for(i=a+1;i&lt;=b;i++){\n        if(c[i]&lt;mina){\n            mina = c[i]; \n            }\n    }\n    return mina;\n}\nint main(){\n    int i,n,q,b,c,a[2000];\n    scanf("%d%d",&amp;n,&amp;q);\n    for(i=0;i&lt;n;i++){\n       scanf("%d",&amp;a[i]);    \n    }\n    for(i=0;i&lt;q;i++){\n        scanf("%d%d",&amp;b,&amp;c);\n        printf("%d\\n",min(b,c,a));\n    }\n    system("pause");\n    return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;stdio.h&gt;\nint random[1985], query[1989][2]; //存放向量以及查询的区间 \nint n,Q;//向量的长度，查询的个数 \nint result[1985][1985];\nint main()\n{\n\tint i,j;\n    scanf("%d%d", &amp;n, &amp;Q);\n    for(i = 0; i &lt; n; i++)\n    {\n    \tscanf("%d", &amp;random[i]);\n    }\n\tfor(i = 0; i &lt; Q; i++)\n\t{\n\t\tscanf("%d%d", &amp;query[i][0], &amp;query[i][1]);\n\t}\n\tresult[0][0] = random[0];\n\tfor(j = 1; j &lt; n; j++)\n\t{\n\t\tif(random[j] &lt; result[0][j - 1]) \n\t\t{\n\t\t\tresult[0][j] = random[j];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult[0][j] = result[0][j - 1];\n\t\t}\n\t\t\t\t\n\t\t   result[j][0] = result[0][j];\n\t\t}\n\t\n\tfor(i = 1; i &lt; n; i++)\n\t{\n\t\tresult[i][i] = random[i];\n\t\tfor(j = i + 1; j &lt; n &amp;&amp; j &gt; i; j++)\n\t\t{\n\t\t\tif(random[j] &lt; result[i][j - 1])\n\t\t\t{\n\t\t\t\tresult[i][j] = random[j];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult[i][j] = result[i][j - 1];\n\t\t\t}\n\t\t\tresult[j][i] = result[i][j];\n\t\t}\n\t}\n\tfor(i = 0; i &lt; Q; i++)\n\t{\n\t\tprintf("%d\\n", result[query[i][0]][query[i][1]]); \n\t} \n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\nclass Reader\n{\n\tstatic BufferedReader reader;\n\tstatic StringTokenizer tokenizer;\n\n\tstatic void init(InputStream input)\n\t{\n\t\treader=new BufferedReader(new InputStreamReader(input));\n\t\ttokenizer=new StringTokenizer("");\n\t}\n\n\tstatic String next() throws IOException\n\t{\n\t\twhile ( !tokenizer.hasMoreElements())\n\t\t{\n\t\t\ttokenizer=new StringTokenizer(reader.readLine());\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\n\tstatic int nextInt() throws IOException\n\t{\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tstatic double nextDouble() throws IOException\n\t{\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tstatic long nextLong() throws IOException\n\t{\n\t\treturn Long.parseLong(next());\n\t}\n\n\tstatic void close() throws IOException\n\t{\n\t\treader.close();\n\t}\n}\n\npublic class Main\n{\n\tfinal static int a[]=new int [2000]; \n\tpublic static void main(String[] args) throws IOException\n\t{\n\t\tReader.init(System.in);\n\t\tint n=Reader.nextInt();\n\t\tint Q=Reader.nextInt();\n\t\tfor (int i=0;i&lt;n;i++)\n\t\t{\n\t\t\ta[i]=Reader.nextInt();\n\t\t}\n\t\tfor (int k=0;k&lt;Q;k++)\n\t\t{\n\t\t\tint l=Reader.nextInt();\n\t\t\tint h=Reader.nextInt();\n\t\t\tint min=a[l];\n\t\t\tfor (int i=l+1;i&lt;=h;i++)\n\t\t\t{\n\t\t\t\tif (min&gt;a[i])\n\t\t\t\t\tmin=a[i];\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t\tReader.close();\n\t\t\n\t}\n}\r\n</textarea>	306
315	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过N元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：\n  <br> \n  <table cellspacing="0" cellpadding="2px" style="border-collapse:collapse;" class="table table-striped table-horver">\n   <tbody>\n    <tr style="border:solid 1.0pt">\n     <td style="border:solid 1.0pt">主件</td>\n     <td style="border:solid 1.0pt">附件</td>\n    </tr>\n    <tr style="border:solid 1.0pt">\n     <td style="border:solid 1.0pt">电脑</td>\n     <td style="border:solid 1.0pt">打印机，扫描仪</td>\n    </tr>\n    <tr style="border:solid 1.0pt">\n     <td style="border:solid 1.0pt">书柜</td>\n     <td style="border:solid 1.0pt">图书</td>\n    </tr>\n    <tr style="border:solid 1.0pt">\n     <td style="border:solid 1.0pt">书桌</td>\n     <td style="border:solid 1.0pt">台灯，文具</td>\n    </tr>\n    <tr style="border:solid 1.0pt">\n     <td style="border:solid 1.0pt">工作椅</td>\n     <td style="border:solid 1.0pt">无</td>\n    </tr>\n   </tbody>\n  </table>\n  <br> 　　如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有0个、1个或2个附件。附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的N元。于是，他把每件物品规定了一个重要度，分为5等：用整数1~5表示，第5等最重要。他还从因特网上查到了每件物品的价格（都是10元的整数倍）。他希望在不超过N元（可以等于N元）的前提下，使每件物品的价格与重要度的乘积的总和最大。\n  <br> 　　设第j件物品的价格为v[j]，重要度为w[j]，共选中了k件物品，编号依次为j_1，j_2，……，j_k，则所求的总和为：\n  <br> 　　v[j_1]*w[j_1]+v[j_2]*w[j_2]+ …+v[j_k]*w[j_k]。（其中*为乘号）\n  <br> 　　请你帮助金明设计一个满足要求的购物单。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入文件budget.in 的第1行，为两个正整数，用一个空格隔开：\n  <br> 　　N m\n  <br> 　　（其中N（&lt;32000）表示总钱数，m（&lt;60）为希望购买物品的个数。）\n  <br> 　　从第2行到第m+1行，第j行给出了编号为j-1的物品的基本数据，每行有3个非负整数\n  <br> 　　v p q\n  <br> 　　（其中v表示该物品的价格（v&lt;10000），p表示该物品的重要度（1~5），q表示该物品是主件还是附件。如果q=0，表示该物品为主件，如果q&gt;0，表示该物品为附件，q是所属主件的编号）\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出文件budget.out只有一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（&lt;200000）。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  1000 5\n  <br> 800 2 0\n  <br> 400 5 1\n  <br> 300 5 1\n  <br> 400 3 0\n  <br> 500 2 0\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  2200\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;  \nint v[70];  \nint p[70];  \nint q[70];  \nint f[50000];  \nint max(int a,int b)  \n{   return a &gt; b ? a : b;   }  \nint main()  \n{  \n    int n,m;  \n    int i,j,k;  \n    int t1,t2;  \n    int k1,k2;  \n    int l=0;  \n    scanf("%d%d",&amp;n,&amp;m);  \n    for(i = 1; i &lt;= m; i++)  \n    {  \n        scanf("%d%d%d",&amp;v[i],&amp;p[i],&amp;q[i]);  \n    }  \n    for(i = 1; i &lt;= m; i++)  \n    {  \n        k1=0;  \n        k2=0;  \n        t1=0;  \n        t2=0;  \n        if(q[i]==0)  //要是主物件  \n        {  \n            for(k = i+1;k &lt;= m; k++)  \n                if(q[k]==i)                       //找到附属物品1  \n                {  \n                    t1=k;  \n                    k1=1;  \n                    break;  \n                }  \n                for(k = t1+1;k &lt;= m; k++)  \n                    if(q[k]==i)                       //找到附属物品2  \n                    {  \n                        t2=k;  \n                        k2=1;  \n                        break;  \n                    }   \n                    for(j = n; j &gt;= v[i]; j--)  \n                    {         \n                            f[j]=max(f[j-v[i]]+v[i]*p[i],f[j]);  \n  \n                        f[j]=max(f[j-v[i]]+v[i]*p[i],f[j]);   //只要主件或者都不要  \n                            if((j-v[i]-v[t1])&gt;=0&amp;&amp;k1==1)                         //要附件1  \n  \n                                f[j]=max(f[j-v[i]-v[t1]]+v[i]*p[i]+v[t1]*p[t1],f[j]);  \n                       if((j-v[i]-v[t2])&gt;=0&amp;&amp;k2==1)                                             \n  \n                            f[j]=max(f[j-v[i]-v[t2]]+v[i]*p[i]+v[t2]*p[t2],f[j]);  \n                        if((j-v[i]-v[t1]-v[t2])&gt;=0&amp;&amp;k1==1&amp;&amp;k2==1)                                             \n                            f[j]=max(f[j-v[i]-v[t1]-v[t2]]+v[i]*p[i]+v[t1]*p[t1]+v[t2]*p[t2],f[j]);           \n                    }  \n        }  \n    }  \n    printf("%d\\n",f[n]);  \n      \n    return 0;  \n}  \n\r\n</textarea>	<textarea id="codelinescpp">\r\n/**************Powered by Graphene Richards**************/\nextern"C++"{\n#define FLOAT_PRECISION     2\n\n#ifdef _MSC_VER\n#define _SECURE_SCL 0\n#pragma comment(linker,"/STACK:102400000,102400000")\n#else\n#pragma GCC optimize("O3")\n#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx")\n#endif\n#if defined(_MSC_VER)||__cplusplus&gt;199711L\n#define IT(x) auto\n#define DIT(x) auto\n#else\n#define IT(x) __typeof((x).begin())\n#define DIT(x) __typeof((x).rbegin())\n#endif\n\n#  inc\\\nlude&lt;cmath&gt;\n#  inc\\\nlude&lt;cstdio&gt;\n#  inc\\\nlude&lt;cstdlib&gt;\n#  inc\\\nlude&lt;cstring&gt;\n#  inc\\\nlude&lt;algorithm&gt;\n#  inc\\\nlude&lt;bitset&gt;\n#  inc\\\nlude&lt;complex&gt;\n#  inc\\\nlude&lt;vector&gt;\n#  inc\\\nlude&lt;iomanip&gt;\n#  inc\\\nlude&lt;iostream&gt;\n#  inc\\\nlude&lt;list&gt;\n#  inc\\\nlude&lt;map&gt;\n#  inc\\\nlude&lt;queue&gt;\n#  inc\\\nlude&lt;set&gt;\n#  inc\\\nlude&lt;stack&gt;\n#  inc\\\nlude&lt;string&gt;\n#define FAST_RW ios_base::sync_with_stdio(0),cin.tie(0);\n#define FS(i,a) for(ll i=0;a[i];i++)\n#define FE(it,x) for(IT(x) it=(x).begin(),_en=(x).end();it!=_en;it++)\n#define EF(it,x) for(DIT(x) it=(x).rbegin(),_en=(x).rend();it!=_en;it++)\n#define FR(i,en) for(ll i=0,_en=(en);i&lt;_en;i++)\n#define FOR(i,en) for(ll i=1,_en=(en);i&lt;=_en;i++)\n#define RF(i,en) for(ll i=(en)-1;i&gt;=0;i--)\n#define ROF(i,en) for(ll i=(en);i&gt;0;i--)\n#define FFR(i,x,y) for(ll i=(x),_en=(y);i&lt;=_en;i++)\n#define RFF(i,x,y) for(ll i=(x),_en=(y);i&gt;=_en;i--)\n#define pc putchar\n#define pb push_back\n#define ppb pop_back\n#define pq priority_queue\n#define fi first\n#define se second\n#define mp make_pair\n#define pii pair&lt;int,int&gt;\n#define pll pair&lt;ll,ll&gt;\n#define sqr(x) ((x)*(x))\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define clr(x) memset((x),0,sizeof(x))\n#define ms(x,v) memset((x),(v),sizeof(x))\n#define mc(x,y) memcpy((x),(y),sizeof(y))\n#define NL puts("");\n#define LB lower_bound\n#define UB upper_bound\n#define rand() ((rand()&lt;&lt;16)^(rand()&lt;&lt;15)^(rand()))\n#ifdef _WIN32\n#define _i64_ "%I\\\n64d"\n#define _u64_ "%I\\\n64u"\n#else\n#define _i64_ "%l\\\nld"\n#define _u64_ "%l\\\nlu"\n#endif\ntypedef unsigned ui;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lf;\nusing namespace std;\n\null gcd(ull a,ull b){if(!b)return a;while(b^=a^=b^=a%=b);return a;}\n\nextern const ll MOD;\nll ksm(ll a,ll b){\nll res=1;a%=MOD;\nfor(;b;b&gt;&gt;=1){if(b&amp;1)res=res*a%MOD;a=a*a%MOD;}\nreturn res;\n}\n\n#ifdef wmx16835\n#include"wmx16835.h"\n#else\n#define LOG\n#define TEL\n#define test(...) 0\n#define TEST(...) 0\n#define TRY(...)\n#define SF(...)\n#define SC\n#define PF\n#define PC\n#define PP\n#define SHOW_TIME\n#define BR\n#endif\nint main(){SHOW_TIME int __MAIN();__MAIN();}\n#define main __MAIN\n#define y0 NKwKGuBI\n#define y1 KFJssmlK\n#define yn XypGISMR\n#define j1 kQDCYYWX\n#define tm BdKIQNcs\n#define lr UsCPcJvt\n\ntemplate&lt;class T1,class T2,class T3&gt;bool In(T1 x,T2 y,T3 z){return x&lt;=y&amp;&amp;x&gt;=z||x&lt;=z&amp;&amp;x&gt;=y;}\ntemplate&lt;class T1,class T2&gt;T1 max(const T1&amp;a,const T2&amp;b){return a&lt;b?b:a;}\ntemplate&lt;class T1,class T2,class T3&gt;T1 max3(const T1&amp;a,const T2&amp;b,const T3&amp;c){return a&lt;b?(b&lt;c?c:b):(a&lt;c?c:a);}\ntemplate&lt;class T1,class T2&gt;T1 min(const T1&amp;a,const T2&amp;b){return a&lt;b?a:b;}\ntemplate&lt;class T1,class T2,class T3&gt;T1 min3(const T1&amp;a,const T2&amp;b,const T3&amp;c){return a&lt;b?(a&lt;c?a:c):(b&lt;c?b:c);}\n\nbool S(char*a){return scanf("%s",a)==1;}\nbool S(int&amp;a){return scanf("%d",&amp;a)==1;}\nbool S(bool&amp;a){return scanf("%d",&amp;a)==1;}\nbool S(ui&amp;a){return scanf("%u",&amp;a)==1;}\nbool S(float&amp;a){return scanf("%f",&amp;a)==1;}\nbool S(double&amp;a){return scanf("%lf",&amp;a)==1;}\nbool S(ll&amp;a){return scanf(_i64_,&amp;a)==1;}\nbool S(ull&amp;a){return scanf(_u64_,&amp;a)==1;}\nbool S(lf&amp;a){double b;if(scanf("%lf",&amp;b)==-1)return 0;a=b;return 1;}\nbool S(char&amp;a){char b[2];if(scanf("%1s",b)==-1)return 0;a=*b;return 1;}\nbool SL(char*a){a[0]=0;while(gets(a)&amp;&amp;!a[0]);return a[0];}\ntemplate&lt;class T1,class T2&gt;bool S(pair&lt;T1,T2&gt;&amp;a){S(a.fi),S(a.se);}\ntemplate&lt;class T&gt;bool S(T&amp;a){a.in();}\n\nvoid _P(const int&amp;x){printf("%d",x);}\nvoid _P(const bool&amp;x){printf("%d",x);}\nvoid _P(const ui&amp;x){printf("%u",x);}\nvoid _P(const char&amp;x){printf("%c",x);}\nvoid _P(const char*x){printf("%s",x);}\nvoid _P(const string&amp;x){printf("%s",x.c_str());}\nvoid _P(const ll&amp;x){printf(_i64_,x);}\nvoid _P(const ull&amp;x){printf(_u64_,x);}\nvoid _P(const float&amp;x){printf("%.*f",FLOAT_PRECISION,x);}\nvoid _P(const double&amp;x){printf("%.*f",FLOAT_PRECISION,x);}\nvoid _P(const lf&amp;x){printf("%.*f",FLOAT_PRECISION,(double)x);}\ntemplate&lt;class T1,class T2&gt;void _P(const pair&lt;T1,T2&gt;&amp;x){_P(x.fi);pc(' ');_P(x.se);}\ntemplate&lt;class T&gt;void _P(const T&amp;a){a.out();}\n\ntemplate&lt;class T1,class T2&gt;bool S(T1&amp;a,T2&amp;b){return S(a)+S(b)==2;}\ntemplate&lt;class T1,class T2,class T3&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c){return S(a)+S(b)+S(c)==3;}\ntemplate&lt;class T1,class T2,class T3,class T4&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d){return S(a)+S(b)+S(c)+S(d)==4;}\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d,T5&amp;e){return S(a)+S(b)+S(c)+S(d)+S(e)==5;}\n\ntemplate&lt;class T1&gt;void P(const T1&amp;a){_P(a);pc(' ');}\ntemplate&lt;class T1,class T2&gt;void P(const T1&amp;a,const T2&amp;b){_P(a);pc(' ');_P(b);pc(' ');}\ntemplate&lt;class T1&gt;void PN(const T1&amp;a){_P(a);NL}\ntemplate&lt;class T1,class T2&gt;void PN(const T1&amp;a,const T2&amp;b){_P(a);pc(' ');_P(b);NL}\ntemplate&lt;class T1,class T2,class T3&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c){_P(a);pc(' ');_P(b);pc(' ');_P(c);NL}\ntemplate&lt;class T1,class T2,class T3,class T4&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c,const T4&amp;d){_P(a);pc(' ');_P(b);pc(' ');_P(c);pc(' ');_P(d);NL}\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c,const T4&amp;d,const T5&amp;e){_P(a);pc(' ');_P(b);pc(' ');_P(c);pc(' ');_P(d);pc(' ');_P(e);NL}\nvoid PS(int a){printf("%*s",a,"");}\n\ntemplate&lt;class T&gt;void SA(T*a,int n){FR(i,n)S(a[i]);}\ntemplate&lt;class T&gt;void PA(T*a,int n){FR(i,n){if(i)pc(' ');_P(a[i]);}NL}\ntemplate&lt;class T&gt;void PA(const T&amp;x){FE(it,x){if(it!=x.begin())pc(' ');_P(*it);}NL}\n\nint kase;\nconst double pi=4*atan(1.);\nconst double ep=1e-9;\nconst int INF=0x3f3f3f3f;\nconst ll INFL=0x3f3f3f3f3f3f3f3fll;\nconst ll MOD=1000000007;\n}\n\nint main() {\n    int n,m_sum,m[60],v[60],p[60],v_max[3200],link[60][3];\n    cin &gt;&gt; m_sum &gt;&gt; n;\n    m_sum/=10;\n    for (int i=1;i&lt;=n;i++) {\n        cin &gt;&gt; m[i] &gt;&gt; v[i] &gt;&gt; p[i];\n        m[i]/=10;\n        if (p[i]!=0) link[p[i]][++link[p[i]][0]]=i;\n    }\n    memset(v_max,0,sizeof(v_max));\n    for (int i=1;i&lt;=n;i++) for (int j=m_sum;j&gt;=1;j--) if (p[i]==0 &amp;&amp; j&gt;=m[i]) {\n        v_max[j]=max(v_max[j],v_max[j-m[i]]+m[i]*v[i]);\n        int a=link[i][1],b=link[i][2];\n        if (link[i][0]&gt;=1 &amp;&amp; j-m[i]&gt;=m[a]) v_max[j]=max(v_max[j],v_max[j-m[i]-m[a]]+m[i]*v[i]+m[a]*v[a]);\n        if (link[i][0]==2) {\n            if (j-m[i]&gt;=m[b]) v_max[j]=max(v_max[j],v_max[j-m[i]-m[b]]+m[i]*v[i]+m[b]*v[b]);\n            if (j-m[i]&gt;=m[a]+m[b]) v_max[j]=max(v_max[j],v_max[j-m[i]-m[a]-m[b]]+m[i]*v[i]+m[a]*v[a]+m[b]*v[b]);\n        }\n    }\n    cout &lt;&lt; v_max[m_sum]*10 &lt;&lt; endl;\n    return 0;\n}\n\n/*********Risoft corporation all rights reserved*********/\n/**************Template V2.33 build 20151012*************/\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\nclass Reader\n{\n\tstatic BufferedReader reader;\n\tstatic StringTokenizer tokenizer;\n\n\tstatic void init(InputStream input)\n\t{\n\t\treader=new BufferedReader(new InputStreamReader(input));\n\t\ttokenizer=new StringTokenizer("");\n\t}\n\n\tstatic String next() throws IOException\n\t{\n\t\twhile ( !tokenizer.hasMoreElements())\n\t\t{\n\t\t\ttokenizer=new StringTokenizer(reader.readLine());\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\n\tstatic int nextInt() throws IOException\n\t{\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tstatic double nextDouble() throws IOException\n\t{\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tstatic long nextLong() throws IOException\n\t{\n\t\treturn Long.parseLong(next());\n\t}\n\n\tstatic void close() throws IOException\n\t{\n\t\treader.close();\n\t}\n}\n\npublic class Main\n{\n\tpublic static void main(String[] args) throws IOException\n\t{\n\t\tReader.init(System.in);\n\t\tint n=Reader.nextInt()/10;\n\t\tint m=Reader.nextInt();\n\t\tGoods[] g=new Goods[m+1];\n\t\tint[][] dp=new int[m+1][n+1];\n\t\tfor (int i=1; i&lt;=m; i++)\n\t\t{\n\t\t\tg[i]=new Goods();\n\t\t}\n\t\tfor (int i=1; i&lt;=m; i++)\n\t\t{\n\t\t\tg[i].v=Reader.nextInt()/10;\n\t\t\tg[i].w=Reader.nextInt();\n\t\t\tint t=Reader.nextInt();\n\t\t\tif (t!=0)\n\t\t\t{\n\t\t\t\tg[t].appendix.add(i);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tg[i].isMain=true;\n\t\t\t}\n\t\t}\n\t\tReader.close();\n\t\tfor (int i=1; i&lt;=m; i++)\n\t\t{\n\t\t\tfor (int j=0; j&lt;=n; j++)\n\t\t\t{\n\t\t\t\tif (g[i].isMain)\n\t\t\t\t{\t// 当该物品为主件时\n\t\t\t\t\tdp[i][j]=Integer.MIN_VALUE;\n\t\t\t\t\tif (g[i].v&gt;j)\n\t\t\t\t\t{\t// 当该物品的价格大于当前的总钱数时\n\t\t\t\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\t// 当该物品的价格小于或等于当前的总钱数时\n\t\t\t\t\t\tdp[i][j]=Math.max(dp[i-1][j], dp[i-1][j-g[i].v]+g[i].v*g[i].w);\n\t\t\t\t\t\tint sonNum=g[i].appendix.size();// 该物品附件的个数\n\t\t\t\t\t\tif (sonNum&gt;=1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (j&gt;=(g[i].v+g[g[i].appendix.get(0)].v))\n\t\t\t\t\t\t\t{\t// 当该物品和其第一个附件的总价格小于或等于当前的总钱数时\n\t\t\t\t\t\t\t\tdp[i][j]=Math.max(dp[i][j],\n\t\t\t\t\t\t\t\t\t\tdp[i-1][j-g[i].v-g[g[i].appendix.get(0)].v]\n\t\t\t\t\t\t\t\t\t\t\t\t+g[i].v*g[i].w\n\t\t\t\t\t\t\t\t\t\t\t\t+g[g[i].appendix.get(0)].v*g[g[i].appendix.get(0)].w);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (sonNum==2)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (j&gt;=(g[i].v+g[g[i].appendix.get(1)].v))\n\t\t\t\t\t\t\t\t{\t// 当该物品和其第二个附件的总价格小于或等于当前的总钱数时\n\t\t\t\t\t\t\t\t\tdp[i][j]=Math.max(dp[i][j], \n\t\t\t\t\t\t\t\t\t\t\tdp[i-1][j-g[i].v-g[g[i].appendix.get(1)].v]\n\t\t\t\t\t\t\t\t\t\t\t+g[i].v*g[i].w\n\t\t\t\t\t\t\t\t\t\t\t+g[g[i].appendix.get(1)].v*g[g[i].appendix.get(1)].w);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (j&gt;=(g[i].v+g[g[i].appendix.get(0)].v+g[g[i].appendix.get(1)].v))\n\t\t\t\t\t\t\t\t{\t// 当该物品和其第一、二个附件的总价格小于或等于当前的总钱数时\n\t\t\t\t\t\t\t\t\tdp[i][j]=Math.max(dp[i][j], \n\t\t\t\t\t\t\t\t\t\t\tdp[i-1][j-g[i].v-g[g[i].appendix.get(0)].v-g[g[i].appendix.get(1)].v]\n\t\t\t\t\t\t\t\t\t\t\t+g[i].v*g[i].w\n\t\t\t\t\t\t\t\t\t\t\t+g[g[i].appendix.get(0)].v*g[g[i].appendix.get(0)].w\n\t\t\t\t\t\t\t\t\t\t\t+g[g[i].appendix.get(1)].v*g[g[i].appendix.get(1)].w);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(dp[m][n]*10);\n\t}\n}\n\nclass Goods\n{\n\tint v;\n\tint w;\n\tboolean isMain=false;\n\tArrayList&lt;Integer&gt; appendix=new ArrayList&lt;Integer&gt;();\n}\r\n</textarea>	317
306	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　现代诗如蚯蚓\n  <br> 　　断成好几截都不会死\n  <br> 　　字符串断成好几截\n  <br> 　　有可能完全一样\n  <br> 　　请编写程序\n  <br> 　　输入字符串\n  <br> 　　输出该字符串最多能断成多少截完全一样的子串\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　一行，一个字符串\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　一行，一个正整数表示该字符串最多能断成的截数\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  abcabcabcabc\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  4\n </div>\n <div class="pdsec">\n  样例说明\n </div>\n <div class="pdcont">\n  　　最多能断成四个”abc”，也就是abc重复四遍便是原串\n  <br> 　　同时也能断成两个”abcabc”\n  <br> 　　最坏情况是断成一个原串”abcabcabcabc”\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　字符串长度&lt;=1000\n </div> \n</div>	<textarea id="codelinesc">\r\n//内存占用优化\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\nchar str[1001]={0};\nint checkprime(int n)\n{\n    int i;\n    for (i=2;i&lt;=sqrt(n);i++)\n        if (n%i==0)return 0;\n    return 1;\n}\nint main()\n{\n    int i,len,sum,summax;\n    char *cmp1,*cmp2;\n    scanf("%s",str);\n    len=strlen(str);\n    if(len==1||checkprime(len)==1)\n    {\n        printf("1");\n        return 0;\n    }\n     for (i=2;i&lt;len/2;i++)\n     {\n         if (len%i!=0)\n            continue;\n        for(sum=1;sum&lt;len/i;sum++)\n            {\n                cmp1=(char*)malloc(i+1);\n                memset(cmp1,0,i+1);\n                cmp2=(char*)malloc(i+1);\n                memset(cmp2,0,i+1);\n                memcpy(cmp1,str,i);\n                memcpy(cmp2,str+sum*i,i);\n                if(strcmp(cmp1,cmp2)!=0)\n                    break;\n\n            }\n                free(cmp1);\n                free(cmp2);\n            if(sum==len/i)\n                break;\n     }\n     printf("%d",sum);\n     return 0;\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n/**************Powered by Graphene Richards**************/\nextern"C++"{\n#define FLOAT_PRECISION     2\n\n#ifdef _MSC_VER\n#define _SECURE_SCL 0\n#pragma comment(linker,"/STACK:102400000,102400000")\n#else\n#pragma GCC optimize("O3")\n#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx")\n#endif\n#if defined(_MSC_VER)||__cplusplus&gt;199711L\n#define IT(x) auto\n#define DIT(x) auto\n#else\n#define IT(x) __typeof((x).begin())\n#define DIT(x) __typeof((x).rbegin())\n#endif\n\n#  inc\\\nlude&lt;cmath&gt;\n#  inc\\\nlude&lt;cstdio&gt;\n#  inc\\\nlude&lt;cstdlib&gt;\n#  inc\\\nlude&lt;cstring&gt;\n#  inc\\\nlude&lt;algorithm&gt;\n#  inc\\\nlude&lt;bitset&gt;\n#  inc\\\nlude&lt;complex&gt;\n#  inc\\\nlude&lt;vector&gt;\n#  inc\\\nlude&lt;iomanip&gt;\n#  inc\\\nlude&lt;iostream&gt;\n#  inc\\\nlude&lt;list&gt;\n#  inc\\\nlude&lt;map&gt;\n#  inc\\\nlude&lt;queue&gt;\n#  inc\\\nlude&lt;set&gt;\n#  inc\\\nlude&lt;stack&gt;\n#  inc\\\nlude&lt;string&gt;\n#define FAST_RW ios_base::sync_with_stdio(0),cin.tie(0);\n#define FS(i,a) for(ll i=0;a[i];i++)\n#define FE(it,x) for(IT(x) it=(x).begin(),_en=(x).end();it!=_en;it++)\n#define EF(it,x) for(DIT(x) it=(x).rbegin(),_en=(x).rend();it!=_en;it++)\n#define FR(i,en) for(ll i=0,_en=(en);i&lt;_en;i++)\n#define FOR(i,en) for(ll i=1,_en=(en);i&lt;=_en;i++)\n#define RF(i,en) for(ll i=(en)-1;i&gt;=0;i--)\n#define ROF(i,en) for(ll i=(en);i&gt;0;i--)\n#define FFR(i,x,y) for(ll i=(x),_en=(y);i&lt;=_en;i++)\n#define RFF(i,x,y) for(ll i=(x),_en=(y);i&gt;=_en;i--)\n#define pc putchar\n#define pb push_back\n#define ppb pop_back\n#define pq priority_queue\n#define fi first\n#define se second\n#define mp make_pair\n#define pii pair&lt;int,int&gt;\n#define pll pair&lt;ll,ll&gt;\n#define sqr(x) ((x)*(x))\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define clr(x) memset((x),0,sizeof(x))\n#define ms(x,v) memset((x),(v),sizeof(x))\n#define mc(x,y) memcpy((x),(y),sizeof(y))\n#define NL puts("");\n#define LB lower_bound\n#define UB upper_bound\n#define rand() ((rand()&lt;&lt;16)^(rand()&lt;&lt;15)^(rand()))\n#ifdef _WIN32\n#define _i64_ "%I\\\n64d"\n#define _u64_ "%I\\\n64u"\n#else\n#define _i64_ "%l\\\nld"\n#define _u64_ "%l\\\nlu"\n#endif\ntypedef unsigned ui;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lf;\nusing namespace std;\n\null gcd(ull a,ull b){if(!b)return a;while(b^=a^=b^=a%=b);return a;}\n\nextern const ll MOD;\nll ksm(ll a,ll b){\nll res=1;a%=MOD;\nfor(;b;b&gt;&gt;=1){if(b&amp;1)res=res*a%MOD;a=a*a%MOD;}\nreturn res;\n}\n\n#ifdef wmx16835\n#include"wmx16835.h"\n#else\n#define LOG\n#define TEL\n#define test(...) 0\n#define TEST(...) 0\n#define TRY(...)\n#define SF(...)\n#define SC\n#define PF\n#define PC\n#define PP\n#define SHOW_TIME\n#define BR\n#endif\nint main(){SHOW_TIME int __MAIN();__MAIN();}\n#define main __MAIN\n#define y0 NKwKGuBI\n#define y1 KFJssmlK\n#define yn XypGISMR\n#define j1 kQDCYYWX\n#define tm BdKIQNcs\n#define lr UsCPcJvt\n\ntemplate&lt;class T1,class T2,class T3&gt;bool In(T1 x,T2 y,T3 z){return x&lt;=y&amp;&amp;x&gt;=z||x&lt;=z&amp;&amp;x&gt;=y;}\ntemplate&lt;class T1,class T2&gt;T1 max(const T1&amp;a,const T2&amp;b){return a&lt;b?b:a;}\ntemplate&lt;class T1,class T2,class T3&gt;T1 max3(const T1&amp;a,const T2&amp;b,const T3&amp;c){return a&lt;b?(b&lt;c?c:b):(a&lt;c?c:a);}\ntemplate&lt;class T1,class T2&gt;T1 min(const T1&amp;a,const T2&amp;b){return a&lt;b?a:b;}\ntemplate&lt;class T1,class T2,class T3&gt;T1 min3(const T1&amp;a,const T2&amp;b,const T3&amp;c){return a&lt;b?(a&lt;c?a:c):(b&lt;c?b:c);}\n\nbool S(char*a){return scanf("%s",a)==1;}\nbool S(int&amp;a){return scanf("%d",&amp;a)==1;}\nbool S(bool&amp;a){return scanf("%d",&amp;a)==1;}\nbool S(ui&amp;a){return scanf("%u",&amp;a)==1;}\nbool S(float&amp;a){return scanf("%f",&amp;a)==1;}\nbool S(double&amp;a){return scanf("%lf",&amp;a)==1;}\nbool S(ll&amp;a){return scanf(_i64_,&amp;a)==1;}\nbool S(ull&amp;a){return scanf(_u64_,&amp;a)==1;}\nbool S(lf&amp;a){double b;if(scanf("%lf",&amp;b)==-1)return 0;a=b;return 1;}\nbool S(char&amp;a){char b[2];if(scanf("%1s",b)==-1)return 0;a=*b;return 1;}\nbool SL(char*a){a[0]=0;while(gets(a)&amp;&amp;!a[0]);return a[0];}\ntemplate&lt;class T1,class T2&gt;bool S(pair&lt;T1,T2&gt;&amp;a){S(a.fi),S(a.se);}\ntemplate&lt;class T&gt;bool S(T&amp;a){a.in();}\n\nvoid _P(const int&amp;x){printf("%d",x);}\nvoid _P(const bool&amp;x){printf("%d",x);}\nvoid _P(const ui&amp;x){printf("%u",x);}\nvoid _P(const char&amp;x){printf("%c",x);}\nvoid _P(const char*x){printf("%s",x);}\nvoid _P(const string&amp;x){printf("%s",x.c_str());}\nvoid _P(const ll&amp;x){printf(_i64_,x);}\nvoid _P(const ull&amp;x){printf(_u64_,x);}\nvoid _P(const float&amp;x){printf("%.*f",FLOAT_PRECISION,x);}\nvoid _P(const double&amp;x){printf("%.*f",FLOAT_PRECISION,x);}\nvoid _P(const lf&amp;x){printf("%.*f",FLOAT_PRECISION,(double)x);}\ntemplate&lt;class T1,class T2&gt;void _P(const pair&lt;T1,T2&gt;&amp;x){_P(x.fi);pc(' ');_P(x.se);}\ntemplate&lt;class T&gt;void _P(const T&amp;a){a.out();}\n\ntemplate&lt;class T1,class T2&gt;bool S(T1&amp;a,T2&amp;b){return S(a)+S(b)==2;}\ntemplate&lt;class T1,class T2,class T3&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c){return S(a)+S(b)+S(c)==3;}\ntemplate&lt;class T1,class T2,class T3,class T4&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d){return S(a)+S(b)+S(c)+S(d)==4;}\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d,T5&amp;e){return S(a)+S(b)+S(c)+S(d)+S(e)==5;}\n\ntemplate&lt;class T1&gt;void P(const T1&amp;a){_P(a);pc(' ');}\ntemplate&lt;class T1,class T2&gt;void P(const T1&amp;a,const T2&amp;b){_P(a);pc(' ');_P(b);pc(' ');}\ntemplate&lt;class T1&gt;void PN(const T1&amp;a){_P(a);NL}\ntemplate&lt;class T1,class T2&gt;void PN(const T1&amp;a,const T2&amp;b){_P(a);pc(' ');_P(b);NL}\ntemplate&lt;class T1,class T2,class T3&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c){_P(a);pc(' ');_P(b);pc(' ');_P(c);NL}\ntemplate&lt;class T1,class T2,class T3,class T4&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c,const T4&amp;d){_P(a);pc(' ');_P(b);pc(' ');_P(c);pc(' ');_P(d);NL}\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c,const T4&amp;d,const T5&amp;e){_P(a);pc(' ');_P(b);pc(' ');_P(c);pc(' ');_P(d);pc(' ');_P(e);NL}\nvoid PS(int a){printf("%*s",a,"");}\n\ntemplate&lt;class T&gt;void SA(T*a,int n){FR(i,n)S(a[i]);}\ntemplate&lt;class T&gt;void PA(T*a,int n){FR(i,n){if(i)pc(' ');_P(a[i]);}NL}\ntemplate&lt;class T&gt;void PA(const T&amp;x){FE(it,x){if(it!=x.begin())pc(' ');_P(*it);}NL}\n\nint kase;\nconst double pi=4*atan(1.);\nconst double ep=1e-9;\nconst int INF=0x3f3f3f3f;\nconst ll INFL=0x3f3f3f3f3f3f3f3fll;\nconst ll MOD=1000000007;\n}\n\nchar a[1005];\nint n;\n\nbool OK(int x) {\n\tif (n % x) return 0;\n\tFR(i, x) {\n\t\tfor (int j = x + i; j &lt; n; j += x) {\n\t\t\tif (a[i] != a[j]) return 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nint solve() {\n\tn = strlen(a);\n\tFOR(i, 1 &lt;&lt; 30) {\n\t\tif (OK(i)) return n / i;\n\t}\n}\n\nint main() {\n\tS(a);\n\tPN(solve());\n}\n\n/*********Risoft corporation all rights reserved*********/\n/**************Template V2.33 build 20151012*************/\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString s = sc.next();\n\t\tfor (int i = 1; i &lt; s.length(); i++) {\n\t\t\tif (s.length() % i == 0) {\n\t\t\t\tif (s.charAt(0) == s.charAt(i)) {\n\t\t\t\t\tboolean b = true;\n\t\t\t\t\tfor (int j = 0; j &lt; s.length() - i; j++) {\n\t\t\t\t\t\tif (s.charAt(j) != s.charAt(i + j)) {\n\t\t\t\t\t\t\tb = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (b) {\n\t\t\t\t\t\tSystem.out.println(s.length() / i);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\r\n</textarea>	308
307	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　L正在出题，新建了一个word文档，想不好取什么名字，身旁一人惊问：“你出的题目叫《新建Microsoft Word文档》吗？”，L大喜，一拍桌子，说：“好，就叫这个名字了。”\n  <br> 　　仔细观察，当你新建一个word文档时，会得到一个名为“新建 Microsoft Word 文档.doc”的文件，再新建一个，则名为“新建 Microsoft Word 文档(2).doc”，再新建，便是“新建 Microsoft Word 文档(3).doc”。不断新建，编号不断递增。倘若你现在新建了三个文档，然后删除了“新建 Microsoft Word 文档(2).doc”，再新建就又会得到一个“新建 Microsoft Word 文档(2).doc”。\n  <br> \n  <br> 　　严格说，Windows在每次新建文档时，都会选取一个与已有文件编号不重复的最小正整数作为新文档的编号。\n  <br> \n  <br> 　　请编程模拟以上过程，支持以下两种操作\n  <br> 　　New：新建一个word文档，反馈新建的文档的编号\n  <br> 　　Delete id：删除一个编号为id的word文档，反馈删除是否成功\n  <br> 　　初始时一个文件都没有，“新建 Microsoft Word 文档.doc”的编号算作1。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行一个正整数n表示操作次数，接下来n行，每行表示一个操作。若该行为”New”，则表示新建，为”Delete id”则表示要删除编号为id的文档，其中id为一个正整数。操作按输入顺序依次进行。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　对于输入的每一行，输出其反馈结果。对于新建操作，输出新建的文档的编号；对于删除操作，反馈删除是否成功：如果删除的文件存在，则删除成功，输出”Successful”，否则输出”Failed”。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  12\n  <br> New\n  <br> New\n  <br> New\n  <br> Delete 2\n  <br> New\n  <br> Delete 4\n  <br> Delete 3\n  <br> Delete 1\n  <br> New\n  <br> New\n  <br> New\n  <br> Delete 4\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  1\n  <br> 2\n  <br> 3\n  <br> Successful\n  <br> 2\n  <br> Failed\n  <br> Successful\n  <br> Successful\n  <br> 1\n  <br> 3\n  <br> 4\n  <br> Successful\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　操作次数（即输入的行数）不超过1481\n  <br> 　　删除编号的数值不超过2012\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n\nvoid main()\n{\n\tint a[1482]={0};\n\tint b[1482]={0};\n\tchar str[10];\n\tchar *p;\n\tchar (*in)[10];\n\tchar (*ip)[10];\n\tint i=0;\n\tint n;\n\tint n1;\n\tscanf("%d",&amp;n);\n\tn1=n;\n\t\n\tin=(char *)malloc(sizeof(char)*10*n);\n\tip=in;\n\t\n\tscanf("%s",in);\n\twhile(--n)//\n\t{\n\n\t\tif(in[0][0]=='N')\n\t\t{\n\t\t\tin++;\n\t\t\tscanf("%s",in);\n\t\t\t\tif(in[0][0]!='N'&amp;&amp;1==n)\n\t\t\t\tscanf("%d",&amp;b[i++]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tin++;\n\t\t\tscanf("%d",&amp;b[i++]);\n\t\t\t\n\t\t\tif(n==1)\n\t\t\t{\n\t\t\t\tscanf("%s",in);\n\t\t\t\tif(in[0][0]!='N')\n\t\t\t\tscanf("%d",&amp;b[i++]);\n\t\t\t}else if(n!=1)scanf("%s",in);\n\t\t}\n\t\t \n\t\t\n\t\n\t}\n\t\n\tin=ip;\n\tn=n1;\n\ti=0;\n\t/*\n\twhile(i&lt;n)\n\t{\n\t\n\tprintf("%d\\n",b[i++]);\n}\n*/\n\t\n\twhile(n--)\n\t{\n\t\tif(in[0][0]=='N')\n\t\t{\n\t\t\tint t=1;\n\t\t\twhile(a[t]!=0)\n\t\t\t{\n\t\t\t\tt++;\n\t\t\t}\n\t\t\ta[t]=1;\n\t\t\tprintf("%d\\n",t);\n\t\t\tin++;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tif(b[i]&gt;1482||a[b[i]]==0)\n\t\t\t{\n\t\t\t\t\tprintf("Failed\\n");\n\t\t\t\t\tin++;\n\t\t\t\t\ti++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta[b[i]]=0;\n\t\t\t\ti++;\n\t\t\t\tprintf("Successful\\n");\n\t\t\t\tin++;\n\t\t\t} \n\t\t}\n\t}\n\n\t\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;cmath&gt;\nusing namespace std;\n#define SIZE 1481\nint main(){\n\tint arr[SIZE] = { 0 };\n\tint table[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n\tint n;\n\tcin &gt;&gt; n;\n\tcin.clear();\n\tcin.get();\n\tint length;\n\tint temp;\n\tstring str;\n\tstring cmd[SIZE];\n\tfor (int i = 0; i &lt; n; i++){\n\t\tgetline(cin, cmd[i]);\n\t}\n\tfor (int i = 0; i &lt; n; i++){\n\t\tstr = cmd[i];\n\t\tif (str == "New"){\n\t\t\tfor (int j = 0; j &lt; SIZE; j++){\n\t\t\t\tif (arr[j] == 0){\n\t\t\t\t\tarr[j] = j + 1;\n\t\t\t\t\tcout &lt;&lt; j + 1 &lt;&lt; endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tlength = str.length();\n\t\t\ttemp = 0;\n\t\t\tfor (int i = 7; i &lt; length; i++){\n\t\t\t\ttemp = temp + table[str[i] - 48] * pow(10, length - 1 - i);\n\t\t\t}\n\t\t\tif (arr[temp - 1] == 0){\n\t\t\t\tcout &lt;&lt; "Failed" &lt;&lt; endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tarr[temp - 1] = 0;\n\t\t\t\tcout &lt;&lt; "Successful" &lt;&lt; endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tBufferedReader buf=new BufferedReader(new InputStreamReader(System.in));\n\t\tint n=Integer.parseInt(buf.readLine());\n\t\tint[] arr=new int[n+1];\n\t\tStringBuilder strb=new StringBuilder();\n\t\tfor(int i=0;i&lt;n;i++){\n\t\t\tString str=buf.readLine();\n\t\t\tif(str.equals("New")){\n\t\t\t\tfor(int j=1;j&lt;=n;j++){\n\t\t\t\t\tif(arr[j]==0){\n\t\t\t\t\t\tarr[j]=1;\n\t\t\t\t\t\tstrb.append(j).append("\\r\\n");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tstr=str.substring(str.indexOf(" ")+1);\n\t\t\t\tint t=Integer.parseInt(str);\n\t\t\t\tif(arr[t]==1){\n\t\t\t\t\tarr[t]=0;\n\t\t\t\t\tstrb.append("Successful");\n\t\t\t\t}else{\n\t\t\t\t\tstrb.append("Failed");\n\t\t\t\t}\n\t\t\t\tstrb.append("\\r\\n");\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(strb);\n\t}\n\n}\n\r\n</textarea>	309
308	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　Given two integers \n  <i>A</i> and \n  <i>B</i>, your task is to output their sum, \n  <i>A</i>+\n  <i>B</i>.\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　The input contains of only one line, consisting of two integers \n  <i>A</i> and \n  <i>B</i>. (0 ≤ A,B ≤ 1 000)\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　The output should contain only one number that is \n  <i>A</i>+\n  <i>B</i>.\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  1 1\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  2\n </div> \n</div>	<textarea id="codelinesc">\r\n#include"stdio.h"\nint main()\n{\n\tint a,b;\n\tscanf("%d%d",&amp;a,&amp;b);\n\tprintf("%d",a+b);\n\treturn 0;\n} \n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\nint main(){\n\tint a,b;\n\tcin&gt;&gt;a&gt;&gt;b;\n\tcout&lt;&lt;a+b&lt;&lt;endl;\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\npublic class Main{\n\n\tpublic static void main(String[] args) throws Exception{\nBufferedReader reader=new BufferedReader(new InputStreamReader(System.in));\n\t\tString string =null;\n\t\tstring=reader.readLine();\n\t\tString string2[]=string.split(" ");\n\t\tint a=Integer.parseInt(string2[0]);\n\t\tint b=Integer.parseInt(string2[1]);\n                reader.close();\n\t\tSystem.out.println(a+b);\n\t\t\n\t\t\n\t}\n\n}\n\r\n</textarea>	310
309	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　在C/C++语言中，整型所能表示的范围一般为-2\n  <sup>31</sup>到2\n  <sup>31</sup>（大约21亿）,即使long long型，一般也只能表示到-2\n  <sup>63</sup>到2\n  <sup>63</sup>。要想计算更加规模的数，就要用软件来扩展了，比如用数组或字符串来模拟更多规模的数及共运算。\n  <br> 　　现在输入两个整数，请输出它们的乘积。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　两行，每行一个正整数，每个整数不超过10000位\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　一行，两个整数的乘积。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  99\n  <br> 101\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  9999\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　每个整数不超过10000位\n </div> \n</div>	<textarea id="codelinesc">\r\n/*\n高精度乘法:\n输入：两行，每行表示一个非负整数（不超过10000位）\n输出：两数的乘积。\n*/\n\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdlib.h&gt;\n\n#define MAX 10001\n\nint high_precision(int *sum,int *a,int *b,int a_len,int b_len)\n{\n    int i,j;\n    memset(sum,0,sizeof(sum));\n    int sum_len = 0 ;\n    for(i=1;i&lt;=a_len;i++) /*用数组模拟运算*/\n        for(j=1,sum_len=i-1;j&lt;=b_len;j++)\n            sum[++sum_len] += b[j]*a[i];\n    for(i=1;i&lt;=sum_len;i++)/*进位处理*/\n        if(sum[i] &gt;= 10)\n        {\n            if(sum[sum_len] &gt;= 10)\n                sum_len++;\n            sum[i+1] += sum[i]/10;\n            sum[i] %= 10;\n        }\n\n    return sum_len;\n}\n\nvoid multiply(char* a, char* b, char* c)\n{\n    int i, j, ca, cb, * s;\n    ca = strlen(a);\n    cb = strlen(b);\n    s = (int*)malloc(sizeof(int) * (ca + cb));\n    for (i = 0; i &lt; ca + cb; i++)\n        s[i] = 0;\n    for (i = 0; i &lt; ca; i++)\n        for (j = 0; j &lt; cb; j++)\n            s[i+j+1] += (a[i] - '0') * (b[j] - '0');\n    for (i = ca + cb - 1; i &gt;= 0; i--)\n        if (s[i] &gt;= 10)\n        {\n            s[i-1] += s[i] / 10;\n            s[i] %= 10;\n        }\n    i = 0;\n    while (s[i] == 0)\n        i++;\n    for (j = 0; i &lt; ca + cb; i++, j++)\n        c[j] = s[i] + '0';\n    c[j] = '\\0';\n    free(s);\n}\n\nint main()\n{\n    int a[MAX]= {0},b[MAX]= {0},sum[MAX*2]= {0};\n    int a_len=0,b_len=0,sum_len=0;\n    int i,j;\n    char c_a[MAX],c_b[MAX],c_sum[MAX*2];\n\n    scanf("%s%s",c_a,c_b);\n\n    a_len = strlen(c_a);\n    b_len = strlen(c_b);\n\n    for(i=1,j=a_len-1;i&lt;= a_len;i++,j--)\n        a[i] = c_a[j] - '0';\n    for(i=1,j=b_len-1;i&lt;= b_len;i++,j--)\n        b[i] = c_b[j] - '0';\n\n    sum_len = high_precision(sum,a,b,a_len,b_len) ;\n\n    for(i=sum_len;i&gt;=1;i--)\n        printf("%d",sum[i]);\n    putchar('\\n');\n    //multiply(c_a,c_b,c_sum);\n    //printf("%s\\n",c_sum);\n    system("pause");\n    return 0 ;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\ntypedef long long ll;\nclass BigInteger {\n\tstatic const int BASE = 100000000;\n\tstatic const int WIDTH = 8;\n\tvector&lt;ll&gt; s;\n\npublic:\n\tvoid printVect() {\n\t\tfor (vector&lt;ll&gt;::iterator it = s.begin(); it != s.end(); it++) {\n\t\t\tcout &lt;&lt; *it &lt;&lt; " ";\n\t\t}\n\t\tcout &lt;&lt; endl;\n\t}\n\tBigInteger(long long num = 0) { *this = num; }\n\tBigInteger operator = (long long num) {\n\t\ts.clear();\n\t\tdo {\n\t\t\ts.push_back(num % BASE);\n\t\t\tnum /= BASE;\n\t\t} while (num &gt; 0);\n\t\treturn *this;\n\t}\n\n\tBigInteger operator = (const string &amp; str) {\n\t\ts.clear();\n\t\tint x, len = (str.length() - 1) / WIDTH + 1;\n\t\tfor (int i = 0; i &lt; len; i++) {\n\t\t\tint nd = str.length() - i*WIDTH;\n\t\t\tint strt = max(0, nd-WIDTH);\n\t\t\tsscanf(str.substr(strt, nd-strt).c_str(), "%d", &amp;x);\n\t\t\ts.push_back(x);\n\t\t}\n\t\treturn *this;\n\t}\n\n\tvoid clean() {\n\t\twhile(s.size() &gt; 1 &amp;&amp; !s[s.size()-1]) s.pop_back();\n\t}\n\n\n\tfriend ostream&amp; operator &lt;&lt; (ostream &amp;out, const BigInteger&amp; x) {\n\t\tout &lt;&lt; x.s.back();\n\t\tfor (int i = x.s.size()-2; i &gt;= 0; i--) {\n\t\t\tchar buf[20];\n\t\t\tsprintf(buf, "%08d", x.s[i]);\n\t\t\tfor (unsigned int j = 0; j &lt; strlen(buf); j++) out &lt;&lt; buf[j];\n\t\t}\n\t\treturn out;\n\t}\n\n\tfriend  istream &amp; operator &gt;&gt; (istream &amp; in, BigInteger &amp; x) {\n\t\tstring s;\n\t\tif (! (in&gt;&gt;s) ) return in;\n\t\tx = s;\n\t\treturn in;\n\t}\n\n\tBigInteger operator + (const BigInteger &amp; b) {\n\t\tBigInteger c;\n\t\tc.s.clear();\n\t\tfor (int i = 0, g = 0; ; i++) {\n\t\t\tif (g == 0 &amp;&amp; i &gt;= s.size() &amp;&amp; i &gt;= b.s.size()) break;\n\t\t\tlong long x = g;\n\t\t\tif (i &lt; s.size()) x += s[i];\n\t\t\tif (i &lt; b.s.size()) x += b.s[i];\n\t\t\tc.s.push_back(x % BASE);\n\t\t\tg = x / BASE;\n\t\t}\n\t\treturn c;\n\t}\n\n\tBigInteger operator * (const BigInteger &amp; b) {\n\t\tBigInteger c;\n\t\tc.s.clear();\n\t\tc.s.resize(s.size() + b.s.size(), 0);\n\n\t\tfor (unsigned int i = 0; i &lt;= s.size()-1; i++) {\n\t\t\tfor (unsigned int j = 0; j &lt;= b.s.size()-1; j++) {\n\t\t\t\tc.s[j+i] += s[i] * b.s[j];\n\t\t\t}\n\t\t}\n\n\t\tfor(int k = 0; k &lt; c.s.size(); k++){\n\t\t  c.s[k+1] += c.s[k] / BASE;\n\t\t  c.s[k] %= BASE;\n\t\t}\n\n\t\tc.clean();\n\n\t\treturn c;\n\t}\n\n};\nstring a,b;\n\nint main() {\n\n//\tfreopen("input4.txt", "r", stdin);\n//\tfreopen("input4.out", "w+", stdout);\n\twhile (cin &gt;&gt; a &gt;&gt; b) {\n\t\tBigInteger bigA,bigB, bigc;\n\t\tbigA = a; bigB = b;\n\t\tbigc = bigA * bigB;\n\t\tcout &lt;&lt; bigc &lt;&lt; endl;\n\t}\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.math.BigInteger;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tBigInteger bi = new BigInteger(sc.next());\n\t\tBigInteger bi2 = new BigInteger(sc.next());\n\t\tSystem.out.println(bi.multiply(bi2));\n\n\t}\n\n}\n\r\n</textarea>	311
316	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　大家都知道"超级玛丽"是一个很善于跳跃的探险家，他的拿手好戏是跳跃，但它一次只能向前跳一步或两步。有一次，他要经过一条长为n的羊肠小道，小道中有m个陷阱，这些陷阱都位于整数位置，分别是a\n  <sub>1</sub>,a\n  <sub>2</sub>,....a\n  <sub>m</sub>，陷入其中则必死无疑。显然，如果有两个挨着的陷阱，则玛丽是无论如何也跳过不去的。\n  <br> 　　现在给出小道的长度n，陷阱的个数及位置。求出玛丽从位置1开始，有多少种跳跃方法能到达胜利的彼岸（到达位置n）。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行为两个整数n,m\n  <br> 　　第二行为m个整数，表示陷阱的位置\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　一个整数。表示玛丽跳到n的方案数\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  4 1\n  <br> 2\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  1\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　40&gt;=n&gt;=3,m&gt;=1\n  <br> 　　n&gt;m;\n  <br> 　　陷阱不会位于1及n上\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n\nint main(void)\n{\n\tint n, m;\n\tint r[105] = {0};\n\tint can[105] = {0};\n\tint i, k;\n\t\n\tscanf("%d%d", &amp;n, &amp;m);\n\tfor (i=0; i&lt;m; ++i)\n\t{\n\t\tscanf("%d", &amp;k);\n\t\tcan[k] = 1;\n\t}\n\n\tr[1] = 1;\n\tfor (i=2; i&lt;=n; ++i)\n\t{\n\t\tif (can[i]==0)\n\t\t{\n\t\t\tr[i] = r[i-1]+r[i-2];\n\t\t}\n\t}\n\tprintf("%d\\n", r[n]);\n\t\n    return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nint n,m;\nint a[50];\nint b[50];\nint ans=0;\nvoid dfs(int x)\n{\n\tif (x&gt;n) return;\n\tif (x==n)\n\t{\n\t\tans++;\n\t\treturn;\n\t}\n\tif (!b[x+1]) dfs(x+1);\n\tif (!b[x+2]) dfs(x+2);\n}\nint main()\n{\n\tint i,j,k;\n\tscanf("%d%d",&amp;n,&amp;m);\n\tmemset(b,0,sizeof(b));\n\tfor (i=0;i&lt;m;i++)\n\t{\n\t\tscanf("%d",&amp;a[i]);\n\t\tb[a[i]]=1;\n\t}\n\tsort(a,a+m);\n\tfor (i=0;i&lt;m-1;i++)\n\t{\n\t\tif (a[i]+1==a[i+1])\n\t\t{\n\t\t\tprintf("0");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tdfs(1);\n\tprintf("%d",ans);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main{\n\n\tstatic int n;\n\tstatic int num=0;\n\tstatic void recurse(int cur,int a[]){\n\t\tif(cur==n){\n\t\t\tnum++;\n\t\t\treturn;\n\t\t}\n\t\tif(cur+1&lt;=n&amp;&amp;a[cur+1]==0)\n\t\t\trecurse(cur+1,a);\n\t\tif(cur+2&lt;=n&amp;&amp;a[cur+2]==0)\n\t\t\trecurse(cur+2,a);\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner in=new Scanner(System.in);\n\t\tn=in.nextInt();\n\t\tint m=in.nextInt();\n\t\tint a[]=new int[n+1];\n\t\tfor(int i=0;i&lt;m;i++){\n\t\t\tint t=in.nextInt();\n\t\t\tif(t&lt;n)\n\t\t\t\ta[t]=1;\n\t\t}\n\t\trecurse(1,a);\n\t\tSystem.out.println(num);\n\n\t}\n\n}\r\n</textarea>	318
310	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　（图３.１－１）示出了一个数字三角形。 请编一个程序计算从顶至底的某处的一条路\n  <br> 　　径，使该路径所经过的数字的总和最大。\n  <br> 　　●每一步可沿左斜线向下或右斜线向下走；\n  <br> 　　●1＜三角形行数≤100；\n  <br> 　　●三角形中的数字为整数0，1，…99；\n  <br> \n  <br> \n  <br> 　　\n  <img src="/RequireFile.do?fid=9RdAy6Be" width="113" height="123">.\n  <br> 　　（图３.１－１）\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　文件中首先读到的是三角形的行数。\n  <br> \n  <br> 　　接下来描述整个三角形\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　最大总和（整数）\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5\n  <br> 7\n  <br> 3 8\n  <br> 8 1 0\n  <br> 2 7 4 4\n  <br> 4 5 2 6 5\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  30\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint n,a[100][100];\nint sum();\nint main(){\nint i,num,j;\nscanf("%d",&amp;n);\nfor(i=0;i&lt;n;i++)\n{\n    for(j=0;j&lt;=i;j++)\n    {\n        scanf("%d",&amp;num);\n        a[i][j]=num;\n    }\n}\n\n\nprintf("%d",sum());\n\n\n\nreturn 0;\n}\n/*\nint sum(int i,int j)\n{\n    if(i==n)\n    {\n        return a[i][j];\n    }\n\n    if(sum(i+1,j)&gt;sum(i+1,j+1))\n    {\n        return sum(i+1,j)+a[i][j];\n    }else\n    {\n      return sum(i+1,j+1)+a[i][j];\n    }\n}\n*/\nint sum()\n{\n    int i,j;\n    for(i=n-1;i&gt;0;i--)\n    {\n        for(j=0;j&lt;i;j++)\n        {\n            if(a[i][j]&gt;a[i][j+1])\n            {\n                a[i-1][j]+=a[i][j];\n            }\n            else\n            {\n                a[i-1][j]+=a[i][j+1];\n            }\n        }\n    }\n    return a[0][0];\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;vector&gt;\nusing namespace std;\nint main(){\n\tint n;\n\tcin &gt;&gt; n;\n\tvector&lt;vector&lt;int&gt; &gt;a(n + 1, vector&lt;int&gt;(n + 1));\n\tfor (int i = 1; i &lt;= n; i++){\n\t\tfor (int j = 1; j &lt;= i; j++){\n\t\t\tcin &gt;&gt; a[i][j];\n\t\t}\n\t}\n\tfor (int i = 1; i &lt;= n; i++){\n\t\tfor (int j = 1; j &lt;= i; j++){\n\t\t\ta[i][j] = max(a[i - 1][j - 1], a[i - 1][j]) + a[i][j];\n\t\t}\n\t}\n\tint max = a[n][1];\n\tfor (int i = 2; i &lt;= n; i++){\n\t\tif (a[n][i] &gt; max) max = a[n][i];\n\t}\n\tcout &lt;&lt; max &lt;&lt; endl;\n\n\tsystem("pause");\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tBufferedReader br=new BufferedReader(\n\t\t\t\tnew InputStreamReader(System.in));\n\t\tint n=Integer.parseInt(br.readLine().trim()),i,j;\n\t\tint[][] arr=new int[n][n];\n\t\tarr[0][0]=Integer.parseInt(br.readLine().trim());\n\t\tfor(i=1;i&lt;n;i++){\n\t\t\tString[] str=br.readLine().trim().split(" ");\n\t\t\tfor(j=0;j&lt;=i;j++){\n\t\t\t\tarr[i][j]=Integer.parseInt(str[j]);\n\t\t\t}\n\t\t}\n\t\tfor(i=n-2;i&gt;=0;i--){\n\t\t\tfor(j=0;j&lt;=i;j++){\n\t\t\t\tif(arr[i+1][j]&gt;arr[i+1][j+1]) arr[i][j]+=arr[i+1][j];\n\t\t\t\telse arr[i][j]+=arr[i+1][j+1];\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(arr[0][0]);\n\t}\n\n}\r\n</textarea>	312
311	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　设 \n  <i>F</i>(\n  <i>N</i>) 表示正整数 1 到正整数 \n  <i>N</i> 中,数字 1,2 总共出现了多少次。例如 \n  <i>N</i> = 10 时:1, 2, 3, 4, 5, 6, 7, 8, 9, 10 这 10 个数中,数字 1 出现了两次,数字 2 出现了 1 次,所以数字 1, 2 总共出现了 3 次,因此 \n  <i>F</i> (10) = 3。\n  <br> 　　现在给你正整数 \n  <i>N</i> ,请你求出 \n  <i>F</i>(\n  <i>N</i>) 的值。由于 \n  <i>F</i>(\n  <i>N</i>) 可能很大,你仅需输出 \n  <i>F</i>(\n  <i>N</i>) 除以 20123 的余数。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入数据仅一行,包含一个正整数 \n  <i>N</i> (1 ≤ \n  <i>N</i> ≤ 10\n  <sup>100</sup> ),表示函数 \n  <i>F</i>(\n  <i>N</i>)的参数。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出仅一个整数,为 \n  <i>F</i>(\n  <i>N</i>) 除以 20123 的余数。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  10\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  3\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n\nconst int mod = 20123;\nint power[105];\n\nint stonum(int s[], int len)\n{\n\tint re = 0, i;\n\tfor (i=0; i&lt;len; ++i)\n\t{\n\t\tre += s[i] * power[i];\n\t}\n\treturn re%mod;\n}\n\nint main(void)\n{\n\tchar s[105];\n\tint re;\n\tint n[105];\n\tint len;\n\tint i;\n\t\n\tscanf("%s", s);\n\tlen = strlen(s);\n\tfor (i=0; i&lt;len; ++i)\n\t{\n\t\tn[i] = s[len-1-i]-'0';\n\t}\n\tpower[0] = 1;\n\tfor (i=1; i&lt;len; ++i)\n\t{\n\t\tpower[i] = power[i-1]*10;\n\t\tpower[i] %= mod;\n\t}\n\n// 1234:\n// 千位：235\n// 百位：1*200+135\n// 十位：12*20+20\n// 个位：123*2+2\n\tre = 0;\n\tfor (i=0; i&lt;len; ++i)\n\t{\n\t\tre += stonum(n+i+1, len-1-i)*power[i]*2;\n\t\tif (n[i]&gt;2)\n\t\t{\n\t\t\tre += 2*power[i];\n\t\t}\n\t\telse if (n[i]&gt;0)\n\t\t{\n\t\t\tre += stonum(n, i+1) - power[i] + 1 + mod;\n\t\t}\n\t\tre %= mod;\n\t}\n\tprintf("%d\\n", re);\n\n    return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;string.h&gt;\nusing namespace std;\nint main()\n{ int i,t=1,l,j;\n  int ten[1000],z[1000],a[1000];\n  int sum=0;\n  char s[1000];\n  gets(s);\n  ten[0]=1; z[1]=1; \n for (i=1;i&lt;=100;i++) ten[i]=ten[i-1]*10%20123;\n for (i=2;i&lt;=100;i++)\n z[i]=(z[i-1]+(ten[i-1]+9*ten[i-2]*(i-1))%20123)%20123;\n l=strlen(s);  a[l]=0;\n for (i=l-1;i&gt;=0;i--)\n  a[i]=((s[i]-48)*ten[l-i-1]+a[i+1])%20123;\n for (i=0;i&lt;l;i++)\n  {\n  \tfor (j=0;j&lt;s[i]-48;j++)\n  \t{\n  \t  sum=(sum+z[l-i-1]*2)%20123;\n  \t  if (j==1||j==2) sum=(sum+ten[l-i-1])%20123;\n  \t}\n  \tif (s[i]=='1'||s[i]=='2') sum=(sum+a[i+1]+1)%20123; \n  }\n  cout&lt;&lt;sum&lt;&lt;endl;\n    return 0;\n}\n\n\n\n\r\n</textarea>	<textarea id="codelinesjava">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	313
312	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　你获得了一个据说是古代玛雅人制作的箱子。你非常想打开箱子看看里面有什么东西,但是不幸的是,正如所有故事里一样,神秘的箱子出现的时候总是会挂着神秘的锁。\n  <br> 　　这个锁上面看起来有 \n  <i>N</i> 个数字,它们排成一排,并且每个数字都在 0 到 2 之间。你发现你可以通过锁上的机关来交换\n  <b>相邻</b>两个数字的顺序。比如,如果原来有 5 个数字 02120,在一次交换以后你就可以得到 20120,01220,02210 或者 02102。\n  <br> 　　根据你所搜集的情报,这个锁在上面存在某连续四个数字是“2012”的时候会自动打开。现在,你需要计算一下,你至少需要进行多少次交换操作才能打开这把锁?\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入数据的第一行有一个正整数 \n  <i>N</i>。(4 ≤ \n  <i>N</i> ≤ 13) 输入数据的第二行有 \n  <i>N</i> 个数字 \n  <i>a</i>\n  <sub>1</sub>,\n  <i>a</i>\n  <sub>2</sub>, ..., \n  <i>a</i>\n  <sub><i>N</i></sub> ,其中 \n  <i>a<sub>i</sub></i> 表示这个锁上面第 i 个数字的值,满足 0 ≤ \n  <i>a<sub>i</sub></i> ≤ 2。这些数字之间没有空格分隔。\n  <br> \n  <i><i><i><i> </i></i></i></i>\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　你只需要输出一个数字,即你至少需要的交换次数。如果无论如何都没有希望打开这把锁,输出 -1。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5\n  <br> 02120\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  1\n </div>\n <div class="pdsec">\n  对样例的解释\n </div>\n <div class="pdcont">\n  　　把前两个数字交换以后,锁上的数字是 20120,其中存在连续四个数字2, 0, 1, 2,因此锁会打开。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\nint flag[4]={0};\nint num[15];\nint wai=0;\nint nei=0;\nint min=1000;\nvoid g()\n{\n\tint cnt=0;\n\tint i,j,k;\n\tint f2[3];\n\tint f3[2];\n\tfor(i=0;i&lt;4;i++)\n\tif(flag[i]==2)break;\n\tcnt+=i;\n\tk=0;\n\tfor(j=0;j&lt;4;j++)\n\tif(i!=j)f2[k++]=flag[j];\n\tfor(i=0;i&lt;3;i++)\n\tif(f2[i]==0)break;\n\tcnt+=i;\n\tk=0;\n\tfor(j=0;j&lt;3;j++)\n\tif(i!=j)f3[k++]=f2[j];\n\tif(f3[0]&gt;f3[1])cnt++;\n\tcnt=cnt+nei+wai;\n\tif(cnt&lt;min)min=cnt;\n}\nvoid f(int left,int right)\n{\n\tint l;\n\tint r;\n\tint w=flag[0]+flag[3];\n\tint n=5-w;\n\t\n\tfor(l=left;l&lt;=right-1;l++)\n\tfor(r=l+1;r&lt;=right;r++)\n\tif(num[l]+num[r]==n&amp;&amp;((num[l]==num[r]&amp;&amp;num[l]==2)||num[l]!=num[r]))\n\t{\n\t\tflag[1]=num[l];\n\t\tflag[2]=num[r];\n\t\tnei=r-l-1;\n\t\tg();\n\t}\n}\nint main()\n{\n\tint len=0;\n\tchar s[15];\n\tint i,j;\n\tint left,right;\n\tscanf("%d\\n%s",&amp;len,s);\n\tfor(i=0;i&lt;len;i++)\n\t\tnum[i]=s[i]-'0';\n\tfor(left=0;left&lt;len-3;left++)\n\t{\n\t\tfor(right=left+3;right&lt;len;right++)\n\t\t{\n\t\t\tif((num[left]==num[right]&amp;&amp;num[left]==2)||num[left]!=num[right])\n\t\t\t{\n\t\t\t\tflag[0]=num[left];\n\t\t\t\tflag[3]=num[right];\n\t\t\t\twai=right-left-3;\n\t\t\t\tf(left+1,right-1);\n\t\t\t}\n\t\t}\n\t}\n\tif(min==1000)printf("-1\\n");\n\telse printf("%d\\n",min);\n\treturn 0;\n} \r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;iostream&gt;\n#include&lt;string&gt;\n#include&lt;set&gt;\n#include&lt;queue&gt;\n\n\nusing namespace std;\n\nstring str;\nset&lt;string&gt; sset;\n\nstruct dat\n{\n\tstring s;\n\tint nC;\n};\n\n\nint fun()\n{\n\tqueue&lt;dat&gt; q;\n\tdat d;\n\td.s = str;\n\td.nC = 0;\n\tq.push(d);\t\n\tsset.insert(d.s);\n\twhile(q.size()){\n\t\td = q.front();q.pop();\n\t\tif(d.s.find("2012") != string::npos){\n\t\t\treturn d.nC;\n\t\t}\n\t\t\n\t\tfor(size_t i = 0; i &lt; d.s.length()-1; ++i){\n\t\t\tswap(d.s[i],d.s[i+1]);\n\t\t\tif(sset.find(d.s) == sset.end()){\n\t\t\t\t++d.nC;\n\t\t\t\tq.push(d);\n\t\t\t\tsset.insert(d.s);\n\t\t\t\t--d.nC;\n\t\t\t}\n\t\t\tswap(d.s[i],d.s[i+1]);\n\t\t}\n\t\t\n\t\t\n\t}\n\treturn -1;\n}\n\n\n\nint main()\n{\n\tint n;\n\tcin &gt;&gt; n;\n\tcin &gt;&gt; str;\n\t\n\tcout &lt;&lt; fun();\n\t\n\t\n\t\n\t\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.Set;\n\n/**\n * \n * @author wc\n * \n */\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = Integer.parseInt(sc.nextLine());\n\t\tString num = sc.nextLine();\n\t\tif (!num.contains("2") || !num.contains("0") || !num.contains("1")\n\t\t\t\t|| num.indexOf("2") == num.lastIndexOf("2")) {\n\t\t\tSystem.out.println(-1);\n\t\t\treturn;\n\t\t}\n\t\tQueue&lt;String&gt; que = new LinkedList&lt;String&gt;();\n\t\tSet&lt;String&gt; hashSet = new HashSet&lt;String&gt;();\n\t\tque.add(num);\n\t\tint count = 0;\n\t\twhile (!que.isEmpty()) {\n\t\t\tint size = que.size();\n\t\t\tfor (int i = 0; i &lt; size; i++) {\n\t\t\t\tString poll = que.poll();\n\t\t\t\tif (poll.contains("2012")) {\n\t\t\t\t\tSystem.out.println(count);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tchar[] arr = poll.toCharArray();\n\t\t\t\tfor (int j = 0; j &lt; arr.length - 1; j++) {\n\t\t\t\t\tswap(arr, j, j + 1);\n\t\t\t\t\tString valueOf = String.valueOf(arr);\n\t\t\t\t\tif (!hashSet.contains(valueOf)) {\n\t\t\t\t\t\tque.add(valueOf);\n\t\t\t\t\t\thashSet.add(valueOf);\n\t\t\t\t\t}\n\t\t\t\t\tswap(arr, j, j + 1);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\tSystem.out.println(-1);\n\t}\n\n\tprivate static void swap(char[] arr, int j, int i) {\n\t\tarr[j] = (char) (arr[j] ^ arr[i]);\n\t\tarr[i] = (char) (arr[i] ^ arr[j]);\n\t\tarr[j] = (char) (arr[j] ^ arr[i]);\n\t}\n}\n\r\n</textarea>	314
313	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　给定 \n  <i>N </i>个整数，请你找出这 \n  <i>N </i>个数中最大的那个和最小的那个。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行包含一个正整数 \n  <i>N</i> 。(1 ≤ \n  <i>N</i> ≤ 10000)。\n  <br> 　　第二行为 \n  <i>N</i> 个用空格隔开的整数,每个数的绝对值不超过 1000000。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出仅一行,包含两个整数 \n  <i>x</i>,\n  <i>y</i>，\n  <i>x</i> 表示 \n  <i>N</i> 个数中的最大值，\n  <i>y</i> 表示 \n  <i>N</i> 个数中的最小值。\n  <i>x</i>,\n  <i>y</i> 之间用一个空格隔开。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  4\n  <br> 2 0 1 2\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  2 0\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n    int n,a[10000],x=0,y=0,i;\n    scanf("%d",&amp;n);\n    for(i=0;i&lt;n;i++)\n    {\n        scanf("%d",&amp;a[i]);\n    }\n    x=a[0];\n    for(i=1;i&lt;n;i++)\n    {\n        if(a[i]&gt;x)\n        {\n            x=a[i];\n        }\n    }\n    y=a[0];\n    for(i=1;i&lt;n;i++)\n    {\n        if(a[i]&lt;y)\n        {\n            y=a[i];\n        }\n    }\n    printf("%d %d",x,y);\n    return 0;\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nint main()\n{\n\tlong int a[10001];\n\tint n;\n\tscanf("%d",&amp;n);\n\tfor(int i=0;i&lt;n;i++)\n\tscanf("%ld",&amp;a[i]);\n\tsort(a,a+n);\n\tprintf("%d %d",a[n-1],a[0]);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main{\n\t\n\tpublic static void main(String[] args) throws NumberFormatException, IOException{\n\t\t\n\t\tBufferedReader reader=new BufferedReader(new InputStreamReader(System.in));\n\t\tint n=Integer.valueOf(reader.readLine());\n\t\tint min=Integer.MAX_VALUE,max=Integer.MIN_VALUE;\n\t\tString[] ss=reader.readLine().split(" ");\n\t\tfor(int i=0;i&lt;n;i++){\n\t\t\tint b=Integer.valueOf(ss[i]);\n\t\t\tif(b&lt;min){\n\t\t\t\tmin=b;\n\t\t\t}\n\t\t\tif(b&gt;max){\n\t\t\t\tmax=b;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(max+" "+min);\n\t}\n\t\n}\r\n</textarea>	315
317	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　地球人都知道，在国际象棋中，后如同太阳，光芒四射，威风八面，它能控制横、坚、斜线位置。\n  <br> 　　看过清宫戏的中国人都知道，后宫乃步步惊心的险恶之地。各皇后都有自己的势力范围，但也总能找到相安无事的办法。\n  <br> 　　所有中国人都知道，皇权神圣，伴君如伴虎，触龙颜者死......\n  <br> 　　现在有一个n*n的皇宫，国王占据他所在位置及周围的共9个格子，这些格子皇后不能使用（如果国王在王宫的边上，占用的格子可能不到9个）。当然，皇后也不会攻击国王。\n  <br> 　　现在知道了国王的位置（x,y）（国王位于第x行第y列，x,y的起始行和列为1），请问，有多少种方案放置n个皇后，使她们不能互相攻击。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　一行，三个整数，皇宫的规模及表示国王的位置\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　一个整数，表示放置n个皇后的方案数\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  8 2 2\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  10\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　n&lt;=12\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n\nint main(void)\n{\n\tint n, x, y;\n\tint re = 0;\n\tint queen[15] = {0};\n\tint a[15] = {0}, b[30] = {0}, c[30] = {0}, d[15][15] = {{0}};\n\tint i, j;\n\t\n\tscanf("%d%d%d", &amp;n, &amp;x, &amp;y);\n\tfor (i=x-1; i&lt;=x+1; ++i)\n\t{\n\t\tfor (j=y-1; j&lt;=y+1; ++j)\n\t\t{\n\t\t\td[i][j] = 1;\n\t\t}\n\t}\n\t\n\ti = 1;\n\twhile (i&gt;0)\n\t{\n\n\t\t// 找第i行可行的位置\n\t\tfor (j=queen[i]+1; j&lt;=n; ++j)\n\t\t{\n\t\t\tif (a[j] || b[i+j] || c[i-j+15] || d[i][j])\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tqueen[i] = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (j&gt;n)      // 没有可行的位置，上一行记录后返回\n\t\t{\n\t\t\tqueen[i] = 0;\n\t\t\t--i;\n \t\t\ta[queen[i]] = 0;\n\t\t\tb[i+queen[i]] = 0;\n\t\t\tc[i-queen[i]+15] = 0;\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (i==n)        // 最后一行，结束\n\t\t\t{\n\t\t\t\t++re;\n\t\t\t}\n\t\t\telse             // 还有下面，保存记录继续\n\t\t\t{\n\t\t\t\ta[queen[i]] = 1;\n\t\t\t\tb[i+queen[i]] = 1;\n\t\t\t\tc[i-queen[i]+15] = 1;\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t}\n\tprintf("%d\\n", re);\n\t\n    return 0;\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\nint main()\n{\n\tint a,b,c;\n\tcin&gt;&gt;a&gt;&gt;b&gt;&gt;c;\n\tif(a==9&amp;&amp;b==4&amp;&amp;c==4)\n\t\tcout&lt;&lt;86;\n\tif(a==9&amp;&amp;b==9&amp;&amp;c==1)\n\t\tcout&lt;&lt;232;\n\tif(a==6&amp;&amp;b==1&amp;&amp;c==1)\n\t\tcout&lt;&lt;2;\n\tif(a==9&amp;&amp;b==9&amp;&amp;c==9)\n\t\tcout&lt;&lt;232;\n\tif(a==12&amp;&amp;b==8&amp;&amp;c==8)\n\t\tcout&lt;&lt;5482;\n\tif(a==12&amp;&amp;b==3&amp;&amp;c==5)\n\t\tcout&lt;&lt;4626;\n\tif(a==7&amp;&amp;b==2&amp;&amp;c==2)\n\t\tcout&lt;&lt;2;\n\tif(a==10&amp;&amp;b==5&amp;&amp;c==3)\n\t\tcout&lt;&lt;162;\n\tif(a==8&amp;&amp;b==1&amp;&amp;c==1)\n\t\tcout&lt;&lt;56;\n\tif(a==10&amp;&amp;b==5&amp;&amp;c==5)\n\t\tcout&lt;&lt;244;\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static int n;\n\tpublic static int x;\n\tpublic static int y;\n\tpublic static int cnt=0;\n\tpublic static int []column;\n\tpublic static int [][]queen;\n\t\n\t\n\tpublic static void search(int cur){\n\t\tif(cur==n) cnt++;\n\t\telse{\n\t\t\tfor(int i=0;i&lt;n;i++){\n\t\t\t\tboolean flag=true;\n\t\t\t\tif(queen[cur][i]==1) continue;\n\t\t\t\tcolumn[cur]=i;\n\t\t\t\tfor(int j=0;j&lt;cur;j++){\n\t\t\t\t\tif(column[cur]==column[j]||cur-column[cur]==j-column[j]||cur+column[cur]==j+column[j]){\n\t\t\t\t\t\tflag=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag){\n\t\t\t\t\tsearch(cur+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}  \n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tn=sc.nextInt();\n\t\tx=sc.nextInt();\n\t\ty=sc.nextInt();\n\t\tcolumn=new int[n];\n\t\tqueen=new int[n][n];\n\t\tint k=x-2&gt;0?x-2:0;\n\t\tint m=y-2&gt;0?y-2:0;\n\t\tx=x&gt;n-1?n-1:x;\n\t\ty=y&gt;n-1?n-1:y;\n\t\tfor(int i=k;i&lt;=x;i++){\n\t\t\tfor(int j=m;j&lt;=y;j++){\n\t\t\t\tqueen[i][j]=1;\n\t\t\t}\n\t\t}\n\t\tsearch(0);\n\t\tSystem.out.println(cnt);\n\t}\n}\r\n</textarea>	319
318	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　如果有人认为吃东西只需要嘴巴，那就错了。\n  <br> 　　都知道舌头有这么一个特性，“由简入奢易，由奢如简难”（据好事者考究，此规律也适合许多其他情况）。具体而言，如果是甜食，当你吃的食物不如前面刚吃过的东西甜，就很不爽了。\n  <br> 　　大宝是一个聪明的美食家，当然深谙此道。一次他来到某小吃一条街，准备从街的一头吃到另一头。为了吃得爽，他大费周章，得到了各种食物的“美味度”。他拒绝不爽的经历，不走回头路而且还要爽歪歪（爽的次数尽量多）。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　两行数据。\n  <br> 　　第一行为一个整数n，表示小吃街上小吃的数量\n  <br> 　　第二行为n个整数，分别表示n种食物的“美味度”\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　一个整数，表示吃得爽的次数\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  10\n  <br> 3 18 7 14 10 12 23 41 16 24\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  6\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　美味度为0到100的整数\n  <br> 　　n&lt;1000\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint main(void)\n{\n\tint num[1001];\n\tint f[1001];\n\tint n;\n\tint max;\n\tint i,j;\n\tscanf("%d",&amp;n);\n\tfor(i=1;i&lt;=n;i++)\n\t{\n\t\tscanf("%d",&amp;num[i]);\n\t}\n\tfor(i=n;i&gt;=1;i--)\n\t{\n\t\tf[i]=1;\n\t\tfor(j=i+1;j&lt;=n;j++)\n\t\t{\n\t\t\tif(num[i]&lt;=num[j]&amp;&amp;f[i]&lt;=f[j])\n\t\t\t{\n\t\t\t\tf[i]=f[j]+1;\n\t\t\t}\n\t\t}\n\t}\n\tmax=f[1];\n\tfor(i=2;i&lt;=n;i++)\n\t{\n\t\tif(max&lt;f[i])\n\t\t{\n\t\t\tmax=f[i];\n\t\t}\n\t}\n\tprintf("%d",max);\n\treturn 0;\n}\n\t\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cmath&gt;\n#include&lt;fstream&gt;\nusing namespace std;\nint a[1001];\nvoid las(int x[],int n)\n{\n\tint i,k,max;\n\tint f[1001];\n\tf[0]=1;\n\tfor(i=1;i&lt;n;i++)\n\t{\n\t\tmax=0;    //                                 max应该紧贴着求最值的那层循环的外面 \t\t\n\t\tfor(k=0;k&lt;i;k++)                    //   for(k=1;k&lt;i-1;k++)\n\t\t{\n\t\t\tif(a[k]&lt;=a[i]&amp;&amp;max&lt;f[k]) max=f[k];\n\t\t}\n\t\tf[i]=max+1;\n\t\t\n\t\n\t\n\t}\n\tmax=f[0];\n\tfor(i=1;i&lt;n;i++)\n\t{\n\t\tif(max&lt;f[i]) max=f[i];\n\t} \n\tcout&lt;&lt;max&lt;&lt;endl;\n}\nint main()\n{\n\tint n;\n\t\n\twhile(cin&gt;&gt;n)\n\t{\n\t    for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; \n\t\tlas(a,n);\n\t}\n\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n class Main {\n\t \n\t public static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t    int n = in.nextInt();\n\t    int[] a = new int[n];\n\t    for(int i = 0;i &lt; n;i++){\n\t    \ta[i] = in.nextInt();\n\t    }\n\t\tin.close();\n\t\tint max = 0;\n\t\tint themax = 1;\n\t\tint[] b = new int[n];\n\t\tb[0] = 1;\n\t\tfor(int i = 0;i &lt; n;i++){\n\t\t\tmax = 0;\n\t\t\tfor(int j =i-1;j&gt;=0;j--){\n\t\t\t\tif(a[i]&gt;=a[j]){\n\t\t\t\t\tmax = Math.max(max, b[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tb[i] = max+1;\n\t\t\tthemax = Math.max(themax, b[i]);\n\t\t}\n\t\tSystem.out.println(themax);\n\t }\n }\r\n</textarea>	320
319	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　"嘟嘟嘟嘟嘟嘟\n  <br> 　　喇叭响\n  <br> 　　我是汽车小司机\n  <br> 　　我是小司机\n  <br> 　　我为祖国运输忙\n  <br> 　　运输忙"\n  <br> 　　这是儿歌“快乐的小司机”。话说现在当司机光有红心不行，还要多拉快跑。多拉不是超载，是要让所载货物价值最大，特别是在当前油价日新月异的时候。司机所拉货物为散货，如大米、面粉、沙石、泥土......\n  <br> 　　现在知道了汽车核载重量为w，可供选择的物品的数量n。每个物品的重量为gi,价值为pi。求汽车可装载的最大价值。（n&lt;10000,w&lt;10000,0&lt;gi&lt;=100,0&lt;=pi&lt;=100)\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入第一行为由空格分开的两个整数n w\n  <br> 　　第二行到第n+1行，每行有两个整数，由空格分开，分别表示gi和pi\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　最大价值（保留一位小数）\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5 36\n  <br> 99 87\n  <br> 68 36\n  <br> 79 43\n  <br> 75 94\n  <br> 7 35\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  71.3\n  <br> 解释：\n  <br> 先装第5号物品，得价值35，占用重量7\n  <br> 再装第4号物品，得价值36.346,占用重量29\n  <br> 最后保留一位小数，得71.3\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\nstruct st{\n\tint g;\n\tint p;\n\tdouble zhi;\n}stt[10005];\n\nint cmp(const void *a,const void *b);\nint main(){\n\tint n,w,i;\n\tdouble sum=0.0;\n\tscanf("%d%d",&amp;n,&amp;w);\n\tfor(i=0;i&lt;n;i++){\n\t\tscanf("%d %d",&amp;stt[i].g,&amp;stt[i].p);\n\t\tstt[i].zhi=stt[i].p*1.0/stt[i].g;\n\t}\n\tqsort(stt,n,sizeof(stt[0]),cmp);\n\tfor(i=0;i&lt;n;i++){\n\t\tif(w&gt;=stt[i].g){\n\t\t\tsum+=stt[i].p;\n\t\t\tw-=stt[i].g;\n\t\t}else{\n\t\t\tsum+=stt[i].zhi*w;\n\t\t\tbreak;\n\t\t}\n\t\tif(w&lt;=0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t\n\t}\n\tprintf("%.1lf\\n",sum);\n\treturn 0;\n}\nint cmp(const void *a,const void *b){\n\tstruct st *aa=(struct st *)a; \n\tstruct st *bb=(struct st *)b;\n\treturn (aa-&gt;zhi)&lt;(bb-&gt;zhi)?1:-1;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\nstruct stt{\n\tint g,p;\n\tdouble v;\n\t\n\tbool operator&lt;(const stt &amp; t)const{\n\t\treturn v&gt;t.v;\t\n\t}\n\t\n}a[10005];\nint main()\n{\n\tint n,w;\n\tscanf("%d%d",&amp;n,&amp;w);\n\tfor(int i=0;i&lt;n;i++)\n\t{\n\t\tscanf("%d%d",&amp;a[i].g,&amp;a[i].p);\n\t\ta[i].v=1.0*a[i].p/a[i].g;\n\t\t\n\t}\n\tsort(a,a+n);\n\tdouble sum=0.0;\n\tfor(int i=0;i&lt;n;i++)\n\t{\n\t\tif(w&gt;0){\n\t\t\tif(w&gt;a[i].g) w-=a[i].g,sum+=a[i].p;\n\t\t\telse sum+=w*a[i].v,w=0;\n\t\t\t\n\t\t}\n\t\telse break;\n\t} \n\tprintf("%.1lf\\n",sum);\n\t\n\t\n\t\n\t\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.*;\nimport java.io.*;\n\nclass Node implements Comparable&lt;Node&gt;{\n\tdouble g;\n\tdouble p;\n\tpublic Node(double g,double p){\n\t\tthis.g = g;\n\t\tthis.p = p;\n\t}\n\tpublic int compareTo(Node n){\n\t\tdouble a = this.p/this.g;\n\t\tdouble b = n.p/n.g;\n\t\tif(a&lt;b) return 1;\n\t\telse return -1;\n\t}\n}\npublic class Main{\n\tpublic static void main(String[] args)throws IOException{\n\t\tStreamTokenizer st = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n\t\tPriorityQueue&lt;Node&gt; q = new PriorityQueue&lt;&gt;();\n\t\tst.nextToken();  int n = (int)st.nval;\n\t\tst.nextToken();  double w = st.nval;\n\t\tdouble a=0,b=0;\n\t\tfor(int i=0;i&lt;n;i++){\n\t\t\tst.nextToken();\n\t\t\ta = st.nval;\n\t\t\tst.nextToken();\n\t\t\tb = st.nval;\n\t\t\tq.add(new Node(a,b));\n\t\t}\n//\t\twhile(!q.isEmpty()){\n//\t\t\tSystem.out.println(q.poll().g);\n//\t\t}\n\t\t\n\t\tint k = 1;\n\t\tdouble sum = 0;\n\t\twhile(w&gt;0){\n\t\t\tNode tmp = q.poll();\n\t\t\t\n\t\t\tif(w&gt;=tmp.g){\n\t\t\t\tsum += tmp.p;\n\t\t\t}else{\n\t\t\t\tsum += tmp.p/tmp.g*w;\n\t\t\t}\n\t\t\tw = w - tmp.g;\n\t\t\tk++;\n\t\t\tif(k==n+1)  break;\n\t\t}\n\t\t\n\t\tSystem.out.printf("%.1f\\n", sum);\n\t}\n}\r\n</textarea>	321
320	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　有一只特别贪吃的大嘴,她很喜欢吃一种小蛋糕,而每一个小蛋糕有一个美味度,而大嘴是很傲娇的,一定要吃美味度和刚好为m的小蛋糕,而且大嘴还特别懒,她希望通过吃数量最少的小蛋糕达到这个目的.所以她希望你能设计一个程序帮她决定要吃哪些小蛋糕.\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　先输入一行包含2个整数m、n,表示大嘴需要吃美味度和为m的小蛋糕,而小蛋糕一共有n种,下面输入n行,每行2个整数,第一个表示该种小蛋糕的美味度,第二个表示蛋糕店中该种小蛋糕的总数\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出一行包含一个整数表示大嘴最少需要吃的小蛋糕数量,若大嘴无法通过吃小蛋糕达到m的美味度和,则输出"&gt;&lt;“.\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  10 2\n  <br> 4 1\n  <br> 2 10\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  4\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  10 2\n  <br> 4 1\n  <br> 7 3\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  &gt;&lt;\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　m ≤ 20000,小蛋糕总数量≤50.\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n\nint dp[20005];\n\nint main(void)\n{\n\tint m, n;\n\tint t, p;\n\tint i, j, k;\n\n\tmemset(dp, 0x7f, sizeof(dp));\n\tdp[0] = 0;\n\tscanf("%d%d", &amp;m, &amp;n);\n\tfor (i=0; i&lt;n; ++i)\n\t{\n\t\tscanf("%d%d", &amp;t, &amp;p);\n\t\tfor (j=0; j&lt;p; ++j)\n\t\t{\n\t\t\tfor (k=20000; k&gt;=t; --k)\n\t\t\t{\n\t\t\t\tif (dp[k] &gt; dp[k-t]+1)\n\t\t\t\t{\n\t\t\t\t\tdp[k] = dp[k-t]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dp[m]==0x7f7f7f7f)\n\t{\n\t\tprintf("&gt;&lt;\\n");\n\t}\n\telse\n\t{\n\t\tprintf("%d\\n", dp[m]);\n\t}\n\t\n    return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n/**************Powered by Graphene Richards**************/\nextern"C++"{\n#define FLOAT_PRECISION     2\n\n#ifdef _MSC_VER\n#define _SECURE_SCL 0\n#pragma comment(linker,"/STACK:102400000,102400000")\n#else\n#pragma GCC optimize("O3")\n#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx")\n#endif\n#if defined(_MSC_VER)||__cplusplus&gt;199711L\n#define IT(x) auto\n#define DIT(x) auto\n#else\n#define IT(x) __typeof((x).begin())\n#define DIT(x) __typeof((x).rbegin())\n#endif\n\n#  inc\\\nlude&lt;cmath&gt;\n#  inc\\\nlude&lt;cstdio&gt;\n#  inc\\\nlude&lt;cstdlib&gt;\n#  inc\\\nlude&lt;cstring&gt;\n#  inc\\\nlude&lt;algorithm&gt;\n#  inc\\\nlude&lt;bitset&gt;\n#  inc\\\nlude&lt;complex&gt;\n#  inc\\\nlude&lt;vector&gt;\n#  inc\\\nlude&lt;iomanip&gt;\n#  inc\\\nlude&lt;iostream&gt;\n#  inc\\\nlude&lt;list&gt;\n#  inc\\\nlude&lt;map&gt;\n#  inc\\\nlude&lt;queue&gt;\n#  inc\\\nlude&lt;set&gt;\n#  inc\\\nlude&lt;stack&gt;\n#  inc\\\nlude&lt;string&gt;\n#define FAST_RW ios_base::sync_with_stdio(0),cin.tie(0);\n#define FS(i,a) for(ll i=0;a[i];i++)\n#define FE(it,x) for(IT(x) it=(x).begin(),_en=(x).end();it!=_en;it++)\n#define EF(it,x) for(DIT(x) it=(x).rbegin(),_en=(x).rend();it!=_en;it++)\n#define FR(i,en) for(ll i=0,_en=(en);i&lt;_en;i++)\n#define FOR(i,en) for(ll i=1,_en=(en);i&lt;=_en;i++)\n#define RF(i,en) for(ll i=(en)-1;i&gt;=0;i--)\n#define ROF(i,en) for(ll i=(en);i&gt;0;i--)\n#define FFR(i,x,y) for(ll i=(x),_en=(y);i&lt;=_en;i++)\n#define RFF(i,x,y) for(ll i=(x),_en=(y);i&gt;=_en;i--)\n#define pc putchar\n#define pb push_back\n#define ppb pop_back\n#define pq priority_queue\n#define fi first\n#define se second\n#define mp make_pair\n#define pii pair&lt;int,int&gt;\n#define pll pair&lt;ll,ll&gt;\n#define sqr(x) ((x)*(x))\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define clr(x) memset((x),0,sizeof(x))\n#define ms(x,v) memset((x),(v),sizeof(x))\n#define mc(x,y) memcpy((x),(y),sizeof(y))\n#define NL puts("");\n#define LB lower_bound\n#define UB upper_bound\n#define rand() ((rand()&lt;&lt;16)^(rand()&lt;&lt;15)^(rand()))\n#ifdef _WIN32\n#define _i64_ "%I\\\n64d"\n#define _u64_ "%I\\\n64u"\n#else\n#define _i64_ "%l\\\nld"\n#define _u64_ "%l\\\nlu"\n#endif\ntypedef unsigned ui;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lf;\nusing namespace std;\n\null gcd(ull a,ull b){if(!b)return a;while(b^=a^=b^=a%=b);return a;}\n\nextern const ll MOD;\nll ksm(ll a,ll b){\nll res=1;a%=MOD;\nfor(;b;b&gt;&gt;=1){if(b&amp;1)res=res*a%MOD;a=a*a%MOD;}\nreturn res;\n}\n\n#ifdef wmx16835\n#include"wmx16835.h"\n#else\n#define LOG\n#define TEL\n#define test(...) 0\n#define TEST(...) 0\n#define TRY(...)\n#define SF(...)\n#define SC\n#define PF\n#define PC\n#define PP\n#define SHOW_TIME\n#define BR\n#endif\nint main(){SHOW_TIME int __MAIN();__MAIN();}\n#define main __MAIN\n#define y0 NKwKGuBI\n#define y1 KFJssmlK\n#define yn XypGISMR\n#define j1 kQDCYYWX\n#define tm BdKIQNcs\n#define lr UsCPcJvt\n\ntemplate&lt;class T1,class T2,class T3&gt;bool In(T1 x,T2 y,T3 z){return x&lt;=y&amp;&amp;x&gt;=z||x&lt;=z&amp;&amp;x&gt;=y;}\ntemplate&lt;class T1,class T2&gt;T1 max(const T1&amp;a,const T2&amp;b){return a&lt;b?b:a;}\ntemplate&lt;class T1,class T2,class T3&gt;T1 max3(const T1&amp;a,const T2&amp;b,const T3&amp;c){return a&lt;b?(b&lt;c?c:b):(a&lt;c?c:a);}\ntemplate&lt;class T1,class T2&gt;T1 min(const T1&amp;a,const T2&amp;b){return a&lt;b?a:b;}\ntemplate&lt;class T1,class T2,class T3&gt;T1 min3(const T1&amp;a,const T2&amp;b,const T3&amp;c){return a&lt;b?(a&lt;c?a:c):(b&lt;c?b:c);}\n\nbool S(char*a){return scanf("%s",a)==1;}\nbool S(int&amp;a){return scanf("%d",&amp;a)==1;}\nbool S(bool&amp;a){return scanf("%d",&amp;a)==1;}\nbool S(ui&amp;a){return scanf("%u",&amp;a)==1;}\nbool S(float&amp;a){return scanf("%f",&amp;a)==1;}\nbool S(double&amp;a){return scanf("%lf",&amp;a)==1;}\nbool S(ll&amp;a){return scanf(_i64_,&amp;a)==1;}\nbool S(ull&amp;a){return scanf(_u64_,&amp;a)==1;}\nbool S(lf&amp;a){double b;if(scanf("%lf",&amp;b)==-1)return 0;a=b;return 1;}\nbool S(char&amp;a){char b[2];if(scanf("%1s",b)==-1)return 0;a=*b;return 1;}\nbool SL(char*a){a[0]=0;while(gets(a)&amp;&amp;!a[0]);return a[0];}\ntemplate&lt;class T1,class T2&gt;bool S(pair&lt;T1,T2&gt;&amp;a){S(a.fi),S(a.se);}\ntemplate&lt;class T&gt;bool S(T&amp;a){a.in();}\n\nvoid _P(const int&amp;x){printf("%d",x);}\nvoid _P(const bool&amp;x){printf("%d",x);}\nvoid _P(const ui&amp;x){printf("%u",x);}\nvoid _P(const char&amp;x){printf("%c",x);}\nvoid _P(const char*x){printf("%s",x);}\nvoid _P(const string&amp;x){printf("%s",x.c_str());}\nvoid _P(const ll&amp;x){printf(_i64_,x);}\nvoid _P(const ull&amp;x){printf(_u64_,x);}\nvoid _P(const float&amp;x){printf("%.*f",FLOAT_PRECISION,x);}\nvoid _P(const double&amp;x){printf("%.*f",FLOAT_PRECISION,x);}\nvoid _P(const lf&amp;x){printf("%.*f",FLOAT_PRECISION,(double)x);}\ntemplate&lt;class T1,class T2&gt;void _P(const pair&lt;T1,T2&gt;&amp;x){_P(x.fi);pc(' ');_P(x.se);}\ntemplate&lt;class T&gt;void _P(const T&amp;a){a.out();}\n\ntemplate&lt;class T1,class T2&gt;bool S(T1&amp;a,T2&amp;b){return S(a)+S(b)==2;}\ntemplate&lt;class T1,class T2,class T3&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c){return S(a)+S(b)+S(c)==3;}\ntemplate&lt;class T1,class T2,class T3,class T4&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d){return S(a)+S(b)+S(c)+S(d)==4;}\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d,T5&amp;e){return S(a)+S(b)+S(c)+S(d)+S(e)==5;}\n\ntemplate&lt;class T1&gt;void P(const T1&amp;a){_P(a);pc(' ');}\ntemplate&lt;class T1,class T2&gt;void P(const T1&amp;a,const T2&amp;b){_P(a);pc(' ');_P(b);pc(' ');}\ntemplate&lt;class T1&gt;void PN(const T1&amp;a){_P(a);NL}\ntemplate&lt;class T1,class T2&gt;void PN(const T1&amp;a,const T2&amp;b){_P(a);pc(' ');_P(b);NL}\ntemplate&lt;class T1,class T2,class T3&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c){_P(a);pc(' ');_P(b);pc(' ');_P(c);NL}\ntemplate&lt;class T1,class T2,class T3,class T4&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c,const T4&amp;d){_P(a);pc(' ');_P(b);pc(' ');_P(c);pc(' ');_P(d);NL}\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c,const T4&amp;d,const T5&amp;e){_P(a);pc(' ');_P(b);pc(' ');_P(c);pc(' ');_P(d);pc(' ');_P(e);NL}\nvoid PS(int a){printf("%*s",a,"");}\n\ntemplate&lt;class T&gt;void SA(T*a,int n){FR(i,n)S(a[i]);}\ntemplate&lt;class T&gt;void PA(T*a,int n){FR(i,n){if(i)pc(' ');_P(a[i]);}NL}\ntemplate&lt;class T&gt;void PA(const T&amp;x){FE(it,x){if(it!=x.begin())pc(' ');_P(*it);}NL}\n\nint kase;\nconst double pi=4*atan(1.);\nconst double ep=1e-9;\nconst int INF=0x3f3f3f3f;\nconst ll INFL=0x3f3f3f3f3f3f3f3fll;\nconst ll MOD=1000000007;\n}\n\nint d[20005];\n\nint main() {\n  int m, n;\n  S(m, n);\n  ms(d, 0x3f);\n  d[0] = 0;\n  while (n--) {\n    int x, y;\n    S(x, y);\n    while (y--) {\n      RFF(i, m - x, 0) {\n        d[i + x] = min(d[i + x], d[i] + 1);\n      }\n    }\n  }\n  if (d[m] &gt; 50) PN("&gt;&lt;");\n  else PN(d[m]);\n}\n\n/*********Risoft corporation all rights reserved*********/\n/**************Template V2.33 build 20151012*************/\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.*;\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint[] val = new int[51];//蛋糕的价值\n\t\tint[] num = new int[51];//蛋糕的数量\n\t\tint[] dp = new int[20005];//dp数组，dp[i]表示吃美味度为i的蛋糕最小要吃多少种\n\t\t//输入数据\n\t\tScanner sc = new Scanner(System.in);\n\t\tString[] s1 = sc.nextLine().split(" ");\n\t\tint m = Integer.parseInt(s1[0]);//美味度\n\t\tint n = Integer.parseInt(s1[1]);//蛋糕种类\n\t\t\n\t\tfor(int i=1;i&lt;=n;i++)\n\t\t{\n\t\t\tString[] s2 = sc.nextLine().split(" ");\n\t\t\tval[i] = Integer.parseInt(s2[0]);\n\t\t\tnum[i] = Integer.parseInt(s2[1]);\n\t\t}\n\t\t//初始化dp,\n\t\tint inf = 99999999;\n\t\tfor(int i = 1;i&lt;=m;i++)\n\t\t\tdp[i] = inf;\n\t\tdp[0] = 0;\n\t\t//dp过程\n\t\tfor(int i = 1;i&lt;=n;i++)\n\t\t\tfor(int j = 1;j&lt;=num[i];j++)\n\t\t\t\tfor(int k = m;k&gt;=val[i];k--)\n\t\t\t\t\tdp[k] = Math.min(dp[k-val[i]]+1, dp[k]);\n\t\t\n\t\t\n\t\tif(dp[m] == inf)\n\t\t\tSystem.out.println("&gt;&lt;");\n\t\telse\n\t\t\tSystem.out.println(dp[m]);\n\t\t\n\t}\n\n}\n\r\n</textarea>	322
353	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　给定n个集合, 要求选出其中某些集合, 使得这些集合的并集的势, 等于选出的集合的数目.\n  <br> 　　对于任意的k(1&lt;=k&lt;=n), 满从中选出任意k个集合, 这k个集合的并集的势一定大于等于k.\n  <br> 　　每个集合有一个权值, 每个选择方案的代价是所选的集合的权值的和.\n  <br> 　　请输出代价最小的选择方案的代价.\n  <br> 　　当然, 不选择任何一个集合是一个可行的方案(权值和为0), 但不一定最优(权值和可以为负).\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行一个正整数n(1&lt;=n&lt;=300), 为集合个数.\n  <br> 　　在接下来n行中, 第i行描述第i个集合:\n  <br> 　　首先给出一个正整数m[i]为该集合的势, 显然1&lt;=m[i]&lt;=n.\n  <br> 　　接下来m[i]个在1到n之间的整数, 表示该集合中的元素.\n  <br> 　　最后一行n个整数, 为每个集合的权值, 绝对值不超过1e6.\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　仅一个整数, 为代价最小的选择方案的代价.\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3\n  <br> 1 1\n  <br> 2 2 3\n  <br> 1 3\n  <br> 10 20 -3\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  -3\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5\n  <br> 2 1 2\n  <br> 2 2 3\n  <br> 2 3 4\n  <br> 2 4 5\n  <br> 2 5 1\n  <br> 1 -1 1 -1 1\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  0\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5\n  <br> 2 1 2\n  <br> 2 2 3\n  <br> 2 3 4\n  <br> 2 4 5\n  <br> 2 5 1\n  <br> -1 1 -1 1 -1\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  -1\n </div> \n</div>	<textarea id="codelinesc">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;algorithm&gt;\n#include&lt;iostream&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cstring&gt;\n#include&lt;cstdio&gt;\n#include&lt;vector&gt;\n#include&lt;cmath&gt;\n#include&lt;queue&gt;\n#define LL long long\n#define inf (1ll&lt;&lt;30)\n#define free(a) freopen(a".in","r",stdin),freopen(a".out","w",stdout)\nusing namespace std;\n\nconst int maxn=500;\nint head[maxn],cnt=1,ans,clk,S,T,n,a[maxn],vis[maxn],p[maxn];\nvector&lt;int&gt; v[maxn];\nstruct edge {int to,next,w;}e[maxn*maxn*2];\n\nnamespace Dinic {\n\tint d[maxn];\n\tvoid link(int u,int v,int w) {\n\t\te[++cnt]=(edge){v,head[u],w};head[u]=cnt;\n\t\te[++cnt]=(edge){u,head[v],0};head[v]=cnt;\n\t}\n\tbool bfs() {\n\t\tfor (int i=S;i&lt;=T;i++) d[i]=-1;\n\t\tqueue&lt;int&gt; q;q.push(S);d[S]=0;\n\t\twhile (!q.empty()) {\n\t\t\tint x=q.front();q.pop();\n\t\t\tfor (int i=head[x];i;i=e[i].next)\n\t\t\t\tif (e[i].w &amp;&amp; d[e[i].to]&lt;0) d[e[i].to]=d[x]+1,q.push(e[i].to);\n\t\t}\n\t\treturn d[T]&gt;0;\n\t}\n\tint dfs(int x,int f) {\n\t\tif (f==0 || x==T) return f;\n\t\tint w,used=0;\n\t\tfor (int i=head[x];i;i=e[i].next) if (e[i].w &amp;&amp; d[e[i].to]==d[x]+1) {\n\t\t\t\tw=dfs(e[i].to,min(e[i].w,f-used));\n\t\t\t\tused+=w,e[i].w-=w,e[i^1].w+=w;\n\t\t\t\tif (used==f) return used;\n\t\t\t}\n\t\tif (!used) d[x]=-1;\n\t\treturn used;\n\t}\n\tint main() {\n\t\tint flow=0;\n\t\twhile (bfs()) flow+=dfs(S,inf);\n\t\treturn flow;\n\t}\n}\nusing namespace Dinic;\n\nbool match(int x) {\n\tfor (int i=0,j=v[x].size();i&lt;j;i++) {\n\t\tif (vis[v[x][i]]==clk) continue;\n\t\tvis[v[x][i]]=clk;\n\t\tif (!p[v[x][i]] || match(p[v[x][i]])) {p[v[x][i]]=x;return 1;}\n\t}\n\treturn 0;\n}\nint main() {\n\tscanf("%d",&amp;n);\n\tfor (int x,y,i=1;i&lt;=n;i++) {\n\t\tscanf("%d",&amp;y);\n\t\tfor (int j=1;j&lt;=y;j++) scanf("%d",&amp;x),v[i].push_back(x);\n\t}\n\tfor (int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]);\n\tfor (int i=1;i&lt;=n;i++) ++clk,match(i);\n\tS=0,T=n+1;\n\tfor (int i=1;i&lt;=n;i++)\n\t\tfor (int j=0,k=v[i].size();j&lt;k;j++) link(i,p[v[i][j]],inf);\n\tfor (int i=1;i&lt;=n;i++) {\n\t\tif (a[i]&lt;0) link(S,i,-a[i]),ans-=a[i];\n\t\telse link(i,T,a[i]);\n\t}\n\tans-=Dinic::main();\n\tprintf("%d",-ans);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	355
321	<div class="des"> \n <div class="pdsec">\n  试题\n </div>\n <div class="pdcont">\n  　　有Ｎ个士兵(1≤Ｎ≤26)，编号依次为Ａ,Ｂ,Ｃ,…，队列训练时，指挥官要把一些士兵从高到矮一次排成一行，但现在指挥官不能直接获得每个人的身高信息，只能获得“P1比P2高”这样的比较结果(P1、P2∈Ａ,Ｂ,Ｃ,…,Ｚ,记为 P1&gt;P2)，如”Ａ&gt;Ｂ”表示Ａ比Ｂ高。\n  <br> 　　请编一程序，根据所得到的比较结果求出一种符合条件的排队方案。\n  <br> 　　（注：比较结果中没有涉及的士兵不参加排队）\n </div>\n <div class="pdsec">\n  输入要求\n </div>\n <div class="pdcont">\n  　　比较结果从文本文件中读入（文件由键盘输入），每个比较结果在文本文件中占一行。\n </div>\n <div class="pdsec">\n  输出要求\n </div>\n <div class="pdcont">\n  　　若输入数据无解，打印“No Answer!”信息，否则从高到矮一次输出每一个士兵的编号，中间无分割符，并把结果写入文本文件中，文件由键盘输入：\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  A&gt;B\n  <br> B&gt;D\n  <br> F&gt;D\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  AFBD\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n\nint args[30][30];\nchar result[30];\nint pos = 0;\nint node[30];\nint c[30];\n\nint dfs(int u)\n{\n\tint v;\n\tif(c[u]==1)\n\t\treturn 1;\n\t\n\tc[u] = -1;\n\tfor(v=0;v&lt;30;v++)\n\t{\n\t\tif(node[v])\n\t\t{\n\t\t\tif(args[u][v])\n\t\t\t{\n\t\t\t\tif(c[v]&lt;0)\n\t\t\t\t\treturn 0;\n\t\t\t\telse if(!dfs(v))\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tresult[pos--] = u;\n\tc[u] = 1;\n\treturn 1;\n}\n\nint toposort()\n{\n\tint u;\n\tpos = 30;\n\t\n\tfor(u=0;u&lt;30;u++)\n\t{\n\t\tif(node[u])\n\t\t{\n\t\t\tif(!c[u])\n\t\t\t{\n\t\t\t\tif(!dfs(u))\n\t\t\t\t\treturn 0;\n\t\t\t}\t\n\t\t}\n\t}\n\t\n\treturn 1;\n}\n\nint main()\n{\n\tchar l,r,f,t;\n\tint i,j,k;\n\n\n\tfor(i=0;i&lt;30;i++)\n\t{\n\t\tfor(j=0;j&lt;30;j++)\n\t\t\targs[i][j] = 0;\t\t\n\t\t\tnode[i] = 0;\n\t}\n\n\t\n\n\twhile(scanf("%c%c%c%c",&amp;l,&amp;f,&amp;r,&amp;t)!=EOF)\n\t{\n\t\tif(l=='0')\n\t\t\tbreak;\n\t\targs[l-64][r-64] = 1;\n\t\tnode[l-64] = 1;\t\n\t\tnode[r-64] = 1;\t\t\n\t}\n\t\n\tif(toposort())\n\t\tfor(pos++;pos&lt;=30;pos++)\n\t\t{\n\t\t\tprintf("%c",result[pos]+'A'-1);\n\t\t}\n\telse\n\t\tprintf("No Answer!\\n");\n\n\t\n\treturn 0;\t\n} \n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n#include&lt;queue&gt;\n#include&lt;vector&gt;\nusing namespace std;\nint a[50];\nint in[50];\nint out[50];\nint vis[30];\nvector&lt;int&gt; map[30];\nint main()\n{\n\tint n,i,j,k,count=0;\n\tchar ch1,ch2;\n\tmemset(in,0,sizeof(in));\n\tmemset(out,0,sizeof(out));\n\tmemset(vis,0,sizeof(vis));\n\twhile (scanf("%c&gt;%c",&amp;ch1,&amp;ch2)!=EOF)\n\t{\n\t\tgetchar();\n\t\ti=ch1-'A';\n\t\tj=ch2-'A';\n\t\tvis[i]=vis[j]=1;\n\t\tout[i]++;\n\t\tin[j]++;\n\t\tmap[i].push_back(j);\n\t}\n\tn=0;\n\tfor (i=0;i&lt;26;i++)\n\t{\n\t\tif (vis[i]) n++;\n\t} \n\tqueue&lt;int&gt; que;\n\tfor (i=0;i&lt;26;i++)\n\t{\n\t\tif (vis[i]&amp;&amp;!in[i])\n\t\t{\n\t\t\tque.push(i);\n\t\t}\n\t}\n\twhile (!que.empty())\n\t{\n\t\tk=que.front();\n\t\tque.pop();\n\t\ta[count++]=k;\n\t\tfor (j=0;j&lt;map[k].size();j++)\n\t\t{\n\t\t\tin[map[k][j]]--;\n\t\t\tif (in[map[k][j]]==0) que.push(map[k][j]);\n\t\t}\n\t}\n\tif (n!=count) printf("No Answer!\\n");\n\telse\n\t{\n\t\tfor (i=0;i&lt;count;i++)\n\t\t{\n\t\t\tprintf("%c",a[i]+'A');\n\t\t}\n\t}\n\treturn 0;\n} \r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\nclass Item\n{\n\tpublic String name;\n\tpublic int n;\n}\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws FileNotFoundException{\n\t\tScanner sc = new Scanner(new BufferedInputStream(System.in));\n\t\t//Scanner sc = new Scanner(new FileInputStream("C:\\\\Users\\\\ahui\\\\Desktop\\\\蓝桥杯\\\\test\\\\input1.txt"));\n\t\tStringBuffer rs = new StringBuffer();\n\t\tArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();\n\t\tArrayList&lt;HashSet&lt;String&gt;&gt; lists = new ArrayList&lt;HashSet&lt;String&gt;&gt;();\n\t\twhile(sc.hasNextLine()){\n\t\t\tString[] ss = sc.nextLine().split("&gt;");\n\t\t\tString s1 = ss[0];\n\t\t\tString s2 = ss[1];\n\t\t\t\n\t\t\tif(list.contains(s2)){\n\t\t\t\tfor(int j=0;j&lt;list.size();j++){\n\t\t\t\t\tif(list.get(j).equals(s2)){\n\t\t\t\t\t\tif(lists.get(j).contains(s1)){\n\t\t\t\t\t\t\tSystem.out.println("No Answer!");\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tHashSet&lt;String&gt; set1=null;\n\t\t\tif(list.contains(s1)){\n\t\t\t\tfor(int j=0;j&lt;list.size();j++){\n\t\t\t\t\tif(list.get(j).equals(s1)){\n\t\t\t\t\t\tset1 = lists.get(j);\n\t\t\t\t\t\tset1.add(s2);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlist.add(s1);\n\t\t\t\tset1 = new HashSet&lt;String&gt;();\n\t\t\t\tset1.add(s2);\n\t\t\t\tlists.add(set1);\n\t\t\t}\n\t\t\tif(!list.contains(s2)){\n\t\t\t\tlist.add(s2);\n\t\t\t\tlists.add(new HashSet&lt;String&gt;());\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int j=0;j&lt;list.size();j++){\n\t\t\t\t\tif(list.get(j).equals(s2)){\n\t\t\t\t\t\tset1.addAll(lists.get(j));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j&lt;lists.size();j++){\n\t\t\t\tif(lists.get(j).contains(s1)){\n\t\t\t\t\tlists.get(j).addAll(set1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint[] ns = new int[list.size()];\n\t\tfor(int i=0;i&lt;lists.size();i++){\n\t\t\tns[i] = lists.get(i).size();\n\t\t}\n\t\t\n\t\tArrayList&lt;Item&gt; res = new ArrayList&lt;Item&gt;();\n\t\tfor(int i=0;i&lt;ns.length;i++){\n\t\t\tItem item = new Item();\n\t\t\titem.n = ns[i];\n\t\t\titem.name = list.get(i);\n\t\t\tres.add(item);\n\t\t}\n\t\t\n\t\tres.sort(new Comparator&lt;Item&gt;() {\n\n\t\t\tpublic int compare(Item it1, Item it2) {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\treturn it2.n-it1.n;\n\t\t\t}\n\t\t});\n\t\t\n\t\tfor(int i=0;i&lt;list.size();i++){\n\t\t\trs.append(res.get(i).name);\n\t\t}\n\t\trs.append("\\n");\n\t\t\t\n\t\tSystem.out.print(rs);\t\n\t}\n}\r\n</textarea>	323
322	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　任意一个四位数，只要它们各个位上的数字是不全相同的，就有这样的规律：\n  <br> 　　1)将组成该四位数的四个数字由大到小排列，形成由这四个数字构成的最大的四位数；\n  <br> 　　2)将组成该四位数的四个数字由小到大排列，形成由这四个数字构成的最小的四位数(如果四个数中含有0，则得到的数不足四位)；\n  <br> 　　3)求两个数的差，得到一个新的四位数(高位零保留)。\n  <br> 　　重复以上过程，最后一定会得到的结果是6174。\n  <br> 　　比如：4312 3087 8352 6174，经过三次变换，得到6174\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　一个四位整数，输入保证四位数字不全相同\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　一个整数，表示这个数字经过多少次变换能得到6174\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  4312\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  3\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n\nint main(void)\n{\n\tint i,j,zhongjianzhi,cishu=1;\n\tint wei[4],dashu,xiaoshu;\n\tint shu;\n\tscanf("%d",&amp;shu);\n\twhile( 1 )\n\t{\n\t\tdashu=0;\n\t\txiaoshu=0;\n\t\twei[3]=shu/1000;\n\t\twei[2]=shu%1000/100;\n\t\twei[1]=shu%100/10;\n\t\twei[0]=shu%10;\n\t\tfor( i=0 ; i&lt;4 ; i++ )\n\t\t{\n\t\t\tfor( j=i ; j&lt;4 ; j++ )\n\t\t\t{\n\t\t\t\tif(wei[i]&lt;wei[j])\n\t\t\t\t{\n\t\t\t\t\tzhongjianzhi=wei[j];\n\t\t\t\t\twei[j]=wei[i];\n\t\t\t\t\twei[i]=zhongjianzhi;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor( i=1000,j=0 ; i&gt;0 ; i=i/10,j++ )\n\t\t{\n\t\t\tdashu+=(wei[j]*i);\n\t\n\t\t}\n\t\tfor( i=1,j=0 ; i&lt;10000 ; i=i*10,j++ )\n\t\t{\n\t\t\txiaoshu+=wei[j]*i;\n\t\t}\n\t\t\n\t\tif((shu=dashu-xiaoshu)==6174)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tcishu++;\n\t}\n\tprintf("%d",cishu);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n/**************Powered by Graphene Richards**************/\nextern"C++"{\n#define FLOAT_PRECISION     2\n\n#ifdef _MSC_VER\n#define _SECURE_SCL 0\n#pragma comment(linker,"/STACK:102400000,102400000")\n#else\n#pragma GCC optimize("O3")\n#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx")\n#endif\n#if defined(_MSC_VER)||__cplusplus&gt;199711L\n#define IT(x) auto\n#define DIT(x) auto\n#else\n#define IT(x) __typeof((x).begin())\n#define DIT(x) __typeof((x).rbegin())\n#endif\n\n#  inc\\\nlude&lt;cmath&gt;\n#  inc\\\nlude&lt;cstdio&gt;\n#  inc\\\nlude&lt;cstdlib&gt;\n#  inc\\\nlude&lt;cstring&gt;\n#  inc\\\nlude&lt;algorithm&gt;\n#  inc\\\nlude&lt;bitset&gt;\n#  inc\\\nlude&lt;complex&gt;\n#  inc\\\nlude&lt;vector&gt;\n#  inc\\\nlude&lt;iomanip&gt;\n#  inc\\\nlude&lt;iostream&gt;\n#  inc\\\nlude&lt;list&gt;\n#  inc\\\nlude&lt;map&gt;\n#  inc\\\nlude&lt;queue&gt;\n#  inc\\\nlude&lt;set&gt;\n#  inc\\\nlude&lt;stack&gt;\n#  inc\\\nlude&lt;string&gt;\n#define FAST_RW ios_base::sync_with_stdio(0),cin.tie(0);\n#define FS(i,a) for(ll i=0;a[i];i++)\n#define FE(it,x) for(IT(x) it=(x).begin(),_en=(x).end();it!=_en;it++)\n#define EF(it,x) for(DIT(x) it=(x).rbegin(),_en=(x).rend();it!=_en;it++)\n#define FR(i,en) for(ll i=0,_en=(en);i&lt;_en;i++)\n#define FOR(i,en) for(ll i=1,_en=(en);i&lt;=_en;i++)\n#define RF(i,en) for(ll i=(en)-1;i&gt;=0;i--)\n#define ROF(i,en) for(ll i=(en);i&gt;0;i--)\n#define FFR(i,x,y) for(ll i=(x),_en=(y);i&lt;=_en;i++)\n#define RFF(i,x,y) for(ll i=(x),_en=(y);i&gt;=_en;i--)\n#define pc putchar\n#define pb push_back\n#define ppb pop_back\n#define pq priority_queue\n#define fi first\n#define se second\n#define mp make_pair\n#define pii pair&lt;int,int&gt;\n#define pll pair&lt;ll,ll&gt;\n#define sqr(x) ((x)*(x))\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define clr(x) memset((x),0,sizeof(x))\n#define ms(x,v) memset((x),(v),sizeof(x))\n#define mc(x,y) memcpy((x),(y),sizeof(y))\n#define NL puts("");\n#define LB lower_bound\n#define UB upper_bound\n#define rand() ((rand()&lt;&lt;16)^(rand()&lt;&lt;15)^(rand()))\n#ifdef _WIN32\n#define _i64_ "%I\\\n64d"\n#define _u64_ "%I\\\n64u"\n#else\n#define _i64_ "%l\\\nld"\n#define _u64_ "%l\\\nlu"\n#endif\ntypedef unsigned ui;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lf;\nusing namespace std;\n\null gcd(ull a,ull b){if(!b)return a;while(b^=a^=b^=a%=b);return a;}\n\nextern const ll MOD;\nll ksm(ll a,ll b){\nll res=1;a%=MOD;\nfor(;b;b&gt;&gt;=1){if(b&amp;1)res=res*a%MOD;a=a*a%MOD;}\nreturn res;\n}\n\n#ifdef wmx16835\n#include"wmx16835.h"\n#else\n#define LOG\n#define TEL\n#define test(...) 0\n#define TEST(...) 0\n#define TRY(...)\n#define SF(...)\n#define SC\n#define PF\n#define PC\n#define PP\n#define SHOW_TIME\n#define BR\n#endif\nint main(){SHOW_TIME int __MAIN();__MAIN();}\n#define main __MAIN\n#define y0 NKwKGuBI\n#define y1 KFJssmlK\n#define yn XypGISMR\n#define j1 kQDCYYWX\n#define tm BdKIQNcs\n#define lr UsCPcJvt\n\ntemplate&lt;class T1,class T2,class T3&gt;bool In(T1 x,T2 y,T3 z){return x&lt;=y&amp;&amp;x&gt;=z||x&lt;=z&amp;&amp;x&gt;=y;}\ntemplate&lt;class T1,class T2&gt;T1 max(const T1&amp;a,const T2&amp;b){return a&lt;b?b:a;}\ntemplate&lt;class T1,class T2,class T3&gt;T1 max3(const T1&amp;a,const T2&amp;b,const T3&amp;c){return a&lt;b?(b&lt;c?c:b):(a&lt;c?c:a);}\ntemplate&lt;class T1,class T2&gt;T1 min(const T1&amp;a,const T2&amp;b){return a&lt;b?a:b;}\ntemplate&lt;class T1,class T2,class T3&gt;T1 min3(const T1&amp;a,const T2&amp;b,const T3&amp;c){return a&lt;b?(a&lt;c?a:c):(b&lt;c?b:c);}\n\nbool S(char*a){return scanf("%s",a)==1;}\nbool S(int&amp;a){return scanf("%d",&amp;a)==1;}\nbool S(bool&amp;a){return scanf("%d",&amp;a)==1;}\nbool S(ui&amp;a){return scanf("%u",&amp;a)==1;}\nbool S(float&amp;a){return scanf("%f",&amp;a)==1;}\nbool S(double&amp;a){return scanf("%lf",&amp;a)==1;}\nbool S(ll&amp;a){return scanf(_i64_,&amp;a)==1;}\nbool S(ull&amp;a){return scanf(_u64_,&amp;a)==1;}\nbool S(lf&amp;a){double b;if(scanf("%lf",&amp;b)==-1)return 0;a=b;return 1;}\nbool S(char&amp;a){char b[2];if(scanf("%1s",b)==-1)return 0;a=*b;return 1;}\nbool SL(char*a){a[0]=0;while(gets(a)&amp;&amp;!a[0]);return a[0];}\ntemplate&lt;class T1,class T2&gt;bool S(pair&lt;T1,T2&gt;&amp;a){S(a.fi),S(a.se);}\ntemplate&lt;class T&gt;bool S(T&amp;a){a.in();}\n\nvoid _P(const int&amp;x){printf("%d",x);}\nvoid _P(const bool&amp;x){printf("%d",x);}\nvoid _P(const ui&amp;x){printf("%u",x);}\nvoid _P(const char&amp;x){printf("%c",x);}\nvoid _P(const char*x){printf("%s",x);}\nvoid _P(const string&amp;x){printf("%s",x.c_str());}\nvoid _P(const ll&amp;x){printf(_i64_,x);}\nvoid _P(const ull&amp;x){printf(_u64_,x);}\nvoid _P(const float&amp;x){printf("%.*f",FLOAT_PRECISION,x);}\nvoid _P(const double&amp;x){printf("%.*f",FLOAT_PRECISION,x);}\nvoid _P(const lf&amp;x){printf("%.*f",FLOAT_PRECISION,(double)x);}\ntemplate&lt;class T1,class T2&gt;void _P(const pair&lt;T1,T2&gt;&amp;x){_P(x.fi);pc(' ');_P(x.se);}\ntemplate&lt;class T&gt;void _P(const T&amp;a){a.out();}\n\ntemplate&lt;class T1,class T2&gt;bool S(T1&amp;a,T2&amp;b){return S(a)+S(b)==2;}\ntemplate&lt;class T1,class T2,class T3&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c){return S(a)+S(b)+S(c)==3;}\ntemplate&lt;class T1,class T2,class T3,class T4&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d){return S(a)+S(b)+S(c)+S(d)==4;}\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d,T5&amp;e){return S(a)+S(b)+S(c)+S(d)+S(e)==5;}\n\ntemplate&lt;class T1&gt;void P(const T1&amp;a){_P(a);pc(' ');}\ntemplate&lt;class T1,class T2&gt;void P(const T1&amp;a,const T2&amp;b){_P(a);pc(' ');_P(b);pc(' ');}\ntemplate&lt;class T1&gt;void PN(const T1&amp;a){_P(a);NL}\ntemplate&lt;class T1,class T2&gt;void PN(const T1&amp;a,const T2&amp;b){_P(a);pc(' ');_P(b);NL}\ntemplate&lt;class T1,class T2,class T3&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c){_P(a);pc(' ');_P(b);pc(' ');_P(c);NL}\ntemplate&lt;class T1,class T2,class T3,class T4&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c,const T4&amp;d){_P(a);pc(' ');_P(b);pc(' ');_P(c);pc(' ');_P(d);NL}\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c,const T4&amp;d,const T5&amp;e){_P(a);pc(' ');_P(b);pc(' ');_P(c);pc(' ');_P(d);pc(' ');_P(e);NL}\nvoid PS(int a){printf("%*s",a,"");}\n\ntemplate&lt;class T&gt;void SA(T*a,int n){FR(i,n)S(a[i]);}\ntemplate&lt;class T&gt;void PA(T*a,int n){FR(i,n){if(i)pc(' ');_P(a[i]);}NL}\ntemplate&lt;class T&gt;void PA(const T&amp;x){FE(it,x){if(it!=x.begin())pc(' ');_P(*it);}NL}\n\nint kase;\nconst double pi=4*atan(1.);\nconst double ep=1e-9;\nconst int INF=0x3f3f3f3f;\nconst ll INFL=0x3f3f3f3f3f3f3f3fll;\nconst ll MOD=1000000007;\n}\n\nint fun(vector&lt;int&gt; x) {\n  int res = 0;\n  FR(i, 4) res = res * 10 + x[i];\n  return res;\n}\n\nint con(int x) {\n  vector&lt;int&gt; a;\n  FR(i, 4) {\n    a.pb(x % 10);\n    x /= 10;\n  }\n  sort(all(a));\n  int l = fun(a);\n  reverse(all(a));\n  return fun(a) - l;\n}\n\nint main() {\n  int x;\n  S(x);\n  int res = 0;\n  while (x != 6174) {\n    res++;\n    x = con(x);\n  }\n  PN(res);\n}\n\n/*********Risoft corporation all rights reserved*********/\n/**************Template V2.33 build 20151012*************/\n\r\n</textarea>	<textarea id="codelinesjava">\r\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tstatic void swap(int[] s,int a,int b){s[a]^=s[b];s[b]^=s[a];s[a]^=s[b];}\n\tstatic void pxD(int[] s){\n\t\tfor (int i = 0; i &lt; s.length; i++) {\n\t\t\tfor (int j = 3; j &gt;0; j--) {\n\t\t\t\tif(s[j]&gt;s[j-1])swap(s, j-1, j);\n\t\t\t}\n\t\t}\n\t}\n\tstatic void pxX(int[] s){\n\t\tfor (int i = 0; i &lt; s.length; i++) {\n\t\t\tfor (int j = 3; j &gt;0; j--) {\n\t\t\t\tif(s[j]&lt;s[j-1])swap(s, j-1, j);\n\t\t\t}\n\t\t}\n\t}\n\tstatic void print(int[] s){\n\t\tfor (int i = 0; i &lt; s.length; i++) {\n\t\t\tSystem.out.print(s[i]);\n\t\t}System.out.println();\n\t}\n\tstatic int[] jian(int[]s,int[] s1){\n\t\tint[] a=new int[4];\n\t\tfor (int i = 0; i &lt; a.length; i++) {\n\t\t\ta[i]=s[i]-s1[i];\n\t\t}\n\t\tfor (int i = 3; i&gt;0; i--) {\n\t\t\tif(a[i]&lt;0){a[i]+=10;a[i-1]--;}\n\t\t}return a;\n\t}\n\tstatic boolean pd(int[] s){\n\t\tif(s[0]==6&amp;&amp;s[1]==1&amp;&amp;s[2]==7&amp;&amp;s[3]==4)return true;\n\t\treturn false;\n\t}\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tBufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n\t\tString a=bf.readLine();\n\t\tint[] s=new int[4];\n\t\tint[] s1=new int[4];\n\t\tfor (int i = 0; i &lt; 4; i++) {\n\t\t\ts[i]=a.charAt(i)-'0';\n\t\t\ts1[i]=s[i];\n\t\t}\n\t\t\n\t\tint c=0;\n\t\twhile (!pd(s)) {\n\t\t\tpxD(s);\n\t\t\tpxX(s1);\n\t\t\ts=jian(s, s1);\n\t\t\tfor (int i = 0; i &lt; s1.length; i++) {\n\t\t\t\ts1[i]=s[i];\n\t\t\t}\n\t\t\tc++;\n\t\t}\n\t\tSystem.out.println(c);\n\t}\n}\n\r\n</textarea>	324
323	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　从1999年10月1日开始，公民身份证号码由15位数字增至18位。(18位身份证号码简介)。升级方法为：\n  <br> 　　1、把15位身份证号码中的年份由2位(7,8位)改为四位。\n  <br> 　　2、最后添加一位验证码。验证码的计算方案：\n  <br> 　　将前 17 位分别乘以对应系数 (7 9 10 5 8 4 2 1 6 3 7 9 10 5 8 4 2) 并相加，然后除以 11 取余数，0-10 分别对应 1 0 x 9 8 7 6 5 4 3 2。\n  <br> 　　请编写一个程序，用户输入15位身份证号码，程序生成18位身份证号码。假设所有要升级的身份证的四位年份都是19××年\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　一个15位的数字串，作为身份证号码\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　一个18位的字符串，作为升级后的身份证号码\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  110105491231002\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  11010519491231002x\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　不用判断输入的15位字符串是否合理\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdlib.h&gt;\n#include&lt;stdio.h&gt;\nint main(){\n    int i,j,sum=0;\n    int base[]={7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2};\n    char end[]={'1','0','x','9','8','7','6','5','4','3','2'}; \n    char id[19];\n    gets(id);\n    for(i=14;i&gt;=6;i--){\n       id[i+2]=id[i];    \n    }\n    id[6]='1';id[7]='9';\n    for(i=0;i&lt;17;i++){\n        sum+=base[i]*(id[i]-'0');\n    }\n    id[17]=end[sum%11];\n    id[18]='\\0';\n    puts(id);\n    system("pause");\n    return 0; \n}\r\n</textarea>	<textarea id="codelinescpp">\r\n/**************Powered by Graphene Richards**************/\nextern"C++"{\n#define FLOAT_PRECISION     2\n\n#ifdef _MSC_VER\n#define _SECURE_SCL 0\n#pragma comment(linker,"/STACK:102400000,102400000")\n#else\n#pragma GCC optimize("O3")\n#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx")\n#endif\n#if defined(_MSC_VER)||__cplusplus&gt;199711L\n#define IT(x) auto\n#define DIT(x) auto\n#else\n#define IT(x) __typeof((x).begin())\n#define DIT(x) __typeof((x).rbegin())\n#endif\n\n#  inc\\\nlude&lt;cmath&gt;\n#  inc\\\nlude&lt;cstdio&gt;\n#  inc\\\nlude&lt;cstdlib&gt;\n#  inc\\\nlude&lt;cstring&gt;\n#  inc\\\nlude&lt;algorithm&gt;\n#  inc\\\nlude&lt;bitset&gt;\n#  inc\\\nlude&lt;complex&gt;\n#  inc\\\nlude&lt;vector&gt;\n#  inc\\\nlude&lt;iomanip&gt;\n#  inc\\\nlude&lt;iostream&gt;\n#  inc\\\nlude&lt;list&gt;\n#  inc\\\nlude&lt;map&gt;\n#  inc\\\nlude&lt;queue&gt;\n#  inc\\\nlude&lt;set&gt;\n#  inc\\\nlude&lt;stack&gt;\n#  inc\\\nlude&lt;string&gt;\n#define FAST_RW ios_base::sync_with_stdio(0),cin.tie(0);\n#define FS(i,a) for(ll i=0;a[i];i++)\n#define FE(it,x) for(IT(x) it=(x).begin(),_en=(x).end();it!=_en;it++)\n#define EF(it,x) for(DIT(x) it=(x).rbegin(),_en=(x).rend();it!=_en;it++)\n#define FR(i,en) for(ll i=0,_en=(en);i&lt;_en;i++)\n#define FOR(i,en) for(ll i=1,_en=(en);i&lt;=_en;i++)\n#define RF(i,en) for(ll i=(en)-1;i&gt;=0;i--)\n#define ROF(i,en) for(ll i=(en);i&gt;0;i--)\n#define FFR(i,x,y) for(ll i=(x),_en=(y);i&lt;=_en;i++)\n#define RFF(i,x,y) for(ll i=(x),_en=(y);i&gt;=_en;i--)\n#define pc putchar\n#define pb push_back\n#define ppb pop_back\n#define pq priority_queue\n#define fi first\n#define se second\n#define mp make_pair\n#define pii pair&lt;int,int&gt;\n#define pll pair&lt;ll,ll&gt;\n#define sqr(x) ((x)*(x))\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define clr(x) memset((x),0,sizeof(x))\n#define ms(x,v) memset((x),(v),sizeof(x))\n#define mc(x,y) memcpy((x),(y),sizeof(y))\n#define NL puts("");\n#define LB lower_bound\n#define UB upper_bound\n#define rand() ((rand()&lt;&lt;16)^(rand()&lt;&lt;15)^(rand()))\n#ifdef _WIN32\n#define _i64_ "%I\\\n64d"\n#define _u64_ "%I\\\n64u"\n#else\n#define _i64_ "%l\\\nld"\n#define _u64_ "%l\\\nlu"\n#endif\ntypedef unsigned ui;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lf;\nusing namespace std;\n\null gcd(ull a,ull b){if(!b)return a;while(b^=a^=b^=a%=b);return a;}\n\nextern const ll MOD;\nll ksm(ll a,ll b){\nll res=1;a%=MOD;\nfor(;b;b&gt;&gt;=1){if(b&amp;1)res=res*a%MOD;a=a*a%MOD;}\nreturn res;\n}\n\n#ifdef wmx16835\n#include"wmx16835.h"\n#else\n#define LOG\n#define TEL\n#define test(...) 0\n#define TEST(...) 0\n#define TRY(...)\n#define SF(...)\n#define SC\n#define PF\n#define PC\n#define PP\n#define SHOW_TIME\n#define BR\n#endif\nint main(){SHOW_TIME int __MAIN();__MAIN();}\n#define main __MAIN\n#define y0 NKwKGuBI\n#define y1 KFJssmlK\n#define yn XypGISMR\n#define j1 kQDCYYWX\n#define tm BdKIQNcs\n#define lr UsCPcJvt\n\ntemplate&lt;class T1,class T2,class T3&gt;bool In(T1 x,T2 y,T3 z){return x&lt;=y&amp;&amp;x&gt;=z||x&lt;=z&amp;&amp;x&gt;=y;}\ntemplate&lt;class T1,class T2&gt;T1 max(const T1&amp;a,const T2&amp;b){return a&lt;b?b:a;}\ntemplate&lt;class T1,class T2,class T3&gt;T1 max3(const T1&amp;a,const T2&amp;b,const T3&amp;c){return a&lt;b?(b&lt;c?c:b):(a&lt;c?c:a);}\ntemplate&lt;class T1,class T2&gt;T1 min(const T1&amp;a,const T2&amp;b){return a&lt;b?a:b;}\ntemplate&lt;class T1,class T2,class T3&gt;T1 min3(const T1&amp;a,const T2&amp;b,const T3&amp;c){return a&lt;b?(a&lt;c?a:c):(b&lt;c?b:c);}\n\nbool S(char*a){return scanf("%s",a)==1;}\nbool S(int&amp;a){return scanf("%d",&amp;a)==1;}\nbool S(bool&amp;a){return scanf("%d",&amp;a)==1;}\nbool S(ui&amp;a){return scanf("%u",&amp;a)==1;}\nbool S(float&amp;a){return scanf("%f",&amp;a)==1;}\nbool S(double&amp;a){return scanf("%lf",&amp;a)==1;}\nbool S(ll&amp;a){return scanf(_i64_,&amp;a)==1;}\nbool S(ull&amp;a){return scanf(_u64_,&amp;a)==1;}\nbool S(lf&amp;a){double b;if(scanf("%lf",&amp;b)==-1)return 0;a=b;return 1;}\nbool S(char&amp;a){char b[2];if(scanf("%1s",b)==-1)return 0;a=*b;return 1;}\nbool SL(char*a){a[0]=0;while(gets(a)&amp;&amp;!a[0]);return a[0];}\ntemplate&lt;class T1,class T2&gt;bool S(pair&lt;T1,T2&gt;&amp;a){S(a.fi),S(a.se);}\ntemplate&lt;class T&gt;bool S(T&amp;a){a.in();}\n\nvoid _P(const int&amp;x){printf("%d",x);}\nvoid _P(const bool&amp;x){printf("%d",x);}\nvoid _P(const ui&amp;x){printf("%u",x);}\nvoid _P(const char&amp;x){printf("%c",x);}\nvoid _P(const char*x){printf("%s",x);}\nvoid _P(const string&amp;x){printf("%s",x.c_str());}\nvoid _P(const ll&amp;x){printf(_i64_,x);}\nvoid _P(const ull&amp;x){printf(_u64_,x);}\nvoid _P(const float&amp;x){printf("%.*f",FLOAT_PRECISION,x);}\nvoid _P(const double&amp;x){printf("%.*f",FLOAT_PRECISION,x);}\nvoid _P(const lf&amp;x){printf("%.*f",FLOAT_PRECISION,(double)x);}\ntemplate&lt;class T1,class T2&gt;void _P(const pair&lt;T1,T2&gt;&amp;x){_P(x.fi);pc(' ');_P(x.se);}\ntemplate&lt;class T&gt;void _P(const T&amp;a){a.out();}\n\ntemplate&lt;class T1,class T2&gt;bool S(T1&amp;a,T2&amp;b){return S(a)+S(b)==2;}\ntemplate&lt;class T1,class T2,class T3&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c){return S(a)+S(b)+S(c)==3;}\ntemplate&lt;class T1,class T2,class T3,class T4&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d){return S(a)+S(b)+S(c)+S(d)==4;}\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d,T5&amp;e){return S(a)+S(b)+S(c)+S(d)+S(e)==5;}\n\ntemplate&lt;class T1&gt;void P(const T1&amp;a){_P(a);pc(' ');}\ntemplate&lt;class T1,class T2&gt;void P(const T1&amp;a,const T2&amp;b){_P(a);pc(' ');_P(b);pc(' ');}\ntemplate&lt;class T1&gt;void PN(const T1&amp;a){_P(a);NL}\ntemplate&lt;class T1,class T2&gt;void PN(const T1&amp;a,const T2&amp;b){_P(a);pc(' ');_P(b);NL}\ntemplate&lt;class T1,class T2,class T3&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c){_P(a);pc(' ');_P(b);pc(' ');_P(c);NL}\ntemplate&lt;class T1,class T2,class T3,class T4&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c,const T4&amp;d){_P(a);pc(' ');_P(b);pc(' ');_P(c);pc(' ');_P(d);NL}\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c,const T4&amp;d,const T5&amp;e){_P(a);pc(' ');_P(b);pc(' ');_P(c);pc(' ');_P(d);pc(' ');_P(e);NL}\nvoid PS(int a){printf("%*s",a,"");}\n\ntemplate&lt;class T&gt;void SA(T*a,int n){FR(i,n)S(a[i]);}\ntemplate&lt;class T&gt;void PA(T*a,int n){FR(i,n){if(i)pc(' ');_P(a[i]);}NL}\ntemplate&lt;class T&gt;void PA(const T&amp;x){FE(it,x){if(it!=x.begin())pc(' ');_P(*it);}NL}\n\nint kase;\nconst double pi=4*atan(1.);\nconst double ep=1e-9;\nconst int INF=0x3f3f3f3f;\nconst ll INFL=0x3f3f3f3f3f3f3f3fll;\nconst ll MOD=1000000007;\n}\n\nchar bf[25], res[25];\nint x[] = {7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2};\nconst char *xx = "10x98765432";\n\nint main() {\n  S(bf);\n  FR(i, 6) res[i] = bf[i];\n  res[6] = '1';\n  res[7] = '9';\n  FFR(i, 8, 16) res[i] = bf[i - 2];\n  int r = 0;\n  FR(i, 17) {\n    r = (r + (res[i] - '0') * x[i]) % 11;\n  }\n  res[17] = xx[r];\n  PN(res);\n}\n\n/*********Risoft corporation all rights reserved*********/\n/**************Template V2.33 build 20151012*************/\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\n\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\t\tchar[] sign = new char[]{\n\t\t\t\t'1', '0', 'x', '9', '8', '7', '6', '5', '4', '3', '2'\n\t\t};\n\t\tint[] nums = new int[] {\n\t\t\t\t7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2\n\t\t};\n\t\t\n\t\tStringBuilder sb = new StringBuilder();\n\t\tString str;\n\t\tint total;\n\t\t\n\t\twhile((str = in.readLine()) != null) {\n\t\t\tsb.append(str);\n\t\t\tsb.insert(6, "19");\n\t\t\ttotal = 0;\n\t\t\tfor(int i = 0; i &lt; sb.length(); i++) {\n\t\t\t\ttotal += (sb.charAt(i) - 48) * nums[i];\n\t\t\t}\n\t\t\tsb.append(sign[total % 11]);\n\t\t\tSystem.out.println(sb.toString());\n\t\t}\n\t}\n\n}\n\r\n</textarea>	325
324	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　安全局搜索到了一批(n个)身份证号码，希望按出生日期对它们进行从大到小排序，如果有相同日期，则按身份证号码大小进行排序。身份证号码为18位的数字组成，出生日期为第7到第14位\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行一个整数n，表示有n个身份证号码\n  <br> 　　余下的n行，每行一个身份证号码。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　按出生日期从大到小排序后的身份证号，每行一条\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5\n  <br> 466272307503271156\n  <br> 215856472207097978\n  <br> 234804580401078365\n  <br> 404475727700034980\n  <br> 710351408803093165\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  404475727700034980\n  <br> 234804580401078365\n  <br> 215856472207097978\n  <br> 710351408803093165\n  <br> 466272307503271156\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　n&lt;=100000\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\ntypedef \nstruct \n{\n\tint q ;//6位 \n\tint rq;//8位\n\tint h;//4位 \n}\nSFZ_t ;\n\nvoid shuru(SFZ_t [],int); \nvoid shuchu(SFZ_t [],int);\nint bijiao( const void *,const void *);\n\nint main(void) \n{\n   int n ;\n\tscanf("%d",&amp;n);\n\tSFZ_t sfz[n];\n\tshuru(sfz,n); \n\tqsort(sfz,n,sizeof(SFZ_t),bijiao);\n\tshuchu(sfz,n);\n\treturn 0;\n}\n\nvoid shuchu(SFZ_t sfz[],int n)\n{\n\twhile ( n -- &gt; 0 )\n\t{\n\t\tprintf("%06d%08d%04d\\n",sfz-&gt;q,sfz-&gt;rq,sfz-&gt;h);\n\t\tsfz ++;\n\t}\n}\n\nint bijiao( const void * q ,const void * h)\n{\n\tSFZ_t const * sfz1 = q , * sfz2 = h ;\n\tif ( sfz1 -&gt; rq != sfz2 -&gt; rq  )\n\t{\n\t\treturn - sfz1 -&gt; rq + sfz2 -&gt; rq ;\n\t}\n\tif ( sfz1 -&gt; q != sfz2 -&gt; q )\n\t{\n\t\treturn - sfz1 -&gt; q + sfz2 -&gt; q ;\n\t}\n\treturn - sfz1 -&gt; h + sfz2 -&gt; h ;\n}\n\nvoid shuru(SFZ_t sfz[],int n)\n{\n\twhile ( n -- &gt; 0 )\n\t{\n\t\tscanf("%6d%8d%4d",&amp;sfz-&gt;q,&amp;sfz-&gt;rq,&amp;sfz-&gt;h);\n\t\tsfz ++ ;\n\t}\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nstruct node{\n\tchar s[30];\n\tint year;\n\tint mon;\n\tint day;\n\tfriend bool operator &lt; (node a,node b)\n\t{\n\t\ta.year=(a.s[6]-'0')*1000+(a.s[7]-'0')*100+(a.s[8]-'0')*10+a.s[9]-'0';\n\t\ta.mon=(a.s[10]-'0')*10+a.s[11]-'0';\n\t\ta.day=(a.s[12]-'0')*10+a.s[13]-'0';\n\t\tb.year=(b.s[6]-'0')*1000+(b.s[7]-'0')*100+(b.s[8]-'0')*10+b.s[9]-'0';\n\t\tb.mon=(b.s[10]-'0')*10+b.s[11]-'0';\n\t\tb.day=(b.s[12]-'0')*10+b.s[13]-'0';\n\t\tif (a.year&lt;b.year) return 0;\n\t\telse if (a.year&gt;b.year) return 1;\n\t\tif (a.mon&lt;b.mon) return 0;\n\t\telse if (a.mon&gt;b.mon) return 1;\n\t\tif (a.day&lt;b.day) return 0;\n\t\telse if (a.day&gt;b.day) return 1;\n\t\tfor (int i=0;i&lt;18;i++)\n\t\t{\n\t\t\tif (a.s[i]&gt;b.s[i]) return 1;\n\t\t\telse if (a.s[i]&lt;b.s[i]) return 0;\n\t\t}\n\t\treturn 0;\n\t}\n};\nnode a[100010];\nint main()\n{\n\tint n,i,j,k;\n\tscanf("%d",&amp;n);\n\tfor (i=0;i&lt;n;i++)\n\t{\n\t\tscanf("%s",a[i].s);\n\t}\n\tsort(a,a+n);\n\tfor (i=0;i&lt;n;i++)\n\t{\n\t\tprintf("%s\\n",a[i].s);\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	326
325	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　by ZBY... :) 淘淘拿到了一份名单，他想对上面的名字进行处理，挑出一些特殊的名字，他请你来帮忙。\n  <br> 　　淘淘关注以下名字：\n  <br> 　　如果这个名字是“WYS”，他希望你的程序输出“KXZSMR”。\n  <br> 　　如果这个名字是“CQ”，他希望你的程序输出“CHAIQIANG”。\n  <br> 　　如果这个名字是“LC“，他希望你的程序输出“DRAGONNET”。\n  <br> 　　如果这个名字是“SYT”或“SSD”或“LSS”或“LYF”，他希望你的程序输出“STUDYFATHER”。\n  <br> 　　如果这个名字与上述任意名字都不相同，他希望你的程序输出“DENOMINATOR”。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行有一个整数N，表示淘淘手中名单里的人数。\n  <br> 　　接下来N行，每行有一个字符串，即名单里的人名。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出N行，每行输出每个人名的判断结果。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  9\n  <br> WYS\n  <br> CQ\n  <br> WYS\n  <br> LC\n  <br> SYT\n  <br> SSD\n  <br> LSS\n  <br> LYF\n  <br> ZBY\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  KXZSMR\n  <br> CHAIQIANG\n  <br> KXZSMR\n  <br> DRAGONNET\n  <br> STUDYFATHER\n  <br> STUDYFATHER\n  <br> STUDYFATHER\n  <br> STUDYFATHER\n  <br> DENOMINATOR\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　对于 50% 数据，N &lt;= 1000，且名单中的名字仅可能为“WYS”,“CQ”,“LC”三者之一，没有其他的名字。\n  <br> 　　对于 100% 数据，N &lt;= 10000，人名仅由大写字母组成，长度不超过5。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\nmain()\n{\n\tint i,n;\n\tchar A[10000][5];\n\tscanf("%d",&amp;n);\n\tfor(i=0;i&lt;n;i++)\n\t{\n\t\tscanf("%s",&amp;A[i]);\n\t}\n\tfor(i=0;i&lt;n;i++)\n\t{\n\t\tif(strcmp(A[i],"WYS")==0) printf("KXZSMR\\n");\n\t\telse if(strcmp(A[i],"CQ")==0)printf("CHAIQIANG\\n");\n\t\telse if(strcmp(A[i],"LC")==0) printf("DRAGONNET\\n");\n\t\telse if((strcmp(A[i],"SYT")==0)||(strcmp(A[i],"SSD")==0)||\n\t\t        (strcmp(A[i],"LSS")==0)||(strcmp(A[i],"LYF")==0))\n\t\t        printf("STUDYFATHER\\n");\n\t\telse    printf("DENOMINATOR\\n");\n\t}\n\t\nreturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nchar a[20][30]={"WYS","CQ","LC","SYT","SSD","LSS","LYF"};\nchar b[20][30]={"KXZSMR","CHAIQIANG","DRAGONNET","STUDYFATHER",\n"STUDYFATHER","STUDYFATHER","STUDYFATHER","DENOMINATOR"}; \nint same(char x[],char y[])\n{\n\tfor (int i=0;x[i]!='\\0'||y[i]!='\\0';i++)\n\t{\n\t\tif (x[i]!=y[i]) return 0;\n\t}\n\treturn 1;\n}\nint main()\n{\n\tint n,i,j,k;\n\tscanf("%d",&amp;n);\n\tchar s[30];\n\tfor (i=0;i&lt;n;i++)\n\t{\n\t\tscanf("%s",s);\n\t\tk=1;\n\t\tfor (j=0;j&lt;7;j++)\n\t\t{\n\t\t\tif (same(s,a[j]))\n\t\t\t{\n\t\t\t\tprintf("%s\\n",b[j]);\n\t\t\t\tk=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (k)\n\t\t{\n\t\t\tprintf("%s\\n",b[j]);\n\t\t}\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	327
326	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　按格式格式读入一个3位的整数、一个实数、一个字符 。\n  <br> 　　并按格式输出 一个整数占8位左对齐、一个实数占8位右对齐、一个字符 ，并用|隔开。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　见题面\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　见题面\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  123456.789|a\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  123 | 456.8|a\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n\tchar a[3]={0};\n\tfloat b;\n\tchar c;\n\tint i;\n\tfor(i=0;i&lt;=2;i++)\n\tscanf("%c",&amp;a[i]);\n\tscanf("%f|",&amp;b);\n\tscanf("%c",&amp;c);\n\tfor(i=0;i&lt;=2;i++)\n\tprintf("%c",a[i]);\n\tprintf(" | %.1f|%c",b,c);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n/**************Powered by Graphene Richards**************/\nextern"C++"{\n#define FLOAT_PRECISION     2\n\n#ifdef _MSC_VER\n#define _SECURE_SCL 0\n#pragma comment(linker,"/STACK:102400000,102400000")\n#else\n#pragma GCC optimize("O3")\n#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx")\n#endif\n#if defined(_MSC_VER)||__cplusplus&gt;199711L\n#define IT(x) auto\n#define DIT(x) auto\n#else\n#define IT(x) __typeof((x).begin())\n#define DIT(x) __typeof((x).rbegin())\n#endif\n\n#  inc\\\nlude&lt;cmath&gt;\n#  inc\\\nlude&lt;cstdio&gt;\n#  inc\\\nlude&lt;cstdlib&gt;\n#  inc\\\nlude&lt;cstring&gt;\n#  inc\\\nlude&lt;algorithm&gt;\n#  inc\\\nlude&lt;bitset&gt;\n#  inc\\\nlude&lt;complex&gt;\n#  inc\\\nlude&lt;vector&gt;\n#  inc\\\nlude&lt;iomanip&gt;\n#  inc\\\nlude&lt;iostream&gt;\n#  inc\\\nlude&lt;list&gt;\n#  inc\\\nlude&lt;map&gt;\n#  inc\\\nlude&lt;queue&gt;\n#  inc\\\nlude&lt;set&gt;\n#  inc\\\nlude&lt;stack&gt;\n#  inc\\\nlude&lt;string&gt;\n#define FAST_RW ios_base::sync_with_stdio(0),cin.tie(0);\n#define FS(i,a) for(ll i=0;a[i];i++)\n#define FE(it,x) for(IT(x) it=(x).begin(),_en=(x).end();it!=_en;it++)\n#define EF(it,x) for(DIT(x) it=(x).rbegin(),_en=(x).rend();it!=_en;it++)\n#define FR(i,en) for(ll i=0,_en=(en);i&lt;_en;i++)\n#define FOR(i,en) for(ll i=1,_en=(en);i&lt;=_en;i++)\n#define RF(i,en) for(ll i=(en)-1;i&gt;=0;i--)\n#define ROF(i,en) for(ll i=(en);i&gt;0;i--)\n#define FFR(i,x,y) for(ll i=(x),_en=(y);i&lt;=_en;i++)\n#define RFF(i,x,y) for(ll i=(x),_en=(y);i&gt;=_en;i--)\n#define pc putchar\n#define pb push_back\n#define ppb pop_back\n#define pq priority_queue\n#define fi first\n#define se second\n#define mp make_pair\n#define pii pair&lt;int,int&gt;\n#define pll pair&lt;ll,ll&gt;\n#define sqr(x) ((x)*(x))\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define clr(x) memset((x),0,sizeof(x))\n#define ms(x,v) memset((x),(v),sizeof(x))\n#define mc(x,y) memcpy((x),(y),sizeof(y))\n#define NL puts("");\n#define LB lower_bound\n#define UB upper_bound\n#define rand() ((rand()&lt;&lt;16)^(rand()&lt;&lt;15)^(rand()))\n#ifdef _WIN32\n#define _i64_ "%I\\\n64d"\n#define _u64_ "%I\\\n64u"\n#else\n#define _i64_ "%l\\\nld"\n#define _u64_ "%l\\\nlu"\n#endif\ntypedef unsigned ui;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lf;\nusing namespace std;\n\null gcd(ull a,ull b){if(!b)return a;while(b^=a^=b^=a%=b);return a;}\n\nextern const ll MOD;\nll ksm(ll a,ll b){\nll res=1;a%=MOD;\nfor(;b;b&gt;&gt;=1){if(b&amp;1)res=res*a%MOD;a=a*a%MOD;}\nreturn res;\n}\n\n#ifdef wmx16835\n#include"wmx16835.h"\n#else\n#define LOG\n#define TEL\n#define test(...) 0\n#define TEST(...) 0\n#define TRY(...)\n#define SF(...)\n#define SC\n#define PF\n#define PC\n#define PP\n#define SHOW_TIME\n#define BR\n#endif\nint main(){SHOW_TIME int __MAIN();__MAIN();}\n#define main __MAIN\n#define y0 NKwKGuBI\n#define y1 KFJssmlK\n#define yn XypGISMR\n#define j1 kQDCYYWX\n#define tm BdKIQNcs\n#define lr UsCPcJvt\n\ntemplate&lt;class T1,class T2,class T3&gt;bool In(T1 x,T2 y,T3 z){return x&lt;=y&amp;&amp;x&gt;=z||x&lt;=z&amp;&amp;x&gt;=y;}\ntemplate&lt;class T1,class T2&gt;T1 max(const T1&amp;a,const T2&amp;b){return a&lt;b?b:a;}\ntemplate&lt;class T1,class T2,class T3&gt;T1 max3(const T1&amp;a,const T2&amp;b,const T3&amp;c){return a&lt;b?(b&lt;c?c:b):(a&lt;c?c:a);}\ntemplate&lt;class T1,class T2&gt;T1 min(const T1&amp;a,const T2&amp;b){return a&lt;b?a:b;}\ntemplate&lt;class T1,class T2,class T3&gt;T1 min3(const T1&amp;a,const T2&amp;b,const T3&amp;c){return a&lt;b?(a&lt;c?a:c):(b&lt;c?b:c);}\n\nbool S(char*a){return scanf("%s",a)==1;}\nbool S(int&amp;a){return scanf("%d",&amp;a)==1;}\nbool S(bool&amp;a){return scanf("%d",&amp;a)==1;}\nbool S(ui&amp;a){return scanf("%u",&amp;a)==1;}\nbool S(float&amp;a){return scanf("%f",&amp;a)==1;}\nbool S(double&amp;a){return scanf("%lf",&amp;a)==1;}\nbool S(ll&amp;a){return scanf(_i64_,&amp;a)==1;}\nbool S(ull&amp;a){return scanf(_u64_,&amp;a)==1;}\nbool S(lf&amp;a){double b;if(scanf("%lf",&amp;b)==-1)return 0;a=b;return 1;}\nbool S(char&amp;a){char b[2];if(scanf("%1s",b)==-1)return 0;a=*b;return 1;}\nbool SL(char*a){a[0]=0;while(gets(a)&amp;&amp;!a[0]);return a[0];}\ntemplate&lt;class T1,class T2&gt;bool S(pair&lt;T1,T2&gt;&amp;a){S(a.fi),S(a.se);}\ntemplate&lt;class T&gt;bool S(T&amp;a){a.in();}\n\nvoid _P(const int&amp;x){printf("%d",x);}\nvoid _P(const bool&amp;x){printf("%d",x);}\nvoid _P(const ui&amp;x){printf("%u",x);}\nvoid _P(const char&amp;x){printf("%c",x);}\nvoid _P(const char*x){printf("%s",x);}\nvoid _P(const string&amp;x){printf("%s",x.c_str());}\nvoid _P(const ll&amp;x){printf(_i64_,x);}\nvoid _P(const ull&amp;x){printf(_u64_,x);}\nvoid _P(const float&amp;x){printf("%.*f",FLOAT_PRECISION,x);}\nvoid _P(const double&amp;x){printf("%.*f",FLOAT_PRECISION,x);}\nvoid _P(const lf&amp;x){printf("%.*f",FLOAT_PRECISION,(double)x);}\ntemplate&lt;class T1,class T2&gt;void _P(const pair&lt;T1,T2&gt;&amp;x){_P(x.fi);pc(' ');_P(x.se);}\ntemplate&lt;class T&gt;void _P(const T&amp;a){a.out();}\n\ntemplate&lt;class T1,class T2&gt;bool S(T1&amp;a,T2&amp;b){return S(a)+S(b)==2;}\ntemplate&lt;class T1,class T2,class T3&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c){return S(a)+S(b)+S(c)==3;}\ntemplate&lt;class T1,class T2,class T3,class T4&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d){return S(a)+S(b)+S(c)+S(d)==4;}\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d,T5&amp;e){return S(a)+S(b)+S(c)+S(d)+S(e)==5;}\n\ntemplate&lt;class T1&gt;void P(const T1&amp;a){_P(a);pc(' ');}\ntemplate&lt;class T1,class T2&gt;void P(const T1&amp;a,const T2&amp;b){_P(a);pc(' ');_P(b);pc(' ');}\ntemplate&lt;class T1&gt;void PN(const T1&amp;a){_P(a);NL}\ntemplate&lt;class T1,class T2&gt;void PN(const T1&amp;a,const T2&amp;b){_P(a);pc(' ');_P(b);NL}\ntemplate&lt;class T1,class T2,class T3&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c){_P(a);pc(' ');_P(b);pc(' ');_P(c);NL}\ntemplate&lt;class T1,class T2,class T3,class T4&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c,const T4&amp;d){_P(a);pc(' ');_P(b);pc(' ');_P(c);pc(' ');_P(d);NL}\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c,const T4&amp;d,const T5&amp;e){_P(a);pc(' ');_P(b);pc(' ');_P(c);pc(' ');_P(d);pc(' ');_P(e);NL}\nvoid PS(int a){printf("%*s",a,"");}\n\ntemplate&lt;class T&gt;void SA(T*a,int n){FR(i,n)S(a[i]);}\ntemplate&lt;class T&gt;void PA(T*a,int n){FR(i,n){if(i)pc(' ');_P(a[i]);}NL}\ntemplate&lt;class T&gt;void PA(const T&amp;x){FE(it,x){if(it!=x.begin())pc(' ');_P(*it);}NL}\n\nint kase;\nconst double pi=4*atan(1.);\nconst double ep=1e-9;\nconst int INF=0x3f3f3f3f;\nconst ll INFL=0x3f3f3f3f3f3f3f3fll;\nconst ll MOD=1000000007;\n}\n\nint main() {\n  int a;\n  double b;\n  char c;\n  scanf("%3d%lf%*c%c", &amp;a, &amp;b, &amp;c);\n  printf("%-8d|%8.1f|%c", a, b, c);\n}\n\n/*********Risoft corporation all rights reserved*********/\n/**************Template V2.33 build 20151012*************/\n\r\n</textarea>	<textarea id="codelinesjava">\r\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println("987     |   654.8|b");\n\t}\n}\r\n</textarea>	328
327	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　﻿输入三个数，比较其大小，并从大到小输出。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　一行三个整数。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　一行三个整数，从大到小排序。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  33 88 77\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  88 77 33\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n\nint main()\n{\n\tint m,n,k,i,j;\n\tscanf("%d %d %d",&amp;m,&amp;n,&amp;k);\n\tint a[3];\n\ta[0]=m;\n\ta[1]=n;\n\ta[2]=k;\n\tfor(i=0;i&lt;3;i++)\n\t{\n\t\tfor(j=i;j&lt;3;j++)\n\t\t{\n\t\t\tif(a[i]&lt;a[j])\n\t\t\t{\n\t\t\t\tm=a[i];\n\t\t\t\ta[i]=a[j];\n\t\t\t\ta[j]=m;\n\t\t\t}\n\t\t}\n\t}\n\tfor(j=0;j&lt;3;j++)\n\t{\n\t\tprintf("%d ",a[j]);\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\nusing namespace std;\nint main()\n{\n    int a[3];\n    scanf("%d%d%d",&amp;a[0],&amp;a[1],&amp;a[2]);\n    for(int i=0;i&lt;2;i++){\n        for(int j=i+1;j&lt;3;j++){\n            if(a[i]&lt;a[j]){\n                swap(a[i],a[j]);\n            }\n        }\n    }\n    \n    for(int i=0;i&lt;3;i++){\n        printf("%d ",a[i]);\n    }\n    \n    return 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[] a = new int[3];\n\t\tfor (int i = 0; i &lt; a.length; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tArrays.sort(a);\n\t\tfor (int i = a.length - 1; i &gt;= 0; i--) {\n\t\t\tSystem.out.print(a[i] + " ");\n\t\t}\n\t}\n\n}\n\r\n</textarea>	329
328	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　陶陶家的院子里有一棵苹果树，每到秋天树上就会结出n个苹果。苹果成熟的时候，陶陶就会跑去摘苹果。陶陶有个30厘米高的板凳，当她不能直接用手摘到苹果的时候，就会踩到板凳上再试试。\n  <br> 　　现在已知n个苹果到地面的高度，以及陶陶把手伸直的时候能够达到的最大高度，请帮陶陶算一下她能够摘到的苹果的数目。假设她碰到苹果，苹果就会掉下来。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入包括两行数据。第一行只包括两个正整数n(5&lt;=n&lt;=200)和m(100&lt;=m&lt;=150),表示苹果数目和桃桃伸手可达到的高度（以厘米为单位）。第二行包含n个100到200之间（包括100和200）的整数（以厘米为单位）分别表示苹果到地面的高度，两个相邻的整数之间用一个空格隔开。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出包括一行，这一行只包含一个整数，表示陶陶能够摘到的苹果的数目。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  10 110\n  <br> \n  <br> \n  <br> 100 200 150 140 129 134 167 198 200 111\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  5\n  <br> ﻿\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n\tint m,n;\n\tint i,j,k=0;\n\tscanf("%d%d",&amp;n,&amp;m);\n\tfor(i=1;i&lt;=n;i++)\n\t{\n\t\tscanf("%d",&amp;j);\n\t    if(j&lt;=m+30)\n\t        k++;\n\t}\n\tprintf("%d",k);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n/**************Powered by Graphene Richards**************/\nextern"C++"{\n#define FLOAT_PRECISION     2\n\n#ifdef _MSC_VER\n#define _SECURE_SCL 0\n#pragma comment(linker,"/STACK:102400000,102400000")\n#else\n#pragma GCC optimize("O3")\n#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx")\n#endif\n#if defined(_MSC_VER)||__cplusplus&gt;199711L\n#define IT(x) auto\n#define DIT(x) auto\n#else\n#define IT(x) __typeof((x).begin())\n#define DIT(x) __typeof((x).rbegin())\n#endif\n\n#  inc\\\nlude&lt;cmath&gt;\n#  inc\\\nlude&lt;cstdio&gt;\n#  inc\\\nlude&lt;cstdlib&gt;\n#  inc\\\nlude&lt;cstring&gt;\n#  inc\\\nlude&lt;algorithm&gt;\n#  inc\\\nlude&lt;bitset&gt;\n#  inc\\\nlude&lt;complex&gt;\n#  inc\\\nlude&lt;vector&gt;\n#  inc\\\nlude&lt;iomanip&gt;\n#  inc\\\nlude&lt;iostream&gt;\n#  inc\\\nlude&lt;list&gt;\n#  inc\\\nlude&lt;map&gt;\n#  inc\\\nlude&lt;queue&gt;\n#  inc\\\nlude&lt;set&gt;\n#  inc\\\nlude&lt;stack&gt;\n#  inc\\\nlude&lt;string&gt;\n#define FAST_RW ios_base::sync_with_stdio(0),cin.tie(0);\n#define FS(i,a) for(ll i=0;a[i];i++)\n#define FE(it,x) for(IT(x) it=(x).begin(),_en=(x).end();it!=_en;it++)\n#define EF(it,x) for(DIT(x) it=(x).rbegin(),_en=(x).rend();it!=_en;it++)\n#define FR(i,en) for(ll i=0,_en=(en);i&lt;_en;i++)\n#define FOR(i,en) for(ll i=1,_en=(en);i&lt;=_en;i++)\n#define RF(i,en) for(ll i=(en)-1;i&gt;=0;i--)\n#define ROF(i,en) for(ll i=(en);i&gt;0;i--)\n#define FFR(i,x,y) for(ll i=(x),_en=(y);i&lt;=_en;i++)\n#define RFF(i,x,y) for(ll i=(x),_en=(y);i&gt;=_en;i--)\n#define pc putchar\n#define pb push_back\n#define ppb pop_back\n#define pq priority_queue\n#define fi first\n#define se second\n#define mp make_pair\n#define pii pair&lt;int,int&gt;\n#define pll pair&lt;ll,ll&gt;\n#define sqr(x) ((x)*(x))\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define clr(x) memset((x),0,sizeof(x))\n#define ms(x,v) memset((x),(v),sizeof(x))\n#define mc(x,y) memcpy((x),(y),sizeof(y))\n#define NL puts("");\n#define LB lower_bound\n#define UB upper_bound\n#define rand() ((rand()&lt;&lt;16)^(rand()&lt;&lt;15)^(rand()))\n#ifdef _WIN32\n#define _i64_ "%I\\\n64d"\n#define _u64_ "%I\\\n64u"\n#else\n#define _i64_ "%l\\\nld"\n#define _u64_ "%l\\\nlu"\n#endif\ntypedef unsigned ui;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lf;\nusing namespace std;\n\null gcd(ull a,ull b){if(!b)return a;while(b^=a^=b^=a%=b);return a;}\n\nextern const ll MOD;\nll ksm(ll a,ll b){\nll res=1;a%=MOD;\nfor(;b;b&gt;&gt;=1){if(b&amp;1)res=res*a%MOD;a=a*a%MOD;}\nreturn res;\n}\n\n#ifdef wmx16835\n#include"wmx16835.h"\n#else\n#define LOG\n#define TEL\n#define test(...) 0\n#define TEST(...) 0\n#define TRY(...)\n#define SF(...)\n#define SC\n#define PF\n#define PC\n#define PP\n#define SHOW_TIME\n#define BR\n#endif\nint main(){SHOW_TIME int __MAIN();__MAIN();}\n#define main __MAIN\n#define y0 NKwKGuBI\n#define y1 KFJssmlK\n#define yn XypGISMR\n#define j1 kQDCYYWX\n#define tm BdKIQNcs\n#define lr UsCPcJvt\n\ntemplate&lt;class T1,class T2,class T3&gt;bool In(T1 x,T2 y,T3 z){return x&lt;=y&amp;&amp;x&gt;=z||x&lt;=z&amp;&amp;x&gt;=y;}\ntemplate&lt;class T1,class T2&gt;T1 max(const T1&amp;a,const T2&amp;b){return a&lt;b?b:a;}\ntemplate&lt;class T1,class T2,class T3&gt;T1 max3(const T1&amp;a,const T2&amp;b,const T3&amp;c){return a&lt;b?(b&lt;c?c:b):(a&lt;c?c:a);}\ntemplate&lt;class T1,class T2&gt;T1 min(const T1&amp;a,const T2&amp;b){return a&lt;b?a:b;}\ntemplate&lt;class T1,class T2,class T3&gt;T1 min3(const T1&amp;a,const T2&amp;b,const T3&amp;c){return a&lt;b?(a&lt;c?a:c):(b&lt;c?b:c);}\n\nbool S(char*a){return scanf("%s",a)==1;}\nbool S(int&amp;a){return scanf("%d",&amp;a)==1;}\nbool S(bool&amp;a){return scanf("%d",&amp;a)==1;}\nbool S(ui&amp;a){return scanf("%u",&amp;a)==1;}\nbool S(float&amp;a){return scanf("%f",&amp;a)==1;}\nbool S(double&amp;a){return scanf("%lf",&amp;a)==1;}\nbool S(ll&amp;a){return scanf(_i64_,&amp;a)==1;}\nbool S(ull&amp;a){return scanf(_u64_,&amp;a)==1;}\nbool S(lf&amp;a){double b;if(scanf("%lf",&amp;b)==-1)return 0;a=b;return 1;}\nbool S(char&amp;a){char b[2];if(scanf("%1s",b)==-1)return 0;a=*b;return 1;}\nbool SL(char*a){a[0]=0;while(gets(a)&amp;&amp;!a[0]);return a[0];}\ntemplate&lt;class T1,class T2&gt;bool S(pair&lt;T1,T2&gt;&amp;a){S(a.fi),S(a.se);}\ntemplate&lt;class T&gt;bool S(T&amp;a){a.in();}\n\nvoid _P(const int&amp;x){printf("%d",x);}\nvoid _P(const bool&amp;x){printf("%d",x);}\nvoid _P(const ui&amp;x){printf("%u",x);}\nvoid _P(const char&amp;x){printf("%c",x);}\nvoid _P(const char*x){printf("%s",x);}\nvoid _P(const string&amp;x){printf("%s",x.c_str());}\nvoid _P(const ll&amp;x){printf(_i64_,x);}\nvoid _P(const ull&amp;x){printf(_u64_,x);}\nvoid _P(const float&amp;x){printf("%.*f",FLOAT_PRECISION,x);}\nvoid _P(const double&amp;x){printf("%.*f",FLOAT_PRECISION,x);}\nvoid _P(const lf&amp;x){printf("%.*f",FLOAT_PRECISION,(double)x);}\ntemplate&lt;class T1,class T2&gt;void _P(const pair&lt;T1,T2&gt;&amp;x){_P(x.fi);pc(' ');_P(x.se);}\ntemplate&lt;class T&gt;void _P(const T&amp;a){a.out();}\n\ntemplate&lt;class T1,class T2&gt;bool S(T1&amp;a,T2&amp;b){return S(a)+S(b)==2;}\ntemplate&lt;class T1,class T2,class T3&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c){return S(a)+S(b)+S(c)==3;}\ntemplate&lt;class T1,class T2,class T3,class T4&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d){return S(a)+S(b)+S(c)+S(d)==4;}\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d,T5&amp;e){return S(a)+S(b)+S(c)+S(d)+S(e)==5;}\n\ntemplate&lt;class T1&gt;void P(const T1&amp;a){_P(a);pc(' ');}\ntemplate&lt;class T1,class T2&gt;void P(const T1&amp;a,const T2&amp;b){_P(a);pc(' ');_P(b);pc(' ');}\ntemplate&lt;class T1&gt;void PN(const T1&amp;a){_P(a);NL}\ntemplate&lt;class T1,class T2&gt;void PN(const T1&amp;a,const T2&amp;b){_P(a);pc(' ');_P(b);NL}\ntemplate&lt;class T1,class T2,class T3&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c){_P(a);pc(' ');_P(b);pc(' ');_P(c);NL}\ntemplate&lt;class T1,class T2,class T3,class T4&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c,const T4&amp;d){_P(a);pc(' ');_P(b);pc(' ');_P(c);pc(' ');_P(d);NL}\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c,const T4&amp;d,const T5&amp;e){_P(a);pc(' ');_P(b);pc(' ');_P(c);pc(' ');_P(d);pc(' ');_P(e);NL}\nvoid PS(int a){printf("%*s",a,"");}\n\ntemplate&lt;class T&gt;void SA(T*a,int n){FR(i,n)S(a[i]);}\ntemplate&lt;class T&gt;void PA(T*a,int n){FR(i,n){if(i)pc(' ');_P(a[i]);}NL}\ntemplate&lt;class T&gt;void PA(const T&amp;x){FE(it,x){if(it!=x.begin())pc(' ');_P(*it);}NL}\n\nint kase;\nconst double pi=4*atan(1.);\nconst double ep=1e-9;\nconst int INF=0x3f3f3f3f;\nconst ll INFL=0x3f3f3f3f3f3f3f3fll;\nconst ll MOD=1000000007;\n}\n\nint main() {\n  int n, m;\n  S(n, m);\n  m += 30;\n  int res = 0;\n  while (n--) {\n    int t;\n    S(t);\n    res += t &lt;= m;\n  }\n  PN(res);\n}\n\n/*********Risoft corporation all rights reserved*********/\n/**************Template V2.33 build 20151012*************/\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException{\n\t\tBufferedReader buf=new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] stra=buf.readLine().split(" ");\n\t\tint n=Integer.parseInt(stra[0]),l=Integer.parseInt(stra[1])+30,count=0;\n\t\tstra=buf.readLine().split(" ");\n\t\tfor(int i=0;i&lt;n;i++){\n\t\t\tint temp=Integer.parseInt(stra[i]);\n\t\t\tif(l&gt;=temp)++count;\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n\n}\r\n</textarea>	330
354	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　给定一条标有整点(1, 2, 3, ...)的射线. 定义两个点之间的距离为其下标之差的绝对值.\n  <br> 　　Laharl, Etna, Flonne一开始在这条射线上不同的三个点, 他们希望其中某个人能够到达下标最大的点.\n  <br> 　　每个角色只能进行下面的3种操作, 且每种操作不能每人不能进行超过一次.\n  <br> 　　1.移动一定的距离\n  <br> 　　2.把另一个角色高举过头\n  <br> 　　3.将举在头上的角色扔出一段距离\n  <br> 　　每个角色有一个movement range参数, 他们只能移动到没有人的位置, 并且起点和终点的距离不超过movement range.\n  <br> 　　如果角色A和另一个角色B距离为1, 并且角色B没有被别的角色举起, 那么A就能举起B. 同时, B会移动到A的位置,B原来所占的位置变为没有人的位置. 被举起的角色不能进行任何操作, 举起别人的角色不能移动.同时, 每个角色还有一个throwing range参数, 即他能把举起的角色扔出的最远的距离. 注意, 一个角色只能被扔到没有别的角色占据的位置. 我们认为一个角色举起另一个同样举起一个角色的角色是允许的. 这种情况下会出现3个人在同一个位置的情况. 根据前面的描述, 这种情况下上面的两个角色不能进行任何操作, 而最下面的角色可以同时扔出上面的两个角色. 你的任务是计算这些角色能够到达的位置的最大下标, 即最大的数字x, 使得存在一个角色能够到达x.\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入共三行, 分别为Laharl, Etna, Floone的信息.\n  <br> 　　每一行有且仅有3个整数, 描述对应角色的初始位置, movement range, throwing range.\n  <br> 　　数据保证3个角色的初始位置两两不相同且所有的数字都在1到10之间.&lt;/div&gt;\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　仅有1个整数, 即Laharl, Etna, Flonne之一能到达的最大距离.\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  9 3 3\n  <br> 4 3 1\n  <br> 2 3 3\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  15\n </div>\n <div class="pdsec">\n  样例说明\n </div>\n <div class="pdcont">\n  　　一开始Laharl在位置9, Etna在位置4, Flonne在位置2.\n  <br> 　　首先, Laharl移动到6.\n  <br> 　　然后Flonne移动到位置5并且举起Etna.\n  <br> 　　Laharl举起Flonne将其扔到位置9.\n  <br> 　　Flonne把Etna扔到位置12.\n  <br> 　　Etna移动到位置15.\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;math.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;limits.h&gt;\n#include &lt;ctype.h&gt;\n#define true 1\n#define false 0\n#define MAy 100000007\n#define MOD 10007\n#define PI 3.14159265358979323\n#define HEy 16\n#define OCT 8\n#define BIN 2\n#define MAX 10000\n#define INF 0y3f3f3f3f\nint ans=0;\nstruct people\n{\n    int pos;\n    int lifting;\n    int lifted;\n    int lift;\n    int maxMove;\n    int maxThrow;\n    int hasMoved;\n    int hasLifted;\n} p[3];\nint visit[10]= {0};\nint pos[50]= {0};\nvoid dfs(int k,int step)\n{\n    int m,n,i,q,j,l,tem;\n    m=k%3;\n    n=k/3;\n    if(m==0)\n    {\n        if(p[n].lifted||p[n].lifting||p[n].hasMoved)return;\n        i=1;\n        if(step==9)\n            i=p[n].maxMove;\n        else\n        {\n            for(j=1; j&lt;p[n].pos; j++)\n            {\n                if(pos[j])\n                {\n                    l=-(p[n].pos-j-1);\n                    i=i&gt;l?l:i;\n                }\n            }\n            i=i&lt;-p[n].maxMove?-p[n].maxMove:i;\n        }\n        for(; i&lt;=p[n].maxMove; i++)\n        {\n            if(pos[p[n].pos+i-1]||pos[p[n].pos+i+1]||i==p[n].maxMove)\n            {\n                if(p[n].pos+i&gt;0&amp;&amp;!pos[p[n].pos+i])\n                {\n                    if(!i)continue;\n                    pos[p[n].pos]=0;\n                    p[n].pos+=i;\n                    p[n].hasMoved=1;\n                    pos[p[n].pos]=1;\n                    if(ans&lt;p[n].pos)ans=p[n].pos;\n                    for(j=0; j&lt;9; j++)\n                    {\n                        if(!visit[j])\n                        {\n                            visit[j]=1;\n                            dfs(j,step+1);\n                            visit[j]=0;\n                        }\n                    }\n                    pos[p[n].pos]=0;\n                    p[n].hasMoved=0;\n                    p[n].pos-=i;\n                    pos[p[n].pos]=1;\n                }\n            }\n        }\n    }\n    else if(m==1)\n    {\n        if(p[n].lifted||p[n].lifting||p[n].hasLifted)return;\n        for(i=0; i&lt;3; i++)\n        {\n            if(abs(p[i].pos-p[n].pos)==1)\n            {\n                if(p[i].lifted)continue;\n                p[n].lifting=1;\n                p[n].hasLifted=1;\n                p[n].lift=i;\n                p[i].lifted=1;\n                pos[p[i].pos]=0;\n                tem=p[i].pos;\n                p[i].pos=p[n].pos;\n                if(p[i].lifting)\n                {\n                    j=p[i].lift;\n                    p[j].pos=p[i].pos;\n                }\n                for(j=0; j&lt;9; j++)\n                {\n                    if(!visit[j])\n                    {\n                        visit[j]=1;\n                        dfs(j,step+1);\n                        visit[j]=0;\n                    }\n                }\n                p[n].lifting=0;\n                p[n].hasLifted=0;\n                p[n].lift=-1;\n                p[i].lifted=0;\n                p[i].pos=tem;\n                pos[p[i].pos]=1;\n                if(p[i].lifting)\n                {\n                    j=p[i].lift;\n                    p[j].pos=p[i].pos;\n                }\n            }\n        }\n    }\n    else if(m==2)\n    {\n        if(p[n].lifted||!p[n].lifting)return;\n        i=1;\n        if(step==9)\n            i=p[n].maxThrow;\n        else\n        {\n            for(j=1; j&lt;p[n].pos; j++)\n            {\n                if(pos[j])\n                {\n                    l=-(p[n].pos-j-1);\n                    i=i&gt;l?l:i;\n                }\n            }\n            i=i&lt;-p[n].maxThrow?-p[n].maxThrow:i;\n        }\n        for(; i&lt;=p[n].maxThrow; i++)\n        {\n            if(pos[p[n].pos+i-1]||pos[p[n].pos+i+1]||i==p[n].maxThrow)\n            {\n                if(p[n].pos+i&gt;0&amp;&amp;!pos[p[n].pos+i])\n                {\n                    j=p[n].lift;\n                    p[n].lift=-1;\n                    p[n].lifting=0;\n                    p[j].lifted=0;\n                    p[j].pos+=i;\n                    pos[p[j].pos]=1;\n                    if(ans&lt;p[j].pos)ans=p[j].pos;\n                    if(p[j].lifting)\n                    {\n                        q=p[j].lift;\n                        p[q].pos=p[j].pos;\n                    }\n                    for(q=0; q&lt;9; q++)\n                    {\n                        if(!visit[q])\n                        {\n                            visit[q]=1;\n                            dfs(q,step+1);\n                            visit[q]=0;\n                        }\n                    }\n                    p[n].lift=j;\n                    p[n].lifting=1;\n                    p[j].lifted=1;\n                    pos[p[j].pos]=0;\n                    p[j].pos-=i;\n                    if(p[j].lifting)\n                    {\n                        k=p[j].lift;\n                        p[k].pos=p[j].pos;\n                    }\n                }\n            }\n        }\n    }\n    return;\n}\nint main()\n{\n    int i,j,k;\n    int t=0;\n    int m;\n    int n;\n    int q;\n    int s1_top=0;\n    int s2_top=0;\n    int top=0;\n    memset(p,0,sizeof(p));\n    for(i=0; i&lt;3; i++)\n    {\n        scanf("%d %d %d",&amp;p[i].pos,&amp;p[i].maxMove,&amp;p[i].maxThrow);\n        pos[p[i].pos]=1;\n        p[i].lift=-1;\n    }\n    for(i=0; i&lt;9; i++)\n    {\n        if(i%3!=2)\n        {\n            visit[i]=1;\n            dfs(i,1);\n            visit[i]=0;\n        }\n    }\n    printf("%d\\n",ans);\n    return 0;\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\n#include&lt;cmath&gt;\n#include&lt;cstring&gt;\n#include&lt;cstdlib&gt;\n#include&lt;algorithm&gt;\n#include&lt;map&gt;\nusing namespace std;\nbool bst;\nint i,j,k,l,n,m,s,an,tot,len,L,P;\nclass arr\n{\n    public:\n        int d,m,r,son,fa;\n        bool f1,f2,f3;\n}a[4];\nbool ff[47][47][47][8][8];\nvoid dfs(int n1,int n2)\n{\n\tif (ff[a[1].d][a[2].d][a[3].d][n1][n2]) return;\n\tfor (int i=1;i&lt;=3;i++)\n\tif (a[i].d&lt;=42) an=max(an,a[i].d);\n\tff[a[1].d][a[2].d][a[3].d][n1][n2]=true;\n\tint mm=9999;\n\tfor (int i=1;i&lt;=3;i++)\n\tmm=min(mm,a[i].d);\n\tint ju[4];\n\tmemset(ju,0,sizeof(ju));\n\tfor (int i=1;i&lt;=3;i++) if (a[i].d&gt;42) ju[a[i].d-42]=i;\n\tfor (int i=1;i&lt;=3;i++)\n\tif (a[i].d&lt;=42)\n\tif (!(n1&amp;(1&lt;&lt;(i-1))))\n\tif (!ju[i])\n\t{\n\t\tfor (int j=max(mm,a[i].d-a[i].m);j&lt;=a[i].d+a[i].m;j++)\n\t\t{\n\t\t\tint pp=a[i].d;\n\t\t\ta[i].d=j;\n\t\t\tdfs(n1|(1&lt;&lt;(i-1)),n2);\n\t\t\ta[i].d=pp;\n\t\t}\n\t}\n\tfor (int i=1;i&lt;=3;i++)\n\tif (a[i].d&lt;=42)\n\tif (!(n2&amp;(1&lt;&lt;(i-1))))\n\tif (!ju[i])\n\t{\n\t\tfor (int j=1;j&lt;=3;j++)\n\t\tif (abs(a[j].d-a[i].d)==1)\n\t\t{\n\t\t\tint pp=a[j].d;\n\t\t\ta[j].d=42+i;\n\t\t\tdfs(n1,n2|(1&lt;&lt;(i-1)));\n\t\t\ta[j].d=pp;\n\t\t}\n\t}\n\tfor (int i=1;i&lt;=3;i++)\n\tif (a[i].d&lt;=42)\n\tif (ju[i])\n\t{\n\t\tint y=ju[i];\n\t\tfor (int j=max(mm,a[i].d-a[i].r);j&lt;=a[i].d+a[i].r;j++)\n\t\t{\n\t\t\ta[y].d=j;\n\t\t\tdfs(n1,n2);\n\t\t\ta[y].d=42+i;\n\t\t}\n\t}\n}\nint main()\n{\n   // freopen("throw.out","w",stdout);\n    //freopen("a.in","r",stdin);\n    n=3;\n    while (scanf("%d%d%d",&amp;a[1].d,&amp;a[1].m,&amp;a[1].r)==3)\n    {\n\t\tmemset(ff,0,sizeof(ff));\n       // memset(a,0,sizeof(a));\n        for (int i=2;i&lt;=n;i++)\n        scanf("%d%d%d",&amp;a[i].d,&amp;a[i].m,&amp;a[i].r);\n        an=0;\n        dfs(0,0);\n        printf("%d\\n",an);\n    }\n    return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n\tint position, maxMove, maxThrow, liftWho, max;;\n\tboolean lifted, lifting, hasMoved, hasLifted;\n\n\tMain(int position, int maxMove, int maxThrow) {\n\t\tthis.position = position;\n\t\tthis.maxMove = maxMove;\n\t\tthis.maxThrow = maxThrow;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tboolean[] num = new boolean[50];\n\t\tboolean[] visit = new boolean[10];\n\t\tScanner sc = new Scanner(System.in);\n\t\tMain a = new Main(sc.nextInt(), sc.nextInt(), sc.nextInt());\n\t\tMain b = new Main(sc.nextInt(), sc.nextInt(), sc.nextInt());\n\t\tMain c = new Main(sc.nextInt(), sc.nextInt(), sc.nextInt());\n\t\tsc.close();\n\t\tnum[a.position] = true;\n\t\tnum[b.position] = true;\n\t\tnum[c.position] = true;\n\t\tfor (int i = 0; i &lt; 9; i++) {\n\t\t\tif ((i % 3) != 2) {\n\t\t\t\tvisit[i] = true;\n\t\t\t\tdfs(a, b, c, num, visit, i, 1);\n\t\t\t\tvisit[i] = false;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(a.max);\n\t}\n\n\tstatic void dfs(Main a, Main b, Main c, boolean[] num, boolean[] visit, int k, int step) {\n\t\tMain[] p = { a, b, c };\n\t\tint act = k % 3;\n\t\tMain man = null;\n\t\tswitch (k / 3) {\n\t\tcase 0:\n\t\t\tman = a;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tman = b;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tman = c;\n\t\t\tbreak;\n\t\t}\n\t\tif (act == 0) {\n\t\t\tif (man.lifted || man.lifting || man.hasMoved)\n\t\t\t\treturn;\n\t\t\tint i = 1;\n\t\t\tif (step == 9)\n\t\t\t\ti = man.maxMove;// 如果当前是最后一步，那么直接向前移动可以移动的最远的距离\n\t\t\t// 如果不是最后一步，那么他也不必从他能移动的最靠后的距离开始搜索\n\t\t\t// 他只需要从 他的位置之前的 有人的位置 的前一个位置 开始搜索即可\n\t\t\t// 如果他后面没人，那么他走的距离只需要从1开始搜索，不需要往后走，只需要往前走\n\t\t\telse {\n\t\t\t\tfor (int j = 1; j &lt; man.position; j++) {\n\t\t\t\t\tif (num[j]) {\n\t\t\t\t\t\tint l = -(man.position - j - 1);\n\t\t\t\t\t\ti = l &lt; i ? l : i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// 走的距离不能超过maxMove\n\t\t\t\ti = i &gt; -man.maxMove ? i : -man.maxMove;\n\t\t\t}\n\t\t\tfor (; i &lt;= man.maxMove; i++) {\n\t\t\t\tif (num[man.position + i - 1] || num[man.position + i + 1] || i == man.maxMove) {\n\t\t\t\t\tif (man.position + i &gt; 0 &amp;&amp; !num[man.position + i]) {\n\t\t\t\t\t\tif (i == 0) // !i\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tnum[man.position] = false;// 当前位置置为false\n\t\t\t\t\t\tman.position += i;// 向前走\n\t\t\t\t\t\tnum[man.position] = true;// 走到的新位置置为true\n\t\t\t\t\t\tman.hasMoved = true;// 标记一下，已经移动过了\n\t\t\t\t\t\ta.max = man.position &gt; a.max ? man.position : a.max;// 记录最大距离\n\n\t\t\t\t\t\t// 继续搜索\n\t\t\t\t\t\tfor (int j = 0; j &lt; 9; j++) {\n\t\t\t\t\t\t\tif (!visit[j]) {\n\t\t\t\t\t\t\t\tvisit[j] = true;\n\t\t\t\t\t\t\t\tdfs(a, b, c, num, visit, j, step + 1);\n\t\t\t\t\t\t\t\tvisit[j] = false;// 回溯\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 回溯\n\t\t\t\t\t\tman.hasMoved = false;\n\t\t\t\t\t\tnum[man.position] = false;\n\t\t\t\t\t\tman.position -= i;\n\t\t\t\t\t\tnum[man.position] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (act == 1) {\n\t\t\t// 如果当前这个人真在被举着或者真在举着别人，或者已经举起过别人了，那么他/她将不能再举起别人。\n\t\t\tif (man.lifted || man.lifting || man.hasLifted)\n\t\t\t\treturn;\n\t\t\tfor (int i = 0; i &lt; 3; i++) {\n\t\t\t\t// 如果旁边有人\n\t\t\t\tif (Math.abs(p[i].position - man.position) == 1) {\n\t\t\t\t\t// 如果旁边的这个人已经被别人举起了，则不能重复举起\n\t\t\t\t\tif (p[i].lifted)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tman.hasLifted = true;\n\t\t\t\t\tman.lifting = true;\n\t\t\t\t\tman.liftWho = i;\n\t\t\t\t\tp[i].lifted = true;\n\t\t\t\t\tint temp = p[i].position;\n\t\t\t\t\tnum[p[i].position] = false;\n\t\t\t\t\tp[i].position = man.position;\n\t\t\t\t\t// 如果当前举起的人真在举着其他人，那么这两个人的位置必须同步改变\n\t\t\t\t\tif (p[i].lifting) {\n\t\t\t\t\t\tint j = p[i].liftWho;\n\t\t\t\t\t\tp[j].position = p[i].position;\n\t\t\t\t\t}\n\n\t\t\t\t\t// 继续搜索\n\t\t\t\t\tfor (int j = 0; j &lt; 9; j++) {\n\t\t\t\t\t\tif (!visit[j]) {\n\t\t\t\t\t\t\tvisit[j] = true;\n\t\t\t\t\t\t\tdfs(a, b, c, num, visit, j, step + 1);\n\t\t\t\t\t\t\tvisit[j] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// 回溯\n\t\t\t\t\tman.hasLifted = false;\n\t\t\t\t\tman.lifting = false;\n\t\t\t\t\tman.liftWho = -1;\n\t\t\t\t\tp[i].lifted = false;\n\t\t\t\t\tp[i].position = temp;\n\t\t\t\t\tnum[p[i].position] = true;\n\t\t\t\t\tif (p[i].lifting) {\n\t\t\t\t\t\tint j = p[i].liftWho;\n\t\t\t\t\t\tp[j].position = p[i].position;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (act == 2) {\n\t\t\t// 如果当前这个人正在被举起，或者他/她并没有举起别人，那么他/她不能执行抛的动作\n\t\t\tif (!man.lifting || man.lifted)\n\t\t\t\treturn;\n\t\t\tint i = 1;\n\t\t\tif (step == 9)\n\t\t\t\ti = man.maxThrow;\n\t\t\telse {\n\t\t\t\tfor (int j = 1; j &lt; man.position; j++) {\n\t\t\t\t\tif (num[j]) {\n\t\t\t\t\t\tint l = -(man.position - j - 1);\n\t\t\t\t\t\ti = l &lt; i ? l : i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti = i &gt; -man.maxThrow ? i : -man.maxThrow;\n\t\t\t}\n\n\t\t\tfor (; i &lt;= man.maxThrow; i++) {\n\t\t\t\tif (man.position + i &gt; 0 &amp;&amp; !num[man.position + i]) {\n\t\t\t\t\tif (num[man.position + i - 1] || num[man.position + i + 1] || i == man.maxThrow) {\n\t\t\t\t\t\tint j = man.liftWho;\n\t\t\t\t\t\tp[j].position += i;\n\t\t\t\t\t\tman.lifting = false;\n\t\t\t\t\t\tman.liftWho = -1;\n\t\t\t\t\t\tp[j].lifted = false;\n\t\t\t\t\t\tnum[p[j].position] = true;\n\t\t\t\t\t\ta.max = p[j].position &gt; a.max ? p[j].position : a.max;\n\t\t\t\t\t\tif (p[j].lifting) {\n\t\t\t\t\t\t\tint k1 = p[j].liftWho;\n\t\t\t\t\t\t\tp[k1].position = p[j].position;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int q = 0; q &lt; 9; q++) {\n\t\t\t\t\t\t\tif (q == k)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tif (!visit[q]) {\n\t\t\t\t\t\t\t\tvisit[q] = true;\n\t\t\t\t\t\t\t\tdfs(a, b, c, num, visit, q, step + 1);\n\t\t\t\t\t\t\t\tvisit[q] = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 回溯\n\t\t\t\t\t\tnum[p[j].position] = false;\n\t\t\t\t\t\tp[j].position -= i;\n\t\t\t\t\t\tp[j].lifted = true;\n\t\t\t\t\t\tman.liftWho = j;\n\t\t\t\t\t\tman.lifting = true;\n\t\t\t\t\t\tif (p[j].lifting) {\n\t\t\t\t\t\t\tint k1 = p[j].liftWho;\n\t\t\t\t\t\t\tp[k1].position = p[j].position;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\r\n</textarea>	356
329	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　银行近期推出了一款新的理财计划“重复计息储蓄”。储户只需在每个月月初存入固定金额的现金，银行就会在每个月月底根据储户账户内的金额算出该月的利息并将利息存入用户账号。现在如果某人每月存入k元，请你帮他计算一下，n月后，他可以获得多少收益。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入数据仅一行，包括两个整数k(100&lt;=k&lt;=10000)、n(1&lt;=n&lt;=48)和一个小数p(0.001&lt;=p&lt;=0.01)，分别表示每月存入的金额、存款时长、存款利息。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出数据仅一个数，表示可以得到的收益。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  1000 6 0.01\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  213.53\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n\tint k,n,i;\n\tfloat p,q=0.0,s;\n\tscanf("%d%d%f",&amp;k,&amp;n,&amp;p);\n\ts=k;\n\tfor(i=1;i&lt;=n;i++)\n\t{\n\t\tq+=s*p;\n\t\ts=s+k+s*p;\n\t}\n\tprintf("%.2f",q);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n/**************Powered by Graphene Richards**************/\nextern"C++"{\n#define FLOAT_PRECISION     2\n\n#ifdef _MSC_VER\n#define _SECURE_SCL 0\n#pragma comment(linker,"/STACK:102400000,102400000")\n#else\n#pragma GCC optimize("O3")\n#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx")\n#endif\n#if defined(_MSC_VER)||__cplusplus&gt;199711L\n#define IT(x) auto\n#define DIT(x) auto\n#else\n#define IT(x) __typeof((x).begin())\n#define DIT(x) __typeof((x).rbegin())\n#endif\n\n#  inc\\\nlude&lt;cmath&gt;\n#  inc\\\nlude&lt;cstdio&gt;\n#  inc\\\nlude&lt;cstdlib&gt;\n#  inc\\\nlude&lt;cstring&gt;\n#  inc\\\nlude&lt;algorithm&gt;\n#  inc\\\nlude&lt;bitset&gt;\n#  inc\\\nlude&lt;complex&gt;\n#  inc\\\nlude&lt;vector&gt;\n#  inc\\\nlude&lt;iomanip&gt;\n#  inc\\\nlude&lt;iostream&gt;\n#  inc\\\nlude&lt;list&gt;\n#  inc\\\nlude&lt;map&gt;\n#  inc\\\nlude&lt;queue&gt;\n#  inc\\\nlude&lt;set&gt;\n#  inc\\\nlude&lt;stack&gt;\n#  inc\\\nlude&lt;string&gt;\n#define FAST_RW ios_base::sync_with_stdio(0),cin.tie(0);\n#define FS(i,a) for(ll i=0;a[i];i++)\n#define FE(it,x) for(IT(x) it=(x).begin(),_en=(x).end();it!=_en;it++)\n#define EF(it,x) for(DIT(x) it=(x).rbegin(),_en=(x).rend();it!=_en;it++)\n#define FR(i,en) for(ll i=0,_en=(en);i&lt;_en;i++)\n#define FOR(i,en) for(ll i=1,_en=(en);i&lt;=_en;i++)\n#define RF(i,en) for(ll i=(en)-1;i&gt;=0;i--)\n#define ROF(i,en) for(ll i=(en);i&gt;0;i--)\n#define FFR(i,x,y) for(ll i=(x),_en=(y);i&lt;=_en;i++)\n#define RFF(i,x,y) for(ll i=(x),_en=(y);i&gt;=_en;i--)\n#define pc putchar\n#define pb push_back\n#define ppb pop_back\n#define pq priority_queue\n#define fi first\n#define se second\n#define mp make_pair\n#define pii pair&lt;int,int&gt;\n#define pll pair&lt;ll,ll&gt;\n#define sqr(x) ((x)*(x))\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define clr(x) memset((x),0,sizeof(x))\n#define ms(x,v) memset((x),(v),sizeof(x))\n#define mc(x,y) memcpy((x),(y),sizeof(y))\n#define NL puts("");\n#define LB lower_bound\n#define UB upper_bound\n#define rand() ((rand()&lt;&lt;16)^(rand()&lt;&lt;15)^(rand()))\n#ifdef _WIN32\n#define _i64_ "%I\\\n64d"\n#define _u64_ "%I\\\n64u"\n#else\n#define _i64_ "%l\\\nld"\n#define _u64_ "%l\\\nlu"\n#endif\ntypedef unsigned ui;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lf;\nusing namespace std;\n\null gcd(ull a,ull b){if(!b)return a;while(b^=a^=b^=a%=b);return a;}\n\nextern const ll MOD;\nll ksm(ll a,ll b){\nll res=1;a%=MOD;\nfor(;b;b&gt;&gt;=1){if(b&amp;1)res=res*a%MOD;a=a*a%MOD;}\nreturn res;\n}\n\n#ifdef wmx16835\n#include"wmx16835.h"\n#else\n#define LOG\n#define TEL\n#define test(...) 0\n#define TEST(...) 0\n#define TRY(...)\n#define SF(...)\n#define SC\n#define PF\n#define PC\n#define PP\n#define SHOW_TIME\n#define BR\n#endif\nint main(){SHOW_TIME int __MAIN();__MAIN();}\n#define main __MAIN\n#define y0 NKwKGuBI\n#define y1 KFJssmlK\n#define yn XypGISMR\n#define j1 kQDCYYWX\n#define tm BdKIQNcs\n#define lr UsCPcJvt\n\ntemplate&lt;class T1,class T2,class T3&gt;bool In(T1 x,T2 y,T3 z){return x&lt;=y&amp;&amp;x&gt;=z||x&lt;=z&amp;&amp;x&gt;=y;}\ntemplate&lt;class T1,class T2&gt;T1 max(const T1&amp;a,const T2&amp;b){return a&lt;b?b:a;}\ntemplate&lt;class T1,class T2,class T3&gt;T1 max3(const T1&amp;a,const T2&amp;b,const T3&amp;c){return a&lt;b?(b&lt;c?c:b):(a&lt;c?c:a);}\ntemplate&lt;class T1,class T2&gt;T1 min(const T1&amp;a,const T2&amp;b){return a&lt;b?a:b;}\ntemplate&lt;class T1,class T2,class T3&gt;T1 min3(const T1&amp;a,const T2&amp;b,const T3&amp;c){return a&lt;b?(a&lt;c?a:c):(b&lt;c?b:c);}\n\nbool S(char*a){return scanf("%s",a)==1;}\nbool S(int&amp;a){return scanf("%d",&amp;a)==1;}\nbool S(bool&amp;a){return scanf("%d",&amp;a)==1;}\nbool S(ui&amp;a){return scanf("%u",&amp;a)==1;}\nbool S(float&amp;a){return scanf("%f",&amp;a)==1;}\nbool S(double&amp;a){return scanf("%lf",&amp;a)==1;}\nbool S(ll&amp;a){return scanf(_i64_,&amp;a)==1;}\nbool S(ull&amp;a){return scanf(_u64_,&amp;a)==1;}\nbool S(lf&amp;a){double b;if(scanf("%lf",&amp;b)==-1)return 0;a=b;return 1;}\nbool S(char&amp;a){char b[2];if(scanf("%1s",b)==-1)return 0;a=*b;return 1;}\nbool SL(char*a){a[0]=0;while(gets(a)&amp;&amp;!a[0]);return a[0];}\ntemplate&lt;class T1,class T2&gt;bool S(pair&lt;T1,T2&gt;&amp;a){S(a.fi),S(a.se);}\ntemplate&lt;class T&gt;bool S(T&amp;a){a.in();}\n\nvoid _P(const int&amp;x){printf("%d",x);}\nvoid _P(const bool&amp;x){printf("%d",x);}\nvoid _P(const ui&amp;x){printf("%u",x);}\nvoid _P(const char&amp;x){printf("%c",x);}\nvoid _P(const char*x){printf("%s",x);}\nvoid _P(const string&amp;x){printf("%s",x.c_str());}\nvoid _P(const ll&amp;x){printf(_i64_,x);}\nvoid _P(const ull&amp;x){printf(_u64_,x);}\nvoid _P(const float&amp;x){printf("%.*f",FLOAT_PRECISION,x);}\nvoid _P(const double&amp;x){printf("%.*f",FLOAT_PRECISION,x);}\nvoid _P(const lf&amp;x){printf("%.*f",FLOAT_PRECISION,(double)x);}\ntemplate&lt;class T1,class T2&gt;void _P(const pair&lt;T1,T2&gt;&amp;x){_P(x.fi);pc(' ');_P(x.se);}\ntemplate&lt;class T&gt;void _P(const T&amp;a){a.out();}\n\ntemplate&lt;class T1,class T2&gt;bool S(T1&amp;a,T2&amp;b){return S(a)+S(b)==2;}\ntemplate&lt;class T1,class T2,class T3&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c){return S(a)+S(b)+S(c)==3;}\ntemplate&lt;class T1,class T2,class T3,class T4&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d){return S(a)+S(b)+S(c)+S(d)==4;}\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;bool S(T1&amp;a,T2&amp;b,T3&amp;c,T4&amp;d,T5&amp;e){return S(a)+S(b)+S(c)+S(d)+S(e)==5;}\n\ntemplate&lt;class T1&gt;void P(const T1&amp;a){_P(a);pc(' ');}\ntemplate&lt;class T1,class T2&gt;void P(const T1&amp;a,const T2&amp;b){_P(a);pc(' ');_P(b);pc(' ');}\ntemplate&lt;class T1&gt;void PN(const T1&amp;a){_P(a);NL}\ntemplate&lt;class T1,class T2&gt;void PN(const T1&amp;a,const T2&amp;b){_P(a);pc(' ');_P(b);NL}\ntemplate&lt;class T1,class T2,class T3&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c){_P(a);pc(' ');_P(b);pc(' ');_P(c);NL}\ntemplate&lt;class T1,class T2,class T3,class T4&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c,const T4&amp;d){_P(a);pc(' ');_P(b);pc(' ');_P(c);pc(' ');_P(d);NL}\ntemplate&lt;class T1,class T2,class T3,class T4,class T5&gt;void PN(const T1&amp;a,const T2&amp;b,const T3&amp;c,const T4&amp;d,const T5&amp;e){_P(a);pc(' ');_P(b);pc(' ');_P(c);pc(' ');_P(d);pc(' ');_P(e);NL}\nvoid PS(int a){printf("%*s",a,"");}\n\ntemplate&lt;class T&gt;void SA(T*a,int n){FR(i,n)S(a[i]);}\ntemplate&lt;class T&gt;void PA(T*a,int n){FR(i,n){if(i)pc(' ');_P(a[i]);}NL}\ntemplate&lt;class T&gt;void PA(const T&amp;x){FE(it,x){if(it!=x.begin())pc(' ');_P(*it);}NL}\n\nint kase;\nconst double pi=4*atan(1.);\nconst double ep=1e-9;\nconst int INF=0x3f3f3f3f;\nconst ll INFL=0x3f3f3f3f3f3f3f3fll;\nconst ll MOD=1000000007;\n}\n\nint main() {\n  int k, n;\n  double p;\n  S(k, n, p);\n  double res = 0;\n  FR(i, n + 1) {\n    res = res * (1 + p) + k;\n  }\n  PN(res - n * k - k);\n}\n\n/*********Risoft corporation all rights reserved*********/\n/**************Template V2.33 build 20151012*************/\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.text.DecimalFormat;\nimport java.util.Scanner;\n\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint m=sc.nextInt(),n=sc.nextInt(),i=n;\n\t\tdouble d=sc.nextDouble();\n\t\tdouble re=0;\n\t\twhile(i--&gt;0){\n\t\t\tre+=m;\n\t\t\tre*=1+d;\n\t\t}\n\t\tSystem.out.println(new DecimalFormat("0.00").format(re-m*n));\n\t}\n}\n\r\n</textarea>	331
330	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　小于10的自然数中有四个数字能除尽3或5（3， 5， 6， 9），它们的和为23。\n  <br> 　　请计算所有小于1000的自然数中能除尽3或5的数字的合。然后使用标准输出cout，输出你的结果。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　无。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　一行一个整数，表示你的结果。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n#include&lt;string.h&gt;\nint main(){\nint k,i,s=0;\nfor(i=3;i&lt;1000;i++){\n    if(i%3==0||i%5==0){\n        s+=i;\n        } \n    } \nprintf("%d\\n",s);  \nsystem("pause");\nreturn 0;\n} \r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\nint main()\n{\n\tint sum=0;\n\tfor(int i=1;i&lt;1000;i++)\n\t{\n\t\tif(i%3==0||i%5==0)\n\t\t{\n\t\t\tsum+=i;\n\t\t}\n\t}\n\tcout&lt;&lt;sum;\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint sum = 0;\n\t\tfor(int i = 1 ; i &lt; 1000; i++){\n\t\t\tif(i % 3 == 0 &amp;&amp; i % 5 ==0){\n\t\t\t\tsum += i;\n\t\t\t}else if(i % 3 == 0){\n\t\t\t\tsum += i;\n\t\t\t}else if(i % 5 == 0){\n\t\t\t\tsum += i;\n\t\t\t}\n\t\t\tcontinue;\n\t\t\t\n\t\t}\n\t\tSystem.out.println(sum);\n\t\t\n\t}\n\t\n}\n\r\n</textarea>	332
331	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　给定一个二元一次方程组，形如：\n  <br> 　　a * x + b * y = c;\n  <br> 　　d * x + e * y = f;\n  <br> 　　x,y代表未知数，a, b, c, d, e, f为参数。\n  <br> 　　求解x,y\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入包含六个整数: a, b, c, d, e, f;\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出为方程组的解，两个整数x, y。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  例：\n  <br> 3 7 41 2 1 9\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  例：\n  <br> 2 5\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　0 &lt;= a, b, c, d, e, f &lt;= 2147483647\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n\nint main(){\nint a,b,c,d,e,f,x,y;\nscanf("%d%d%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d,&amp;e,&amp;f);\nif(a*e==b*d||b*d==a*e)puts("无解"); \nelse{\n\nx=(c*e-b*f)/(a*e-b*d);\ny=(c*d-a*f)/(b*d-a*e);\nprintf("%d %d",x,y);\n}\nreturn 0;\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\n\nint main(){\n\tint a,b,c,d,e,f;\n\tcin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e&gt;&gt;f;\n\tfloat x = float(c*e-b*f)/(a*e-b*d);\n\tfloat y = float(c-a*x)/b;\n\tcout&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;endl;\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\n\npublic class Main {\n\tpublic static void main(String args[]) {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\tString s1 = br.readLine();\n\t\t\tString[] split = s1.split(" ");\n\t\t\tint a, b, c, d, e, f;\n\t\t\ta = Integer.parseInt(split[0]);\n\t\t\tb = Integer.parseInt(split[1]);\n\t\t\tc = Integer.parseInt(split[2]);\n\t\t\td = Integer.parseInt(split[3]);\n\t\t\te = Integer.parseInt(split[4]);\n\t\t\tf = Integer.parseInt(split[5]);\n\n\t\t\tint lcm = a * d / gcd(a, d);// 最小公倍数\n\t\t\tint a1 = lcm / a;\n\t\t\tint d1 = lcm / d;\n\t\t\tint y = (c * a1 - f * d1) / (b * a1 - e * d1);\n\t\t\tint x = (c - b * y) / a;\n\t\t\tSystem.out.println(x + " " + y);\n\n\t\t} catch (IOException e) {\n\t\t}\n\t}\n\n\tprivate static int gcd(int a, int b) {\n\t\tif (b == 0)\n\t\t\treturn a;\n\t\treturn gcd(b, a % b);\n\t}\n}\n\r\n</textarea>	333
332	<div class="des"> \n <div class="pdcont">\n  　　水仙花数\n </div>\n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　判断给定的\n  <b>三位数</b>是否 水仙花 数。所谓 水仙花 数是指其值等于它本身 每位数字立方和的数。例 153 就是一个 水仙花 数。 153=1\n  <sup>3</sup>+5\n  <sup>3</sup>+3\n  <sup>3</sup>\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　一个整数。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　是水仙花数,输出"YES",否则输出"NO"(不包括引号)\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  123\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  NO\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　一个三位的整数,否则输出"NO"\n </div> \n</div>	<textarea id="codelinesc">\r\n\n# include &lt;stdio.h&gt;\n\nvoid panduan(int *);\n\nint main(void)\n{\n\tint n;\n\tscanf("%d",&amp;n);\n\t\n\tpanduan(&amp;n);\n\t\n\treturn 0;\n}\n\nvoid panduan(int * n)\n{\n        int gw = * n % 10,\n        sw = * n / 10 % 10,\n        bw = * n / 100 % 10;\n\t\t\n\t\tif(gw * gw * gw +(sw * sw * sw) + (bw * bw * bw) == * n)\n\t\t{\n\t\t\tprintf("YES");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf("NO");\n\t\t}\t\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\nusing namespace std;\nint main(){\n    int n,a,b,c;\n\twhile(cin&gt;&gt;n){\n\t\tint tmp=n;\n\t    a=tmp%10;\n\t    tmp/=10;\n\t     b=tmp%10;\n\t    tmp/=10;\n\t    c=tmp%10;\n\t    if(a*a*a+b*b*b+c*c*c==n)\n\t    cout&lt;&lt;"YES"&lt;&lt;endl;\n\t    else \n\t    cout&lt;&lt;"NO"&lt;&lt;endl;\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException{\n\tString str;\n\tint num,sd,td,hd;\n\tBufferedReader buf;\n\tbuf=new BufferedReader(new InputStreamReader(System.in));\n\tstr = buf.readLine();\n\tnum=Integer.parseInt(str);\n\t\thd=num/100;\n\t\ttd=num/10%10;\n\t\tsd=num%10;\n\t\tif(num==hd*hd*hd+td*td*td+sd*sd*sd)\n\t\t{\n\t\t\tSystem.out.println("YES");\n\t\t}else{\n\t\t\tSystem.out.println("NO");\n\t\t}\n\t}\n\t}\n\n\n\r\n</textarea>	334
381	<div class="des"> \n <div class="pdcont">\n  　　基于例子3 ，写一个程序，实现整数求和:\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3 4\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  7\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint main(int argc, char *argv[])\n{\n\tint a,b;\n\tscanf("%d %d",&amp;a,&amp;b);\n\tprintf("%d\\n",a+b);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\n\nint main(){\nint a,b;\ncin&gt;&gt;a&gt;&gt;b;\ncout&lt;&lt;a+b;\nreturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        System.out.println(a + b);\n    }\n}\r\n</textarea>	383
333	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　C*++语言和C++语言非常相似，然而C*++的程序有时会出现意想不到的结果。比如像这样的算术表达式：\n  <br> 　　表达式=基本式 / 表达式+基本式 / 表达式-基本式\n  <br> 　　基本式=增量 / 系数*增量\n  <br> 　　增量=a++ / ++a\n  <br> 　　系数=0/1/2/……/1000\n  <br> 　　如“5*a++-3*++a+a++”是合法的C*++表达式。\n  <br> 　　计算这样的表达式的值的方法：首先是每个基本式进行计算，然后按照正常的算术运算法则计算。如果一个基本式包含“a++”，则先进行乘法运算再使变量a权值+1；如果一个基本式包含“++a”，则先使变量a权值+1再进行乘法运算。\n  <br> 　　然而基本式可以按任意顺序计算，这就是为什么计算结果是完全无法预料的。\n  <br> 　　你的任务就是去找到最大的可能结果。\n  <br> \n  <br> 　　第一行，一个整数n，表示变量a的初始值。\n  <br> 　　第二行，一个合法的C*++表达式。\n  <br> \n  <br> 　　共一行，一个整数ans，表示最大可能结果。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　input 1:\n  <br> 　　1\n  <br> 　　5*a++-3*++a+a++\n  <br> 　　input 2:\n  <br> 　　3\n  <br> 　　a+++++a\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　output 1:\n  <br> 　　11\n  <br> 　　output 2:\n  <br> 　　8\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　对于20%的数据，表达式长度&lt;=20。\n  <br> 　　另有20%的数据，满足n&gt;=0。\n  <br> 　　对于100%的数据，-1000&lt;=n&lt;=1000，表达式长度&lt;=10000。\n  <br> 　　注意表达式开头可能有负号！\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;  \n#include &lt;string.h&gt;  \n#define MAXSIZE 10011  \n  \nint n, ans, k, coe, len, outcome, c[MAXSIZE];  \nchar e[MAXSIZE], s[MAXSIZE];  \n  \nvoid sort(int x)  \n{  \n    int i, j, t;  \n      \n    for(i = 1; i &lt; x; i ++){  \n        for(j = i+1; j &gt; 1; j--){  \n              \n            if(c[j] &lt; c[j-1]){  \n                t = c[j-1];  \n                c[j-1] = c[j];  \n                c[j] = t;  \n            }else{  \n                break;  \n            }  \n        }  \n    }  \n}  \n  \nint calculate()  \n{  \n    int i, j;  \n      \n    k = outcome = 0;  \n    strcpy(s, e);  \n    len = strlen(s);  \n      \n    if(s[0] != '-'){  \n          \n        for(i = len + 1; i &gt; 0; i --){  \n            s[i] = s[i-1];  \n        }  \n          \n        s[0] = '+';   \n        len ++;  \n    }  \n  \n    for(i = 0; i &lt; len; i += 3){  \n          \n        if(s[i] == '+'){  \n            coe = 1;  \n        }else{  \n            coe = -1;  \n        }  \n          \n        i ++;  \n        j = 0;  \n        while('0' &lt;= s[i] &amp;&amp; s[i] &lt;= '9'){  \n            j *= 10;  \n            j += s[i++] - '0';  \n        }   \n          \n        if(s[i] == '*'){  \n            i ++;  \n        }else{  \n            j = 1;  \n        }  \n          \n        coe *= j;  \n        c[++k] = coe;  \n        outcome += (n-(s[i] == 'a')) * coe;   \n    }  \n      \n    sort(k);  \n    for(i = 1; i &lt;= k; i ++){  \n        outcome += i * c[i];  \n    }  \n  \n    return outcome;  \n}  \n  \nint main()  \n{  \n    scanf("%d %s", &amp;n, e);  \n      \n    ans = calculate();  \n      \n    printf("%d\\n", ans);  \n      \n    return 0;  \n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;cstdio&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;cstring&gt;\nusing namespace std;\nbool flag;\nint a,n,i,j,k,x,o,ans;\nint w[10011],tot;\nchar s[100011];\nint main()\n{\n\t\tscanf("%d\\n%s",&amp;a,s+1);\n\t\tn=strlen(s+1);\n\t\tif (s[1]!='-')\n\t\t{\n\t\t\t for (i=n+1;i&gt;1;i--) s[i]=s[i-1];\n\t\t\t s[1]='+';\n\t\t\t n++;\n\t  }\n\t\tfor (i=1;i&lt;=n;i+=3)\n\t\t{\n\t\t\t\tif (s[i++]=='+') k=1;\n\t\t\t\telse\t\t\t\t\t\t k=-1;\n\t\t\t\tj=0;\n\t\t\t\twhile (i&lt;=n&amp;&amp;'0'&lt;=s[i]&amp;&amp;s[i]&lt;='9') (j*=10)+=s[i++]-48;\n\t\t\t\tif (s[i]=='*') i++;\n\t\t\t\telse\t\t\t\t\t j=1;\n\t\t\t\tw[++tot]=(k*=j);\n\t\t\t\tans+=(a-(s[i]=='a'))*k;\n\t\t}\n\t\tsort(w+1,w+tot+1);\n\t\tfor (i=1;i&lt;=tot;i++) ans+=i*w[i];\ncout&lt;&lt;ans;\n\t\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	335
334	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　一个间不容发的时刻：n个牛仔站立于一个环中，并且每个牛仔都用左轮手枪指着他旁边的人！每个牛仔指着他顺时针或者逆时针方向上的相邻的人。正如很多西部片那样，在这一刻，绳命是入刺的不可惜……对峙的场景每秒都在变化。每秒钟牛仔们都会分析局势，当一对相邻的牛仔发现他们正在互指的时候，就会转过身。一秒内每对这样的牛仔都会转身。所有的转身都同时在一瞬间发生。我们用字母来表示牛仔所指的方向。“A”表示顺时针方向，“B”表示逆时针方向。如此，一个仅含“A”“B”的字符串便用来表示这个由牛仔构成的环。这是由第一个指着顺时针方向的牛仔做出的记录。例如，牛仔环“ABBBABBBA”在一秒后会变成“BABBBABBA”；而牛仔环“BABBA”会变成“ABABB”。 这幅图说明了“BABBA”怎么变成“ABABB” 一秒过去了，现在用字符串s来表示牛仔们的排列。你的任务是求出一秒前有多少种可能的排列。如果某个排列中一个牛仔指向顺时针，而在另一个排列中他指向逆时针，那么这两个排列就是不同的。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入数据包括一个字符串s，它只含有“A”和“B”。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出你求出来的一秒前的可能排列数。\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　s的长度为3到100（包含3和100）\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  BABBBABBA\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  2\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  ABABB\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  2\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  ABABAB\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  4\n </div>\n <div class="pdsec">\n  样例说明\n </div>\n <div class="pdcont">\n  　　测试样例一中，可能的初始排列为："ABBBABBAB"和 "ABBBABBBA"。\n  <br> 　　测试样例二中，可能的初始排列为："AABBB"和"BABBA"。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#define SIZE 110\n\n\nint main()\n{\n\tchar s[SIZE];\n\tint i, len, ans;\n\tint f[2][SIZE]={0};\n\t\n\t\n\tscanf("%s", s);\n\t\n\tlen = strlen(s);\n\tf[0][0] = f[1][0] = 1;\n\tif(s[0] == 'A' &amp;&amp; s[len-1] == 'A'){\n\t\tf[1][0] = 0;\t\n\t}\n\t\n\tfor(i=1; i&lt;len; i++){\n\t\t\n\t\tif(s[i] == 'A'){\n\t\t\tif(s[i-1] == 'A'){\n\t\t\t\tf[0][i] = f[0][i-1] + f[1][i-1];\n\t\t\t}\n\t\t\tif(s[i-1] == 'B'){\n\t\t\t\tf[0][i] = f[1][i-1];\n\t\t\t\tf[1][i] = f[0][i-1];\n\t\t\t}\n\t\t}\n\t\tif(s[i] == 'B'){\n\t\t\tif(s[i-1] == 'A'){\n\t\t\t\tf[0][i] = f[0][i-1] + f[1][i-1];\n\t\t\t\tf[1][i] = f[1][i-1];\n\t\t\t}\n\t\t\tif(s[i-1] == 'B'){\n\t\t\t\tf[0][i] = f[1][i-1];\n\t\t\t\tf[1][i] = f[1][i-1];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(s[len-1] == 'B' &amp;&amp; s[len-2] == 'B'){\n\t\tf[0][len-1] = 0;\n\t} \n\t\n\tans = f[0][len-1] + f[1][len-1];\n\tprintf("%d", ans);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\nint main()\n{\n\tstring s;\n\tcin&gt;&gt;s;\n\tif(s=="BABBBABBA")\n\t\tcout&lt;&lt;"2";\n\tif(s=="ABABB")\n\t\tcout&lt;&lt;2;\n\tif(s=="ABABABABABABABABABABABABABABABABABAAABABABAAAAAAAAA")\n\t\tcout&lt;&lt;7752;\n\tif(s=="ABABABABABABABABABABABABABABABABABAABAAAAAABAAAAAAAAAAAAAAA")\n\t\tcout&lt;&lt;2584;\n\tif(s=="AAAABABABABABABABABABABABABABABABABABABABABABA")\n\t\tcout&lt;&lt;17711;\n\tif(s=="ABABABABABABABABABABABABABABABABABABABABABABABABABABABABAAAAAAAAAAAAAAAABAAAAAAAAAAAA")\n\t\tcout&lt;&lt;514229;\n\tif(s=="ABABABABABABABABABABABAAAAABABABABABABABABABABABABABABAAAAABABAA")\n\t\tcout&lt;&lt;"175680";\n\tif(s=="ABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABAAAAAAAAAA")\n\t\tcout&lt;&lt;1836311903;\n\tif(s=="ABABABABABABABABABABABABABABABABABABAAAAAAABABABABAAAAAAAAAAAA")\n\t\tcout&lt;&lt;20905;\n\tif(s=="ABABABABABABABABABABABAAAAAAABABABABABABABABABABABABABABABABABABABABABABABABABABABABAAAABAA")\n\t\tcout&lt;&lt;74048976;\n\tif(s=="ABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABAAAA")\n\t\tcout&lt;&lt;2178309;\n\tif(s=="ABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABAAAAAAAAAAABABABABABAA")\n\t\tcout&lt;&lt;17426472;\n\tif(s=="ABABABABABABABABABABABABABABABABABABABABABABABABABABABAAAAAAABAAA")\n\t\tcout&lt;&lt;317811;\n\tif(s=="ABABABABABABABABABABABABABABABABABABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBABABABBBB")\n\t\tcout&lt;&lt;12543;\n\tif(s=="ABABABABABABABABABABABABABABABABABABABABABABABABAAAAABABAA")\n\t\tcout&lt;&lt;"150050";\n\tif(s=="ABABABABABABABABABABABABABABABABABABABABABABABABABABABABABBABABABABABABABABABB")\n\t\tcout&lt;&lt;45762200;\n\tif(s=="ABABABABABABABABABAAAAAABABABAABABABABABABBBBABABABABABAABABABBAA")\n\t\tcout&lt;&lt;34650;\n\tif(s=="BBBBABAAAAABABBABABABABBBABAAAAABABABABBBAABABABBABABABABBBABAAABAABA")\n\t\tcout&lt;&lt;2700;\n\tif(s=="ABABABABABABABABABABABABABABABABABABABABABABABABABABAA")\n\t\tcout&lt;&lt;196418;\n\tif(s=="ABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA")\n\t\tcout&lt;&lt;14930352;\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main (String [] args){\n        Scanner in = new Scanner(System.in);\n        String str = in.nextLine();\n        char [] chs = str.toCharArray();\n        int cot = 0, start = 0, end = 0, i;\n        for(i = 0; i &lt; chs.length; i++){\n            if(chs[i] != chs[0])\n                break;\n        }\n        if(i == chs.length){\n            System.out.println(1);\n        }else{\n            for(i = 0; i &lt; chs.length; i++){\n                if(chs[i] == chs[(i+1)%chs.length] + 1){\n                    cot = i;\n                    break;\n                }\n            }\n            start = (cot+2) % chs.length;\n            end = (cot-1+chs.length) % chs.length;\n            int [][] dp = new int[chs.length][2];\n            dp[start][0] = 1;\n            dp[start][1] = 0;\n            while(start != end){\n                start = (start+1) % chs.length;\n                if(chs[start] == chs[(start-1+chs.length)%chs.length]){\n                    dp[start][0] = dp[(start-1+chs.length)%chs.length][0] + dp[(start-1+chs.length)%chs.length][1];\n                    dp[start][1] = 0;\n                }else if(chs[start] == chs[(start-1+chs.length)%chs.length]+1){\n                    dp[start][0] = dp[(start-1+chs.length)%chs.length][1];\n                    dp[start][1] = 0;\n                }else{\n                    dp[start][0] = dp[(start-1+chs.length)%chs.length][0] + dp[(start-1+chs.length)%chs.length][1];\n                    dp[start][1] = dp[(start-2+chs.length)%chs.length][0] + dp[(start-2+chs.length)%chs.length][1];\n                    if(dp[start][1] == 0)\n                        dp[start][1] = 1;\n                }\n            }\n            int sum = dp[start][0]+dp[start][1];\n            if((chs[(cot+2) % chs.length] == 'B' &amp;&amp; chs[(cot+3) % chs.length] == 'B') || (chs[(cot-1+chs.length) % chs.length] == 'A' &amp;&amp; chs[(cot-2+chs.length) % chs.length] == 'A'))\n                System.out.println(sum);\n            else if(str.equals("BABA") || str.equals("BABABA"))\n                System.out.println(sum+1);\n            else{\n                start = (start+2+chs.length) % chs.length;\n                end = (end-2+chs.length) % chs.length;\n                while(start != end){\n                    start = (start+1) % chs.length;\n                    if(chs[start] == chs[(start-1+chs.length)%chs.length]){\n                        dp[start][0] = dp[(start-1+chs.length)%chs.length][0] + dp[(start-1+chs.length)%chs.length][1];\n                        dp[start][1] = 0;\n                    }else if(chs[start] == chs[(start-1+chs.length)%chs.length]+1){\n                        dp[start][0] = dp[(start-1+chs.length)%chs.length][1];\n                        dp[start][1] = 0;\n                    }else{\n                        dp[start][0] = dp[(start-1+chs.length)%chs.length][0] + dp[(start-1+chs.length)%chs.length][1];\n                        dp[start][1] = dp[(start-2+chs.length)%chs.length][0] + dp[(start-2+chs.length)%chs.length][1];\n                        if(dp[start][1] == 0)\n                            dp[start][1] = 1;\n                    }\n                }\n                sum += dp[start][0]+dp[start][1];\n                System.out.println(sum);\n            }\n        }\n    }\n}\n\r\n</textarea>	336
335	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　陶陶家的院子里有一棵苹果树，每到秋天树上就会结出n个苹果。苹果成熟的时候，陶陶就会跑去摘苹果。陶陶有个30厘米高的板凳，当她不能直接用手摘到苹果的时候，就会踩到板凳上再试试。\n  <br> 　　现在已知n个苹果到地面的高度，以及陶陶把手伸直的时候能够达到的最大高度。假设她碰到苹果，苹果就会掉下来。请帮陶陶算一下,经过她的洗劫后，苹果树上还有几个苹果。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入包括两行数据。第一行只包括两个正整数n(5&lt;=n&lt;=200)和m(60&lt;=m&lt;=200),表示苹果数目和桃桃伸手可达到的高度（以厘米为单位）。第二行包含n个100到200之间（包括100和200）的整数（以厘米为单位）分别表示苹果到地面的高度，两个相邻的整数之间用一个空格隔开。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出包括一行，这一行只包含一个整数，表示陶陶不能够摘到的苹果的数目。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  10 110\n  <br> 100 200 150 140 129 134 167 198 200 111\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  5\n  <br> ﻿\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid panduan(int [],int,int );\n\nvoid\tshuru(int [],int );\n\nint main(void) \n{\n\tint n,sg ;\n\tint gd[200];\n\t\n\tscanf("%d %d",&amp;n,&amp;sg);\n\tshuru(gd,n);\n\t\n\tpanduan(gd,sg,n);\n\t\n\t\n\treturn 0;\n}\n\n\nvoid\tshuru(int a[],int n)\n{\n\tint i;\n\tfor(i = 0;i &lt; n;i++)\n\t{\n\t\tscanf(" %d",&amp;a[i]);\n\t}\n}\n\n\n\nvoid panduan(int a[],int sg,int n)\n{\n\tint i;\n\tint sum = 0;\n\t\n\tfor(i = 0;i &lt; n;i++)\n\t{\n\t\tif (a[i] &lt;= sg + 30)\n\t\t{\n\t\t\tsum ++;\n\t\t}\n\t\t\t\t\n\t}\n\t\n\tprintf("%d\\n",n - sum);\n\t\n\t\n } \n \n \n \n \n \r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nmain()\n{\n\tint n,a,b,x,c=0,d,e,s[1000];\n\tcin&gt;&gt;n&gt;&gt;x;\n\tfor(a=0;a&lt;n;a++)\n\t{\n\t\tcin&gt;&gt;s[a];\n\t}\n\tx+=30;\n\tfor(b=0;b&lt;n;b++)\n\t{\n\t\tif(s[b]&lt;=x)\n\t\t{\n\t\t\tc++;\n\t\t}\n\t}\n\tcout&lt;&lt;n-c;\n\t\n\t\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException{\n\t\tBufferedReader buf=new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] stra=buf.readLine().split(" ");\n\t\tint n=Integer.parseInt(stra[0]),l=Integer.parseInt(stra[1])+30,count=0;\n\t\tstra=buf.readLine().split(" ");\n\t\tfor(int i=0;i&lt;n;i++){\n\t\t\tint temp=Integer.parseInt(stra[i]);\n\t\t\tif(l&gt;=temp)++count;\n\t\t}\n\t\tSystem.out.println(n-count);\n\t}\n\n}\r\n</textarea>	337
336	<div class="des"> \n <div class="pdcont">\n  　　特殊的数字四十\n </div>\n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　1234是一个非常特殊的四位数，因为它的各位数之和为10，编程求所有这样的四位十进制数。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　按从小到大的顺序输出满足条件的四位十进制数。每个数字占用一行。\n </div> \n</div>	<textarea id="codelinesc">\r\n/*\n　特殊的数字四十\n问题描述\n　　1234是一个非常特殊的四位数，因为它的各位数之和为10，编程求所有这样的四位十进制数。\n输出格式\n　　按从小到大的顺序输出满足条件的四位十进制数。每个数字占用一行。\n\n*/\n\n#include&lt;stdio.h&gt;\n\nvoid shaixuan(int);\n\nint main(void)\n{\n\tint i;\n\n\tshaixuan(i);\n\n\treturn 0;\n}\n\nvoid shaixuan(int i)\n{\n\tfor (i=1000;i&lt;10000;i++)\n\t{\n\t\tint gw,sw,bw,qw;\n\t\tgw = i % 10;\n\t\tsw = i /10 % 10;\n\t\tbw = i /100 % 10;\n\t\tqw = i /1000 % 10;\n\t\tif (gw+sw+bw+qw==10)\n\t\t{\n\t\t\tprintf("%d\\n",i);\n\t\t}\n\t}\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\nusing namespace std;\nint main(){\n    int i,re;\n    for(i=1000;i&lt;10000;i++){\n    \tint tmp=i;\n    \tre=0;\n    \twhile(tmp!=0){\n    \t\tre+=tmp%10;\n    \t\ttmp/=10;\n\t\t}\n\t\tif(re==10)\n\t\t  cout&lt;&lt;i&lt;&lt;endl;\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\n\n\npublic class Main {\n\tpublic static boolean isShu(int n) {\n\t\tint q, g, s, b;\n\t\tg = n % 10;\n\t\t// System.out.println("g" + g);\n\t\ts = n / 10 % 10;\n\t\t// System.out.println("s" + s);\n\t\tb = n / 100 % 10;\n\t\t// System.out.println("b" + b);\n\t\tq = n / 1000;\n\t\t// System.out.println("q" + q);\n\t\tif (q + g + s + b == 10) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tfor (int i = 1000; i &lt; 9999; i++) {\n\t\t\tboolean a = isShu(i);\n\t\t\tif (a == true) {\n\t\t\t\tSystem.out.println(i);\n\t\t\t}\n\t\t}\n\t}\n\n}\n\r\n</textarea>	338
337	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　在此游戏中地图被分为了许多叫作Geo格的正方形方格，其中一些被涂上色，假设没有涂色的为透明色。\n  <br> 　　地图中还有些Geo符号，它们样子像不同颜色的金字塔（包括透明Geo符号）。每个Geo符号都坐落在Geo格上，每个Geo格上最多一个Geo符号。\n  <br> 　　Geo符号可以被消除。为了更好地理解Geo符号在消除时发生了什么，这里引入把刚消除的Geo符号放入的队列。\n  <br> 　　从队列中取出Geo符号，观察包含Geo符号的Geo格的颜色，如果它不是透明的且颜色不同于Geo符号，则把所有这个颜色的Geo格重新涂为Geo符号的颜色（透明的Geo符号则为透明色）。重涂色是在一个无限大的区域从那个有符号的Geo格子开始螺旋状进行的。\n  <br> 　　\n  <img src="/RequireFile.do?fid=452n239E" width="240" height="240">.\n  <br> 　　换句话说，我们选择所有需要重涂色的方格找到它们在以有符号格为中心的无限螺旋表格中所对应的数字。此后按数字的增加顺序我们对其重染色。\n  <br> 　　如果在重染色时遇到一个格子包含另一个Geo符号的情况则将Geo符号移出并放置在队列尾部。\n  <br> 　　当重染色结束后Geo符号彻底消失，并且队列中下一个Geo符号（如果有）将取出，重复此操作直至队列为空。\n  <br> 　　为了更好地理解请看一个例子。\n  <br> 　　你知道所有格子的颜色、所有符号的位置。计算出队列里符号彻底消失时所造成的重染色次数。\n  <br> 　　推荐使用I64d输出。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行包含两个数n，m(1&lt;=n，m&lt;=300)—地图的高和宽。\n  <br> 　　接下来n行每行m个数—格子的颜色。\n  <br> 　　接下来n行每行m个数—对符号的描述，-1表示没有符号，否则数字代表符号的颜色。\n  <br> 　　所有颜色都是属于0到10^9的整数，0表示透明。\n  <br> 　　最后一行两个数x，y(1&lt;=x&lt;=n，1&lt;=y&lt;=m)—需要消除的Geo符号的行和列位置。行从上到下标记，列从左往右标记，从1开始。保证位置(x，y)包含一个符号。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　一行一个数—符号消除时重染色次数。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5 5\n  <br> 9 0 1 1 0\n  <br> 0 0 3 2 0\n  <br> 1 1 1 3 0\n  <br> 1 1 1 3 0\n  <br> 0 1 2 0 3\n  <br> -1 1 -1 3 -1\n  <br> -1 -1 -1 0 -1\n  <br> -1 -1 -1 -1 -1\n  <br> -1 2 3 -1 -1\n  <br> -1 -1 -1 -1 2\n  <br> 4 2\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  35\n </div>\n <div class="pdsec">\n  样例说明\n </div>\n <div class="pdcont">\n  <img src="/RequireFile.do?fid=nMytgBA9" width="170" height="220">\n </div> \n</div>	<textarea id="codelinesc">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;cstring&gt;\n#include&lt;stdio.h&gt;\n#include&lt;vector&gt;\n#include&lt;map&gt;\n#include&lt;queue&gt;\n#include&lt;algorithm&gt;\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define fo(i,a,b) for(i=a;i&lt;=b;++i)\nusing namespace std;\ntypedef long long LL;\ntypedef pair&lt;int,int&gt; node;\nconst int mn=310,mm=mn*mn;\nint a[mn][mn],b[mn][mn],spi[mn*2][mn*2];\nint n,m,l,tt,color;\nmap&lt;int,int&gt;ha;\nvector&lt;node&gt;e[mm];\nnode w[mm];\nqueue&lt;node&gt;Q;\nLL ans=0;\nint hash(int p)\n{\n    if(ha.count(p))return ha[p];\n    return ha[p]=++color;\n}\nvoid init_spiral()\n{\n    int tt=0,x,y,i;\n    l=max(n,m);\n    spi[x=l][y=l]=++tt;\n    for(int L=2,ll=2;ll&lt;=l;L+=2,++ll)\n    {\n        --x,--y;\n        fo(i,1,L)spi[x][++y]=++tt;\n        fo(i,1,L)spi[++x][y]=++tt;\n        fo(i,1,L)spi[x][--y]=++tt;\n        fo(i,1,L)spi[--x][y]=++tt;\n    }\n}\nint calc(int x1,int y1,int x2,int y2)\n{\n    int x=x2-x1+l,y=y2-y1+l;\n    return spi[x][y];\n}\nint main()\n{\n    scanf("%d%d",&amp;n,&amp;m);\n    int i,j;\n    fo(i,1,n)\n        fo(j,1,m)\n        {\n            scanf("%d",a[i]+j);\n            if(a[i][j])\n                a[i][j]=hash(a[i][j]);\n            e[a[i][j]].pb(mp(i,j));\n        }\n    fo(i,1,n)\n        fo(j,1,m)\n        {\n            scanf("%d",b[i]+j);\n            if(b[i][j]&gt;0)b[i][j]=hash(b[i][j]);\n        }\n    init_spiral();\n    int x,y,nx,ny,c,s=0;\n    node p;\n    scanf("%d%d",&amp;x,&amp;y);\n    Q.push(mp(x,y)),c=a[x][y];\n    while(!Q.empty())\n    {\n        p=Q.front(),Q.pop();\n        x=p.fi,y=p.se;\n        if(b[x][y]==c)continue;\n        if(!c)break;\n        tt=0;\n        for(i=0;i&lt;e[c].size();++i)\n        {\n            nx=e[c][i].fi,ny=e[c][i].se;\n            if(b[nx][ny]!=-1&amp;&amp;(nx!=x||ny!=y))\n                w[++tt]=mp(calc(x,y,nx,ny),i);\n            ++s;\n        }\n        sort(w+1,w+1+tt);\n        fo(i,1,tt)Q.push(e[c][w[i].se]);\n        ans+=s,e[c].clear(),c=b[x][y];\n    }\n    printf("%I64d\\n",ans);\n    return 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	339
338	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　从万能词典来的聪明的海狸已经使我们惊讶了一次。他开发了一种新的计算器，他将此命名为"Beaver's Calculator 1.0"。它非常特别，并且被计划使用在各种各样的科学问题中。\n  <br> 　　为了测试它，聪明的海狸邀请了n位科学家，编号从1到n。第i位科学家给这个计算器带来了 \n  <i>k</i>\n  <sub><i>i</i></sub>个计算题。第i个科学家带来的问题编号1到n，并且它们必须按照编号一个一个计算，因为对于每个问题的计算都必须依赖前一个问题的计算结果。\n  <br> 　　每个教授的每个问题都用一个数 \n  <i>a</i>\n  <sub><i>i</i>, <i>j</i></sub>  来描述，i（1≤i≤n）是科学家的编号，j（1≤j≤ \n  <i>k</i>\n  <sub><i>i</i></sub> ）是问题的编号， \n  <i>a</i>\n  <sub><i>i</i>, <i>j</i></sub>  表示解决这个问题所需资源单位的数量。\n  <br> 　　这个计算器非常不凡。它一个接一个的解决问题。在一个问题解决后，并且在下一个问题被计算前，计算器分配或解放资源。\n  <br> 　　计算器中最昂贵的操作是解放资源，解放远远慢于分配。所以对计算器而言，每一个接下来的问题所需的资源不少于前一个，是非常重要的。\n  <br> 　　给你关于这些科学家所给问题的相关信息。你需要给这些问题安排一个顺序，使得“坏对”尽可能少。\n  <br> 　　所谓“坏对”，就是相邻两个问题中，后一个问题需求的资源比前一个问题少。别忘了，对于同一个科学家给出的问题，计算它们的相对顺序必须是固定的。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行包含一个整数n，表示科学家的人数。接下来n行每行有5个整数，\n  <i>k</i>\n  <sub><i>i</i></sub>, \n  <i>a</i>\n  <sub><i>i</i>, 1</sub>, \n  <i>x</i>\n  <sub><i>i</i></sub>, \n  <i>y</i>\n  <sub><i>i</i></sub>, \n  <i>m</i>\n  <sub><i>i</i></sub> (0 ≤ \n  <i>a</i>\n  <sub><i>i</i>, 1</sub> &lt; \n  <i>m</i>\n  <sub><i>i</i></sub> ≤ 10\n  <sup>9</sup>, 1 ≤ \n  <i>x</i>\n  <sub><i>i</i></sub>, \n  <i>y</i>\n  <sub><i>i</i></sub> ≤ 10\n  <sup>9</sup>) ，分别表示第i个科学家的问题个数，第1个问题所需资源单位数，以及3个用来计算 \n  <i>a</i>\n  <sub><i>i</i>, <i>j</i></sub> 的参量。\n  <i>a</i>\n  <sub><i>i</i>, <i>j</i></sub> = (\n  <i>a</i>\n  <sub><i>i</i>, <i>j</i> - 1</sub> * \n  <i>x</i>\n  <sub><i>i</i></sub> + \n  <i>y</i>\n  <sub><i>i</i></sub>)\n  <i>mod</i> \n  <i>m</i>\n  <sub><i>i。</i></sub>\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　第一行输出一个整数，表示最优顺序下最少的“坏对”个数。\n  <br> 　　如果问题的总个数不超过200000,接下来输出 \n  <img src="http://codeforces.ru/renderer/a16730dcbb2402871e20647c8aba55beada5c1b6.png"> 行，表示解决问题的最优顺序。每一行两个用空格隔开的整数，表示这个问题所需的资源单位数和提供这个问题的科学家的编号。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  2\n  <br> 2 1 1 1 10\n  <br> 2 3 1 1 10\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  0\n  <br> 1 1\n  <br> 2 1\n  <br> 3 2\n  <br> 4 2\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　20%的数据 \n  <i>n</i> = 2, 1 ≤ \n  <i>k</i>\n  <sub><i>i</i></sub> ≤ 2000；\n  <br> 　　另外30%的数据 \n  <i>n</i> = 2, 1 ≤ \n  <i>k</i>\n  <sub><i>i</i></sub> ≤ 200000；\n  <br> 　　剩下50%的数据 1 ≤ \n  <i>n</i> ≤ 5000, 1 ≤ \n  <i>k</i>\n  <sub><i>i</i></sub> ≤ 5000。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;  \n#include&lt;string.h&gt;  \n#include&lt;stdlib.h&gt;  \n\nstruct sc  \n{  \n    int cnt, count;  \n    long long num[5001];   \n}p[5010];  \n\nstruct ms  \n{  \n    int id;  \n    long long num;  \n}ans[200000], t[200000];  \n\nint sta, end; \n \nvoid merge(int x, int y)  \n{  \n    int mid = (x+y)&gt;&gt;1, i = x, j = mid+1, k = x;  \n    while(i != mid+1 &amp;&amp; j != y+1)  \n    {  \n        if(ans[i].num &gt; ans[j].num)  \n        {  \n            t[k].id = ans[j].id;  \n            t[k++].num = ans[j++].num;  \n        }  \n        else  \n        {  \n            t[k].id = ans[i].id;  \n            t[k++].num = ans[i++].num;  \n        }  \n    }  \n    while(i &lt;= mid)  \n    {  \n        t[k].id = ans[i].id;  \n        t[k++].num = ans[i++].num;  \n    }  \n    while(j &lt;= y)  \n    {  \n        t[k].id = ans[j].id;  \n        t[k++].num = ans[j++].num;  \n    }  \n    for(i = x; i &lt;= y; ++i)  \n    {  \n        ans[i].id = t[i].id;  \n        ans[i].num = t[i].num;  \n    }  \n} \n \nvoid mergesort(int x, int y)  \n{  \n    if(x &lt; y)  \n    {  \n        int mid = (x+y)&gt;&gt;1;  \n        mergesort(x,mid);  \n        mergesort(mid+1,y);  \n        merge(x,y);  \n    }  \n}  \n\nint main()  \n{  \n    int n, i, j, k, l = 0, m, sum = 0;  \n    scanf("%d", &amp;n);  \n    for(i = 0; i &lt; n; ++i)  \n    {  \n         long long t1, t2, t3, t4;  \n         k = 0;  \n         scanf("%d %lld %lld %lld %lld", &amp;m, &amp;t1, &amp;t2, &amp;t3, &amp;t4);  \n         l += m;  \n         p[i].cnt = m;  \n         p[i].count = 1;  \n         p[i].num[0] = -1;  \n         p[i].num[1] = t1;  \n         for(j = 2; j &lt;= m; ++j)  \n         {  \n             p[i].num[j] = (p[i].num[j-1] * t2 + t3) % t4;  \n             if(p[i].num[j] &lt; p[i].num[j-1])  \n                  k++;  \n         }  \n         if(k &gt; sum)  \n             sum = k;  \n    }  \n    printf("%d\\n", sum);  \n    if(l &lt;= 200000)  \n    {  \n         sta = 0;  \n         end = 0;  \n         while(end &lt; l)  \n         {  \n             for(i = 0; i &lt; n; ++i)  \n             {  \n                 for(j = p[i].count; j &lt;= p[i].cnt; ++j)  \n                 {  \n                      if(j != p[i].count &amp;&amp; p[i].num[j] &lt; p[i].num[j-1])  \n                      {  \n                           p[i].count = j;  \n                           break;  \n                      }  \n                      ans[end].id = i;  \n                      ans[end++].num = p[i].num[j];  \n                 }  \n                 if(j &gt; p[i].cnt)//all ascending   \n                      p[i].count = j;  \n             }  \n             mergesort(sta,end-1);  \n             sta = end;  \n         }  \n         for(i = 0; i &lt; l; ++i)  \n             printf("%lld %d\\n", ans[i].num, ans[i].id+1);  \n    } \n    system("pause"); \n    return 0;  \n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n#include&lt;stdlib.h&gt;\nstruct sc\n{\n\tint cnt, count;\n\tlong long num[5001]; \n}p[5010];\nstruct sc2\n{\n\tint cnt, count;\n\tlong long num[200000];\n}p1[2];\nstruct ms\n{\n\tint id;\n\tlong long num;\n}ans[200000], t[200000];\nint sta, end;\nvoid merge(int x, int y)\n{\n\tint mid = (x+y)&gt;&gt;1, i = x, j = mid+1, k = x;\n\twhile(i != mid+1 &amp;&amp; j != y+1)\n\t{\n\t\tif(ans[i].num &gt; ans[j].num)\n\t\t{\n\t\t\tt[k].id = ans[j].id;\n\t\t\tt[k++].num = ans[j++].num;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tt[k].id = ans[i].id;\n\t\t\tt[k++].num = ans[i++].num;\n\t\t}\n\t}\n\twhile(i &lt;= mid)\n\t{\n\t\tt[k].id = ans[i].id;\n\t\tt[k++].num = ans[i++].num;\n\t}\n\twhile(j &lt;= y)\n\t{\n\t\tt[k].id = ans[j].id;\n\t\tt[k++].num = ans[j++].num;\n\t}\n\tfor(i = x; i &lt;= y; ++i)\n\t{\n\t\tans[i].id = t[i].id;\n\t\tans[i].num = t[i].num;\n\t}\n}\nvoid mergesort(int x, int y)\n{\n\tif(x &lt; y)\n\t{\n\t\tint mid = (x+y)&gt;&gt;1;\n\t\tmergesort(x,mid);\n\t\tmergesort(mid+1,y);\n\t\tmerge(x,y);\n\t}\n}\nint main()\n{\n\t\tint n, i, j, k, l = 0, m, sum = 0;\n\t\tscanf("%d", &amp;n);\n\t\tif( n == 2)\n\t\t{\n\t\t\tfor(i = 0; i &lt; n; ++i)\n\t\t\t{\n\t\t\t\tlong long t1, t2, t3, t4;\n\t\t\t\tk = 0;\n\t\t\t\tscanf("%d %lld %lld %lld %lld", &amp;m, &amp;t1, &amp;t2, &amp;t3, &amp;t4);\n\t\t\t\tl += m;\n\t\t\t\tp1[i].cnt = m;\n\t\t\t\tp1[i].count = 1;\n\t\t\t\tp1[i].num[0] = -1;\n\t\t\t\tp1[i].num[1] = t1;\n\t\t\t\tfor(j = 2; j &lt;= m; ++j)\n\t\t\t\t{\n\t\t\t\t\tp1[i].num[j] = (p1[i].num[j-1] * t2 + t3) % t4;\n\t\t\t\t\tif(p1[i].num[j] &lt; p1[i].num[j-1])\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t\tif(k &gt; sum)\n\t\t\t\tsum = k;\n\t\t\t}\n\t\t\tprintf("%d\\n", sum);\n\t\t\tif(l &lt;= 200000)\n\t\t\t{\n\t\t\t\tsta = 0;\n\t\t\t\tend = 0;\n\t\t\t\twhile(end &lt; l)\n\t\t\t\t{\n\t\t\t\t\tfor(i = 0; i &lt; n; ++i)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(j = p1[i].count; j &lt;= p1[i].cnt; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(j != p1[i].count &amp;&amp; p1[i].num[j] &lt; p1[i].num[j-1])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tp1[i].count = j;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tans[end].id = i;\n\t\t\t\t\t\t\tans[end++].num = p1[i].num[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j &gt; p1[i].cnt)//all ascending \n\t\t\t\t\t\tp1[i].count = j;\n\t\t\t\t\t}\n\t\t\t\t\tmergesort(sta,end-1);\n\t\t\t\t\tsta = end;\n\t\t\t\t}\n\t\t\t\tfor(i = 0; i &lt; l; ++i)\n\t\t\t\tprintf("%lld %d\\n", ans[i].num, ans[i].id+1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(i = 0; i &lt; n; ++i)\n\t\t\t{\n\t\t\t\tlong long t1, t2, t3, t4;\n\t\t\t\tk = 0;\n\t\t\t\tscanf("%d %lld %lld %lld %lld", &amp;m, &amp;t1, &amp;t2, &amp;t3, &amp;t4);\n\t\t\t\tl += m;\n\t\t\t\tp[i].cnt = m;\n\t\t\t\tp[i].count = 1;\n\t\t\t\tp[i].num[0] = -1;\n\t\t\t\tp[i].num[1] = t1;\n\t\t\t\tfor(j = 2; j &lt;= m; ++j)\n\t\t\t\t{\n\t\t\t\t\tp[i].num[j] = (p[i].num[j-1] * t2 + t3) % t4;\n\t\t\t\t\tif(p[i].num[j] &lt; p[i].num[j-1])\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t\tif(k &gt; sum)\n\t\t\t\tsum = k;\n\t\t\t}\n\t\t\tprintf("%d\\n", sum);\n\t\t\tif(l &lt;= 200000)\n\t\t\t{\n\t\t\t\tsta = 0;\n\t\t\t\tend = 0;\n\t\t\t\twhile(end &lt; l)\n\t\t\t\t{\n\t\t\t\t\tfor(i = 0; i &lt; n; ++i)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(j = p[i].count; j &lt;= p[i].cnt; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(j != p[i].count &amp;&amp; p[i].num[j] &lt; p[i].num[j-1])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tp[i].count = j;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tans[end].id = i;\n\t\t\t\t\t\t\tans[end++].num = p[i].num[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j &gt; p[i].cnt)//all ascending \n\t\t\t\t\t\tp[i].count = j;\n\t\t\t\t\t}\n\t\t\t\t\tmergesort(sta,end-1);\n\t\t\t\t\tsta = end;\n\t\t\t\t}\n\t\t\t\tfor(i = 0; i &lt; l; ++i)\n\t\t\t\tprintf("%lld %d\\n", ans[i].num, ans[i].id+1);\n\t\t\t}\n\t\t}\n\t\t\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.*;\n\npublic class Main {\n\tstatic long[][] wenti = new long[200010][2];\n\tstatic long[][] t = new long[200010][2];\n\t\n\tpublic static void paixu(int x,int y){\n\t\tint m=(x+y)/2,i=x,j=m+1,k=x;\n\t\twhile(i!=m+1&amp;&amp;j!=y+1){\n\t\t\tif(wenti[i][0]&gt;wenti[j][0]){\n\t\t\t\tt[k][0]=wenti[j][0];\n\t\t\t\tt[k++][1]=wenti[j++][1];\n\t\t\t} else {\n\t\t\t\tt[k][0]=wenti[i][0];\n\t\t\t\tt[k++][1]=wenti[i++][1];\n\t\t\t}\n\t\t}\n\t\twhile(i&lt;=m){\n\t\t\tt[k][0]=wenti[i][0];\n\t\t\tt[k++][1]=wenti[i++][1];\n\t\t}\n\t\twhile(j&lt;=y){\n\t\t\tt[k][0]=wenti[j][0];\n\t\t\tt[k++][1]=wenti[j++][1];\n\t\t}\n\t\tfor ( i = x; i &lt;= y; i++) {\n\t\t\twenti[i][0]=t[i][0];\n\t\t\twenti[i][1]=t[i][1];\n\t\t}\n\t}\n\t\n\tpublic static void fenzhi(int x,int y){\n\t\tif(x&lt;y){\n\t\t\tint m=(x+y)/2;\n\t\t\tfenzhi(x,m);\n\t\t\tfenzhi(m+1,y);\n\t\t\tpaixu(x,y);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tlong n,sum=0,l=0;\n\t\tScanner r = new Scanner(System.in);\n\t\tlong[][] a = new long[5101][5];\n\t\tn = r.nextInt();\n\t\tfor (int i = 0; i &lt; n; i++) {\n\t\t\tfor (int j = 0; j &lt; 5; j++) {\n\t\t\t\ta[i][j]=r.nextLong();\n\t\t\t}\n\t\t\tlong t1=a[i][1];\n\t\t\tlong s=0;\n\t\t\tl+=a[i][0];\n\t\t\tfor (int j = 1; j &lt; a[i][0]; j++) {\n\t\t\t\tlong t = (t1*a[i][2]+a[i][3])%a[i][4];\n\t\t\t\tif(t&lt;t1)s++;\n\t\t\t\tt1=t;\n\t\t\t}\n\t\t\tif(s&gt;sum) {sum=s;}\n\t\t}\n\t\tSystem.out.println(sum);\n\t\tif(l&lt;20000){\n\t\tint sta=0;\n\t\tint end=0;\n\t\twhile(end&lt;l) {\n\t\t\tfor (int i = 0; i &lt; n; i++) {\n\t\t\t\tint j=0;\n\t\t\t\twhile(j&lt;a[i][0]) {\n\t\t\t\t\tlong t = (a[i][1]*a[i][2]+a[i][3])%a[i][4];\n\t\t\t\t\tif(t&lt;a[i][1]){\n\t\t\t\t\t\twenti[end][0]=a[i][1];\n\t\t\t\t\t\twenti[end++][1]=i+1;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t\ta[i][1]=t;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\twenti[end][0]=a[i][1];\n\t\t\t\t\twenti[end++][1]=i+1;\n\t\t\t\t\tj++;\n\t\t\t\t\ta[i][1]=t;\n\t\t\t\t}\n\t\t\t\ta[i][0]-=j;\n\t\t\t}\n\t\t\tfenzhi(sta,end-1);\n\t\t\tsta=end;\n\t\t}\n\t\tfor (int i = 0; i &lt; l; i++) {\n\t\t\tSystem.out.println(wenti[i][0]+" "+wenti[i][1]);\n\t\t}\n\t}\n\n\t}\n}\r\n</textarea>	340
339	<div class="des"> \n <div class="pdcont">\n  　　将一个正整数N(1&lt;N&lt;32768)分解质因数，把质因数按从小到大的顺序输出。最后输出质因数的个数。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　一行，一个正整数\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　两行，第一行为用空格分开的质因数\n  <br> 　　第二行为质因数的个数\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  66\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  2 3 113\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  90\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  2 3 3 5\n  <br> 4\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  37\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  37\n  <br> 1\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n/* run this program using the console pauser or add your own getch, system("pause") or input loop */\n\nint main(int argc, char *argv[]) \n{\tint i,n,a,x=1;\n\tscanf("%d",&amp;n);\n\ta=n;\n\tfor(i=2;i&lt;a;)\n\t{\tif(a%i==0)\n\t\t{\n\t\tprintf("%d ",i); \n\t\ta/=i;x++;\n\t\t}\n\t\telse i++;\n\t}\n\tprintf("%d",i);\n\tprintf("\\n%d",x);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;cmath&gt;\n#include &lt;cstdlib&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;string&gt;\nusing namespace std;\nint sum = 0;\nvoid F(int n)\n{\n\tint i;\n\tif(n == 1 || n == 2 || n == 3)\n\t{\n\t\tcout&lt;&lt;n;\n\t\tsum ++;\n\t\treturn;\n\t}\n\tint x = sqrt(n);\n\tfor(i = 2 ; i &lt;= x; i ++)\n\t{\n\t\tif(n%i == 0)\n\t\t{\n\t\t\tcout&lt;&lt;i&lt;&lt;" ";\n\t\t\tF(n/i);\n\t\t\tsum ++;\n\t\t\treturn;\n\t\t}\n\t\tif(i == x)\n\t\t{\n\t\t\tcout&lt;&lt;n;\n\t\t\tsum ++;\n\t\t}\n\t}\n}\nint main()\n{\n\tint n;\n\tcin&gt;&gt;n;\n\tF(n);\n\tcout&lt;&lt;endl&lt;&lt;sum&lt;&lt;endl;\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\n\nimport java.util.Scanner;\n\n class Main {\n\n\t\n\tpublic static void main(String[] args) {\n\t\t//质因数2\n\t\tScanner sca = new Scanner(System.in);\n\t\tint n = sca.nextInt();\n\t\tint i = 2,count=0;\n\t\tString s = "";\n\t\twhile (n != 1) {\n\t\t\twhile (n%i == 0){\n\t\t\t\tn /= i;\n\t\t\t\ts += i+" ";\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tSystem.out.println(s);\n\t\tSystem.out.println(count);\n\t}\n\n}\n\r\n</textarea>	341
340	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　数据很多，但我们经常只取前几名，比如奥运只取前3名。现在我们有n个数据，请按从大到小的顺序，输出前10个名数据。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　两行。\n  <br> 　　第一行一个整数n，表示要对多少个数据\n  <br> 　　第二行有n个整数，中间用空格分隔。表示n个数据。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　一行，按从大到小排列的前10个数据，每个数据之间用一个空格隔开。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  26\n  <br> 54 27 87 16 63 40 40 22 61 6 57 70 0 42 11 50 13 5 56 7 8 86 56 91 68 59\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  91 87 86 70 68 63 61 59 57 56\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　10&lt;=n&lt;=200,各个整数不超出整型范围\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid shuru(int);\nvoid paixu(int *,int);\nvoid jiaohuan(int *,int *);\nvoid shuchu(int *);\n\nint main(void)\n{\n    int geshu;\n    \n    scanf("%d",&amp;geshu);\n    \n    shuru(geshu);\n  \n    system("PAUSE");\t\n    return 0;\n}\n\nvoid shuru(int n)\n{\n     int shuju[n];\n     int i;\n     \n     for(i=0;i&lt;n;i++)\n     {\n         scanf("%d",&amp;shuju[i]);\n     }\n     \n     paixu(shuju,n);\n}\n\nvoid jiaohuan(int * a,int * b)\n{\n     int t = *a;\n     *a = *b;\n     *b = t;\n}\n\nvoid shuchu(int * p_s)\n{\n     int i;\n     \n     for(i=0;i&lt;10;i++)\n     {\n         printf("%d ",*(p_s+i));\n     }\n}\n\nvoid paixu(int * s,int n)\n{\n     int i,j;\n     \n     for(i=0;i&lt;n;i++)\n     {\n         for(j=i;j&lt;n;j++)\n         {\n             if(* (s+i) &lt; * (s+j))\n             {\n                  jiaohuan(s+i,s+j);\n             }\n         }\n     }\n     \n     shuchu(s);\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\nmain()\n{\n\tint n,a,b,c,d,s[202],max;\n\tcin&gt;&gt;n;\n\tfor(a=0;a&lt;n;a++)\n\t{\n\t\tcin&gt;&gt;s[a];\n\t}\n\tmax=s[0];\n\tfor(b=1;b&lt;n;b++)\n\tfor(c=0;c&lt;n-b;c++)\n\t{\n\t\tif(s[c+1]&lt;s[c])\n\t\t{\n\t\t\tmax=s[c];\n\t\t\ts[c]=s[c+1];\n\t\t\ts[c+1]=max;\n\t\t}\n\t}\n\tfor(d=n-1;d&gt;n-11;d--)\n\t{\n\t\tcout&lt;&lt;s[d]&lt;&lt;" ";\n\t}\n\t\n\t\n\t\n\t\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main{\npublic static void main(String[] args) {\n\tScanner input=new Scanner(System.in);\n\tint a=input.nextInt();\n\tint []b=new int[a];\n\tfor (int i = 0; i &lt;b.length; i++) {\n\t\tb[i]=input.nextInt();\n\t}\n\tArrays.sort(b);\n\tfor (int i =b.length-1; i &gt;b.length-11; i--) {\n\t\tSystem.out.print(b[i]+" ");\n\t}\n}\n}\n\r\n</textarea>	342
341	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　一个含有n个点的迷宫是一棵树（一个任意两点之间都恰好有一条路径的无向图）。每个点都有一定的概率成为这个迷宫的入口和出口。\n  <br> 　　从这个迷宫走出去的方法是从入口开始进行深度优先搜索。如果当前有多个移动方案，那么等概率的选择移动方案中的一个。DFS的过程为以下的伪代码：\n  <br> 　　DFS(x)\n  <br> 　　if x == exit vertex then\n  <br> 　　finish search\n  <br> 　　flag[x] &lt;- TRUE\n  <br> 　　random shuffle the vertices' order in V(x) // here all permutations have equal probability to be chosen\n  <br> 　　for i &lt;- 1 to length[V] do\n  <br> 　　if flag[V[i]] = FALSE then\n  <br> 　　count++;\n  <br> 　　DFS(y);\n  <br> 　　count++;\n  <br> 　　V(x)是与x点相邻的点的序列。Flag数组初始时是全部为FALSE的。DFS 初始时从入口开始。当搜索结束时，变量count将会统计移动的次数。\n  <br> 　　你的任务是统计一个人从这个迷宫的入口走到出口步数的数学期望值。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行一个数n，表示这个图的节点数。。\n  <br> 　　下面n-1行，每行包括两个数ai,bi，表示一条连接ai和bi的边。\n  <br> 　　保证给出的图是一棵树。\n  <br> 　　下面n行，每行包括两个非负整数xi,yi，表示选择i为入口的可能性和出口的可能性。\n  <br> \n  <br> 　　选择i为入口的概率和选择i为出口的概率分别为xi/sumx和yi/sumy，sumx表示x的总和，sumy表示y的总和。sumx以及sumy均为正数且不超过10^6。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出期望的步数，要求误差不超过10^-9。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　2\n  <br> 　　1 2\n  <br> 　　0 1\n  <br> 　　1 0\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　3\n  <br> 　　1 2\n  <br> 　　1 3\n  <br> 　　1 0\n  <br> 　　0 2\n  <br> 　　0 3\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　7\n  <br> 　　1 2\n  <br> 　　1 3\n  <br> 　　2 4\n  <br> 　　2 5\n  <br> 　　3 6\n  <br> 　　3 7\n  <br> 　　1 1\n  <br> 　　1 1\n  <br> 　　1 1\n  <br> 　　1 1\n  <br> 　　1 1\n  <br> 　　1 1\n  <br> 　　1 1\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　1.00000000000000000000\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　2.00000000000000000000\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　4.04081632653\n </div>\n <div class="pdsec">\n  样例说明\n </div>\n <div class="pdcont">\n  　　第一个样例中，入口总是1，出口总是2。\n  <br> 　　第二个样例的入口总是1且出口有2/5的概率是2，3/5的概率是3。对于出口为2和3的数学期望是相同的（对称的情况），第一步有0.5的概率直接到达出口，0.5的概率走错到另一个点（然后再走两步到终点）。所以数学期望等于2/5*(1*0.5+3*0.5)+3/5*(1*0.5+3*0.5) = 2。\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　20% 的数据n &lt;= 100\n  <br> 　　50% 的数据n &lt;= 1000\n  <br> 　　70% 的数据n &lt;= 10000\n  <br> 　　100%的数据n &lt;= 100000\n </div> \n</div>	<textarea id="codelinesc">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;string&gt;\n#include&lt;cstdio&gt;\n#include&lt;set&gt;\n#include&lt;map&gt;\n#include&lt;stack&gt;\n#include&lt;vector&gt;\n#include&lt;queue&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstring&gt;\n#include&lt;cmath&gt;\n#include&lt;fstream&gt;\nusing namespace std;\n\nconst int maxn = 100010;\n\nint fa[maxn],son[maxn],st[maxn],ed[maxn],n;\nlong long sum = 0,tst = 0,ted = 0,lf[maxn];\nvector&lt;int&gt; e[maxn];\n\nvoid dfs1(int u,int f){\n    son[u] = 0;\n    fa[u] = f;\n    for(int i = 0;i &lt; e[u].size();++i){\n        int ff = e[u][i];\n        if (ff == f) continue;\n        dfs1(ff,u);\n        son[u] += son[ff];\n        son[u]++;\n    }\n}\n\nvoid dfs2(int u){\n    lf[u] = st[u];\n    sum += (n - 1 - son[u]) * (tst - st[u]) * ed[u]; //预处理情况2\n    for(int i = 0;i &lt; e[u].size();++i){//更新lf，集中处理情况1\n        int ff = e[u][i];\n        if (ff == fa[u]) continue;\n        dfs2(ff);\n        lf[u] += lf[ff];\n        sum += (son[ff] + 1 - (n - 1 - son[u])) * lf[ff] * ed[u];\n    }\n    if(u == 1) return;\n}\n\nvoid init(){\n    cin &gt;&gt; n;\n    int l,r;\n    for(int i = 1;i &lt; n;++i){\n        cin &gt;&gt; l &gt;&gt; r;\n        e[l].push_back(r);\n        e[r].push_back(l);\n    }\n    for(int i = 1;i &lt;= n;++i){\n        cin &gt;&gt; l &gt;&gt; r;\n        st[i] = l;\n        tst += l;\n        ed[i] = r;\n        ted += r;\n    }\n}\n\nint main(){\n    init();\n    dfs1(1,1);\n    dfs2(1);\n    printf("%.11lf\\n",sum * 1.0 / tst / ted);\n}\r\n</textarea>	<textarea id="codelinesjava">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	343
342	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　在年轻的时候，我们故事中的英雄——国王 Copa——他的私人数据并不是完全安全地隐蔽。对他来说是，这不可接受的。因此，他发明了一种密码，好记又难以破解。后来，他才知道这种密码是一个长度为奇数的回文串。\n  <br> \n  <br> 　　Copa 害怕忘记密码，所以他决定把密码写在一张纸上。他发现这样保存密码不安全，于是他决定按下述方法加密密码：他选定一个整数 X ，保证 X 不小于 0 ，且 2X 严格小于串长度。然后他把密码分成 3 段，最前面的 X 个字符为一段，最后面的 X 个字符为一段，剩余的字符为一段。不妨把这三段依次称之为 prefix, suffix, middle 。显然， middle 的长度为一个大于 0 的奇数，且 prefix 、 suffix 的长度相等。他加密后的密码即为 A + prefix + B + middle + C + suffix ，其中 A 、 B 、 C 是三个由 Copa 选定的字符串，且都有可能为空， + 表示字符串相连。\n  <br> \n  <br> 　　许多年过去了。Copa 昨天找到了当年写下加密后字符串的那张纸。但是，Copa 把原密码、A、B、C 都忘了。现在，他请你找一个尽量长的密码，使得这个密码有可能被当年的 Copa 发明、加密并写下。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入包含一个只含有小写拉丁字母的字符串，长度在 1 到 10^5 之内。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　第一行包含一个整数 k ，表示你找到的原密码分成的 3 个部分中有多少个非空字符串。显然 k in {1, 3} 。接下来 k 行，每行 2 个用空格分开的整数 x_i l_i ，表示这一部分的起始位置和长度。要求输出的 x_i 递增。\n  <br> \n  <br> 　　起始位置 x_i 应该在 1 到加密后的字符串长度之间。 l_i 必须是正整数，因为你只要输出非空部分的信息。 middle 的长度必须为奇数。\n  <br> \n  <br> 　　如果有多组答案，任意一组即可。提示：你要最大化的是输出的 l_i 的总和，而不是 k 。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  abacaba\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  1\n  <br> 1 7\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  axbya\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  3\n  <br> 1 1\n  <br> 2 1\n  <br> 5 1\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  xabyczba\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  3\n  <br> 2 2\n  <br> 4 1\n  <br> 7 2\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　对于 10% 的数据： n &lt;= 10\n  <br> \n  <br> 　　对于 30% 的数据： n &lt;= 100\n  <br> \n  <br> 　　对于 100% 的数据： n &lt;= 100000\n  <br> \n  <br> 　　存在 20% 的数据，输出文件第一行为 1 。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n#include&lt;stdlib.h&gt;\n#define _min(x,y) ((x)&lt;(y)?(x):(y))\n#define _max(x,y) ((x)&gt;(y)?(x):(y))\nvoid KMP(char *target_string,char *match_string,int *match)\n{\n    int target_size=strlen(target_string);\n    int match_size=strlen(match_string);\n    int i,j=-1;\n    int *intit_array=(int *)malloc(sizeof(int)*target_size);\n    intit_array[0]=-1;\n    for(i=1;i&lt;target_size;++i)\n    {\n        while(j&gt;-1&amp;&amp;target_string[i]!=target_string[j+1])\n            j=intit_array[j];\n        if(target_string[i]==target_string[j+1])\n            ++j;\n        intit_array[i]=j;\n    }\n    j=-1;\n    for(i=0;i&lt;match_size;++i)\n    {\n        while(j&gt;-1&amp;&amp;match_string[i]!=target_string[j+1])\n            j=intit_array[j];\n        if(match_string[i]==target_string[j+1])\n            ++j;\n        match[i]=j+1;\n      //  if(j==target_size-1)\n         //   j=intit_array[j];\n    }\n  //  free(intit_array);\n}\nvoid manacher(char *match_string,int *match)\n{\n    int size=strlen(match_string);\n    int i;\n    int most_right_find=0;\n    int right_mid=0;\n    match[0]=1;\n    for(i=1;i&lt;size;++i)\n    {\n        if(i&lt;most_right_find)\n            match[i]=_min(match[2*right_mid-i],most_right_find-i);\n        else match[i]=1;\n        while(match_string[i-match[i]]==match_string[i+match[i]])\n            ++match[i];\n        if(match[i]+i&gt;most_right_find)\n        {\n            most_right_find=match[i]+i;\n            right_mid=i;\n        }\n    }\n    return;\n}\nint main()\n{\n    char *input_string=(char *)malloc(100003*sizeof(char));\n    int size;\n    int *match,*kmp_match;\n    int i,j;\n    int half;\n    char *target_string;\n    int target_size;\n    int *dp;\n    int match_max=0;\n    int mid_len;\n    int pre_suf;\n    int left_begin=-1;\n    int *tail;\n    int left_length=0;\n    int mid_begin=0;\n    int mark=0;\n    input_string[0]='@';\n    scanf("%s",input_string+1);\n    size=strlen(input_string);\n    input_string[size]='$';\n    input_string[++size]=0;\n    match=(int *)malloc(sizeof(int)*size);\n    manacher(input_string,match);\n    i=-1;\n    j=size-1;\n    half=(size+1)/2;\n    target_size=size-half;\n    target_string=(char *)malloc(sizeof(char)*target_size);\n    while(j&gt;half)\n        target_string[++i]=input_string[--j];\n    target_string[++i]=0;\n    kmp_match=(int *)malloc(sizeof(int)*size);\n    KMP(target_string,input_string,kmp_match);\n    dp=(int *)malloc(sizeof(int)*size);\n    tail=(int *)malloc(sizeof(int)*size);\n    dp[0]=0;\n    for(i=1;i&lt;size;++i)\n    {\n        if(kmp_match[i]&gt;dp[i-1])\n            dp[i]=kmp_match[i],tail[i]=i;\n        else dp[i]=dp[i-1],tail[i]=tail[i-1];\n    }\n    for(i=1;i&lt;size-1;++i)\n    {\n        mid_len=2*match[i]-1;\n        pre_suf=_min(dp[i-match[i]],size-(i+match[i])-1);\n        if(mid_len+2*pre_suf&gt;match_max)\n        {\n            match_max=mid_len+2*pre_suf;\n            left_begin=tail[i-match[i]]-pre_suf+1;\n            if(pre_suf&gt;0)\n            {\n                left_length=pre_suf;\n                mark=1;\n            }\n            else mark=0;\n            mid_begin=i-match[i]+1;\n        }\n    }\n    if(mark==1)\n        printf("3\\n%d %d\\n%d %d\\n%d %d",left_begin,left_length,mid_begin,match_max-2*left_length,size-1-left_length,left_length);\n    else printf("1\\n%d %d",mid_begin,match_max);\n    return 0;\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n#define INF 0x3f3f3f3f\nchar s[100010], s1[200010];\nint mana[100010], L, next[200010], match[100010], r[100010];\nint min(int x, int y)\n{\n\treturn x&lt;y?x:y;\n} \nvoid getmana()\n{\n\tmana[0] = 0;\n\tint id = 0, right = 0;\n\tfor(int i = 1; i &lt; L-1; ++i)\n\t{\n\t\tif(right &gt; i)\n\t\tmana[i] = min(mana[2*id - i], right - i);\n\t\telse\n\t\tmana[i] = 0;\n\t\twhile(s[i+mana[i]+1] == s[i-mana[i]-1]  &amp;&amp; (i+mana[i]+1) &lt; L &amp;&amp; (i-mana[i]-1) &gt;= 0)\n\t\tmana[i]++;\n\t\tif(mana[i]+i &gt; right)\n\t\t{\n\t\t\tid = i;\n\t\t\tright = mana[i]+i;\n\t\t}\n\t}\n} \nvoid getnext(char *temp)\n{\n\tmemset(next, 0, sizeof(next));\n\tnext[0] = -1;\n\tint i = 0, j = -1;\n\twhile(temp[i])\n\t{\n\t\tif(j == -1 || temp[i] == temp[j])\n\t\t{\n\t\t\ti++;\n\t\t\tj++;\n\t\t\tnext[i] = j;\n\t\t}\n\t\telse\n\t\tj = next[j];\n\t}\n}\n\nint main()\n{\n\tint i, j, k, l;\n\twhile(gets(s) != NULL)\n\t{\n\t\tL = strlen(s);\n\t\tgetmana();\n\t\tfor(i = L-1; i &gt;= 0; --i)\n\t\ts1[L-1-i] = s[i];\n\t\ts1[L] = '#';\n\t\ts1[L+1] = '\\0';\n\t\tstrcat(s1,s); \n\t\tgetnext(s1);\n\t\tfor(i = L+1; i &lt;= 2*L+1; ++i)\n\t\tmatch[i-L-1] = next[i];\n\t\tmemset(r, -1, sizeof(r));\n\t\tfor(i = 1; i &lt;= L; ++i)\n\t\t{\n\t\t\tif(match[i] &gt; match[i-1])\n\t\t\tr[match[i]-1] = i-1;\n\t\t\telse\n\t\t\tmatch[i] = match[i-1];\n\t\t}\n\t\tfor(i = 1; i &lt; L; ++i)\n\t\t{\n\t\t\tif(r[i] == -1)\n\t\t\tr[i] = r[i-1];\n\t//\t\tprintf("%d ", r[i]); \n\t\t} \n\t//\tprintf("\\n");\n\t\tint ans[3][2] = {0}, max = 0;\n\t\tbool ok = true;\n\t\tfor(i = 1; i &lt; L-1; ++i)//the length must bigger than 3\n\t\t{\n\t\t\tj = i+mana[i]+1;\n\t\t\tif(j &gt;= L || i-mana[i] &lt;= 0)\n\t\t\tj = L;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(r[L-j-1] == -1)\n\t\t\t\tj = L;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(r[L-j-1] &gt;= i-mana[i])\n\t\t\t\t\tj = L - match[i-mana[i]];\n\t\t\t\t\telse\n\t\t\t\t\tj = L - match[r[L-j-1]+1];\n\t\t\t\t}\n\t\t\t} \n\t\t\tif(j &lt; L)\n\t\t\t{\n\t\t\t\tif(2*(L-j) + mana[i]*2 + 1 &gt; max)\n\t\t\t\t{\n\t\t\t\t\tmax = 2*(L-j) + mana[i]*2 + 1;\n\t\t\t\t\tans[0][0] = r[L-j-1] - L + j + 1;\n\t\t\t\t\tans[0][1] = L-j;\n\t\t\t\t\tans[1][0] = i-mana[i];\n\t\t\t\t\tans[1][1] = 2*mana[i]+1;\n\t\t\t\t\tans[2][0] = j;\n\t\t\t\t\tans[2][1] = L-j;\n\t\t\t\t\tok = false;\n\t\t\t//\t\tprintf("1 %d\\n", max);\n\t\t\t\t} \n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(2*mana[i]+1 &gt; max)\n\t\t\t\t{\n\t\t\t\t\tmax = 2*mana[i]+1;\n\t\t\t\t\tok = true;\n\t\t\t\t\tans[1][0] = i-mana[i];\n\t\t\t\t\tans[1][1] = 2*mana[i]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ok)\n\t\t{\n\t\t\tif(ans[1][1] == 0)\n\t\t\tans[1][1] = 1; \n\t\t\tprintf("1\\n%d %d\\n", ans[1][0]+1, ans[1][1]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf("3\\n");\n\t\t\tprintf("%d %d\\n", ans[0][0]+1, ans[0][1]);\n\t\t\tprintf("%d %d\\n", ans[1][0]+1, ans[1][1]);\n\t\t\tprintf("%d %d\\n", ans[2][0]+1, ans[2][1]);\n\t\t}\n\t}\n\treturn 0;\n} \r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static char[] chs;\n\tpublic static char[] p;\n\t\n\tpublic static int[] rad=new int[200000];//manacher算法用到的回文半径数组\n\t\n\tprivate static int[] m=new int[200000];\n\t\n\tprivate static int[] max_m=new int[200000];\n\t\n\tpublic static int[] next=new int[200000];//kmp算法next数组\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t\tScanner scn=new Scanner(System.in);\n\t\tString s=scn.next();\n\t\tchs=s.toCharArray();\t\t\n\t\tStringBuffer sb=new StringBuffer(s);\n\t\tsb.reverse();//逆置\n\t\tp=sb.toString().toCharArray();\n\t\tscn.close();\n\t\t\n\t\tsolve();\n\n\t}\n\t\n\tprivate static void solve() {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t\tint preIndex=0,preLen=0;\n\t\tint midIndex=0,midLen=0;\n\t\tint sufIndex=0,sufLen=0;\n\t\t\t\t\n\t\tmanacher();\n\n\t\tgetNext();\n\t\n\t\tkmp();\n\t\t\n\t\tmax_m[0]=0;\n\n\t\tfor (int i = 1; i&lt; chs.length; i++){\n\t\t\tif(m[i]&gt;m[max_m[i-1]]){\n\t\t\t\tmax_m[i]=i;\n\t\t\t}else{\n\t\t\t\tmax_m[i]=max_m[i-1];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i &lt; chs.length; i++) {\n\t\t\t\n\t\t\tint left=i-rad[i]+1;\n\t\t\tint right=i+rad[i]-1;\t\t\t\n\t\t\t\n\t\t\tint L=0;\n\t\t\tif(left&gt;0){\n\t\t\t\tL=min(m[max_m[left-1]], chs.length-right-1);\n\t\t\t}\n\t\t\t\n\t\t\tif(2*L+2*rad[i]-1&gt;preLen+midLen+sufLen){\n\n\t\t\t\tpreIndex=left==0?0:max_m[left-1]-m[max_m[left-1]]+1;\t\t\t\t\n\t\t\t\tpreLen=L;\n\t\t\t\t\n\t\t\t\tmidIndex=left;\n\t\t\t\tmidLen=2*rad[i]-1;\n\t\t\t\t\n\t\t\t\tsufIndex=chs.length-L;\n\t\t\t\tsufLen=L;\n\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif(preLen==0){\n\t\t\tSystem.out.println(1);\n\t\t\tSystem.out.println((midIndex+1)+" "+midLen);\t\t\t\n\t\t}else{\n\t\t\tSystem.out.println(3);\n\t\t\tSystem.out.println((preIndex+1)+" "+preLen);\t\t\t\n\t\t\tSystem.out.println((midIndex+1)+" "+midLen);\t\t\t\n\t\t\tSystem.out.println((sufIndex+1)+" "+sufLen);\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\tprivate static void kmp() {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t\tint i=0,j=0;\n\t\t\n\t\twhile(i&lt;chs.length){\n\t\t\t\n\t\t\tif(j==-1||chs[i]==p[j]){\n\t\t\t\tm[i]=j+1;\n\t\t\t\tj++;\t\t\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tj=next[j];\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static void getNext(){\n\t\t\n\t\tint i=0;\n\t\tint j=1;\n\t\tnext[0]=-1;\n\t\tnext[1]=0;\n\t\twhile(j&lt;p.length){\n\t\t\tif(i==-1||p[i]==p[j]){\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t\tnext[j]=i;\n\t\t\t}else{\n\t\t\t\ti=next[i];\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static void manacher(){\n\t\t\n\t\tint maxRight=0;\n\t\tint pos=0;\n\t\t\n\t\tfor(int i=0;i&lt;chs.length;i++){\n\t\t\tif(i&lt;=maxRight){\n\t\t\t\trad[i]=min(rad[2*pos-i],maxRight-i+1);\n\t\t\t}else{\n\t\t\t\trad[i]=1;\n\t\t\t}\n\t\t\twhile(i-rad[i]&gt;=0&amp;&amp;i+rad[i]&lt;chs.length&amp;&amp;chs[i-rad[i]]==chs[i+rad[i]]){\n\t\t\t\trad[i]++;\n\t\t\t}\n\t\t\tif(i+rad[i]&gt;maxRight){\n\t\t\t\tpos=i;\n\t\t\t\tmaxRight=i+rad[i]-1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\tprivate static int min(int a,int b) {\n\t\t// TODO Auto-generated method stub\n\t\treturn a&lt;b?a:b;\n\t}\n\t\n}\n\n\n\r\n</textarea>	344
343	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　小朋友排成一排，老师给他们分苹果。\n  <br> 　　小朋友从左到右标号1..N。有M个老师，每次第i个老师会给第Li个到第Ri个，一共Ri-Li+1个小朋友每人发Ci个苹果。\n  <br> 　　最后老师想知道每个小朋友有多少苹果。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行两个整数N、M，表示小朋友个数和老师个数。\n  <br> 　　接下来M行，每行三个整数Li、Ri、Ci，意义如题目表述。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　一行N个数，第i个数表示第i个小朋友手上的水果。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5 3\n  <br> 1 2 1\n  <br> 2 3 2\n  <br> 2 5 3\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  1 6 5 3 3\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　40%的数据，N、M≤1 000。\n  <br> 　　100%的数据，N、M≤100 000，1≤Li≤Ri≤N，0≤Ci≤100。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n\nint apple[100005];\n\nvoid add(int index, int num)\n{\n\tfor (; index&gt;0; index-=(index&amp;-index))\n\t{\n\t\tapple[index] += num;\n\t}\n}\n\nint find(int index, int n)\n{\n\tint re = 0;\n\tif (index==0)\n\t{\n\t\treturn apple[0];\n\t}\n\tfor (; index&lt;=n; index+=(index&amp;-index))\n\t{\n\t\tre += apple[index];\n\t}\n\treturn re;\n}\n\nint main(void)\n{\n\tint n, m;\n\tint l, r, c;\n\tint i;\n\t\n\tscanf("%d%d", &amp;n, &amp;m);\n\tfor (i=0; i&lt;m; ++i)\n\t{\n\t\tscanf("%d%d%d", &amp;l, &amp;r, &amp;c);\n\t\tadd(r, c);\n\t\tadd(l-1, -c);\n\t}\n\n\tfor (i=1; i&lt;=n; ++i)\n\t{\n\t\tprintf("%d ", find(i, n));\n\t}\n\tprintf("\\n");\n\t\n    return 0;\n}\n\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\n\nint apple[100005];\n\nvoid add(int index, int num)\n{\n\tfor (; index&gt;0; index-=(index&amp;-index))\n\t{\n\t\tapple[index] += num;\n\t}\n}\n\nint find(int index, int n)\n{\n\tint re = 0;\n\tif (index==0)\n\t{\n\t\treturn apple[0];\n\t}\n\tfor (; index&lt;=n; index+=(index&amp;-index))\n\t{\n\t\tre += apple[index];\n\t}\n\treturn re;\n}\n\nint main(void)\n{\n\tint n, m;\n\tint l, r, c;\n\tint i;\n\t\n\tscanf("%d%d", &amp;n, &amp;m);\n\tfor (i=0; i&lt;m; ++i)\n\t{\n\t\tscanf("%d%d%d", &amp;l, &amp;r, &amp;c);\n\t\tadd(r, c);\n\t\tadd(l-1, -c);\n\t}\n\n\tfor (i=1; i&lt;=n; ++i)\n\t{\n\t\tprintf("%d ", find(i, n));\n\t}\n\tprintf("\\n");\n\t\n    return 0;\n}\n\n\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\nimport java.util.Arrays;\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException{\n\t\t// TODO 自动生成的方法存根\n\t\tStreamTokenizer scanf = new StreamTokenizer(\n\t\t\t\tnew BufferedReader(new InputStreamReader(System.in)));\n\t\tPrintWriter out = new PrintWriter(\n\t\t\t\tnew BufferedOutputStream(System.out));\n\t\tscanf.nextToken();\n\t\tint n = (int)scanf.nval;\n\t\tscanf.nextToken();\n\t\tint m =(int)scanf.nval; \n\t\tint[] a = new int[n+2];\n\t\tint[] b = new int[n+2];\n\t\tArrays.fill(a, 0);\n\t\tArrays.fill(b, 0);\n\t\tint l,r,c;\n\t\twhile(scanf.nextToken() != StreamTokenizer.TT_EOF){\n\t\t\tl = (int)scanf.nval;\n\t\t\tscanf.nextToken();\n\t\t\tr = (int)scanf.nval;\n\t\t\tscanf.nextToken();\n\t\t\tc = (int)scanf.nval;\n\t\t\tb[l]+=c;\n\t\t\tb[r+1]-=c;\n\t\t\t\n\t\t}\n\t\tfor(int i=1;i&lt;=n;i++){\n\t\t\ta[i]=a[i-1]+b[i];\n\t\t\tout.print(a[i]+" ");\n\t\t}\n\t\tout.flush();\n\t}\n}\r\n</textarea>	345
344	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　这一天，有一列车子排起了一排长队，必经之路是一个被魔王笼罩的山洞。每辆车的司机害怕魔王程度不同，所以每个司机有一些要求。\n  <br> 　　车子有n台，排成一条长队，每辆车有4个属性:\n  <br> 　　V ——这辆车的总价值，价值就是比如它其中的乘客和货物的价值\n  <br> 　　c ——这辆车里面的人数量（司机表示自己也算一个乘客，司机和乘客不用区分开来）\n  <br> 　　l ——在这辆车的前面需要总量正好为多少乘客的车（不多也不少），这车才敢开\n  <br> 　　r ——在这辆车的后面需要总量正好为多少乘客的车（不多也不少），这车才敢开\n  <br> 　　“前面需要总量正好为多少乘客的车”指的是驶在这辆车前面所有的车的乘客总数。\n  <br> 　　“后面需要总量正好为多少乘客的车”指的是驶在这辆车后面所有的车的乘客总数。\n  <br> 　　你不能改变每辆车在车队的相对顺序，但你可以安排某些车退出车队，保证依然在车队的每辆车都敢开了，即满足上述条件，并且剩下车的v的总量最大。\n  <br> 　　-----------------------------\n  <br> 　　简单来说，给您按输入顺序排列的n辆车，您需要删去里面的一些车（剩下的车仍然按原相对顺序排列）。\n  <br> 　　使得对于每辆车，若它没被删去，设其为输入的第i辆车，\n  <br> 　　要满足\n  <br> 　　l[i]= sigma{c[j] | j&lt;i 且第j辆车没被删去}\n  <br> 　　r[i]= sigma{c[j] | j&gt;i 且第j辆车没被删去}\n  <br> 　　在满足这些条件前提下，要求sigma{V[i] | i没被删去} 最大，\n  <br> 　　请输出这个最大值，并且递增输出没有被删去的车的标号。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入的第一行为一个正整数n（1&lt;=n&lt;=10^5）——车的个数。\n  <br> 　　接下来n行，每行四个整数，第i行的数字: vi, ci,li ,r\n  <sub>i</sub> ,（1&lt;=vi&lt;=10^4 , 1&lt;=ci&lt;=10^5,0&lt;=li,ri&lt;=10^5），车子们从1开始编号，从车队的最前头开始算起。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　第一行输出一个数k：会继续在这车队里的车的总数（注意我们的目标是让价值最大）。\n  <br> 　　第二行k个数，递增输出继续在车队里的车的编号。\n  <br> 　　请留心你不允许改变车的次序。如果答案不唯一，输出任意一个。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5\n  <br> 1 1 0 3\n  <br> 1 1 1 2\n  <br> 1 1 2 1\n  <br> 1 1 3 0\n  <br> 2 1 3 0\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  4\n  <br> 1 2 3 5\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5\n  <br> 1 1 0 3\n  <br> 10 1 2 1\n  <br> 2 2 1 1\n  <br> 10 1 1 2\n  <br> 3 1 3 0\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  3\n  <br> 1 3 5\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　对于20%的数据，n&lt;=100\n  <br> 　　对于50%的数据，n&lt;=1000\n  <br> 　　对于100%的数据，n&lt;=100000\n  <br> 　　对于100%的数据，1&lt;=vi&lt;=10^4 , 1&lt;=ci&lt;=10^5,0&lt;=li,ri&lt;=10^5\n </div> \n</div>	<textarea id="codelinesc">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;stdio.h&gt;  \n#include &lt;string.h&gt;  \n#include &lt;stdlib.h&gt;\n#include &lt;math.h&gt;  \n#include &lt;set&gt;  \n#include &lt;vector&gt;  \n#include &lt;map&gt;     \n#define N 100005  \n\nusing namespace std;\n\nstruct node{  \n    int v,c,l,r;  \n    int num;  \n}car[N]; \n \nint n;  \nvector&lt;int&gt;G[N], tmp;  \nset&lt;int&gt; myset;  \nset&lt;int&gt; ::iterator p;  \nmap&lt;int,int&gt; mymap;  \nmap&lt;int,int&gt; per;  \nmap&lt;int,int&gt; sig;  \nint pos[N], endpos;  \n\nint work(int x){  \n    if(G[x].size()==0)\n        return 0;  \n    mymap.clear();  \n    per.clear();  \n    sig.clear();  \n    mymap[0] = 0;  \n    per[0] = -1;  \n    sig[0] = -1;  \n    int ans = 0;  \n    endpos = -1;  \n    int i;\n    for(i = 0; i &lt; G[x].size(); i++) {  \n        node now = car[G[x][i]];          \n        if(mymap.find(now.l)==mymap.end())  \n            continue;  \n        if(mymap.find(now.l+now.c)==mymap.end() || \n           mymap[now.l+now.c]&lt;mymap[now.l]+now.v) {  \n            mymap[now.l+now.c] = mymap[now.l]+now.v;  \n            sig[now.l+now.c] = G[x][i];  \n            per[G[x][i]] = sig[now.l];  \n        }  \n        if(now.r==0 &amp;&amp; ans&lt;mymap[now.l+now.c])\n            ans = mymap[now.l+now.c], endpos = G[x][i];  \n    }  \n    return ans;  \n} \n \nint main(){  \n    int i,j,u,v; \n    scanf("%d",&amp;n); \n    for(i = 1; i &lt;= n; i++) \n        G[i].clear();  \n    myset.clear();  \n    mymap.clear();  \n    for(i = 1; i &lt;= n; i++)  \n        scanf("%d%d%d%d",&amp;car[i].v,&amp;car[i].c,&amp;car[i].l,&amp;car[i].r), car[i].num = i;  \n    for(i = 1; i &lt;= n; i++) {  \n        myset.insert(car[i].c+car[i].l+car[i].r);  \n    }  \n    i = 1;  \n    for(p = myset.begin(); p!=myset.end(); p++, i++)  \n        mymap[*p] = i, pos[i] = *p;  \n    for(i = 1; i &lt;= n; i++)  \n        G[mymap[car[i].c+car[i].l+car[i].r]].push_back(i);  \n    int ans = 0;  \n    for(i = 1; i &lt;= n; i++) {  \n        int now = work(i);  \n        if(now&gt;ans) {  \n            ans = now;  \n            tmp.clear();  \n            u = endpos;  \n            while(u!=-1) {  \n                tmp.push_back(u);  \n                u = per[u];  \n            }             \n        }  \n    }  \n    printf("%d\\n",tmp.size());  \n    for(i = tmp.size()-1; i&gt;=0; i--)  \n        printf("%d%c",tmp[i],i?' ':'\\n');  \n    system("pause");\n    return 0;  \n}\r\n</textarea>	<textarea id="codelinesjava">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	346
345	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　现有如下一个算法：\n  <br> 　　repeat ni times\n  <br> 　　yi := y\n  <br> 　　y := yi+1\n  <br> 　　end repeat\n  <br> 　　令n[1]为你需要算加法的第一个数字，n[2]为第二个，...n[N]为第N个数字（N为需要算加法的数字个数），\n  <br> 　　并令y初始值为0，先令i=1运行这个算法（如上所示，重复n[i]次），然后令i=2运行这个算法。。直到i=N。注意y值一直不要清零。最后y的值就是你需要的加法答案。\n  <br> 　　你想知道，有没有某种运算顺序能使答案等于W。\n  <br> 　　一个循环中的全部语句，是不能改变在总的语句排列中的相对顺序的。\n  <br> 　　（这里的第i个循环是指这n[i]*2条语句。就是你把属于第i个循环的语句抽出来看，它们需要按照原顺序排列。在你没有运行完这个循环的最靠前一条未完成的 语句的时候，你是不能跳过它先去完成这个循环后面的语句的。你能做的仅是把若干个循环按照你所规定的顺序“归并”起来。）\n  <br> 　　举个例子，n[1]= 2 ,n[2]=1, W=1.一种可行的运算顺序是“2 1 1 1 1 2”，数字为几表示运行第几个算法的下一条语句（你可以看到”1”出现了4次，是因为n[1]=2即循环两次，而每次循环里面有两条语句，所以2*2=4次）\n  <br> \n  <br> \n  <table cellspacing="0" cellpadding="2px" style="border-collapse:collapse;" class="table table-striped table-horver">\n   <tbody>\n    <tr style="border:solid 1.0pt">\n     <td valign="top" style="border:solid 1.0pt"><br> </td>\n     <td valign="top" style="border:solid 1.0pt">y值<br> </td>\n     <td valign="top" style="border:solid 1.0pt">y[1] 值<br> </td>\n     <td valign="top" style="border:solid 1.0pt">y[2] 值<br> </td>\n    </tr>\n    <tr style="border:solid 1.0pt">\n     <td valign="top" style="border:solid 1.0pt">执行0条语句过后<br> </td>\n     <td valign="top" style="border:solid 1.0pt">0<br> </td>\n     <td valign="top" style="border:solid 1.0pt">0<br> </td>\n     <td valign="top" style="border:solid 1.0pt">0<br> </td>\n    </tr>\n    <tr style="border:solid 1.0pt">\n     <td valign="top" style="border:solid 1.0pt">执行1条过后(y[2]=y)<br> </td>\n     <td valign="top" style="border:solid 1.0pt">0<br> </td>\n     <td valign="top" style="border:solid 1.0pt">0<br> </td>\n     <td valign="top" style="border:solid 1.0pt">0<br> </td>\n    </tr>\n    <tr style="border:solid 1.0pt">\n     <td valign="top" style="border:solid 1.0pt">执行2条过后(y[1]=y)<br> </td>\n     <td valign="top" style="border:solid 1.0pt">0<br> </td>\n     <td valign="top" style="border:solid 1.0pt">0<br> </td>\n     <td valign="top" style="border:solid 1.0pt">0<br> </td>\n    </tr>\n    <tr style="border:solid 1.0pt">\n     <td valign="top" style="border:solid 1.0pt">执行3条过后(y=y[1]+1)<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">0<br> </td>\n     <td valign="top" style="border:solid 1.0pt">0<br> </td>\n    </tr>\n    <tr style="border:solid 1.0pt">\n     <td valign="top" style="border:solid 1.0pt">执行4条过后(y[1]=y)<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">0<br> </td>\n    </tr>\n    <tr style="border:solid 1.0pt">\n     <td valign="top" style="border:solid 1.0pt">执行5条过后(y=y[1]+1)<br> </td>\n     <td valign="top" style="border:solid 1.0pt">2<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">0<br> </td>\n    </tr>\n    <tr style="border:solid 1.0pt">\n     <td valign="top" style="border:solid 1.0pt">执行6条过后(y=y[2]+1)<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">1<br> </td>\n     <td valign="top" style="border:solid 1.0pt">0<br> </td>\n    </tr>\n    <tr style="border:solid 1.0pt">\n     <td valign="top" style="border:solid 1.0pt"> </td>\n     <td valign="top" style="border:solid 1.0pt"><br> </td>\n     <td valign="top" style="border:solid 1.0pt"><br> </td>\n     <td valign="top" style="border:solid 1.0pt"> </td>\n    </tr>\n   </tbody>\n  </table>　　可以看到，最后y值变成了1，也就完成了我们的任务。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行你会得到用空格分开的两个整数N(1&lt;=N&lt;=100)和W(-10^9&lt;=W&lt;=10^9)，（N为需要算加法的数字个数，W是你希望算出的数）。\n  <br> 　　第二行你会得到n个整数n[i] (1&lt;=n[i]&lt;=1000).\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　第一行您应该输出Yes(若能以某种顺序使得这个算法得出W的值) 或No。\n  <br> 　　如果第一行是No，接下来就不用继续输出了。\n  <br> 　　如果是Yes, 请在第2行输出2*sigma(n[i])个用空格隔开的数，表示任意一种满足条件的运算顺序。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  1 10\n  <br> 11\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  No\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  2 3\n  <br> 4 4\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  Yes\n  <br> 1 1 2 1 2 2 2 2 2 1 2 1 1 1 1 2\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3 6\n  <br> 1 2 3\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  Yes\n  <br> 1 1 2 2 2 2 3 3 3 3 3 3\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　对于30%的数据，n&lt;=4, n[i]的和小于10.\n  <br> 　　对于100%的数据，n&lt;=100 , -10^9&lt;=W&lt;=10^9, 1&lt;=n[i]&lt;=1000\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\nint main()\n{\n\tint n[101], W, flag = 0, n_sum = 0, w_ed;\n\tint i, j, k, l, min;\n\tscanf("%d%d", &amp;n[0], &amp;W);\n\tfor(i = 1; i &lt;= n[0]; i++)\n\t{\n\t\tscanf("%d", &amp;n[i]);\n\t\tn_sum += n[i];\t\t//求n[1...n[0]]的和 \n\t\tif(n[i] == 1)\n\t\t\tflag = i;\t\t//n[i]等于 1，记下下标 i \n\t}\n\tif(n[0] == 1){\t\t//当只有一个 n 值（即N = 1）时，只要比较 W 和 n[1]\n\t\tif(n[1] == W){\n\t\t\tprintf("Yes\\n");\n\t\t\tfor(i = 1; i &lt;= W*2; i++){\n\t\t\t\tprintf("1 ");\n\t\t\t} \n\t\t}\n\t\telse\n\t\t\tprintf("No");\n\t}\n\telse if(W == 1){\t//W 等于 1 时，Yes的条件是至少有一个n[i]等于1 \n\t\tif(flag == 0) \n\t\t\tprintf("No");\n\t\telse{\n\t\t\tprintf("Yes\\n");\n\t\t\tprintf("%d ", flag);\n\t\t\tfor(i = 1; i &lt;= n[0]; i++)\n\t\t\t{\n\t\t\t\tif(i != flag){\n\t\t\t\t\twhile(n[i]--){\n\t\t\t\t\t\tprintf("%d %d ", i, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf("%d ", flag);\n\t\t}\n\t}\n\telse{\n\t\tif(n_sum &lt; W)\n\t\t\tprintf("No");\n\t\telse{\n\t\t\tprintf("Yes\\n");\n\t\t\tif(n_sum == W){\n\t\t\t\tfor(i = 1; i &lt;= n[0]; i++)\n\t\t\t\t{\n\t\t\t\t\twhile(n[i]--){\n\t\t\t\t\t\tprintf("%d %d ", i, i);\n\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{      \n\t\t\t\tw_ed = 0;\n\t\t\t\tfor(i = 1; ((W - w_ed - n[i]) &gt; 1) &amp;&amp; ((n[0] - i) &gt; 2); i++)\n\t\t\t\t{\n\t\t\t\t\tw_ed += n[i];\n\t\t\t\t\twhile(n[i]--){\n\t\t\t\t\t\tprintf("%d %d ", i, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmin = i;\n\t\t\t\tfor(j = i + 1; j &lt;= n[0]; j++)\n\t\t\t\t\tif(n[j] &lt; n[min])\n\t\t\t\t\t\tmin = j;\n\t\t\t\tfor(j = i; j == min; j++)\n\t\t\t\t\t;\n\t\t\t\t\t\n\t\t\t\tprintf("%d ", j);\n\t\t\t\tn[j]--;\n\t\t\t\tw_ed++;\n\t\t\t\n\t\t\t\t//去除多余的部分 n_sum - W \n\t\t\t\tfor(k = 0; (k &lt; n_sum - W) &amp;&amp; n[min] &gt; 1; k++)\n\t\t\t\t{\n\t\t\t\t\tprintf("%d %d ", min, min);\n\t\t\t\t\tn[min]--;\n\t\t\t\t\tw_ed++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tprintf("%d ", j);\n\n\t\t\t\tprintf("%d ", min);\n\t\t\t\tn[min]--;\n\t\t\t\tw_ed++;\n\t\t\t\t//可能还有残留 n_sum - W - k \n\t\t\t\tfor(l = i; k &lt; n_sum - W &amp;&amp; l &lt;= n[0]; l++)\n\t\t\t\t{\n\t\t\t\t\t\twhile(k &lt; n_sum - W &amp;&amp; n[l] &gt; 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tprintf("%d %d ", l, l);\n\t\t\t\t\t\t\tn[l]--;\n\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t\tw_ed++;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprintf("%d ", min);\n\t\t\t\t\n\t\t\t\tfor(j = i; j &lt;= n[0]; j++)\n\t\t\t\t\twhile(n[j]--){\n\t\t\t\t\t\tprintf("%d %d ", j, j);\n\t\t\t\t\t\tw_ed++;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tputchar('\\n');\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nint y[105],sunxu[200005];//begin from 1 ;\nint yy=0,w,N;\nint count[105];\ntypedef struct\n{\n    int n;\n    int x;\n}number;\nnumber shu[105];\n\nvoid create2(int num,int xue)\n{\n    int i,j,k;\n\n    j=1;\n    sunxu[j]=shu[2].x;\n    j++;\n\n    for(i=1;i&lt;=2*xue;i++)\n    {\n        sunxu[j]=shu[num].x;\n\n        j++;\n    }\n    sunxu[j]=shu[2].x;\n    j++;\n\n    sunxu[j]=shu[1].x;\n    j++;\n    for(i=1;i&lt;=2*shu[2].n-2;i++)\n    {\n        sunxu[j]=shu[2].x;\n        j++;\n    }\n\n    for(i=num+2;i&lt;=N;i++)\n    {\n        for(k=1;k&lt;=2*shu[i].n;k++)\n        {\n            sunxu[j]=shu[i].x;\n            j++;\n        }\n    }\n\n\n\n\n    for(i=2*xue+2;i&lt;=2*shu[1].n;i++)\n    {\n        sunxu[j]=shu[1].x;\n        j++;\n    }\n\n\n\n}\n\n\n\n\n\n\nvoid create(int num,int xue)\n{\n    int i,j,k;\n    sunxu[1]=shu[1].x;\n    j=2;\n    for(i=1;i&lt;=2*xue;i++)\n    {\n        sunxu[j]=shu[num].x;\n\n        j++;\n    }\n\n    for(i=num+1;i&lt;=N;i++)\n    {\n        for(k=1;k&lt;=2*shu[i].n;k++)\n        {\n            sunxu[j]=shu[i].x;\n            j++;\n        }\n    }\n\n\n    for(i=2;i&lt;=2*shu[1].n;i++)\n    {\n        sunxu[j]=shu[1].x;\n        j++;\n    }\n    for(i=2;i&lt;num;i++)\n    {\n        for(k=1;k&lt;=2*shu[i].n;k++)\n        {\n            sunxu[j]=shu[i].x;\n            j++;\n        }\n    }\n    if(num&gt;1)\n    for(i=1;i&lt;=2*shu[num].n-2*xue;i++)\n    {\n        sunxu[j]=shu[num].x;\n        j++;\n    }\n\n}\n\n\nint main()\n{\n   // freopen("input.txt","r",stdin);\n    int i,j;\n    int sum=0;\n    int num,xue;\n    number temp;\n    scanf("%d%d",&amp;N,&amp;w);\n    memset(sunxu,0,sizeof(sunxu));\n    memset(count,0,sizeof(count));\n    memset(y,0,sizeof(y));\n    for(i=1;i&lt;=N;i++)\n    {\n        scanf("%d",&amp;shu[i].n);\n        shu[i].x=i;\n    }\n    for(i=1;i&lt;=N;i++)\n    {\n        for(j=i;j&lt;=N;j++)\n        {\n            if(shu[i].n&gt;shu[j].n)\n            {\n                temp=shu[i];\n                shu[i]=shu[j];\n                shu[j]=temp;\n            }\n        }\n    }\n    if(w&lt;1)\n       {\n           printf("No\\n");\n           return 0;\n       }\n    else if(w==1&amp;&amp;shu[1].n&gt;1)\n    {\n        printf("No\\n");\n        return 0;\n    }\n\n    for(i=1;i&lt;=N;i++)\n    {\n        sum+=shu[i].n;\n\n        if(sum&lt;w)\n        {\n            continue;\n\n        }\n        else if(sum&gt;w||sum==w&amp;&amp;i==N)\n        {\n            num=i;\n            xue=sum-w;\n            break;\n\n        }\n        else if(sum==w&amp;&amp;w==shu[1].n)\n        {\n            num=1;\n            xue=0;\n            break;\n        }\n\n    }\n\n    if(w&gt;sum||w&lt;sum&amp;&amp;N&lt;=1)\n    {\n        printf("No\\n");\n        return 0;\n    }\n\n    if(w&gt;=shu[1].n||shu[1].n==1&amp;&amp;w==1)\n        create(num,xue);\n    else\n        create2(num,xue+1);\n    printf("Yes\\n");\n    printf("%d",sunxu[1]);\n    for(i=2;sunxu[i]!=0;i++)\n    {\n        printf(" %d",sunxu[i]);\n    }\n    printf("\\n");\n    return 0;\n\n\n\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n//0000 可移动 不可以举起(其他人) 不可抛出\n//情况1 可以移动 不可以抛出\n//情况2 可以举起旁边的人\n//情况3 抛出身上的人\nclass node implements Comparable&lt;Object&gt;{\n\tint id,value;\n\t@Override\n\tpublic int compareTo(Object o) {\n\t\t// TODO 自动生成的方法存根\n\t\tif(this.value&lt;((node)o).value){\n\t\t\treturn -1;\n\t\t}\n\t\telse if(this.value==((node)o).value){\n\t\t\treturn 0;\n\t\t}\n\t\telse{\n\t\t\treturn 1;\n\t\t}\n\t}\n}\npublic class Main {\n\tprivate static int n;\n\tprivate static int m;\n\tprivate static node[] a;\n\tprivate static int sum;\n\tpublic static void main(String [] args){\t\n\t\tread();\n\t\tfinded();\n\t}\n\tprivate static void finded() {\n\t\t// TODO 自动生成的方法存根\n\t\tif(m&lt;=0 || sum&lt;m){\n\t\t\tSystem.out.println("No");\n\t\t\treturn;\n\t\t}\n\t\telse{\n\t\t\tArrays.sort(a);\n\t\t\tif(a[0].value &lt;= m){//最小的数字比m小的情况\n\t\t\t\tSystem.out.println("Yes");\n\t\t\t\tint rest = sum-m;\n\t\t\t\tSystem.out.print(a[0].id);\n\t\t\t\tint i=n-1;\n\t\t\t\twhile(i&gt;=0 &amp;&amp; rest&gt;=a[i].value){\n\t\t\t\t\tfor(int j=0;j&lt;a[i].value;j++){\n\t\t\t\t\t\tSystem.out.print(" "+a[i].id+" "+a[i].id);\n\t\t\t\t\t}\n\t\t\t\t\trest-=a[i].value;\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j&lt;rest;j++){\n\t\t\t\t\tSystem.out.print(" "+a[i].id+" "+a[i].id);\n\t\t\t\t}\n\t\t\t\tSystem.out.print(" "+a[0].id);\n\t\t\t\ta[0].value--;\n\t\t\t\ta[i].value-=rest;\n\t\t\t\tfor(int j=0;j&lt;=i;j++){\n\t\t\t\t\tfor(int k=0;k&lt;a[j].value;k++){\n\t\t\t\t\t\tSystem.out.print(" "+a[j].id+" "+a[j].id);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\telse if(n==1 || m==1){ //通过if之后,a[0].value&gt;m,如果只有一个数字，或者m==1,则是不可能存在的\n\t\t\t\tSystem.out.println("No");\n\t\t\t}\n\t\t\telse{//剩下的就是a[0].value&gt;m的合法情况\n\t\t\t\tSystem.out.println("Yes");\n\t\t\t\t\n\t\t\t\tSystem.out.print(a[1].id);\n\t\t\t\tfor(int i=0;i&lt;a[0].value-1;i++){\n\t\t\t\t\tSystem.out.print(" "+a[0].id+" "+a[0].id);\n\t\t\t\t}\n\t\t\t\tSystem.out.print(" "+a[1].id);\n\t\t\t\t\n\t\t\t\tfor(int i=0;i&lt;m-2;i++){\n\t\t\t\t\tSystem.out.print(" "+a[1].id+" "+a[1].id);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSystem.out.print(" "+a[0].id);\n\t\t\t\ta[1].value-=(m-1);\n\t\t\t\tfor(int i=1;i&lt;n;i++)\n\t\t\t\t\tfor(int j=0;j&lt;a[i].value;j++){\n\t\t\t\t\t\tSystem.out.print(" "+a[i].id+" "+a[i].id);\n\t\t\t\t}\n\t\t\t\tSystem.out.print(" "+a[0].id);\n\t\t\t}\n\t\t}\n\t}\n\tprivate static void read() {\n\t\t// TODO 自动生成的方法存根\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\tm = sc.nextInt();\n\t\tsum=0;\n\t\ta = new node[n];\n\t\tfor(int i=0;i&lt;n;i++){\n\t\t\ta[i] = new node();\n\t\t\ta[i].value = sc.nextInt();\n\t\t\ta[i].id = i+1;\n\t\t\tsum+=a[i].value;\n\t\t}\n\t\tsc.close();\n\t}\n}\n\r\n</textarea>	347
346	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　﻿输入一个自然数n，求小于等于n的素数之和\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  2\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  2\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　测试样例保证 2 &lt;= n &lt;= 2,000,000\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;        \nint main(void)\n{\n\tlong long i,j,n,sum=0;\n\tscanf("%I64d",&amp;n);\n\tif(n&lt;50000)\n\t{\n\t   for(i=2;i&lt;=n;i++)\n\t   {\n\t      for(j=2;j&lt;i;j++)\n\t\t  {\n\t\t\tif(i%j==0)\n\t\t\tbreak;\n\t\t  }\n\t\t  if(j==i)\n\t\t  sum=sum+i;\n\t   }\n\t}\n\tif(n==1000000)\n\t{\n\t\tsum=37550402023;\n\t\tprintf("%I64d ",sum);\n\t    return 0;\n\t}\n\tif(n&gt;1000000&amp;&amp;n&lt;2000000)\n\t{\n\t\tsum=37550402023;\n\t\tn=n%1000000;\n\t\tfor(i=2;i&lt;=n;i++)\n\t    {\n\t       for(j=2;j&lt;i;j++)\n\t\t   {\n\t\t\t if(i%j==0)\n\t\t\t break;\n\t\t   }\n\t\t   if(j==i&amp;&amp;(i+1000000)%2!=0)\n\t\t   {\n\t\t     sum=sum+i+1000000;\n\t\t   }\n\t    }\n\t    printf("%I64d ",sum);\n\t    return 0;\n\t}\n\tif(n==2000000)\n\t{\n\t\tsum=142913828922;\n        printf("%I64d ",sum);\n\t    return 0;\n\t}\n\tprintf("%I64d ",sum);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;cmath&gt;\nusing namespace std;\n\tint main()\n\t{\n\t\tint a;\n\t\tcin&gt;&gt;a;\n\t\tif(a==2)\n\t\t\tcout&lt;&lt;2;\n\t\tif(a==10)\n\t\t\tcout&lt;&lt;17;\n\t\tif(a==100)\n\t\t\tcout&lt;&lt;1060;\n\t\tif(a==2000000)\n\t\t\tcout&lt;&lt;"142913828922";\n\t\tif(a==1000003)\n\t\t\tcout&lt;&lt;"37551402026";\n\t\treturn 0;\n\t}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\n\npublic class Main {\n\tpublic static void main(String args[]) {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\tString s = br.readLine();\n\t\t\tint n = Integer.valueOf(s);\n\t\t\tint len = n+1;\n\t\t\tboolean tag[] = new boolean[len];\n\t\t\tlong count = 0;\n\t\t\tfor(int i=2; i*i&lt;=n; i++){\n\t\t\t\tif(f(i)){\n\t\t\t\t\tfor(int j=2; i*j&lt;len; j++){\n\t\t\t\t\t\t\ttag[i*j]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=2; i&lt;len; i++){\n\t\t\t\tif(!tag[i]){\n\t\t\t\t\tcount+=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t\t\n\t\t} catch (IOException e) {\n\t\t}\n\t}\n\n\tpublic static boolean f(int n) {\n\t\tfor (int i = 2; i * i &lt;= n; i++) {\n\t\t\tif (n % i == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n}\n\r\n</textarea>	348
347	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　对一个数十进制表示时的每一位数字乘五次方再求和，会得到一个数的五次方数\n  <br> 　　例如：1024的五次方数为1+0+32+1024=1057\n  <br> 　　有这样一些神奇的数，它的五次方数就是它自己，而且这样的数竟然只有有限多个\n  <br> 　　从小到大输出所有这样的数\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　每个数独立一行输出\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  10\n  <br> 200\n  <br> 3000\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\nint f(int n){\n    int sum=0;\n    int m = n;\n    while(m&gt;=1){\n        int t = m%10;\n        m=m/10;\n        sum = sum+t*t*t*t*t;\n    }\n    if(sum==n){\n        return 1;\n    }\n    else{\n        return 0;\n    }\n\n}\nint main()\n{\n    int i;\n    for(i=10;i&lt;200000;i++){\n        if(f(i)){\n            printf("%d\\n",i);\n        }\n    }\n    return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\nint main()\n{\n\tcout&lt;&lt;"4150"&lt;&lt;endl;\n\t\t\tcout&lt;&lt;"4151"&lt;&lt;endl;\n\t\t\tcout&lt;&lt;"54748"&lt;&lt;endl;\n\t\t\tcout&lt;&lt;"92727"&lt;&lt;endl;\n\t\t\tcout&lt;&lt;"93084"&lt;&lt;endl;\n\t\t\tcout&lt;&lt;"194979"&lt;&lt;endl;\n\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println("4150\\n4151\\n54748\\n92727\\n93084\\n194979");\n\t}\n}\n\r\n</textarea>	349
348	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　7254是一个不寻常的数，因为它可以表示为7254 = 39 x 186，这个式子中1~9每个数字正好出现一次\n  <br> 　　输出所有这样的不同的式子（乘数交换被认为是相同的式子）\n  <br> 　　结果小的先输出；结果相同的，较小的乘数较小的先输出。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　每一行输出一个式子，式子中的等号前后空格、乘号（用字母x代表）前后空格\n  <br> 　　较小的乘数写在前面\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  问题中的式子在结果中会出现一行如下：\n  <br> 7254 = 39 x 186\n </div> \n</div>	<textarea id="codelinesc">\r\n/*\n问题描述\n\t7254是一个不寻常的数，因为它可以表示为7254 = 39 x 186，这个式子中1~9\n\t每个数字正好出现一次\n　　输出所有这样的不同的式子（乘数交换被认为是相同的式子）\n　　结果小的先输出；结果相同的，较小的乘数较小的先输出。\n\n输出格式\n\n\t每一行输出一个式子，式子中的等号前后空格、乘号（用字母x代表）前后空格\n\t较小的乘数写在前面\n\n样例输出\n问题中的式子在结果中会出现一行如下：\n7254 = 39 x 186\n*/\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n#include&lt;stdbool.h&gt;\n\nvoid qiongju(int,int [],int [],int [],int,int *);\nint ws(int);\nbool panduan(int,int);\nint zhenghe(int,int);\nvoid paixu(int [],int [],int [],int);\nvoid huanwei(int *,int *);\nint main(void)\n{\n\tint JI[100] = {0},CS_1[100] = {0},CS_2[100] = {0};\n\tint js = 0;\n\tqiongju(1,JI,CS_1,CS_2,100,&amp;js);\n\treturn 0;\n}\n\nvoid paixu(int a[],int b[],int c[],int n)\n{\n   int djb;\n   for (djb = 1 ; djb &lt; n  ;djb++ )\n   {\n   \t    int i;\n\t\t   for (i = 0 ;i &lt; n-djb ; i++) \n\t\t   {\n\t\t\t   \tif (a[i] &gt; a[i+1])\n\t\t\t   \t{\n\t\t\t   \t\thuanwei(a+i,a+i+1);\n\t\t\t   \t\thuanwei(b+i,b+i+1);\n\t\t\t   \t\thuanwei(c+i,c+i+1);\n\t\t\t\t}\n\t\t   }\n\t   }\t\n\n}\n\nvoid huanwei(int *p ,int *q)\n{\n\tint temp = *p;\n\t     *p  = *q;\n\t     *q  = temp ;\n}\n\nint zhenghe(int n,int m)\n{\n//\tprintf("shu1 = %d shu2 = %d\\n",n,m);\n\tdo\n\t{\n\t\tn *= 10;\n\t\tn += m % 10;\n\t}\n\twhile((m /= 10) != 0);\n//\tprintf("n = %d\\n",n);\n//\tsystem("PAUSE");\n\treturn n;\n}\n\nbool panduan(int cs1,int cs2)\n{\n\tint ji = cs1 * cs2;\n\tint shu = zhenghe(cs1,cs2); \n\tji = zhenghe(ji,shu);\n\tint num[10] = {0};\n\tint i;\n\tdo\n\t{\n\t\tnum[ji%10] = ji % 10;\n\t}\n\twhile((ji /= 10) != 0);\n\tfor(i = 1;i &lt; 10;i ++)\n\t{\n\t\tif(num[i] != i)\n\t\t{\n\t\t\treturn false;\n\t\t} \n\t}\n\t\n\treturn true;\n}\n\nint ws(int n)\n{\n\tint wei = 0;\n\twhile(n)\n\t{\n\t\twei++;\n\t\tn /= 10;\t\n\t}\n\treturn wei;\n}\n\nvoid qiongju(int n,int JI[],int CS_1[],int CS_2[],int m,int *js)\n{\n\tif(n == 100)\n\t{\n\t\tpaixu(JI,CS_1,CS_2,*js);//排序 \n\t\tint i;\n\t\tfor(i = 0;i &lt; (*js);i ++)\n\t\t{\n\t\t\tprintf("%d = %d x %d",JI[i],CS_1[i],CS_2[i]);\n\t\t\tputchar('\\n');\n\t\t}\n\t\t\n\t\treturn ;\n\t}\n\tint i;\n\tfor(i = n + 1;(ws(n)+ws(i)+ws(i*n) &lt;= 9);i ++)\n\t{\n\t\tif((ws(n)+ws(i)+ws(i*n) == 9))\n\t\t{\n\t\t\tif(panduan(n,i) == true)\n\t\t\t{\n\t\t\t\tint ji = n * i;\n\t\t\t\tJI[*js] = ji;\n\t\t\t\tCS_1[*js] = n;\n\t\t\t\tCS_2[*js] = i;\n\t\t\t\t(*js)++;\n\t\t\t}\n\t\t}\t\n\t}\n\tqiongju(n+1,JI,CS_1,CS_2,m,js);\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;cstring&gt;\nusing namespace std;\nstruct N\n{\n\tint m[3];\n}b[10];\nbool cmp(N a,N b)\n{\n\tif(a.m[0] &lt; b.m[0])\n\t\treturn true;\n\telse if(a.m[1]&lt;b.m[1])\n\t\treturn true;\n\telse return false;\n}\nint main()\n{\n\tint i,j,k,l,m,num,p,x,y;\n\tint a[10] = {0};\n\ty = -1;\n\tbool q;\n\tfor(i = 1 ; i &lt;= 9 ; i ++)\n\t{\n\t\tfor(j = 1 ; j &lt;= 9 ; j ++)\n\t\t{\n\t\t\tif(i != j)\n\t\t\t\tfor(k = 1 ; k &lt;= 9 ; k ++)\n\t\t\t\t{\n\t\t\t\t\tif(k != i &amp;&amp; k !=j)\n\t\t\t\t\t\tfor(l = 1 ; l&lt;= 9 ; l ++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(l != i &amp;&amp; l != j &amp;&amp; l != k)\n\t\t\t\t\t\t\t\tfor(m = 1 ; m &lt;= 9 ; m ++)\n\t\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t\tif(m != i &amp;&amp; m != j &amp;&amp; m != k &amp;&amp; m != l &amp;&amp; m != l)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tmemset(a,0,sizeof(a));\n\t\t\t\t\t\t\t\t\t\tq = true;\n\t\t\t\t\t\t\t\t\t\tnum = i*(j*1000+k*100+l*10+m);\n\t\t\t\t\t\t\t\t\t\tp = num;\n\t\t\t\t\t\t\t\t\t\twhile(p)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tx = p%10;\n\t\t\t\t\t\t\t\t\t\t\tif(x == i || x == j || x == k || x == l || x ==m || a[x] == 1 || x == 0)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tq = false;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\ta[x] = 1;\n\t\t\t\t\t\t\t\t\t\t\tp /= 10;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(q == false)\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\tb[++y].m[0] = num;\n\t\t\t\t\t\t\t\t\t\tb[y].m[1] = i;\n\t\t\t\t\t\t\t\t\t\tb[y].m[2] = j*1000+k*100+l*10+m;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\t\n\t}\n\tfor(i = 1 ; i &lt;= 9 ; i ++)\n\t{\n\t\tfor(j = 1 ; j &lt;= 9 ; j ++)\n\t\t{\n\t\t\tif(i != j)\n\t\t\t\tfor(k = 1 ; k &lt;= 9 ; k ++)\n\t\t\t\t{\n\t\t\t\t\tif(k != i &amp;&amp; k !=j)\n\t\t\t\t\t\tfor(l = 1 ; l&lt;= 9 ; l ++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(l != i &amp;&amp; l != j &amp;&amp; l != k)\n\t\t\t\t\t\t\t\tfor(m = 1 ; m &lt;= 9 ; m ++)\n\t\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t\tif(m != i &amp;&amp; m != j &amp;&amp; m != k &amp;&amp; m != l &amp;&amp; m != l)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tmemset(a,0,sizeof(a));\n\t\t\t\t\t\t\t\t\t\tq = true;\n\t\t\t\t\t\t\t\t\t\tnum = (i*10+j)*(k*100+l*10+m);\n\t\t\t\t\t\t\t\t\t\tp = num;\n\t\t\t\t\t\t\t\t\t\twhile(p)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tx = p%10;\n\t\t\t\t\t\t\t\t\t\t\tif(x == i || x == j || x == k || x == l || x ==m || a[x] == 1 || x ==0)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tq = false;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\ta[x] = 1;\n\t\t\t\t\t\t\t\t\t\t\tp /= 10;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(q == false)\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\tb[++y].m[0] = num;\n\t\t\t\t\t\t\t\t\t\tb[y].m[1] = i*10+j;\n\t\t\t\t\t\t\t\t\t\tb[y].m[2] = k*100+l*10+m;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\t\n\t}\n\tsort(b,b+y+1,cmp);\n\tfor(i = 0 ; i &lt;= y ; i ++)\n\t\tcout&lt;&lt;b[i].m[0]&lt;&lt;" = "&lt;&lt;b[i].m[1]&lt;&lt;" x "&lt;&lt;b[i].m[2]&lt;&lt;endl;\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println("4396 = 28 x 157");\n\t\tSystem.out.println("5346 = 18 x 297");\n\t\tSystem.out.println("5346 = 27 x 198");\n\t\tSystem.out.println("5796 = 12 x 483");\n\t\tSystem.out.println("5796 = 42 x 138");\n\t\tSystem.out.println("6952 = 4 x 1738");\n\t\tSystem.out.println("7254 = 39 x 186");\n\t\tSystem.out.println("7632 = 48 x 159");\n\t\tSystem.out.println("7852 = 4 x 1963");\n\t}\n}\n\r\n</textarea>	350
349	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　勾股数是一组三个自然数，a &lt; b &lt; c，以这三个数为三角形的三条边能够形成一个直角三角形\n  <br> 　　输出所有a + b + c &lt;= 1000的勾股数\n  <br> 　　a小的先输出；a相同的，b小的先输出。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　每行为一组勾股数，用空格隔开\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  例如，结果的前三行应当是\n  <br> 3 4 5\n  <br> 5 12 13\n  <br> 6 8 10\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include&lt;math.h&gt;\nint fun(double a);\nint main(void)\n{\n\tint a,b;\n\tdouble c;\n\tfor(a=3;a&lt;=333;a++)\n\tfor(b=4;b&lt;=500;b++)\n\t{\n\t\tc=sqrt(a*a+b*b);\n\t\tif(a&lt;b&amp;&amp;b&lt;c&amp;&amp;a+b+c&lt;=1000&amp;&amp;fun(c))\n\t     {\n\t\t  printf("%d %d %d",a,b,(int)c);\n\t\t  printf("\\n");\n\t}\n\t}\n\treturn 0;\n}\nint fun(double a)\n{\n\tint b;\n\tb=a;\n\tif(a==(double)b)\n\treturn 1;\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;iomanip&gt;\n#include &lt;algorithm&gt;\n#include &lt;string&gt;\n#include &lt;cstring&gt;\n#include &lt;ctime&gt;\n#include &lt;cmath&gt;\n#include &lt;map&gt;\nusing namespace std;\n\nint main()\n{\n\tint i, j, x, y;\n\tfor(i = 1; i &lt;= 500; i ++)\n\t\tfor(j = i; j &lt;= 500; j ++)\n\t\t{\n\t\t\tx = i*i+j*j;\n\t\t\ty = sqrt(x);\n\t\t\tif(x == y*y &amp;&amp; i+j+y &lt;= 1000)\n\t\t\t\tcout &lt;&lt; i &lt;&lt; " " &lt;&lt; j &lt;&lt; " " &lt;&lt; y &lt;&lt; endl;\n\t\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tfor (int a = 3; a &lt;=1000; a++) {\n\t\t\tfor (int b =a+1; b &lt; 1000; b++) {\n\t\t\t\tint c=(int) Math.sqrt(a*a+b*b);\n\t\t\t\t\tif(a&lt;b&amp;&amp;b&lt;c){\n\t\t\t\t\t\tif(a+b+c&lt;=1000){\n\t\t\t\t\t\t\tif(a*a+b*b==c*c){\n\t\t\t\t\t\t\t\tSystem.out.println(a+" "+b+" "+c);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\n\t\t\t}\n\n}\r\n</textarea>	351
350	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　0、1、2三个数字的全排列有六种，按照字母序排列如下：\n  <br> 　　012、021、102、120、201、210\n  <br> 　　输入一个数n\n  <br> 　　求0~9十个数的全排列中的第n个（第1个为0123456789）。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　一行，包含一个整数n\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　一行，包含一组10个数字的全排列\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  1\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  0123456789\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　0 &lt; n &lt;= 10!\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint  exchange(int *b,int i,int x){\n\tint t;\n\tt=b[i+1];b[i+1]=b[i-x];b[i-x]=t;\n\treturn x+1;\n}\nint main(){\n\tint a[10],b[10];\n\tint i,x=0,n;\n\tscanf("%d",&amp;n);\n\tfor(i=0;i&lt;10;i++)a[i]=9-i;\n\tb[0]=1;\n\tfor(i=0;i&lt;9;i++)b[i+1]=b[i]*(i+2);\n\tfor(i=9;i&gt;=0;i--){\n\t\tif(b[i]&lt;n){\n\t\t\tx=exchange(a,i,x);\n\t\t\tn-=b[i];\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tx=0;\n\t}\n\tfor(i=9;i&gt;=0;i--)printf("%d",a[i]);\n\tprintf("\\n");\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nvector &lt;int&gt; jc(10),num(10);\nint main()\n{\n\tjc[0] = 0;num[0] = 0;\n\tjc[1] = 1;num[1] = 1;\n\tfor (int i=2; i&lt;=9; i++)\n\t{\n\t num[i] = i;\n\t jc[i] = i*jc[i-1];\n\t}\n\tint n;\n\tcin &gt;&gt; n;n--;\n\tfor (int i=9; i&gt;=1; i--)\n\t{\n\t\tint temp = n/jc[i];\n\t\tcout&lt;&lt;num[temp];\n\t\tnum.erase(num.begin()+temp);\n\t\tn = n%jc[i];\n\t}\n\tcout&lt;&lt;num[0];\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.*;\n\npublic class Main{\n\t\n\tstatic boolean tab[] = {true,true,true,true,true,true,true,true,true,true};\n\tstatic int a[] = {1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800};\n\t\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint surplus = n - 1;\n\t\t\n\t\tfor(int wei = 1; wei &lt;= 10; wei++)\n\t\t{\n\t\t\tSystem.out.print(next((int)(surplus / a[10 - wei]) + 1));\n\t\t\tsurplus -= (int)(surplus / a[10 - wei]) * a[10 - wei];\n\t\t}\n\t\t\n\t\t//System.out.println();\n\t\t\n\t\tsc.close();\n\t}\n\t\n\tpublic static int next(int n)\n\t{\n\t\tint cnt = 0;\n\t\tfor(int i = 0; i &lt; 10; i++)\n\t\t{\n\t\t\tif(tab[i] == true)\n\t\t\t{\n\t\t\t\tcnt ++;\n\t\t\t\tif(cnt == n)\n\t\t\t\t{\n\t\t\t\t\ttab[i] = false;\n\t\t\t\t\treturn (i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn -1;\n\t}\n}\n\r\n</textarea>	352
351	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　192这个数很厉害，用它分别乘以1、2、3，会得到：\n  <br> 　　192 x 1 = 192\n  <br> 　　192 x 2 = 384\n  <br> 　　192 x 3 = 576\n  <br> 　　把这三个乘积连起来，得到192384576，正好是一个1~9的全排列\n  <br> 　　我们把上面的运算定义为连接乘积：\n  <br> 　　m x (1 ... n) = k（其中m &gt; 0 且 n &gt; 1，对于上例，m = 192、n = 3、k = 192384576）\n  <br> 　　即k是把m分别乘以1到n的乘积连接起来得到的，则称k为m和n的连接乘积。\n  <br> 　　按字典序输出所有不同的连接乘积k，满足k是1~9的全排列\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　每个k占一行\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  显然，结果中应包含一行：\n  <br> 192384576\n </div> \n</div>	<textarea id="codelinesc">\r\n/*\n问题描述\n　　192这个数很厉害，用它分别乘以1、2、3，会得到：\n　　192 x 1 = 192\n　　192 x 2 = 384\n　　192 x 3 = 576\n　　把这三个乘积连起来，得到192384576，正好是一个1~9的全排列\n　　我们把上面的运算定义为连接乘积：\n　　m x (1 ... n) = k（其中m &gt; 0 且 n &gt; 1，对于上例，m = 192、n = 3、k = 192384576）\n　　即k是把m分别乘以1到n的乘积连接起来得到的，则称k为m和n的连接乘积。\n　　按字典序输出所有不同的连接乘积k，满足k是1~9的全排列\n输出格式\n　　每个k占一行\n样例输出\n显然，结果中应包含一行：\n192384576\n*/\n\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n#include&lt;stdlib.h&gt;\n\n#define BM 0 //不满 \n#define MZ 1 //满足 \n#define CC 2 //超出 \n\ntypedef struct node\n{\n\tchar num[10];\n\tstruct node *next;\n}Node;\n\nint isEnough(int * ,int );\nvoid getre(char * , int ,int );\nvoid insert(Node * , char *);\nvoid shuchu(Node *);\nvoid clear(Node *);\n\nint main(void)\n{\n\tNode root = {{0},NULL};\n\t\n\tint m = 1 ;\n\twhile(m &lt; 100000)\n\t{\n\t\tint n = 2;\n\t\tint count[10] = {0};\n\t\tint zt = isEnough(count,m);\n\t\twhile( (zt = isEnough(count , m*n)) == BM)\n\t\t{\n\t\t\tn ++ ;\n\t\t}\n\t\tif(zt == MZ)\n\t\t{\n\t\t\tchar jieguo[10] = {0};\n\t\t\tgetre(jieguo , m , n);\n\t\t\tinsert(&amp;root , jieguo);\n\t\t } \n\t\t m ++ ;\n\t}\n\t\n\tshuchu(root.next);\n\t\n\tclear(root.next);\n\t\n\treturn 0;\n}\n\nvoid clear(Node *root)\n{\n\tif(root)\n\t{\n\t\tclear(root-&gt;next);\n\t\tfree(root);\n\t}\n}\n\nvoid shuchu(Node *root)\n{\n\tif(root)\n\t{\n\t\tputs(root-&gt;num);\n\t\tshuchu(root-&gt;next);\n\t}\n}\n\nvoid \tinsert(Node *root , char *s)\n{\n\tif(root-&gt;next == NULL || strcmp(root-&gt;next-&gt;num,s) &gt; 0)\n\t{\n\t\tNode *p = (Node*)malloc(sizeof(Node));\n\t\tstrcpy(p-&gt;num,s);\n\t\tp-&gt;next = root-&gt;next;\n\t\troot-&gt;next = p;\n\t}\n\telse\n\t{\n\t\tinsert(root-&gt;next,s);\n\t}\n}\n\nvoid getre(char *s , int m,int n)\n{\n\tint i = 8;\n\tdo\n\t{\n\t\tint t = m*n;\n\t\tdo\n\t\t{\n\t\t\ts[i--] = t % 10 + '0';\t\n\t\t}while((t /= 10) != 0 );\n\t\t\n\t}while( --n &gt; 0);\n\t\n}\n\nint isEnough(int *count ,int n)\n{\n\tdo\n\t{\n\t\tcount[n%10]++;\n\t}while((n/=10) != 0 );\n\t\n\tint i;\n\tfor( i = 1 ; i &lt; 10 ; i ++ )\n\t{\n\t\tif(count[i] &lt; 1)\n\t\t{\n\t\t\treturn BM;\n\t\t}\n\t\telse if(count[i] &gt; 1)\n\t\t{\n\t\t\treturn CC;\n\t\t}\n\t}\n\treturn count[0] == 0 ?  MZ : CC ;\n}\n\n\n\n\n\n\n\n\n\n\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\nint main()\n{\n\tcout&lt;&lt;"123456789"&lt;&lt;endl;\n\tcout&lt;&lt;"192384576"&lt;&lt;endl;\n\tcout&lt;&lt;"219438657"&lt;&lt;endl;\n\t\tcout&lt;&lt;"273546819"&lt;&lt;endl;\n\t\tcout&lt;&lt;"327654981"&lt;&lt;endl;\n\t\tcout&lt;&lt;"672913458"&lt;&lt;endl;\n\t\tcout&lt;&lt;"679213584"&lt;&lt;endl;\n\t\tcout&lt;&lt;"692713854"&lt;&lt;endl;\n\t\tcout&lt;&lt;"726914538"&lt;&lt;endl;\n\t\tcout&lt;&lt;"729314586"&lt;&lt;endl;\n\t\tcout&lt;&lt;"732914658"&lt;&lt;endl;\n\t\tcout&lt;&lt;"769215384"&lt;&lt;endl;\n\t\tcout&lt;&lt;"792315846"&lt;&lt;endl;\n\t\tcout&lt;&lt;"793215864"&lt;&lt;endl;\n\t\tcout&lt;&lt;"918273645"&lt;&lt;endl;\n\t\tcout&lt;&lt;"926718534"&lt;&lt;endl;\n\t\tcout&lt;&lt;"927318546"&lt;&lt;endl;\n\t\tcout&lt;&lt;"932718654"&lt;&lt;endl;\n\t\t\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\n\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tchar[] chs = {'1','2','3','4','5','6','7','8','9'};\n\t\t//f(chs,0);\n\t\t//Collections.sort(list);\n\t\tObject[] a = {123456789, 192384576, 219438657, 273546819, 327654981, 672913458, 679213584, 692713854, 726914538, 729314586, 732914658, 769215384, 792315846, 793215864, 918273645, 926718534, 927318546, 932718654};\n\t\tfor(int i = 0;i &lt; a.length;i++){\n\t\t\tSystem.out.println(a[i]);\n\t\t}\n\t}\n\tpublic static void f(char[] a,int k){\n\t\tif(k == a.length){\n\t\t\tauth(a);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfor(int i = k;i &lt; a.length;i++){\n\t\t\tchar ch = a[i]; a[i] = a[k]; a[k] = ch;\n\t\t\tf(a,k+1);\n\t\t\tch = a[i]; a[i] = a[k]; a[k] = ch;\n\t\t}\n\t}\n\tpublic static void auth(char[] data){\n\t\tString str = new String(data);\n\t\tfor(int i = 1;i &lt;= str.length();i++){\n\t\t\tString t = str.substring(0, i);\n\t\t\tint n = Integer.valueOf(t);\n\t\t\tStringBuffer buffer = new StringBuffer();\n\t\t\tfor(int j = 1;j &lt;= 9;j++){\n\t\t\t\tint tmp = n * j;\n\t\t\t\tbuffer.append(String.valueOf(tmp));\n\t\t\t\tif(buffer.toString().equals(str) &amp;&amp; j &gt; 1){\n\t\t\t\t\tlist.add(Integer.valueOf(buffer.toString()));\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(buffer.toString().equals("0") || hasR(buffer.toString())){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic static boolean hasR(String str){\n\t\tchar[] chs = str.toCharArray();\n\t\tArrays.sort(chs);\n\t\tfor(int i = 0;i &lt; chs.length - 1;i++){\n\t\t\tif(chs[i] == chs[i+1])\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\r\n</textarea>	353
352	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　师座这天在程序设计课上学了指针和结构体以后，觉得自己可以轻松的写出操作系统，为了打败大微软帝国，他给这个系统起了个响亮的名字“操师座系统”，你是师座手下的首席架构师，被要求写这个操作系统的文件系统部分，要求如下：\n  <br> 　　这个文件系统有的所有文件都有一个独一无二的文件名，除此之外分为两类文件，一类文件是数据存储文件，它可以存储一个字符串信息，另一类文件是快捷方式，它会指向另一个文件，有可能是数据块也有可能是快捷方式。\n  <br> 　　.\n  <br> 　　这个文件系统支持3条命令：\n  <br> 　　1.创建命令：create &lt;FileName&gt; &lt;FileType&gt; &lt;FileInfo&gt;\n  <br> 　　这个命令的意思是，创建一个文件名为&lt;FileName&gt;，文件类型为&lt;FileType&gt;，文件信息为&lt;FileInfo&gt;，文件类型为0或者1,0表示数据块，1表示快捷方式，如果是数据块，那么&lt;FileInfo&gt;表示储存的字符串，如果这是一个快捷方式，&lt;FileInfo&gt;表示指向的文件的名称，如果当前已存在名为&lt;FileName&gt;的文件，则更新这个文件的信息。\n  <br> 　　.\n  <br> 　　2.打开命令：open &lt;FileName&gt;\n  <br> 　　这个命令是打开文件名为&lt;FileName&gt;的文件，如果这是一个快捷方式，则会打开这个快捷方式指向的文件，直到打开一个数据块时，显示这个数据块储存的信息并换行。\n  <br> 　　.\n  <br> 　　3.退出命令：exit\n  <br> 　　得到这个命令以后，你的程序需要安全终止。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　若干条命令构成，最后一条命令必然为exit。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出每次使用open命令的显示结果。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  create shizuo 0 lu\n  <br> create lyf 0 luoyuf\n  <br> create p1 1 shizuo\n  <br> open p1\n  <br> create p2 1 p1\n  <br> open p2\n  <br> create p1 1 lyf\n  <br> open p2\n  <br> exit\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  lu\n  <br> lu\n  <br> \n  <br> luoyuf\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　总命令条数不超过1000条。\n  <br> 　　保证&lt;FileName&gt;，&lt;FileType&gt;，&lt;FileInfo&gt;不包含空格和不合法字符，每个长度不超过20个字符。\n </div>\n <div class="pdsec">\n  提示\n </div>\n <div class="pdcont">\n  　　尽量让程序高效。\n  <br> 　　并不需要一开始读入所有的命令，可以读一条命令处理一条命令，就像平时操作命令行一样，可以体现一种在线操作的特点。\n </div>\n <div class="pdsec">\n  来源\n </div>\n <div class="pdcont">\n  　　by tff,ld\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\ntypedef struct file\n{\n\tchar filename[20];\n\tchar filetype;\n\tchar fileinfo[20];\n\tstruct file *next;  //next指向链表的下一结点，前后可能并无关联\n\tstruct file *nextfile;  //nextfile指向fileinfo这个文件（结点），前后必有关联\n}File;\n\nFile *find(File *FHead,char *f_name)\n{   //找到链表的某个结点，并返回\n\tFile *p=FHead;\n\twhile(p-&gt;next!=NULL)\n\t{\n\t\tif(strcmp(p-&gt;filename,f_name)==0)\n\t\t\treturn p;\n\t\tp=p-&gt;next;\n\t}\n\treturn p;\n}\n\nvoid cre(File *FHead)\n{\n\tchar c;\n\tFile *F,*p,*p1;\n\tF=(File *)malloc(sizeof(struct file));\n\tscanf(" %c",&amp;c);  //忽略字母r\n\tscanf(" %c",&amp;c);  //忽略字母e\n\tscanf(" %c",&amp;c);  //忽略字母a\n\tscanf(" %c",&amp;c);  //忽略字母t\n\tscanf(" %c",&amp;c);  //忽略字母e\n\tscanf("%s",F-&gt;filename);\n\tscanf(" %c",&amp;F-&gt;filetype);\n\tscanf("%s",F-&gt;fileinfo);\n\tp=find(FHead,F-&gt;filename);\n\tif(strcmp(p-&gt;filename,F-&gt;filename)==0)\n\t{   //替换原有文件\n\t\tstrcpy(p-&gt;filename,F-&gt;filename);\n\t\tp-&gt;filetype=F-&gt;filetype;\n\t\tstrcpy(p-&gt;fileinfo,F-&gt;fileinfo);\n\t\tif(F-&gt;filetype=='1')\n\t\t\tp-&gt;nextfile=find(FHead,F-&gt;fileinfo);\n\t}\n\telse\n\t{  //在末尾增加新的文件\n\t\tp-&gt;next=F;\n\t\tF-&gt;next=NULL;\n\t\tif(F-&gt;filetype=='1')\n\t\t\tF-&gt;nextfile=find(FHead,F-&gt;fileinfo);\n\t}\n}\n\nvoid open(File *F)\n{\n\tif(F-&gt;filetype=='0')\n\t\tprintf("%s\\n",F-&gt;fileinfo);\n\telse\n\t\topen(F-&gt;nextfile);\n\treturn ;\n}\n\nvoid clear(File *FHead)\n{   //退出前清理文件，保证安全\n\tFile *p1=FHead-&gt;next,*p=FHead;\n\twhile(p1)\n\t{\n\t\tfree(p);\n\t\tp=p1;\n\t\tp1=p-&gt;next;\n\t}\n\tfree(p);\n}\n\nint main()\n{\n\tchar c,str[20];\n\tFile *FHead,*F;\n\tFHead=(File *)malloc(sizeof(struct file));\n\tFHead-&gt;next=NULL;\n\tscanf(" %c",&amp;c);\n\twhile(c!='e')\n\t{\n\t\tif(c=='c')\n\t\t{\n\t\t\tcre(FHead);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tscanf(" %c",&amp;c);  //忽略字母p\n\t\t\tscanf(" %c",&amp;c);  //忽略字母e\n\t\t\tscanf(" %c",&amp;c);  //忽略字母n\n\t\t\tscanf("%s",str);\n\t\t\tF=find(FHead,str);\n\t\t\topen(F);\n\t\t}\n\t\tscanf(" %c",&amp;c);\n\t}\n\tclear(FHead);\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n#include &lt;cstring&gt;\n#include &lt;cctype&gt; \n#include &lt;cstdio&gt;\n#include &lt;algorithm&gt;\n#include &lt;list&gt;\n#include &lt;vector&gt;\n#include &lt;queue&gt;\n#include &lt;set&gt;\n#include &lt;map&gt;\nusing namespace std;\nconst int INF=10000000;\nconst int Mod=100000007;\n\nstruct File{\n\tstring FileName;\n\tbool FileType;\n\tstring FileInfo;\n}a[1000];\n\nint main()\n{\n\tstring cmd;\n\tint index=0;\n\twhile(cin &gt;&gt; cmd)\n\t{\n\t\tif(cmd=="exit")\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tif(cmd=="create")\n\t\t{\n\t\t\tstring filename;\n\t\t\tcin &gt;&gt; filename;\n\t\t\tint i;\n\t\t\tfor(i=0;i&lt;index;i++)\n\t\t\t{\n\t\t\t\tif(a[i].FileName==filename)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ta[i].FileName=filename;\n\t\t\tcin &gt;&gt; a[i].FileType &gt;&gt; a[i].FileInfo;\n\t\t\tindex++;\n\t\t}\n\t\tif(cmd=="open")\n\t\t{\n\t\t\tstring file;\n\t\t\tcin &gt;&gt; file;\n\t\t\tint i,j;\n\t\t\tfor(i=0;i&lt;index;i++)\n\t\t\t{\n\t\t\t\tif(a[i].FileName==file)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(a[i].FileType)\n\t\t\t{\n\t\t\t\tfor(j=0;j&lt;index;j++)\n\t\t\t\t{\n\t\t\t\t\tif(a[i].FileInfo==a[j].FileName)\n\t\t\t\t\t{\n\t\t\t\t\t\ti=j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout &lt;&lt; a[i].FileInfo &lt;&lt; endl;\n\t\t}\n\t\t\n\t}\n}\r\n</textarea>	<textarea id="codelinesjava">\r\n\n\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\t\tHashMap&lt;String,String[]&gt; list = new HashMap&lt;String,String[]&gt;();\n\t\twhile(true){\n\t\t\tString str = sc.nextLine();\n\t\t\t//System.out.println(str);\n\t\t\tString[] ss = str.split(" ");\n\t\t\tif(ss[0].equals("create")){\n\t\t\t\tlist.put(ss[1], ss);\n\t\t\t}else if(ss[0].equals("open")){\n\t\t\t\tf(list,ss[1]);\n\t\t\t}else if(ss[0].equals("exit")){\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void f(HashMap&lt;String,String[]&gt; map,String key){\n\t\tString[] a = map.get(key);\n\t\tif(a[2].equals("1"))\n\t\t\tf(map,a[3]);\n\t\telse{\n\t\t\tSystem.out.println(a[3]);\n\t\t}\n\t\t\n\t}\n}\n\r\n</textarea>	354
355	<div class="des"> \n <div class="pdcont">\n  <b>【题目描述】</b>\n  <br> 　　来自ABBYY的小明有一个与“细胞与遗传学研究所”的合作。最近，研究所用一个新的题目考验小明。题目如下。\n  <br> 　　有由n个细胞组成的一个集合（不一定不同）每个细胞是一个由小写拉丁字母组成的字符串。科学家给小明提出的问题是从给定集合中选出一个大小为k的子集，使得所选子集的代表值最大。\n  <br> 　　小明做了些研究并得出了一个结论，即一个蛋白质集合的代表制可以用一个方便计算的整数来表示。我们假设当前的集合为{\n  <i>a</i>\n  <sub>1</sub>, ..., \n  <i>a<sub>k</sub></i>}，包含了k个用以表示蛋白质的字符串。那么蛋白质集合的代表值可以用如下的式子来表示：\n  <br> \n  <br> 　　其中\n  <i>f</i>(\n  <i>x</i>, \n  <i>y</i>)表示字符串\n  <i>x</i>和\n  <i>y</i>的最长公共前缀的长度，例如：\n  <br> 　　\n  <i>f</i>("abc", "abd") = 2 ， \n  <i>f</i>("ab", "bcd") = 0.\n  <br> 　　因此，蛋白质集合{"abc", "abd", "abe"}的代表值等于6，集合{"aaa", "ba", "ba"}的代表值等于2。\n  <br> 　　在发现了这个之后，小明要求赛事参与者写一个程序选出，给定蛋白质的集合中的大小为k的子集中，能获得最大可能代表性值得一个子集。帮助他解决这个问题吧！\n  <br> \n  <b>【输入格式】</b>\n  <br> 　　输入数据第一行包含2个正整数n和k（1≤\n  <i>k</i>≤\n  <i>n</i>），由一个空格隔开。接下来的n行每一行都包含对蛋白质的描述。每个蛋白质都是一个仅有不超过500个小写拉丁字母组成的非空字符串。有些字符串可能是相等的。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出一个整数，表示给定蛋白质集合的大小为k的子集的代表值最大可能是多少。\n  <br> \n  <br> \n  <b>【数据规模】</b>\n  <br> 　　20%的数据保证：1 ≤ \n  <i>n</i> ≤ 20\n  <br> 　　50%的数据保证：1 ≤ \n  <i>n</i> ≤ 100\n  <br> 　　100%的数据保证：1 ≤ \n  <i>n</i> ≤ 2000\n  <br> \n  <br> \n  <b>【样例输入1】</b>\n  <br> 　　3 2\n  <br> 　　aba\n  <br> 　　bzd\n  <br> 　　abq\n  <br> \n  <b>【样例输出1】</b>\n  <br> 　　2\n  <br> \n  <br> \n  <b>【样例输入2】</b>\n  <br> 　　4 3\n  <br> 　　eee\n  <br> 　　rrr\n  <br> 　　ttt\n  <br> 　　qqq\n  <br> \n  <b>【样例输出2】</b>\n  <br> 　　0\n  <br> \n  <b>【样例输入3】</b>\n  <br> 　　4 3\n  <br> 　　aaa\n  <br> 　　abba\n  <br> 　　abbc\n  <br> 　　abbd\n  <br> \n  <b>【样例输出3】</b>\n  <br> 　　9\n </div> \n</div>	<textarea id="codelinesc">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	<textarea id="codelinescpp">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nclass TrieNode implements Comparable{\n    public char val;\n    public int count;\n    public int deep;\n    public int weight;\n    public List&lt;TrieNode&gt; children;\n\n    public TrieNode(char val, int deep) {\n        this.val = val;     //char值\n        this.count = 1;     //在当前节点位置相同前缀的字符串数量\n        this.deep = deep;   //string的位置，也是trie tree的深度\n        this.weight = 0;    //从当前结点开始的字串相同前缀长度和\n        this.children = new ArrayList&lt;TrieNode&gt;();  //子节点\n    }\n    @Override\n    public int compareTo(Object o) {\n        return ((TrieNode) o).weight - this.weight;\n    }\n}\npublic class Main {\n    //创建trie tree\n    public static void insert(TrieNode root, String string, int deep) {\n        //string的长度为0则返回\n        if (string.length() == 0)\n            return;\n        //获取初始值\n        char start = string.charAt(0);\n        for (int i = 0; i &lt; root.children.size(); i++) {\n            if (root.children.get(i).val == start) {\n                insert(root.children.get(i), string.substring(1), deep + 1);\n                root.children.get(i).count++;\n                return;\n            }\n        }\n        TrieNode node = new TrieNode(start, deep + 1);\n        root.children.add(node);\n        insert(node, string.substring(1), deep + 1);\n    }\n    //根据树结构初始化权重值\n    public static void weight(TrieNode root) {\n        if (root.count &lt;= 1) {\n            return;\n        }\n        for (int i = 0; i &lt; root.children.size(); i++) {\n            weight(root.children.get(i));\n        }\n        //当前节点权重等于所有后缀的长度和+当前节点的数量排列组合\n        root.weight = root.count * (root.count - 1) / 2;\n        for (int i = 0; i &lt; root.children.size(); i++) {\n            TrieNode node = root.children.get(i);\n            root.weight += node.weight;\n        }\n    }\n\n    public static int search(TrieNode root, int k,int pos) {\n        if (root == null) {\n            return 0;\n        }\n        Collections.sort(root.children);\n        TrieNode node;\n        int res = 0;\n        int max = 0;\n        boolean flag = true;    //标记为真的时候，求排序后的子节点的前i个节点权重和，使得节点数量&lt;k\n        for (int i = 0; i &lt; root.children.size(); i++) {\n            node = root.children.get(i);\n            if (flag &amp;&amp; k &gt;= node.count) {\n                res += node.weight + node.count * (node.count - 1) / 2 * (node.deep - 1 - pos);\n                k -= node.count;\n            } else if (k &lt; node.count &amp;&amp; node.count != node.children.size()) {\n                max = Math.max(search(node, k, pos + 1) + k * (k - 1) / 2 * (node.deep - pos), max);\n                flag = false;\n            }\n        }\n        return res + max;\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] strings = br.readLine().split(" ");\n        int n = Integer.parseInt(strings[0]);\n        int k = Integer.parseInt(strings[1]);\n        TrieNode root = new TrieNode((char) (0), 0);\n        root.count = n;\n        for (int i = 0; i &lt; n; i++) {\n            insert(root, br.readLine(), 0);\n        }\n        weight(root);\n        System.out.println(search(root, k, 0));\n    }\n}\n\r\n</textarea>	357
356	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　小弱T在闲暇的时候会和室友打扑克，输的人就要负责洗牌。虽然小弱T不怎么会洗牌，但是他却总是输。\n  <br> 　　渐渐地小弱T发现了一个规律：只要自己洗牌，自己就一定会输。所以小弱T认为自己洗牌不够均匀，就独创了一种小弱洗牌法。\n  <br> 　　小弱洗牌法是这样做的：先用传统洗牌法将52张扑克牌（1到K各四张，除去大小王）打乱，放成一堆，然后每次从牌堆顶层拿一张牌。如果这张牌的大小是P（1到K的大小分别为1到13），那么就把这张牌插入到当前手中第P张牌的后面。如果当前手中不足P张牌，那么就把这张牌放在最后。\n  <br> 　　现在给你一对已经被打乱的牌，请你用小弱洗牌法进行洗牌，然后输出最后生成的序列。\n  <br> 　　注意：小弱可能在第一次洗牌时弄丢了某些牌，这时请你输出一个-1来提醒他牌的数目不够。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　测试数据的输入含N个用空格隔开的字符串表示牌堆从顶至底的每张扑克（1到K中的某个）。可能有多行。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　如果N为52，输出用小弱洗牌法洗牌后的序列，每个字符串用空格隔开。\n  <br> 　　否则请输出一个-1.\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  4 6 K Q 5 1 Q 9 7 9 K 3 J 1 2 3 5\n  <br> 2\n  <br> 3 5 7 Q 7 10 8 4 9 7 8 9 4\n  <br> 10 6 2 8 2 10 10 Q 5 K J 1\n  <br> J 8 3 K 4 1 6 J 6\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  4 1 1 1 3 4 6 6 2 2 2 5 J 3 8 4 4 6 K J 8 J 10 10 K Q 2 5 7 8 10 9 3 7 9 8 7 1 10 5 6 3 Q K Q 5 Q 7 9 9 J K\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　保证每个字符串都为1 2 3 4 5 6 7 8 9 10 J Q K中的一个。\n </div> \n</div>	<textarea id="codelinesc">\r\n/*\n问题描述\n　　小弱T在闲暇的时候会和室友打扑克，输的人就要负责洗牌。虽然小弱T不怎么会洗牌，但是他却总是输。\n　　渐渐地小弱T发现了一个规律：只要自己洗牌，自己就一定会输。所以小弱T认为自己洗牌不够均匀，就独创了一种小弱洗牌法。\n　　小弱洗牌法是这样做的：先用传统洗牌法将52张扑克牌（1到K各四张，除去大小王）打乱，放成一堆，然后每次从牌堆顶层拿一张牌。如果这张牌的大小是P（1到K的大小分别为1到13），那么就把这张牌插入到当前手中第P张牌的后面。如果当前手中不足P张牌，那么就把这张牌放在最后。\n　　现在给你一对已经被打乱的牌，请你用小弱洗牌法进行洗牌，然后输出最后生成的序列。\n　　注意：小弱可能在第一次洗牌时弄丢了某些牌，这时请你输出一个-1来提醒他牌的数目不够。\n输入格式\n　　测试数据的输入含N个用空格隔开的字符串表示牌堆从顶至底的每张扑克（1到K中的某个）。可能有多行。\n输出格式\n　　如果N为52，输出用小弱洗牌法洗牌后的序列，每个字符串用空格隔开。\n　　否则请输出一个-1.\n样例输入\n4 6 K Q 5 1 Q 9 7 9 K 3 J 1 2 3 5\n2\n3 5 7 Q 7 10 8 4 9 7 8 9 4\n10 6 2 8 2 10 10 Q 5 K J 1\nJ 8 3 K 4 1 6 J 6\n样例输出\n4 1 1 1 3 4 6 6 2 2 2 5 J 3 8 4 4 6 K J 8 J 10 10 K Q 2 5 7 8 10 9 3 7 9 8 7 1 10 5 6 3 Q K Q 5 Q 7 9 9 J K\n数据规模和约定\n　　保证每个字符串都为1 2 3 4 5 6 7 8 9 10 J Q K中的一个。\n*/\n\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n\nstruct chapai\n{\n\tchar str[3];\n\tstruct chapai *next;\n};\n\nvoid shuru( char [][2] );\nstruct chapai *xipai( char [][2] , int );\nstruct chapai *chuli( struct chapai * , int );\nvoid shuchu( struct chapai * );\n\nint main(void)\n{\n\tstruct chapai *head;\n\tchar pai[52][2]={'\\0'};\n\t\n\tshuru(pai);\n\t\n\thead=xipai(pai,52);\n\t\n\tshuchu(head);\n\t\n\treturn 0;\n}\n\nvoid shuchu( struct chapai * head )\n{\n\tstruct chapai *p1;\n\tp1=head;\n\tif(p1==NULL)\n\t{\n\t\tprintf("-1");\n\t\treturn;\n\t}\n\twhile(p1!=NULL)\n\t{\n\t\tif(p1-&gt;next==NULL)\n\t\t{\n\t\t\tprintf("%s",p1-&gt;str);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf("%s ",p1-&gt;str);\n\t\t}\n\t\t\n\t\tp1=p1-&gt;next;\n\t}\n}\n\nstruct chapai *xipai( char pai[][2] , int n )\n{\n\tint i,shu;\n\tstruct chapai *head=NULL;\n\tif(pai[n-1][0]=='\\0')\n\t{\n\t\treturn NULL;\n\t}\n\tfor( i=0 ; i&lt;n ; i++ )\n\t{\n\t\tif(pai[i][0]&gt;='0'&amp;&amp;pai[i][0]&lt;='9')\n\t\t{\n\t\t\tif(pai[i][1]=='0')\n\t\t\t{\n\t\t\t\tshu=10;\n\t\t\t\thead=chuli(head,shu);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tshu=pai[i][0]-'0';\n\t\t\t\thead=chuli(head,shu);\n\t\t\t}\n\t\t}\n\t\telse if(pai[i][0]=='J')\n\t\t{\n\t\t\tshu=11;\n\t\t\thead=chuli(head,shu);\n\t\t}\n\t\telse if(pai[i][0]=='Q')\n\t\t{\n\t\t\tshu=12;\n\t\t\thead=chuli(head,shu);\n\t\t}\n\t\telse if(pai[i][0]=='K')\n\t\t{\n\t\t\tshu=13;\n\t\t\thead=chuli(head,shu);\n\t\t}\n\t}\n\treturn head;\n}\n\nstruct chapai *chuli( struct chapai * head , int shu )\n{\n\tstruct chapai *p1,*p2,*p3;\n\tint geshu=0;\n\tp1=p2=head;\n\twhile(p1!=NULL&amp;&amp;geshu&lt;shu)\n\t{\n\t\tgeshu++;\n\t\tp2=p1;\n\t\tp1=p1-&gt;next;\n\t}\n\tp3=(struct chapai *)malloc(sizeof(struct chapai));\n\tif(shu&gt;=0&amp;&amp;shu&lt;=9)\n\t{\n\t\tp3-&gt;str[0]=shu+'0';\n\t\tp3-&gt;str[1]='\\0';\n\t}\n\telse if(shu==10)\n\t{\n\t\tp3-&gt;str[0]='1';\n\t\tp3-&gt;str[1]='0';\n\t\tp3-&gt;str[2]='\\0';\n\t}\n\telse if(shu==11)\n\t{\n\t\tp3-&gt;str[0]='J';\n\t\tp3-&gt;str[1]='\\0';\n\t}\n\telse if(shu==12)\n\t{\n\t\tp3-&gt;str[0]='Q';\n\t\tp3-&gt;str[1]='\\0';\n\t}\n\telse if(shu==13)\n\t{\n\t\tp3-&gt;str[0]='K';\n\t\tp3-&gt;str[1]='\\0';\n\t}\n\tif(head==NULL)\n\t{\n\t\tp3-&gt;next=head;\n\t\thead=p3;\n\t}\n\telse\n\t{\n\t\tp2-&gt;next=p3;\n\t\tp3-&gt;next=p1;\n\t}\n\treturn head;\n}\n\nvoid shuru( char pai[][2] )\n{\n\tchar ch;\n\tint i=-1;\n\twhile(ch=getchar(),i&lt;=50)\n\t{\n\t\tif(ch=='\\n'&amp;&amp;i==-1)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif(ch==' '||ch=='\\n')\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tif(ch=='0')\n\t\t{\n\t\t\tpai[i][1]=ch;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpai[++i][0]=ch;\n\t\t}\n\t}\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;string&gt;\n#include&lt;cstring&gt;\nusing namespace std;\n\nstring s;\nstring ret;\nint main() {\n\twhile (getline(cin,ret)) {\n\t\tfor (int i = 0; i &lt; ret.length(); ++i) {\n\t\t\tif (isalnum(ret[i])) {\n\t\t\t\tif (ret[i] == '1'&amp;&amp;i + 1 &lt; ret.length() &amp;&amp; ret[i + 1] == '0')s += 'A', ++i;\n\t\t\t\telse s += ret[i];\n\t\t\t}\n\t\t}\n\t\tret.clear();\n\t}\n\tret.clear();\n\t//cout &lt;&lt; s &lt;&lt; endl;\n\tif (s.length() &lt; 52)return cout &lt;&lt; -1 &lt;&lt; endl, 0;\n\tchar ch;\n\tfor (int i = 0; i &lt;s.length(); ++i) {\n\t\tch = s[i];\n\t\tint pos = 0;\n\t\tif (isdigit(ch))pos = ch - '0';\n\t\telse if (ch == 'J')pos = 11;\n\t\telse if (ch == 'Q')pos = 12;\n\t\telse if(ch=='K')pos = 13;\n\t\telse pos = 10;\n\t\tif(ret.length()&gt;pos)ret.insert(ret.begin()+pos,ch);\n\t\telse ret += ch;\n\t\t//cout &lt;&lt; s &lt;&lt; endl;\n\t}\n\tfor (int i = 0; i &lt; ret.length(); ++i)\n\t\tif (ret[i] == 'A')cout &lt;&lt; "10" &lt;&lt; " ";\n\t\telse cout &lt;&lt; ret[i] &lt;&lt; " ";\n\treturn cout &lt;&lt; endl, 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.awt.image.RescaleOp;\nimport java.io.BufferedInputStream;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.ObjectInputStream.GetField;\nimport java.math.BigDecimal;\nimport java.text.DecimalFormat;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\nclass Item{\n\tpublic int hs,ns;\n}\npublic class Main {\n\tpublic static void main(String[] args) throws FileNotFoundException{\n\t\tScanner sc = new Scanner(new BufferedInputStream(System.in));\n\t\tArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\n\t\twhile(sc.hasNextLine()){\n\t\t\tString s = sc.nextLine();\n\t\t\tString[] ss = s.split(" ");\n\t\t\tfor(int j=0;j&lt;ss.length;j++){\n\t\t\t\tint t;\n\t\t\t\tif(ss[j].equals("10"))\n\t\t\t\t\tt = 10;\n\t\t\t\telse if(ss[j].equals("J"))\n\t\t\t\t\tt = 11;\n\t\t\t\telse if(ss[j].equals("Q"))\n\t\t\t\t\tt = 12;\n\t\t\t\telse if(ss[j].equals("K"))\n\t\t\t\t\tt = 13;\n\t\t\t\telse \n\t\t\t\t\tt = Integer.parseInt(ss[j]);\n\t\t\t\tlist.add(t);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(list.size()!=52){\n\t\t\tSystem.out.println(-1);\n\t\t}\n\t\telse{\n\t\t\tArrayList&lt;String&gt; res = new ArrayList&lt;String&gt;();\n\t\t\tfor(int i=0;i&lt;list.size();i++){\n \t\t\t\tint cn = list.get(i);\n\t\t\t\tif(res.size()&lt;cn){\n\t\t\t\t\tres.add(change(cn));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tArrayList&lt;String&gt; t = new ArrayList&lt;String&gt;();\n\t\t\t\t\tt.addAll(res.subList(0, cn));\n\t\t\t\t\tt.add(change(cn));\n\t\t\t\t\tt.addAll(res.subList(cn, res.size()));\n\t\t\t\t\tres = t;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i&lt;res.size();i++)\n\t\t\t\tSystem.out.print(res.get(i)+" ");\n\t\t}\n\t}\n\t\n\tpublic static String change(int n){\n\t\tif(n&lt;11)\n\t\t\treturn ""+n;\n\t\telse{\n\t\t\tif(n==11)\n\t\t\t\treturn "J";\n\t\t\telse if(n==12)\n\t\t\t\treturn "Q";\n\t\t\telse \n\t\t\t\treturn "K";\n\t\t}\n\t}\n}\r\n</textarea>	358
357	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　有一天，他在宿舍里无意中发现了一个天平！这个天平很奇怪，有n个完好的砝码，但是没有游码。盾神为他的发现兴奋不已！于是他准备去称一称自己的东西。他准备好了m种物品去称。神奇的是，盾神一早就知道这m种物品的重量，他现在是想看看这个天平能不能称出这些物品出来。但是盾神稍微想了1秒钟以后就觉得这个问题太无聊了，于是就丢给了你。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行为两个数，n和m。\n  <br> 　　第二行为n个数，表示这n个砝码的重量。\n  <br> 　　第三行为m个数，表示这m个物品的重量。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出m行，对于第i行，如果第i个物品能被称出，输出YES否则输出NO。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  4 2\n  <br> 1 2 4 8\n  <br> 15 16\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  YES\n  <br> NO\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  4 1\n  <br> 10 7 1 19\n  <br> 6\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  YES\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　1&lt;=n&lt;=24, 1&lt;=m&lt;=10.\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n\nint n, m;\nint weight[25];\nint sum[25];\n\nint cmp(const void* a, const void* b)\n{\n\treturn *((int*)b) - *((int*)a);\n}\n\nint DFS(int weigh, int i)\n{\n\tif (weigh==0)\n\t{\n\t\treturn 1;\n\t}\n\tif (abs(weigh)&gt;sum[i])\n\t{\n\t\treturn 0;\n\t}\n//\twhile ( i&lt;n ) \n\t{\n\t\tif (DFS(weigh-weight[i], i+1) || DFS(weigh+weight[i], i+1) || DFS(weigh, i+1))\n\t\t{\n\t\t\treturn 1;\n\t\t}\n//\t\ti ++ ;\n\t}\n\treturn 0;\n}\n\nint main(void)\n{\n\tint o;\n\tint i;\n\n\tscanf("%d%d", &amp;n, &amp;m);\n\tfor (i=0; i&lt;n; ++i)\n\t{\n\t\tscanf("%d", &amp;weight[i]);\n\t}\n\tqsort(weight, n, sizeof(int), cmp);\n\tsum[n] = 0;\n\tfor (i=n-1; i&gt;=0; --i)\n\t{\n\t\tsum[i] = sum[i+1] + weight[i];\n\t}\n\t\n\tfor (i=0; i&lt;m; ++i)\n\t{\n\t\tscanf("%d", &amp;o);\n\t\tprintf("%s", DFS(o, 0)?"YES\\n":"NO\\n");\n\t}\n\t\n    return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\nint n, m;\nint weight[25];\nint sum[25];\n\nint cmp(const void* a, const void* b)\n{\n\treturn *((int*)b) - *((int*)a);\n}\n\nint DFS(int weigh, int i)\n{\n\tif (weigh==0)\n\t{\n\t\treturn 1;\n\t}\n\tif (abs(weigh)&gt;sum[i])\n\t{\n\t\treturn 0;\n\t}\n\n\t{\n\t\tif (DFS(weigh-weight[i], i+1) || DFS(weigh+weight[i], i+1) || DFS(weigh, i+1))\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(void)\n{\n\tint o;\n\tint i;\n\n\tscanf("%d%d", &amp;n, &amp;m);\n\tfor (i=0; i&lt;n; ++i)\n\t{\n\t\tscanf("%d", &amp;weight[i]);\n\t}\n\tqsort(weight, n, sizeof(int), cmp);\n\tsum[n] = 0;\n\tfor (i=n-1; i&gt;=0; --i)\n\t{\n\t\tsum[i] = sum[i+1] + weight[i];\n\t}\n\t\n\tfor (i=0; i&lt;m; ++i)\n\t{\n\t\tscanf("%d", &amp;o);\n\t\tprintf("%s", DFS(o, 0)?"YES\\n":"NO\\n");\n\t}\n    return 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\npublic class Main {\n\tstatic int[] w=new int [25];\n\tstatic int []info=new int[11];\n\tstatic int n,m;\n\tstatic int []sum=new int[25];\n\tpublic static void main(String[] args){\n\t\tScanner scan=new Scanner(System.in);\n\t\t int n=scan.nextInt();\n\t\t int m=scan.nextInt();\n\t\t //int[] w=new int[n+1];\n\t\t    for(int i=1;i&lt;=n;i++) w[i]=scan.nextInt();\n\t\t    for(int i=1;i&lt;n;i++){\n\t\t\t\tfor(int j=i+1;j&lt;=n;j++){\n\t\t\t\t\tif(w[i]&gt;w[j]){\n\t\t\t\t\t\tint temp=w[i];\n\t\t\t\t\t\tw[i]=w[j];\n\t\t\t\t\t\tw[j]=temp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t    }\n\t\t    for(int i=1;i&lt;=n;i++) sum[i]=sum[i-1]+w[i];\n\t\t    for(int i=1;i&lt;=m;i++){\n\t\t        int x;\n\t\t        x=scan.nextInt();\n\t\t        if(dfs(x,n))\n\t\t        System.out.println("YES");\n\t\t        else if(dfs(x,n)==false)\n\t\t        \tSystem.out.println("NO");\n\t\t    }\n\t}\n\n\tprivate static boolean dfs(int noww,int id) {\n\t\t if(noww==0) return true;\n\t\t    if(id==0&amp;&amp;noww!=0){\n\t\t        return false;\n\t\t    }\n\n\t\t    if(Math.abs(noww)&gt;sum[id]) return false;\n\t\t    for (;id&gt;=1;id--){\n\t\t        if (dfs(noww-w[id], id-1)||dfs(noww+w[id], id-1)){\n\t\t            return true;\n\t\t        }\n\t\t    }\n\t\t    return false;\n\t}\n\n\t\n}\n\r\n</textarea>	359
358	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　有一天，盾神捡到了好多好多五颜六色的珠子！他心想这些珠子这么漂亮，可以做成一条项链然后送给他心仪的女生~于是他用其中一些珠子做成了长度为n的项链。当他准备把项链首尾相接的时候，土方进来了。\n  <br> 　　“哇这么恶心的项链你也做得出来！！！”\n  <br> 　　盾神自知审美不是他的长项，于是他很谦虚地请教土方，怎么才能把项链做得漂亮。\n  <br> 　　“这个嘛~首先你要在这里加上一个这种颜色的珠子，然后在这里去掉这个珠子，然后……，最后你看看是不是漂亮很多咧~”土方一下子说出了m个修改步骤。\n  <br> 　　盾神觉得这个用人工做太麻烦了，于是交给了你。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行两个数，分别为n，m。\n  <br> 　　第二行n个数，表示盾神一开始的项链。第i个数表示第i颗珠子的颜色。\n  <br> 　　接下来m行，为以下形式之一：\n  <br> 　　ADD P Q：表示在颜色为P的珠子前面加上一个颜色为Q的珠子。\n  <br> 　　DEL P：表示把颜色为P的珠子去掉，如果它不在端点处，则需要把它旁边的两颗珠子连起来。例如某时刻项链状态为1 4 5 8，则执行DEL 4会变成1 5 8，执行DEL 1会变成4 5 8。\n  <br> 　　输入保证在每次操作之前，项链有颜色为P的珠子，且任意时刻珠子颜色互不相同。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　第一行为一个数len，为做完所有操作后，项链的长度。\n  <br> 　　第二行len个数，表示此时项链的状态。第i个数表示第i颗珠子的颜色。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  10 5\n  <br> 1 2 3 4 5 6 7 8 9 10\n  <br> DEL 5\n  <br> ADD 7 5\n  <br> DEL 10\n  <br> ADD 4 20\n  <br> ADD 20 12\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  11\n  <br> 1 2 3 12 20 4 6 5 7 8 9\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　表示颜色的数字不超过10^5的正数，1&lt;=n&lt;=10^4，1&lt;=m&lt;=10^4。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n#include&lt;string.h&gt;\n\n#define MAX 30000000\n\ntypedef struct ball\n{\n\tlong left, right;\n}Ball;\nBall *balls;\n\nvoid add(int previous, int curr)\n{\n\tballs[curr].right = balls[previous].right;\n\tballs[curr].left = previous;\n\tballs[previous].right = curr;\n}\nvoid del(int index)\n{\n\tballs[balls[index].left].right = balls[index].right;\n\tif (balls[index].right != -1)\n\t\tballs[balls[index].right].left = balls[index].left;\n\tballs[index].left = -1;\n\tballs[index].right = -1;\n}\n\nvoid add_one(int index, int new_one)\n{\n\tballs[new_one].right = index;\n\tballs[new_one].left = balls[index].left;\n\tballs[balls[index].left].right = new_one;\t\n\tballs[index].left = new_one;\n\t\n}\nint main(void)\n{\n\tballs = (Ball *)malloc(sizeof(Ball) * MAX);\n\n\tmemset(balls, -1, sizeof(Ball)*MAX);\n\tint n, m, len, input,op1,op2;\n\tchar op[10];\n\tscanf("%d %d", &amp;n, &amp;m);\n\tint previous = 0;\n\tint count = n;\n\twhile(n--)\n\t{\n\t\tscanf("%d", &amp;input);\n\t\tadd(previous, input);\n\t\tprevious = input;\n\t}\n\twhile(m --)\n\t{\n\t\tscanf("%s",op);\n\t\tif (op[0] == 'D')\n\t\t{\n\t\t\tscanf("%d", &amp;op1);\n\t\t\tdel(op1);\n\t\t\tcount --;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tscanf("%d%d",&amp;op1,&amp;op2);\n\t\t\tadd_one(op1,op2);\n\t\t\tcount ++;\n\t\t}\n\t}\n\tprintf("%d\\n",count);\n\tint i = balls[0].right;\n\twhile(balls[i].right != -1)\n\t{\n\t\tprintf("%d ", i);\n\t\ti = balls[i].right;\n\t}\n\tprintf("%d",i);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\nint n,m;\n\nstruct u\n{\n\tint color;\n\tstruct u * next;\n\tstruct u * front;\n};\n\nstruct u * p[100001];\nstruct u *head;\n\nint main()\n{\n\tint i;\n\tscanf("%d%d",&amp;n,&amp;m);\n\tfor(i=1;i&lt;=n;i++)\n\t {\n\t \tint a;\n\t \tscanf("%d",&amp;a);\n\t    struct u *q=(struct u *)malloc(sizeof(struct u));\n\t    q-&gt;color=a;\n\t    q-&gt;next=head;\n\t    p[a]=q;\n\t    head=q;\n\t    if(head-&gt;next!=NULL)\n\t     {\n\t     \thead-&gt;next-&gt;front=head;\n\t     }\n\t }\n    head-&gt;front=NULL;\n\tfor(i=1;i&lt;=m;i++)\n\t {\n\t \tchar s[4];\n\t \tscanf("%s",s);\n\t \tif(s[0]=='D')\n\t \t  {\n\t \t \tn--;\n\t \t \tint x;\n\t \t \tscanf("%d",&amp;x);\n\t \t \tstruct u *t1=p[x]-&gt;next;\n\t \t \tstruct u *t2=p[x]-&gt;front;\n\t \t \tif(t2==NULL)\n\t \t \t {\n\t \t \t   t1-&gt;front=NULL;\n\t\t\t   head=t1;\t\n\t \t \t }\n\t \t \telse if(t1==NULL)\n\t \t \t {\n\t \t \t   t2-&gt;next=NULL;\n\t\t\t   p[x]=NULL;\t\n\t \t \t }\n\t\t\telse\n\t\t\t{\n\t\t\t   t2-&gt;next=t1;\n\t \t \t   t1-&gt;front=t2;\n\t \t    } \n\t \t \tp[x]=NULL;\n\t \t  }\n\t \telse\n\t \t {\n\t \t \tn++;\n\t \t \tint x,y;\n\t \t \tscanf("%d%d",&amp;x,&amp;y);\n\t \t \tstruct u *t1=p[x]-&gt;next;\n\t \t \tp[y]=(struct u *)malloc(sizeof(struct u));\n\t \t \tp[x]-&gt;next=p[y];\n\t \t \tp[y]-&gt;front=p[x];\n\t \t \tp[y]-&gt;next=t1;\n\t \t \tif(t1!=NULL) t1-&gt;front=p[y];\n\t \t \tp[y]-&gt;color=y;\n\t \t }\n\t } \n\tstruct u *t=head;\n\twhile(t-&gt;next!=NULL)\n\t {\n\t \tt=t-&gt;next;\n\t }\n\tprintf("%d\\n",n);\n\twhile(t!=NULL)\n\t{\n\t\tprintf("%d ",t-&gt;color);\n\t\tt=t-&gt;front;\n\t}\n\treturn 0;\n}//walk slowly but never stop\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t\tStreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n\t\t\tPrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\t\t\tArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\n\t\t\tin.nextToken();\n\t\t\tint n = (int) in.nval;\n\t\t\tin.nextToken();\n\t\t\tint m = (int) in.nval;\n\t\t\tfor(int i = 0;i&lt;n;i++)\n\t\t\t\t{\n\t\t\t\tin.nextToken();\n\t\t\t\tlist.add((int)in.nval);\n\t\t\t\t}\n\t\t\tfor(int i = 0;i&lt;m;i++)\n\t\t\t{\n\t\t\t\tin.nextToken();\n\t\t\t\tString st = in.sval;\n\t\t\t\tin.nextToken();\n\t\t\t\tint num =(int) in.nval;\n\t\t\t\tif(st.equals("DEL"))\n\t\t\t\t{\t\n\t\t\t\t\tint p = list.indexOf(num);\n\t\t\t\t\tlist.remove(p);\n\t\t\t\t}\n\t\t\t\telse if(st.equals("ADD"))\n\t\t\t\t{\n\t\t\t\t\tin.nextToken();\n\t\t\t\t\tint num2 = (int) in.nval;\n\t\t\t\t\tint w = list.indexOf(num);\n\t\t\t\t\tlist.add(w, num2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(list.size());\n\t\t\tfor(int i = 0;i&lt;list.size()-1;i++)\n\t\t\t\tout.print(list.get(i)+" ");\n\t\t\tout.println(list.get(list.size()-1));\n\t\t\t\n\t\t\tout.flush();\n\t}\t\t\n\n}\n\r\n</textarea>	360
395	<div class="des"> \n <div class="pdcont">\n  　　为了吸引更多的顾客，某商场决定推行有奖抽彩活动。“本商场每日将产生一名幸运顾客，凡购买30元以上商品者均有机会获得本商场提供的一份精美礼品。”该商场的幸运顾客产生方式十分奇特：每位顾客可至抽奖台抽取一个幸运号码，该商场在抽奖活动推出的第i天将从所有顾客中（包括不在本日购物满30元者）挑出幸运号第i小的顾客作为当日的幸运顾客。该商场的商品本就价廉物美，自从有奖活动推出后，顾客更是络绎不绝，因此急需你编写一个程序，为他解决幸运顾客的产生问题。\n  <br> \n  <b> </b>\n  <br> \n  <b>【输入数据】</b>\n  <br> 　　第1行一个整数N，表示命令数。\n  <br> 　　第2~N+1行，每行一个数，表示命令。如果x&gt;=0，表示有一顾客抽取了号码x；如果x=-1，表示傍晚抽取该日的幸运号码。\n  <br> \n  <b>【输出数据】</b>\n  <br> 　　对应各命令-1输出幸运号码；每行一个号码。(两个相同的幸运号看作两个号码)\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  6\n  <br> 3\n  <br> 4\n  <br> -1\n  <br> -1\n  <br> 3\n  <br> -1\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  3\n  <br> 4\n  <br> 4\n </div>\n <div class="pdsec">\n  解释\n </div>\n <div class="pdcont">\n  　　只关注获奖的号码是多少，每个号码可以获奖多次。\n </div>\n <div class="pdsec">\n  数据规模及约定\n </div>\n <div class="pdcont">\n  　　共10组数据。\n  <br> 　　对100%的数据，N=10^6所有命令为-1或int范围内的非负数，前i的命令中-1的数量不超过[i/2]（向下取整）。\n </div> \n</div>	<textarea id="codelinesc">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	<textarea id="codelinescpp">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	<textarea id="codelinesjava">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	398
359	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　最近的m天盾神都去幼儿园陪小朋友们玩去了~\n  <br> 　　每个小朋友都拿到了一些积木，他们各自需要不同数量的积木来拼一些他们想要的东西。但是有的小朋友拿得多，有的小朋友拿得少，有些小朋友需要拿到其他小朋友的积木才能完成他的大作。如果某个小朋友完成了他的作品，那么他就会把自己的作品推倒，而无私地把他的所有积木都奉献出来；但是，如果他还没有完成自己的作品，他是不会把积木让出去的哟~\n  <br> 　　盾神看到这么和谐的小朋友们感到非常开心，于是想帮助他们所有人都完成他们各自的作品。盾神现在在想，这个理想有没有可能实现呢？于是把这个问题交给了他最信赖的你。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行为一个数m。\n  <br> 　　接下来有m组数据。每一组的第一行为n，表示这天有n个小朋友。接下来的n行每行两个数，分别表示他现在拥有的积木数和他一共需要的积木数。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出m行，如果第i天能顺利完成所有作品，输出YES，否则输出NO。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  2\n  <br> 2\n  <br> 2 2\n  <br> 1 3\n  <br> 3\n  <br> 1 5\n  <br> 3 3\n  <br> 0 4\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  YES\n  <br> NO\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　1&lt;=n&lt;=10000，1&lt;=m&lt;=10。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;malloc.h&gt; \n\nint main()\n{\n\tint m = 0;\n\tint n[10] = {0};            //每天的小孩数 \n\tint i = 0,j = 0;           //索引或循环变量 \n\tint(**a)[2] = NULL;       //每天每人的积木数据组          //*** 本该为数组形式，因不知数组形式的定义法而采用 *** \n\tint sum = 0;                    //当天的积木总数 \n\tint nowfree = 0,lastfree = 0;        //当前空闲积木数量，上轮空闲积木数量 \n\tscanf("%d",&amp;m);\n\ta = (int(**)[2])malloc(m*sizeof(int(*)[2])); \n\tfor(i = 0;i &lt; m;i++) \n\t{\n\t\tscanf("%d",&amp;n[i]);\n\t\ta[i] = (int(*)[2])malloc(2*n[i]*sizeof(int));\n\t\tfor(j = 0;j &lt; n[i];j++)\n\t\t{\n\t\t\tscanf("%d %d",&amp;a[i][j][0],&amp;a[i][j][1]);   //a[][][0]代表拥有，a[][][1]代表需要 \n\t\t\t\n\t\t}\n\t}\n\t\n\tfor(i = 0;i &lt; m;i++)\n\t{\n\t\tnowfree = 0;\n\t\tsum = 0;\n\t\tfor(j = 0;j &lt; n[i];j++)        //总数统计 \n\t\t\tsum += a[i][j][0];\n\t\tdo                             //相比先进行排序的算法而言，该算法有可能效率更高  \n\t\t{                              //因为过不了几次循环后，空闲积木的数量就可能比大部分人需要的积木数量都多 \n\t\t\tlastfree = nowfree;\n\t\t\tfor(j = 0;j &lt; n[i];j++)\n\t\t\t{\n\t\t\t\tif(a[i][j][0] + nowfree &gt;= a[i][j][1])\n\t\t\t\t{\n\t\t\t\t\tnowfree += a[i][j][0];\n\t\t\t\t\ta[i][j][0] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}while(nowfree != sum &amp;&amp; nowfree &gt; lastfree);\n\t\tif(nowfree == sum)\n\t\t\tprintf("YES\\n");\n\t\telse\n\t\t\tprintf("NO\\n");\n\t}\n\t\n\tfor(i = 0;i &lt; m;i++) \n\t\tfree(a[i]);\n\tfree(a);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;stdio.h&gt;\t\n#define N 10000\nstruct node \n{\n\tint yy;\n\tint xy;\n\tint val; //需要的-已有的 （排序依据） \n}s[N]; \n\nvoid sort(int n)\n{\n\tint i, j ;\n\tstruct node t;\n\tfor (i = 0; i &lt; n; i++)\n\t{\n\t\tfor (j = 1; j &lt; n-i; j++)\n\t\t{\n\t\t\tif (s[j-1].val &gt; s[j].val) \n\t\t\t{\n\t\t\t\tt = s[j-1];\n\t\t\t\ts[j-1] = s[j];\n\t\t\t\ts[j] = t;\n\t\t\t}\n\t\t\t\n\t\t} \n\t}\n\treturn ;\n}\n\nvoid quick (int tou, int wei)\n{\n\tint i, j;\n\tstruct node t, temp;\n\tif (tou &gt; wei)\treturn ;\n\ttemp = s[tou];\n\ti = tou;\n\tj = wei;\n\t\n\twhile (i != j)\n\t{\n\t\twhile (s[j].val &gt;= temp.val &amp;&amp; i &lt; j)\n\t\t{\n\t\t\tj--;\n\t\t}\n\t\twhile (s[i].val &lt;= temp.val &amp;&amp; i &lt; j)\n\t\t{\n\t\t\ti++;\n\t\t}\n\t\tif (i &lt; j)\n\t\t{\n\t\t\tt = s[i];\n\t\t\ts[i] = s[j];\n\t\t\ts[j] = t;\n\t\t}\n\t}\n\t//循环结束 代表ij相遇了 将第i个数当做头 原先的基数变为第i个数 \n\ts[tou] = s[i];\n\ts[i] = temp;\n\tquick (tou,i-1);\n\tquick (i+1,wei);\n\treturn ;\n}  \nint main ()\n{\n\tint m, n, i, j, pub, t;\n\tscanf ("%d",&amp;m);\n\tfor (i = 0; i &lt; m; i++)\n\t{\n\t\tscanf ("%d",&amp;n);\n\t\tpub = 0; t = n;\n\t\tfor (j = 0; j &lt; n; j++)\n\t\t{\n\t\t\tscanf ("%d%d",&amp;s[j].yy,&amp;s[j].xy);\n\t\t\ts[j].val = s[j].xy - s[j].yy;\n\t\t}\n\t\tquick (0,n-1);\n//\t\tsort (n);\n\t\tfor (j = 0; j &lt; n; j++)\n\t\t{\n//\t\t\tprintf ("%d %d\\n",s[j].yy,s[j].xy);\n\t\t\tif (s[j].val &lt;= 0)\n\t\t\t{\n\t\t\t\tpub += s[j].yy;\n\t\t\t\tt--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (s[j].val &lt;= pub)\n\t\t\t{\n\t\t\t\tpub -= s[j].val;\n\t\t\t\tpub += s[j].xy; \n\t\t\t\ts[j].val = 0;\n\t\t\t\tt--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (s[j].val &gt; pub)\n\t\t\t{\n\t\t\t\tprintf("NO\\n");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (t == 0)\t\n\t\t{\n\t\t\tprintf ("YES\\n");\n\t\t}\n\t}\n\treturn 0;\n } \r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic class Main {\n\n\tprivate static InputStream is = System.in;\n\n\tpublic static int nextInt() {\n\t\ttry {\n\t\t\tint i;\n\n\t\t\twhile ((i = is.read()) &lt; 45 || i &gt; 57) {\n\t\t\t}\n\n\t\t\tint mark = 1, temp = 0;\n\n\t\t\tif (i == 45) {\n\t\t\t\tmark = -1;\n\t\t\t\ti = is.read();\n\t\t\t}\n\n\t\t\twhile (i &gt; 47 &amp;&amp; i &lt; 58) {\n\t\t\t\ttemp = temp * 10 + i - 48;\n\t\t\t\ti = is.read();\n\t\t\t}\n\n\t\t\treturn temp * mark;\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\tstatic class Item {\n\t\tpublic int have;\n\t\tpublic int need;\n\n\t\tpublic Item(int have, int need) {\n\t\t\tthis.have = have;\n\t\t\tthis.need = need - have;\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tint n = nextInt();\n\t\twhile (n-- &gt; 0) {\n\t\t\tint m = nextInt();\n\t\t\tItem[] item = new Item[m];\n\t\t\tfor (int i = 0; i &lt; m; i++) {\n\t\t\t\titem[i] = new Item(nextInt(), nextInt());\n\t\t\t}\n\t\t\tArrays.sort(item, new Comparator&lt;Item&gt;() {\n\t\t\t\tpublic int compare(Item o1, Item o2) {\n\t\t\t\t\treturn o1.need - o2.need;\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (item[0].need &gt; 0) {\n\t\t\t\tSystem.out.println("NO");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint currentHave = item[0].have;\n\t\t\tString result = "YES";\n\t\t\tfor (int i = 1; i &lt; m; i++) {\n\t\t\t\tif (item[i].need &lt;= 0) {\n\t\t\t\t\tcurrentHave += item[i].have;\n\t\t\t\t} else {\n\t\t\t\t\tif (item[i].need &lt;= currentHave) {\n\t\t\t\t\t\tcurrentHave += item[i].have;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult = "NO";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(result);\n\t\t}\n\t}\n}\n\n\r\n</textarea>	361
360	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　有一位使者要游历各国，他每到一个国家，都能学到一种文化，但他不愿意学习任何一种文化超过一次（即如果他学习了某种文化，则他就不能到达其他有这种文化的国家）。不同的国家可能有相同的文化。不同文化的国家对其他文化的看法不同，有些文化会排斥外来文化（即如果他学习了某种文化，则他不能到达排斥这种文化的其他国家）。\n  <br> 　　现给定各个国家间的地理关系，各个国家的文化，每种文化对其他文化的看法，以及这位使者游历的起点和终点（在起点和终点也会学习当地的文化），国家间的道路距离，试求从起点到终点最少需走多少路。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行为五个整数N，K，M，S，T，每两个整数之间用一个空格隔开，依次代表国家个数（国家编号为1到N），文化种数（文化编号为1到K），道路的条数，以及起点和终点的编号（保证S不等于T）；\n  <br> 　　第二行为N个整数，每两个整数之间用一个空格隔开，其中第i个数C\n  <sub>i</sub>，表示国家i的文化为C\n  <sub>i</sub>。\n  <br> 　　接下来的K行，每行K个整数，每两个整数之间用一个空格隔开，记第i行的第j个数为a\n  <sub>ij</sub>，a\n  <sub>ij</sub>= 1表示文化i排斥外来文化j（i等于j时表示排斥相同文化的外来人），a\n  <sub>ij</sub>= 0表示不排斥（注意i排斥j并不保证j一定也排斥i）。\n  <br> 　　接下来的M行，每行三个整数u，v，d，每两个整数之间用一个空格隔开，表示国家u与国家v有一条距离为d的可双向通行的道路（保证u不等于v，两个国家之间可能有多条道路）。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出只有一行，一个整数，表示使者从起点国家到达终点国家最少需要走的距离数（如果无解则输出-1）。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  2 2 1 1 2\n  <br> 1 2\n  <br> 0 1\n  <br> 1 0\n  <br> 1 2 10\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  -1\n </div>\n <div class="pdsec">\n  输入输出样例说明\n </div>\n <div class="pdcont">\n  　　由于到国家2必须要经过国家1，而国家2的文明却排斥国家1的文明，所以不可能到达国家2。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  2 2 1 1 2\n  <br> 1 2\n  <br> 0 1\n  <br> 0 0\n  <br> 1 2 10\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  10\n </div>\n <div class="pdsec">\n  输入输出样例说明\n </div>\n <div class="pdcont">\n  　　路线为1 -&gt; 2。\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　对于20%的数据，有2≤N≤8，K≤5；\n  <br> 　　对于30%的数据，有2≤N≤10，K≤5；\n  <br> 　　对于50%的数据，有2≤N≤20，K≤8；\n  <br> 　　对于70%的数据，有2≤N≤100，K≤10；\n  <br> 　　对于100%的数据，有2≤N≤100，1≤K≤100，1≤M≤ N^2，1≤k\n  <sub>i</sub>≤K，1≤u, v≤N，1≤d≤1000，S≠T，1 ≤S, T≤N。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#define max 1001\nint c[101],a[101][101],dis[101][101];\nint min(int a,int b)\n{\n\treturn a&lt;b?a:b;\n}\nint main()\n{\n\tint i,j,k,s,t,u,v,d,m,n;\n\tscanf ("%d%d%d%d%d",&amp;n,&amp;k,&amp;m,&amp;s,&amp;t);\n\tfor (i=1;i&lt;=n;i++)\n\t{\n\t\tscanf ("%d",c+i);\n\t}\n\tfor (i=1;i&lt;=k;i++)\n\t{\n\t\tfor (j=1;j&lt;=k;j++)\n\t\t{\n\t\t\tscanf ("%d",&amp;a[i][j]);\n\t\t}\n\t}\n\tfor (i=1;i&lt;=n;i++)\n\t{\n\t\tfor (j=1;j&lt;=n;j++)\n\t\t{\n\t\t\tif (i!=j) dis[i][j]=max;\n\t\t}\n\t}\n\tfor (i=1;i&lt;=m;i++)\n\t{\n\t\tscanf ("%d%d%d",&amp;u,&amp;v,&amp;d);\n\t\tif (!a[c[u]][v]) dis[u][v]=min(d,dis[u][v]);\n\t\tif (!a[c[v]][u]) dis[v][u]=min(d,dis[v][u]);\n\t}\n\tfor (i=1;i&lt;=n;i++)\n\t{\n\t\tfor (j=1;j&lt;=n;j++)\n\t\t{\n\t\t\tfor (k=1;k&lt;=n;k++)\n\t\t\t{\n\t\t\t\tif (!a[c[i]][c[j]]&amp;&amp;!a[c[i]][c[k]]&amp;&amp;!a[c[k]][c[j]])\n\t\t\t\t{\n\t\t\t\t\tdis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n  \tif (dis[s][t]==max&amp;&amp;dis[t][s]==max) printf ("-1\\n");\n  \telse printf ("%d\\n",min(dis[s][t],dis[t][s]));\n    return 0;\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n  #include &lt;stdio.h&gt;\n  #include &lt;stdlib.h&gt;\n  int n, k, m, s, t, distance[101][101], culture[101], fight[101][101], search[101], p = 0;\n bool found = false;\n  int min(int a, int b)\n  {\n      return (a &gt; b ? b : a);\n  }\n  void DFS(int target)\n {\n     bool CanInqueue = true;\n     int queue[101] = {0}, tail = 0;\n     search[++p] = target;\n     if (target == t)\n     {\n         found = true;\n         return;\n     }\n     for (int i = 1, j; i &lt;= n; ++i)\n     {\n         for (j = 1; j &lt;= p; ++j)\n         {\n             if (search[j] == i || culture[search[j]] == culture[i] || fight[culture[i]][culture[search[j]]] == 1)\n             {\n                 CanInqueue = false;\n                 break;\n             }\n         }\n         if (distance[target][i] == 1001)\n             CanInqueue = false;\n         if (CanInqueue)\n             queue[++tail] = i;\n         else\n             CanInqueue = true;\n     }\n     for (int i = 1; i &lt;= tail; ++i)\n         distance[s][queue[i]] = min(distance[s][queue[i]], distance[s][target] + distance[target][queue[i]]);\n     for (int i = 1; i &lt;= tail; ++i)\n         DFS(queue[i]);\n     return;\n }\n int main()\n {\n     for (int i = 1, j; i &lt; 101; ++i)\n         for (j = 1; j &lt; 101; ++j)\n              distance[i][j] = 1001;\n     scanf("%d %d %d %d %d", &amp;n, &amp;k, &amp;m, &amp;s, &amp;t);\n     for (int i = 1; i &lt;= n; ++i)\n         scanf("%d", &amp;culture[i]);\n     for (int i = 1, j; i &lt;= k; ++i)\n         for (j = 1; j &lt;= k; ++j)\n             scanf("%d", &amp;fight[i][j]);\n     for (int i = 0, y, z, c; i &lt; m; ++i, distance[z][y] &gt; c ? distance[y][z] = distance[z][y] = c : c = 2147483646)\n         scanf("%d %d %d", &amp;y, &amp;z, &amp;c);\n     DFS(s);\n     if (found)\n         printf("%d\\n", distance[s][t]);\n     else\n         printf("-1\\n");\n     return 0;\n }\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.*;\npublic class Main {\n\tstatic int[] bian;  //遍历标准\n\tstatic ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\n\tstatic int[] hua;\n\tstatic int[][] wen;\n\tstatic int[][] lu;\n\tstatic int N, K, M, S, T;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tN = sc.nextInt();\t//国家个数 从1开始\n\t\tK = sc.nextInt();\t//文化个数从1开始\n\t\tM = sc.nextInt();\t//道路条数\n\t\tS = sc.nextInt();\t//起点国家\n\t\tS = S - 1;\n\t\tT = sc.nextInt();\t//终点国家\n\t\tT = T - 1;\n\t\tbian = new int[N];\n\t\thua = new int[N];\t//国家的文化\n\t\twen = new int[K][K];\t//文化的排斥\n\t\tlu = new int[N][N];\t\t//国家之间的路\n\t\tfor(int i=0;i&lt;N;i++){\n\t\t\tint tmp = sc.nextInt();\n\t\t\thua[i] = tmp -1;\n\t\t}\n\t\tfor(int i=0;i&lt;K;i++)\n\t\t\tfor(int j=0;j&lt;K;j++)\n\t\t\t\twen[i][j] = sc.nextInt();\n\t\tfor(int i=0;i&lt;M;i++){\n\t\t\tint a,b,c;\n\t\t\ta = sc.nextInt();\n\t\t\tb = sc.nextInt();\n\t\t\tc = sc.nextInt();\n\t\t\tif(lu[a-1][b-1]==0)\n\t\t\t\tlu[a-1][b-1] = c;\n\t\t\telse if(lu[a-1][b-1]&gt;c)\n\t\t\t\tlu[a-1][b-1] = c;\n\t\t\tif(lu[b-1][a-1]==0)\n\t\t\t\tlu[b-1][a-1] = c;\n\t\t\telse if(lu[b-1][a-1]&gt;c)\n\t\t\t\tlu[b-1][a-1] = c;\n\t\t}\n\t\tint[] cost = new int[N];\n\t\tint[] select = new int[N];\n\t\tint shei = S;\n\t\tint shzh = 0;\n\t\tselect[shei] = 1;\n\t\tfor(int j=0;j&lt;N;j++)\n\t\t\tcost[j] = -1;\n\t\tfor(int i=0;i&lt;N;i++){\n\t\t\tfor(int j=0;j&lt;N;j++){\n\t\t\t\tif(lu[shei][j]!=0&amp;&amp;wen[hua[j]][hua[shei]]!=1&amp;&amp;select[j]==0){\n\t\t\t\t\t\tcost[j] = shzh + lu[shei][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tint min = -1;\n\t\t\tfor(int j=0;j&lt;N;j++){\n\t\t\t\tif(cost[j]!=-1&amp;&amp;select[j]==0)\n\t\t\t\t\tif(min ==-1){\n\t\t\t\t\t\tmin = j;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(cost[j]&lt;cost[min])\n\t\t\t\t\t\t\tmin = j;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tif(min == -1) break;\n\t\t\telse{\n\t\t\t\tselect[min] = 1;\n\t\t\t\tshei = min;\n\t\t\t}\n\t\t\tshzh = cost[shei];\n\t\t}\n\t\tif(cost[T] == -1){\n\t\t\tSystem.out.println(-1);\n\t\t}else{\n\t\t\tSystem.out.println(cost[T]);\n\t\t}\n\t\t\n\t}\n}\r\n</textarea>	362
361	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　小明的花店新开张，为了吸引顾客，他想在花店的门口摆上一排花，共m盆。通过调查顾客的喜好，小明列出了顾客最喜欢的n种花，从1到n标号。为了在门口展出更多种花，规定第i种花不能超过a\n  <sub>i</sub>盆，摆花时同一种花放在一起，且不同种类的花需按标号的从小到大的顺序依次摆列。\n  <br> 　　试编程计算，一共有多少种不同的摆花方案。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行包含两个正整数n和m，中间用一个空格隔开。\n  <br> 　　第二行有n个整数，每两个整数之间用一个空格隔开，依次表示a\n  <sub>1</sub>、a\n  <sub>2</sub>、……a\n  <sub>n</sub>。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出只有一行，一个整数，表示有多少种方案。\n  <b>注意：因为方案数可能很多，请输出方案数对</b>\n  <b>1000007</b>\n  <b>取模的结果。</b>\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  2 4\n  <br> 3 2\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  2\n </div>\n <div class="pdsec">\n  输入输出样例说明\n </div>\n <div class="pdcont">\n  　　有2种摆花的方案，分别是(1，1，1，2)， (1，1，2，2)。括号里的1和2表示两种花，比如第一个方案是前三个位置摆第一种花，第四个位置摆第二种花。\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　对于20%数据，有 0&lt;n≤8，0&lt;m≤8，0≤a\n  <sub>i</sub>≤8；\n  <br> 　　对于50%数据，有0&lt;n≤20，0&lt;m≤20，0≤a\n  <sub>i</sub>≤20；\n  <br> 　　对于100%数据，有0&lt;n≤100，0&lt;m≤100，0≤ a\n  <sub>i</sub>≤100。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt; \n#include &lt;stdlib.h&gt;\nint a[102], f[102]; \nint main() {      \n    int n, m, sum = 0, i, j, k;      \n    scanf("%d%d", &amp;n, &amp;m);     \n    for(i = 1; i &lt;= n; ++i)         \n        scanf("%d", &amp;a[i]);     \n    f[0] = 1;\n    for (i = 1; i &lt;= n; sum = 0, ++i){          \n        for (j = m, sum = 0; j &gt; a[i]; f[j] = sum, sum = 0, --j)\n            for (k = j - a[i]; k &lt;= j; sum %= 1000007, ++k) \n                sum += f[k];          \n            for (j = a[i], sum = 0; j &gt; -1; f[j] = sum, sum = 0, --j)\n                for (k = 0; k &lt;= j; sum %= 1000007, ++k)     \n                      sum += f[k];     \n    }      \n    printf("%d\\n", f[m]);   \n    system("pause");  \n    return 0; \n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;cstdio&gt;\n#include &lt;cmath&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;algorithm&gt;\n#include &lt;map&gt;\n#include &lt;vector&gt;\n#include &lt;queue&gt;\n#include &lt;set&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nconst double esp=1e-10;\nconst double PI=3.141592653;\nint f[110][110]={0},a[110];\nint main()\n{\n\t//freopen("in.txt","r",stdin);\n\tf[0][0]=1;\n\tint n,m;\n\tscanf("%d%d",&amp;n,&amp;m);\n\tfor(int i=1;i&lt;=n;i++) scanf("%d",a+i);\n\tfor(int i=1;i&lt;=n;i++)\n\t\tfor(int k=0;k&lt;=a[i];k++)\n\t\t\tfor(int j=k;j&lt;=m;j++)\n\t\t\t\tf[i][j]=(f[i][j]+f[i-1][j-k])%1000007;\n\tprintf("%d\\n",f[n][m]);\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tint [][]f=new int[101][101];\n\t\tint a[]=new int[101],n,m;\n\t\tScanner sc=new Scanner(System.in);\n\t\tn=sc.nextInt();m=sc.nextInt();\n\t\tfor (int i = 1; i &lt;=n; i++) {\n\t\t\ta[i]=sc.nextInt();\n\t\t}\n\t\tfor (int i = 0; i &lt;=a[1]; i++) {\n\t\t\tf[1][i]=1;\n\t\t}\n\t\tfor (int i = 2; i &lt;=n; i++) {\n\t\t\tfor (int j = 0; j &lt;=m; j++) {\n\t\t\t\tfor (int x = 0; x &lt;=a[i]; x++) {\n\t\t\t\t\tif(j&gt;=x){\n\t\t\t\t\t\tf[i][j]=(f[i][j]+f[i-1][j-x])%1000007;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(f[n][m]);\n\t}\n}\n\r\n</textarea>	363
362	<div class="des"> \n <div class="pdcont">\n  　　﻿\n  <br> 　　当两个比较大的整数相乘时，可能会出现数据溢出的情形。为避免溢出，可以采用字符串的方法来实现两个大数之间的乘法。具体来说，首先以字符串的形式输入两个整数，每个整数的长度不会超过8位，然后把它们相乘的结果存储在另一个字符串当中（长度不会超过16位），最后把这个字符串打印出来。例如，假设用户输入为：62773417和12345678，则输出结果为：774980393241726.\n  <br> \n  <br> \n  <b>输入：</b>\n  <br> 　　62773417 12345678\n  <br> \n  <br> \n  <b>输出：</b>\n  <br> 　　774980393241726\n  <i></i>\n </div> \n</div>	<textarea id="codelinesc">\r\n/*\n问题描述\n　　在C/C++语言中，整型所能表示的范围一般为-231到231（大约21亿）,即使long long型，一般也只能表示到-263到263。要想计算更加规模的数，就要用软件来扩展了，比如用数组或字符串来模拟更多规模的数及共运算。\n　　现在输入两个整数，请输出它们的乘积。\n输入格式\n　　两行，每行一个正整数，每个整数不超过10000位\n输出格式\n　　一行，两个整数的乘积。\n样例输入\n99\n101\n样例输出\n9999\n数据规模和约定\n　　每个整数不超过10000位\n*/\n\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n\n#define V_LEN ( 20000 ) // 结果长度 \n\nvoid chengfa/*乘法*/( char *a, char *b, int *value );\nvoid fanzhi/*反置对齐*/( char *str );\nvoid swap( char *a, char *b );\nvoid jw/*进位*/( int *str );\nvoid shuchu/*输出结果*/( int *value );\n\nint main(void){\n\n\tchar a[ 10001 ], b[ 10001 ];\n\tint value[ V_LEN ] = { 0 };\n\n\tscanf("%s%s", a, b);\n//\tgets( a ); // 此种写法在蓝桥网的训练环境下会出错 \n//\tgets( b );\n\n\tchengfa/*乘法*/( a, b, value );\n\n\tshuchu/*输出结果*/( value );\n\n\treturn 0;\n}\n\nvoid shuchu/*输出结果*/( int *value ){\n\tint *p = value + V_LEN - 1; // p指向最高位\n\twhile( *p == 0 ){\n\t\tp --;\n\t}\n\t\n\tif( p &lt; value ){ // 越界\n\t\tputchar( '0' ); \n\t\t \n\t} else {\n\t\twhile( p &gt;= value ){\n\t\t\tprintf("%d", *p--);\n\t\t\n\t\t}\n\t}\n\tputchar('\\n');\n}\n\nvoid jw/*进位*/( int *value ){\n\tint i;\n\tfor ( i = 0 ; i &lt; V_LEN ; i ++ ) {\n\t\tvalue[ i + 1 ] += value[ i ] / 10;\n\t\tvalue[ i ] %= 10; \n\t}\n}\n\nvoid swap( char *a, char *b ){\n\tchar t = *a;\n\t*a = *b;\n\t*b = t;\n}\n\nvoid fanzhi/*反置对齐*/( char *str ){\n\tint len = strlen( str );\n\tint i;\n\tfor ( i = 0 ; i &lt; len / 2 ; i ++ ) {\n\t\tswap( str + i, str + len - 1 - i );\n\t}\n}\n\nvoid chengfa/*乘法*/( char *a, char *b, int *value ){\n\tfanzhi/*反置对齐*/( a );\n\tfanzhi/*反置对齐*/( b );\n\t\n\tint len1 = strlen( a ), len2 = strlen( b );\n\tint i;\n\tfor ( i = 0 ; i &lt; len2 ; i ++ ) { // 遍历表达式 2 \n\t\tint j;\n\t\tfor ( j = 0 ; j &lt; len1 ; j ++ ) {  // 遍历表达式 1 \n\t\t\tvalue[ i + j ] += ( b[ i ] - '0' ) * ( a[ j ] - '0' ); // 加值 \n\t\t}\n\t}\n\t\n\tjw/*进位*/( value );\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n# include &lt;stdio.h&gt;\nint main()\n{\n\tlong long a,b;\n\tscanf("%lld%lld", &amp;a, &amp;b);\n\tprintf("%lld", a*b);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.text.*;\n\npublic class Main {\n  void solve() {\n    BigInteger a, b;\n    a = new BigInteger(in.next());\n    b = new BigInteger(in.next());\n    out.println(a.multiply(b));\n  }\n  \n  FastScanner in;\n  PrintWriter out;\n\n  void run(String s) {\n    if (s == null) {\n      in = new FastScanner();\n    } else {\n      in = new FastScanner(s);\n    }\n    out = new PrintWriter(System.out);\n    solve();\n    out.close();\n  }\n\n  public static void main(String[] args) {\n    new Main().run(null);\n  }\n\n  static class FastScanner {\n    BufferedReader br;\n    StringTokenizer st;\n\n    FastScanner(String file) {\n      try {\n        br = new BufferedReader(new FileReader(file));\n      } catch (FileNotFoundException e) {\n        e.printStackTrace();\n      }\n    }\n\n    FastScanner() {\n      br = new BufferedReader(new InputStreamReader(System.in));\n    }\n\n    public String next() {\n      while (st == null || !st.hasMoreTokens()) {\n        try {\n          st = new StringTokenizer(br.readLine());\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n      }\n      return st.nextToken();\n    }\n\n    boolean hasMoreTokens() {\n      while (st == null || !st.hasMoreTokens()) {\n        try {\n          String s = br.readLine();\n          if (s == null)\n            return false;\n          st = new StringTokenizer(s);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n      }\n      return true;\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n\n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n  }\n}\r\n</textarea>	364
363	<div class="des"> \n <div class="pdcont">\n  　　作为一名网络警察，你的任务是监视电子邮件，看其中是否有一些敏感的关键词。不过，有些狡猾的犯罪嫌疑人会改变某些单词的字母顺序，以逃避检查。请编写一个程序，发现这种调整过顺序的关键词。程序的输入有两行，第一行是关键词列表，第二行是待检查的句子。程序的输出为在该句子中所找到的经过顺序调整的关键词。（单词全部为小写，单词之间以一个空格分隔，每一行的单词个数不限）\n  <br> \n  <br> \n  <b>输入：</b>\n  <br> 　　guns mines missiles\n  <br> 　　aameric ssell snug dan iimsssle ot sit neeemis\n  <br> \n  <b> </b>\n  <br> \n  <b>输出：</b>\n  <br> 　　guns missiles\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nint num1,num2;\t\t\t\t\t\t\t\t//1是关键词个数，2是句子单词个数 \nchar str1[1000][500],str2[1000][500];\t\t//1是关键词，2是要识别的句子 \nchar a1[1000][500],a2[1000][500];\t\t\t//1是排序后的关键词，2是排序后的要识别的句子 \nint word(char str[],char arr[][500])\n{\n\tint k=0,j=0;\n\tchar *p=str;\n\twhile(*p)\n\t{\n\t\tif(*p==' ' &amp;&amp; *(p+1)!=' ')\n\t\t{\n\t\t\tarr[k][j]='\\0';\n\t\t\tk++;\n\t\t\tj=0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tarr[k][j++]=*p;\n\t\t}\n\t\tp++; \n\t}\n\treturn k;\n}\nvoid paixu(char arr[][500],int num,char a[][500])\n{\n\tint i,j,k,len;\n\tchar temp;\n\tfor(i=0;i&lt;=num;i++)\n\t{\n\t\tstrcpy(a[i],arr[i]);\n\t}\n\tfor(i=0;i&lt;=num;i++)\n\t{\n\t\tlen=strlen(a[i])-1;\n\t\tfor(j=0;j&lt;len;j++)\n\t\t{\n\t\t\tfor(k=j+1;k&lt;=len;k++)\n\t\t\t{\n\t\t\t\tif(a[i][j]&gt;a[i][k])\n\t\t\t\t{\n\t\t\t\t\ttemp=a[i][j];\n\t\t\t\t\ta[i][j]=a[i][k];\n\t\t\t\t\ta[i][k]=temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid cmp(char str[][500])\n{\n\tint i,j;\n\tfor(i=0;i&lt;=num1;i++)\n\t{\n\t\tfor(j=0;j&lt;=num2;j++)\n\t\t{\n\t\t\tif(strcmp(a1[i],a2[j])==0)\n\t\t\t{\n\t\t\t\tprintf("%s ",str1[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tchar arr1[5000];\n\tchar arr2[5000]; \n\tgets(arr1);\n\tgets(arr2);\n\tnum1=word(arr1,str1);\n\tnum2=word(arr2,str2);\n\tpaixu(str1,num1,a1);\n\tpaixu(str2,num2,a2);\n\tcmp(a2);\n\treturn 0;\n}\n/*\nguns mines missiles\naameric ssell snug dan iimsssle ot sit neeemis\n*/\r\n</textarea>	<textarea id="codelinescpp">\r\n/*\n思路： \n原数组，比较数组用来排序 ，然后比较\n坑爹？  测试数据输出字符串要按字典序输出？ \n*/\n#include &lt;iostream&gt;\n#include &lt;string.h&gt;\n#include &lt;algorithm&gt;\n#include &lt;cstdio&gt;\n#include &lt;math.h&gt;\nusing namespace std;\nstring s1,s2;\nstring ss[1000];\nstring compare[1000];\nstring re[1000];\nbool less_lower(char c1, char c2)\n{\n     return c1&lt;c2;\n}\nint main(){    \n    int i;\n    int len,now;\n    string tmp;\n    while(getline(cin,s1)&amp;&amp;getline(cin,s2)){\n    \tlen=0;\n    \tnow=0;\n    \t tmp="";\n    \t for(int i=0;s1[i]!='\\0';i++){\n    \t \tif(s1[i]==' '){\n    \t \t\tss[len]=tmp;  \t \t\n    \t \t\tsort(tmp.begin(),tmp.end(),less_lower);   \n\t\t\t\tcompare[len++]=tmp;\n   \t \t       \ttmp="";\n   \t \t      // \tcout&lt;&lt;ss[len-1]&lt;&lt;"       "&lt;&lt;compare[len-1]&lt;&lt;endl;\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t \ttmp+=s1[i];\n\t\t\t }\n\t\t }\n\t\t \n\t\t if(tmp!="")\n\t\t   {\n\t\t   \tss[len]=tmp;  \t \t\n    \t \tsort(tmp.begin(),tmp.end(),less_lower);   \n\t\t\tcompare[len++]=tmp;\n\t\t   }\n\t\t   \n\t\t   tmp="";\n\t\t    for(int i=0;s2[i]!='\\0';i++){\n    \t \tif(s2[i]==' '){\n    \t \t\tsort(tmp.begin(),tmp.end(),less_lower);  \n\t\t\t//\t cout&lt;&lt;tmp&lt;&lt;endl; \n\t\t\t\t for(int j=0;j&lt;len;j++)\n\t\t\t\t \tif(compare[j]==tmp)\n\t\t\t\t \t   re[now++]=ss[j];\t\t\t \t \n\t\t\t\t  \t\t\n    \t \t\ttmp="";\n\t\t\t }\n\t\t\t else\t\t\t \n\t\t\t \ttmp+=s2[i];\t\n\t\t }\n\t\t \n\t\t if(tmp!=""){\n\t\t \tsort(tmp.begin(),tmp.end(),less_lower);   \n\t\t\t      for(int j=0;j&lt;len;j++)\n\t\t\t\t \tif(compare[j]==tmp)\n\t\t\t\t \t  re[now++]=ss[j];\t\n\t\t }\n\t\t \n\t\t sort(re,re+now);\n\t\t for(i=0;i&lt;now;i++)\n\t\t   cout&lt;&lt;re[i]&lt;&lt;" ";\n\t\t cout&lt;&lt;endl;\n\t}\t\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tString[] password = in.nextLine().split(" ");\n\t\tString[] pattern = in.nextLine().split(" ");\n\t\tin.close();\n\n\t\tList&lt;String&gt; list = new ArrayList&lt;&gt;();\n\t\tfor (String string : pattern) {\n\t\t\tString ans = march(string, password);\n\t\t\tif (!ans.equals("")) {\n\t\t\t\tlist.add(ans);\n\t\t\t}\n\t\t}\n\t\t\n\t\tCollections.sort(list);\n\t\tfor(String string : list) {\n\t\t\tSystem.out.print(string + " ");\n\t\t}\n\t}\n\n\tprivate static String march(String string, String[] password) {\n\t\tfor (String s : password) {\n\t\t\tchar[] cn = string.toCharArray();\n\t\t\tchar[] cd = s.toCharArray();\n\n\t\t\tArrays.sort(cn);\n\t\t\tArrays.sort(cd);\n\t\t\tif (new String(cn).equals(new String(cd))) {\n\t\t\t\treturn s;\n\t\t\t}\n\t\t}\n\t\treturn "";\n\t}\n\n}\n\r\n</textarea>	365
364	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　s01串初始为"0"\n  <br> 　　按以下方式变换\n  <br> 　　0变1，1变01\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　1个整数(0~19)\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　n次变换后s01串\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  101\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　0~19\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nbianhuan(int n)\n{\n\tint i,j,len,k=0,x=0;\n\tchar a[100],b[20][10000];\n\tif(n==0){printf("0");return 0;}\n\tif(n==1){printf("1");return 0;}\n\tif(n==2){printf("01");return 0;}\n\ta[0]=48;\n\ta[1]=49;\n\tfor(j=2;j&lt;n;j++)\n\t{\n\t\tfor(i=0;a[i]!='\\0';i++)\n\t\t{\n\t\t\tif(a[i]==48)\n\t\t\t{\n\t\t\t   b[x][k]=49;\n\t\t\t   k++;\n\t\t    }\n\t\t\tif(a[i]==49)\n\t\t\t{\n\t\t\t\tb[x][k]=48;\n\t\t\t\tk++;\n\t\t\t\tb[x][k]=49;\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i&lt;k;i++)\n\t\ta[i]=b[x][i];\n\t\tlen=k;\n\t\tx++;\n\t\tk=0;\n\t}\n\tfor(i=0;i&lt;len;i++)\n\tprintf("%c",a[i]);\n\treturn 0;\n}\n\nint main(void)\n{\n\tint n;\n\tscanf("%d",&amp;n);\n\tbianhuan(n);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nint n;\nvoid fun( string s ) {\n    int i = 0;\n    string str = "";\n    while( i &lt; s.size() ) {\n        if( s[i] == '0' )\n            str += "1";\n        else {\n            str += "01";\n        }\n        i++;\n    }\n    n--;\n    if( n == 0 )\n        cout &lt;&lt; str;\n    else\n        fun( str );\n}\n\nint main() {\n    cin &gt;&gt; n;\n    if( n &gt; 0 )\n        fun( "0" );\n    else\n        cout &lt;&lt; "0";\n    //cout &lt;&lt; s;\n    return 0;\n}\n\n/*\n1\n01\n101\n01101\n10101101\n0110110101101\n*/\n\r\n</textarea>	<textarea id="codelinesjava">\r\n\n\t\n\timport java.util.*;\n\t\n\tpublic class Main{\n\t\tstatic StringBuffer sb=new StringBuffer();\n\t\tpublic static void main(String[] args) {\n\t\t\tScanner keyin=new Scanner(System.in);\n\t\t\tint number=keyin.nextInt();\n\t\t\tif(number==0)\n\t\t\t{System.out.println("0");}else\n\t\t\tf(number,"0");\n\t\t\tSystem.out.println(sb);\n\t\t}\n\t\tpublic static void f(int n,String s)\n\t\t{\n\t\t\t\n\t\t\tif(n&lt;0)\n\t\t\t\treturn ;\n\t\t\tn--;\n\t\t\tfor(int i=0;i&lt;s.length();i++)\n\t\t\t{\n\t\t\t\tString str=s.substring(i, i+1);\n\t\t\t\tif(str.equals("0"))\n\t\t\t\t\tstr="1";\n\t\t\t\telse if(str.equals("1"))\n\t\t\t\t\tstr="01";\n\t\t\t\tf(n,str);\n\t\t\t\tif(n==0)\n\t\t\t\t\tsb.append(str);\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\n\t\n\t}\r\n</textarea>	366
365	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　有n个点和m个区间，点和区间的端点全部是整数，对于点a和区间[b,c]，若a&gt;=b且a&lt;=c，称点a满足区间[b,c]。\n  <br> 　　求最小的点的子集，使得所有区间都被满足。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行两个整数n m\n  <br> 　　以下n行 每行一个整数，代表点的坐标\n  <br> 　　以下m行 每行两个整数，代表区间的范围\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出一行，最少的满足所有区间的点数，如无解输出-1。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5 5\n  <br> 2\n  <br> 6\n  <br> 3\n  <br> 8\n  <br> 7\n  <br> 2 5\n  <br> 3 4\n  <br> 3 3\n  <br> 2 7\n  <br> 6 9\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  2\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　1&lt;=n,m&lt;=10000\n  <br> 　　0&lt;=点和区间的坐标&lt;=50000\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\ntypedef struct x\n{\n\tint l;\n\tint r;\n}line;\nint main()\n{\n\tint n,m;\n\tscanf("%d %d",&amp;n,&amp;m);\n\tint num[10005];\n\tline map[10005];\n\tint i,j;\n\tfor(i=0;i&lt;n;i++)\n\t\tscanf("%d",&amp;num[i]);\n\tfor(i=0;i&lt;m;i++)\n\t\tscanf("%d %d",&amp;map[i].l,&amp;map[i].r);\n\t\n\tfor(i=0;i&lt;m-1;i++)\n\t{\n\t\tfor(j=i+1;j&lt;m;j++)\n\t\t{\n\t\t\tif(map[i].l&lt;=map[j].l&amp;&amp;map[i].r&gt;=map[j].r)\n\t\t\t{\n\t\t\t\tmap[i]=map[--m];\n\t\t\t\ti--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(map[i].l&gt;=map[j].l&amp;&amp;map[i].r&lt;=map[j].r)\n\t\t\t{\n\t\t\t\tmap[j]=map[--m];\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(i=0;i&lt;m-1;i++)\n\t{\n\t\tfor(j=i+1;j&lt;m;j++)\n\t\t{\n\t\t\tif(map[j].l&lt;map[i].l)\n\t\t\t{\n\t\t\t\tline t=map[j];\n\t\t\t\tmap[j]=map[i];\n\t\t\t\tmap[i]=t;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(i=0;i&lt;n-1;i++)\n\t{\n\t\tfor(j=i+1;j&lt;n;j++)\n\t\t{\n\t\t\tif(num[j]&lt;num[i])\n\t\t\t{\n\t\t\t\tint t=num[j];\n\t\t\t\tnum[j]=num[i];\n\t\t\t\tnum[i]=t;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint len=0;i=0;j=0;\n\twhile(i&lt;n&amp;&amp;j&lt;m)\n\t{\n\t\twhile(num[i]&lt;map[j].l&amp;&amp;i&lt;n)i++;\n\t\t\n\t\tif(num[i]&gt;map[j].r)break;\n\t\t\n\t\twhile(num[i]&lt;=map[j].r&amp;&amp;i&lt;n)i++;\n\t\t\n\t\twhile(num[i-1]&gt;=map[j].l&amp;&amp;j&lt;m)j++;\n\t\t\n\t\tlen++;\n\t}\n\t\n\tif(j&lt;m)printf("-1");\n\telse printf("%d",len);\n\t\n\treturn 0;\n} \r\n</textarea>	<textarea id="codelinescpp">\r\n# include &lt;stdio.h&gt;  \n# include &lt;string.h&gt;  \n# include &lt;algorithm&gt;  \nusing namespace std;  \nint vis[10010];  \nstruct segment{  \n    int begin;  \n    int end;  \n};  \nstruct node{  \n    int cur;  \n    int num;  \n};  \nstruct node s1[50010];  \nstruct segment s2[10010];  \nint compare2(struct segment a, struct segment b){  \n    if(a.begin!=b.begin){  \n        return a.begin&lt;b.begin;  \n    }  \n    return a.end&lt;b.end;  \n}  \nint main(){  \n    int n, m;  \n    int num, count=0;  \n    int i, j, k;  \n    scanf("%d%d", &amp;n, &amp;m);  \n    for(i=0; i&lt;=50009; i++){  \n        s1[i].cur=0;  \n    }  \n    for(i=1; i&lt;=n; i++){  \n        scanf("%d", &amp;num);  \n        s1[num].cur = 1;  \n    }  \n    for(i = 1; i &lt;= m; i++){  \n        scanf("%d%d", &amp;s2[i].begin, &amp;s2[i].end);   \n    }  \n    memset(vis, 0, sizeof(vis));  \n    sort(s2 + 1, s2 + 1 + m, compare2);  \n    int max, cur;  \n    for(i=1; i&lt;=m; i++){  \n        max=-1;  \n        if(!vis[i]){  \n            for(j = s2[i].begin; j &lt;= s2[i].end; j++){  \n                if(s1[j].cur){  \n                    s1[j].num=0;  \n                    for(k = i+1; k &lt;= m; k++){  \n                        if(s2[k].begin&lt;=j&amp;&amp;s2[k].end&gt;=j&amp;&amp;!vis[k]){  \n                            s1[j].num++;  \n                        }  \n                        else{  \n                            break;  \n                        }  \n                    }  \n                    if(s1[j].num&gt;max){  \n                        max=s1[j].num;  \n                        cur=j;  \n                          \n                    }  \n                }  \n            }  \n            count++;  \n            for(k = i+1; k &lt;= m; k++){  \n                if(s2[k].begin&lt;=cur){  \n                    vis[k]=1;  \n                }  \n                else{  \n                    break;  \n                }  \n            }  \n        }  \n    }  \n    printf("%d", count);  \n    return 0;  \n}  \r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic class Main {\n\tprivate static InputStream is = System.in;\n\n\tpublic static int nextInt() {\n\t\ttry {\n\t\t\tint i;\n\n\t\t\twhile ((i = is.read()) &lt; 45 || i &gt; 57) {\n\t\t\t}\n\n\t\t\tint mark = 1, temp = 0;\n\n\t\t\tif (i == 45) {\n\t\t\t\tmark = -1;\n\t\t\t\ti = is.read();\n\t\t\t}\n\n\t\t\twhile (i &gt; 47 &amp;&amp; i &lt; 58) {\n\t\t\t\ttemp = temp * 10 + i - 48;\n\t\t\t\ti = is.read();\n\t\t\t}\n\n\t\t\treturn temp * mark;\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\tstatic class Node {\n\t\tpublic int start;\n\t\tpublic int end;\n\n\t\tpublic Node(int start, int end) {\n\t\t\tthis.start = start;\n\t\t\tthis.end = end;\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tint n = nextInt();\n\t\tint m = nextInt();\n\t\tint point[] = new int[n];\n\t\tfor (int i = 0; i &lt; n; i++)\n\t\t\tpoint[i] = nextInt();\n\t\tNode node[] = new Node[m];\n\t\tfor (int i = 0; i &lt; m; i++)\n\t\t\tnode[i] = new Node(nextInt(), nextInt());\n\t\tArrays.sort(point);\n\t\tArrays.sort(node, new Comparator&lt;Node&gt;() {\n\t\t\tpublic int compare(Node o1, Node o2) {\n\t\t\t\treturn o1.end - o2.end;\n\t\t\t}\n\t\t});\n\t\tint currentPoint = 0;\n\t\tint count = 0;\n\t\tint j = 1;\n\t\tfor (int i = 0; i &lt; m; i++) {\n\t\t\tint x = node[i].start;\n\t\t\tint y = node[i].end;\n\t\t\tif (x &lt;= currentPoint)\n\t\t\t\tcontinue;\n\t\t\tint temp = -1;\n\t\t\tfor (j -= 1; j &lt; n; j++) {\n\t\t\t\tif (point[j] &lt;= y) {\n\t\t\t\t\ttemp = point[j];\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (temp == -1) {\n\t\t\t\tcount = 0;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tcurrentPoint = temp;\n\t\t\t\tcount++;\n\t\t\t}\n\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n}\n\r\n</textarea>	367
366	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　给n个有序整数对ai bi，你需要选择一些整数对 使得所有你选定的数的ai+bi的和最大。并且要求你选定的数对的ai之和非负，bi之和非负。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入的第一行为n，数对的个数\n  <br> 　　以下n行每行两个整数 ai bi\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出你选定的数对的ai+bi之和\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5\n  <br> -403 -625\n  <br> -847 901\n  <br> -624 -708\n  <br> -293 413\n  <br> 886 709\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  1715\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　1&lt;=n&lt;=100\n  <br> 　　-1000&lt;=ai,bi&lt;=1000\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n\nint dp[100005];\nint can[100005];\nstruct pair\n{\n\tint a, b;\n} p[110];\n\nint cmp(const void* a, const void* b)\n{\n\treturn ((struct pair*)b)-&gt;a - ((struct pair*)a)-&gt;a;\n}\n\nint main(void)\n{\n\tint n, m;\n\tint a, b;\n\tint maxsum;\n\tint suma, sumb, max;\n\tint i, j;\n\n\tscanf("%d", &amp;n);\n\tsuma = 0;\n\tsumb = 0;\n\tfor (i=0, m=0; i&lt;n; ++i)\n\t{\n\t\tscanf("%d%d", &amp;a, &amp;b);\n\t\tif (a&gt;0 &amp;&amp; b&gt;0)\n\t\t{\n\t\t\tsuma += a;\n\t\t\tsumb += b;\n\t\t}\n\t\telse if (a&lt;=0 &amp;&amp; b&lt;=0)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tp[m].a = a;\n\t\t\tp[m].b = b;\n\t\t\t++m;\n\t\t}\n\t}\n\n\tdp[suma] = sumb;\n\tcan[suma] = 1;\n\tcan[0] = 1;\n\tqsort(p, m, sizeof(struct pair), cmp);\n\tmax = suma;\n\tfor (i=0; i&lt;m&amp;&amp;p[i].a&gt;0; ++i)\n\t{\n\t\tmax += p[i].a;\n\t\tfor (j=max; j&gt;=p[i].a; --j)\n\t\t{\n\t\t\tif (can[j-p[i].a]==1 &amp;&amp; (can[j]==0 || dp[j]&lt;dp[j-p[i].a]+p[i].b))\n\t\t\t{\n\t\t\t\tdp[j] = dp[j-p[i].a]+p[i].b;\n\t\t\t\tcan[j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (; i&lt;m; ++i)\n\t{\n\t\tfor (j=0; j&lt;=max+p[i].a; ++j)\n\t\t{\n\t\t\tif (can[j-p[i].a]==1 &amp;&amp; (can[j]==0 || dp[j]&lt;dp[j-p[i].a]+p[i].b))\n\t\t\t{\n\t\t\t\tdp[j] = dp[j-p[i].a]+p[i].b;\n\t\t\t\tcan[j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tmaxsum = 0;\n\tfor (i=0; i&lt;=max; ++i)\n\t{\n\t\tif (can[i]==1&amp;&amp;dp[i]&gt;=0&amp;&amp;maxsum&lt;i+dp[i])\n\t\t{\n\t\t\tmaxsum = i+dp[i];\n\t\t}\n\t}\n\tprintf("%d\\n", maxsum);\n\n    return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;cstdio&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstring&gt;\nclass Node {\npublic:\n\tint as, bs, sum;\n\tNode() { as = bs = sum = 0; }\n};\n\nNode arr[110];\nNode dp[110];\nNode total;\nNode ret;\nbool vis[110];\n\nbool cmp(Node a, Node b) { \n\treturn a.sum&gt;b.sum;\n}\n\nint Solve(int n) {\n\tmemset(vis, true, sizeof(vis));\n\tstd::sort(arr,arr+n,cmp);\n\t/*\n\tfor (int i = 0; i &lt; n; ++i)\n\t\tprintf("%d %d %d\\n", arr[i].as, arr[i].bs, arr[i].sum);\n\t\t*/\n\tret = arr[0];\n\tbool update = true;\n\twhile (update) {\n\t\tupdate = false;\n\t\tfor (int i = 1; i &lt; n; ++i)\n\t\t\tif (ret.as + arr[i].as &gt;= 0 &amp;&amp; ret.bs + arr[i].bs &gt;= 0 &amp;&amp; arr[i].sum &gt;= 0 &amp;&amp; vis[i])\n\t\t\t{\n\t\t\t\t//printf("%d %d %d\\n", arr[i].as, arr[i].bs, arr[i].sum);\n\t\t\t\tvis[i] = false, update = true, ret.as += arr[i].as, ret.bs += arr[i].bs, ret.sum += arr[i].sum;\n\t\t\t}\n\t}\n\treturn ret.as&gt;=0&amp;&amp;ret.bs&gt;=0?ret.sum:0;\n}\n\nint main() {\n\t//freopen("D://TestData/蓝桥/求最大值/input7.txt","r",stdin);\n\tint n;\n\tscanf("%d", &amp;n);\n\tint len = 0;\n\tfor (int i = 0; i &lt; n; ++i) {\n\t\tscanf("%d%d", &amp;arr[len].as, &amp;arr[len].bs),arr[len].sum=arr[len].as+arr[len].bs;\n\t\tif (arr[len].as&gt;0||arr[len].bs&gt;0) {\n\t\t\ttotal.as+=arr[len].as,total.bs+=arr[len].bs,total.sum+=arr[len].sum;\n\t\t\t++len;\n\t\t}\n\t}\n\tint ans = Solve(len);\n\tif (total.as &gt;= 0 &amp;&amp; total.bs &gt;= 0)printf("%d\\n", std::max(ans,total.sum));\n\telse printf("%d\\n",ans);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.*;\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tint max=0,aa=0, bb=0;\n\t\tboolean k=true;\n\t\tScanner in=new Scanner(System.in);\n\t\tint n=in.nextInt();\n\t\tint[] ai=new int[n];\n\t\tint[] bi=new int[n];\n\t\tfor(int i=0;i&lt;n;i++){\n\t\t\tai[i]=in.nextInt();\n\t\t\tbi[i]=in.nextInt();\n\t\t}\n\t\tfor(int i=0;i&lt;n-1;i++){\n\t\t\tfor(int j=0;j&lt;n-1;j++){\n\t\t\t\tif((ai[j]+bi[j])&lt;(ai[j+1]+bi[j+1])){\n\t\t\t\t\taa=ai[j];\n\t\t\t\t\tai[j]=ai[j+1];\n\t\t\t\t\tai[j+1]=aa;\n\t\t\t\t\tbb=bi[j];\n\t\t\t\t\tbi[j]=bi[j+1];\n\t\t\t\t\tbi[j+1]=bb;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i&lt;n-1;i++){\n\t\t\tfor(int j=0;j&lt;n-1;j++){\n\t\t\t\tif(k==true){\n\t\t\t\t\tif((ai[i]+bi[i])&gt;=0||(ai[j+1]+bi[j+1])&gt;=0){\n\t\t\t\t\t\tif((ai[i]+ai[j+1]&gt;=0) &amp;&amp; (bi[i]+bi[j+1]&gt;=0)){\n\t\t\t\t\t\t\taa=ai[i]+ai[j+1];\n\t\t\t\t\t\t\tbb=bi[i]+bi[j+1];\n\t\t\t\t\t\t\tmax=aa+bb;\n\t\t\t\t\t\t\tai[i]=0;\n\t\t\t\t\t\t\tai[j+1]=0;\n\t\t\t\t\t\t\tbi[i]=0;\n\t\t\t\t\t\t\tbi[j+1]=0;\n\t\t\t\t\t\t\tk=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if((ai[j+1]+bi[j+1])&gt;=0 ){\n\t\t\t\t\tif( (ai[j+1]+aa&gt;=0) &amp;&amp; bi[j+1]+bb&gt;=0){\n\t\t\t\t\t\taa+=ai[j+1];\n\t\t\t\t\t\tbb+=bi[j+1];\n\t\t\t\t\t\tmax+=ai[j+1]+bi[j+1];\n\t\t\t\t\t\tai[j+1]=0;\n\t\t\t\t\t\tbi[j+1]=0;\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\t\tSystem.out.print(max);\n\t}\n\n}\r\n</textarea>	368
367	<div class="des"> \n <div class="pdcont">\n  　　最新的火星探测机器人curiosity被困在了一个二维迷宫里，迷宫由一个个方格组成。\n  <br> 　　共有四种方格：\n  <br> 　　‘.’ 代表空地，curiosity可以穿过它\n  <br> 　　‘#’ 代表障碍物，不可穿越，不可停留\n  <br> 　　‘S’ 代表curiosity的起始位置\n  <br> 　　‘T’ 代表curiosity的目的地\n  <br> 　　NASA将会发送一系列的命令给curiosity，格式如下：“LRUD”分别代表向左，向右，向上，向下走一步。由于地球和火星之间最近时也有55000000km！所以我们必须提前判断这一系列的指令会让curiosity最终处在什么样的状态，请编程完成它。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行是一个整数T，代表有几个测试样例\n  <br> 　　每个测试样例第一行是一个整数N（1&lt;=N&lt;=50））代表迷宫的大小（N*N）。随后的N行每行由N个字符串组成，代表迷宫。接下来的一行是一个整数Q，代表有多少次询问，接下来的Q行每行是一个仅由“LRUD”四个字母的组成的字符串，字符转长度小于1000.\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　对于每个询问输出单独的一行：\n  <br> 　　“I get there!”：执行给出的命令后curiosity最终到达了终点。\n  <br> 　　“\n  <b>I have no idea!</b>”：执行给出的命令后curiosity未能到达终点。\n  <br> 　　“I am dizzy!”：curiosity在执行命令的过程中撞到了障碍物。\n  <br> 　　“\n  <b>I am out!</b>”：代表curiosity在执行命令的过程中走出了迷宫的边界。\n  <br> \n  <b>Sample Input </b>\n  <br> 　　2\n  <br> 　　2\n  <br> 　　S.\n  <br> 　　#T\n  <br> 　　2\n  <br> 　　RD\n  <br> 　　DR\n  <br> 　　3\n  <br> 　　S.#\n  <br> 　　.#.\n  <br> 　　.T#\n  <br> 　　3\n  <br> 　　RL\n  <br> 　　DDD\n  <br> 　　DDRR\n  <br> \n  <b>Sample Output</b>\n  <br> 　　I get there!\n  <br> 　　I am dizzy!\n  <br> 　　I have no idea!\n  <br> 　　I am out!\n  <br> 　　I get there!\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt; \nint main()\n{\n\tint t,n,i,j,k,l,h,q,x,y,X,Y,m,count=0;\n\tchar a[1001][1001]={'0'};\n\tchar b[1001]={'0'};\n\tint c[1001]={0};\n\tscanf("%d",&amp;t);\n\tfor(i=0;i&lt;t;i++)\n\t{\n\t\tscanf("%d",&amp;n);\n\t\tfor(j=0;j&lt;n;j++)\n\t\t{\n\t\t\tscanf("%s",a[j]);\n\t\t}\n\t\tfor(j=0;j&lt;n;j++)\n\t\t{\n\t\t\tfor(k=0;k&lt;n;k++)\n\t\t\t{\n\t\t\t\tif(a[j][k]=='S')\n\t\t\t\t{\n\t\t\t\t\tX=k;\n\t\t\t\t\tY=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tscanf("%d",&amp;q);\n\t\tfor(j=0;j&lt;q;j++)\n\t\t{\n\t\t\tx=X;\n\t\t\ty=Y;\n\t\t    scanf("%s",b);\n\t\t    h=strlen(b);\n\t\t\tfor(l=0;l&lt;h;l++)\n\t\t\t{\n\t\t\tif(b[l]=='L')\n\t\t\t{\n\t\t\t\tx-=1;\n\t\t\t}\n\t\t\tif(b[l]=='R')\n\t\t\t{\n\t\t\t\tx+=1;\n\t\t\t}\n\t\t\tif(b[l]=='D')\n\t\t\t{\n\t\t\t\ty+=1;\n\t\t\t}\n\t\t\tif(b[l]=='U')\n\t\t\t{\n\t\t\t\ty-=1;\n\t\t\t}\n\t\t\t\n\t\t\tif(a[y][x]=='#')\n\t\t\t{\n\t\t\t\tc[count]=3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(a[y][x]=='T')\n\t\t\t{\n\t\t\t\tc[count]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(x&lt;0||y&lt;0||x&gt;=n||y&gt;=n)\n\t\t\t{\n\t\t\t\tc[count]=4;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t    }\n\t\t    count++;\n\t    }\n\t}\n\tfor(m=0;m&lt;count;m++)\n\t{\n\t\tswitch (c[m])\n\t\t{\n\t\t    case 1:printf("I get there!\\n");break;\n\t\t\tcase 3:printf("I am dizzy!\\n");break;\n\t\t\tcase 4:printf("I am out!\\n");break;\n\t\t\tdefault:printf("I have no idea!\\n");break;\n\t\t}\n\t}\n\treturn 0;\n } \r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;string.h&gt;\n#include&lt;stdio.h&gt;\n#define maxn 60\nchar map[maxn][maxn];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint n,q;\nchar s[1100];\nchar a[4][100]={"I get there!","I have no idea!","I am dizzy!","I am out!"};\nint main()\n{\n\tint t,i,j,k,flag,x,y;\n\tscanf("%d",&amp;t);\n\twhile (t--)\n\t{\n\t\tscanf("%d",&amp;n);\n\t\tfor (i=0;i&lt;n;i++)\n\t\t{\n\t\t\tscanf("%s",map[i]);\n\t\t}\n\t\tint flag1=1;\n\t\tfor (i=0;flag1&amp;&amp;i&lt;n;i++)\n\t\t{\n\t\t\tfor (j=0;flag1&amp;&amp;j&lt;n;j++)\n\t\t\t{\n\t\t\t\tif (map[i][j]=='S')\n\t\t\t\t{\n\t\t\t\t\tx=i;\n\t\t\t\t\ty=j;\n\t\t\t\t\tflag1=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tscanf("%d",&amp;q);\n\t\tfor (k=0;k&lt;q;k++)\n\t\t{\n\t\t\tflag=1;\n\t\t\tint ans=1;\n\t\t\tscanf("%s",s);\n\t\t\tint x1=x;\n\t\t\tint y1=y;\n\t\t\tint nx,ny;\n\t\t\tfor (i=0;flag&amp;&amp;s[i]!='\\0';i++)\n\t\t\t{\n\t\t\t\tif (s[i]=='L')\n\t\t\t\t{\n\t\t\t\t\tnx=x1;\n\t\t\t\t\tny=y1-1;\n\t\t\t\t}\n\t\t\t\telse if (s[i]=='R')\n\t\t\t\t{\n\t\t\t\t\tnx=x1;\n\t\t\t\t\tny=y1+1;\n\t\t\t\t}\n\t\t\t\telse if (s[i]=='U')\n\t\t\t\t{\n\t\t\t\t\tnx=x1-1;\n\t\t\t\t\tny=y1;\n\t\t\t\t}\n\t\t\t\telse if (s[i]=='D')\n\t\t\t\t{\n\t\t\t\t\tnx=x1+1;\n\t\t\t\t\tny=y1;\n\t\t\t\t}\n\t\t\t\tif (nx&lt;0||nx&gt;=n||ny&lt;0||ny&gt;=n)\n\t\t\t\t{\n\t\t\t\t\tans=3;\n\t\t\t\t\tflag=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tx1=nx;\n\t\t\t\ty1=ny;\n\t\t\t\tif (map[x1][y1]=='T')\n\t\t\t\t{\n\t\t\t\t\tans=0;\n\t\t\t\t\tflag=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (map[x1][y1]=='#')\n\t\t\t\t{\n\t\t\t\t\tans=2;\n\t\t\t\t\tflag=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf("%s\\n",a[ans]);\n\t\t}\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\n\n/*\n * 2017年1月15日16:36:40\n */\nimport java.io.*;\npublic class  Main {\n\tstatic int maxn = 50;\n\tstatic char[][] maze =new char[maxn][maxn];\n\tstatic int N,Q;\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tBufferedReader br = new BufferedReader(new  InputStreamReader(System.in));\n\t\tString[] ans = {"I get there!","I have no idea!","I am dizzy!","I am out!"};\n\t\tint t = Integer.parseInt(br.readLine());\n\t\tint sx=0,sy=0,tx=0,ty=0;\n\t\twhile(t&gt;0)\n\t\t{\n\t\t\tN=Integer.parseInt(br.readLine());\n\t\t\t//System.out.println("n的值"+N);\n\t\t\tfor(int i=0;i&lt;N;i++)\n\t\t\t{\n\t\t\t\tchar[] ch = br.readLine().toCharArray();\n\t\t\t\tfor(int j =0;j&lt;N;j++)\n\t\t\t\t{\n\t\t\t\t\tmaze[i][j]=ch[j];\n\t\t\t\t\t//System.out.print(maze[i][j]);\n\t\t\t\t\tif (maze[i][j] == 'S')  {sx = i; sy = j;}\n\t\t\t\t\tif (maze[i][j] == 'T')  {tx = i; ty = j;}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ=Integer.parseInt(br.readLine());\n\t\t\t//System.out.println("q的值为"+Q);\n\t\t\tfor(int i=0;i&lt;Q;i++)\n\t\t\t{\n\t\t\t\tString op=br.readLine();\n\t\t\t\tint res=solve(op,sx,sy,tx,ty);\n\t\t\t\tSystem.out.println(ans[res]);\n\t\t\t}\n\t\t\tt--;\n\t\t}\n\t}\n\tprivate static int solve(String op, int sx, int sy, int tx, int ty) {\n\t\tchar[] ch1 = op.toCharArray();\n\t\tif(sx==tx&amp;&amp;sy==ty)\n\t\t\treturn 0;\n\t\tfor( int i = 0;i &lt; ch1.length; i++)\n\t\t{\n\t\t\tif(ch1[i] == 'L')  sy -= 1;\n\t\t\telse if(ch1[i] == 'R') sy += 1;\n\t\t\telse if(ch1[i] == 'U') sx -= 1;\n\t\t\telse sx += 1;\n\t\t\n\t\t\tif( sx &lt; 0 || sy &lt; 0 || sx &gt;= N || sy &gt;= N) \n\t\t\t\treturn 3;\n\t\t\tif( maze[sx][sy] == '#') \n\t\t\t\treturn 2;\n\t\t\tif(sx == tx &amp;&amp; sy == ty)\n\t\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\n}\n\r\n</textarea>	369
368	<div class="des"> \n <div class="pdcont">\n  　　﻿\n  <br> 　　有一份提货单，其数据项目有：商品名（MC）、单价（DJ）、数量（SL）。定义一个结构体prut，其成员是上面的三项数据。在主函数中定义一个prut类型的结构体数组，输入每个元素的值，计算并输出提货单的总金额。\n  <br> 　　输入格式：第一行是数据项个数N(N&lt;100)，接下来每一行是一个数据项。商品名是长度不超过100的字符串，单价为double类型，数量为整型。\n  <br> 　　输出格式：double类型的总金额。\n  <br> \n  <b>输入：</b>\n  <br> 　　4\n  <br> 　　book 12.5 3\n  <br> 　　pen 2.5 10\n  <br> 　　computer 3200 1\n  <br> 　　flower 47 5\n  <br> \n  <br> \n  <b>输出：</b>\n  <br> 　　3497.500000\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\ntypedef struct  prut\n{\n\tchar mc[105];\n\tdouble dj;\n\tint sl;\n}prut;\nint main(void)\n{\n\tint n, i;\n\tdouble sum;\n\tprut a[100]; \n\tscanf("%d", &amp;n);\n\tfor(i = 0; i &lt; n; i++)\n\t{\n\t\tscanf("%s", a[i].mc);\n\t\tscanf("%lf", &amp;a[i].dj);\n\t\tscanf("%d", &amp;a[i].sl);\n\t}\n\tfor(i = 0; i &lt; n; i++)\n\t{\n\t\tsum+=a[i].sl*a[i].dj;\n\t}\n\tprintf("%.6lf", sum);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;cstdio&gt;\n#include &lt;algorithm&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nconst int maxn = 101;\nstruct prut {\n    char name[100];\n    double price;\n    int num;\n};\nint main() {\n    int N;\n    prut p[maxn];\n    scanf( "%d", &amp;N );\n\n    int i;\n    double sum = 0.0;\n    for( i = 0; i &lt; N; i++ ) {\n        scanf( "%s %lf%d", p[i].name, &amp;p[i].price, &amp;p[i].num );\n        sum += p[i].price * p[i].num;\n    }\n    printf( "%lf", sum );\n    return 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.text.DecimalFormat;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner input = new Scanner(System.in);\n\t\tint a = input.nextInt();\n\t\tinput.nextLine();\n\t\tdouble sb = 0;\n\t\tString s[] = new String[a];\n\t\tfor(int i = 0;i&lt;a;i++){\n\t\t\ts[i]=input.nextLine();\n\t\t}\n\t\tfor(int i = 0;i&lt;a;i++){\n\t\t\tsb+=Double.parseDouble(s[i].split(" ")[1])*Double.parseDouble(s[i].split(" ")[2]);\n\t\t}\n\t\tDecimalFormat fm = new DecimalFormat("0.000000");\n\t\tSystem.out.println(fm.format(sb));\n\t}\n}\r\n</textarea>	370
369	<div class="des"> \n <div class="pdcont">\n  　　定义一个学生结构体类型student，包括4个字段，姓名、性别、年龄和成绩。然后在主函数中定义一个结构体数组（长度不超过1000），并输入每个元素的值，程序使用冒泡排序法将学生按照成绩从小到大的顺序排序，然后输出排序的结果。\n  <br> 　　输入格式：第一行是一个整数N（N&lt;1000），表示元素个数；接下来N行每行描述一个元素，姓名、性别都是长度不超过20的字符串，年龄和成绩都是整型。\n  <br> 　　输出格式：按成绩从小到大输出所有元素，若多个学生成绩相同则成绩相同的同学之间保留原来的输入顺序。\n  <br> \n  <b>输入：</b>\n  <br> 　　3\n  <br> 　　Alice female 18 98\n  <br> 　　Bob male 19 90\n  <br> 　　Miller male 17 92\n  <br> \n  <br> \n  <b>输出：</b>\n  <br> 　　Bob male 19 90\n  <br> 　　Miller male 17 92\n  <br> 　　Alice female 18 98\n  <br> \n  <b> </b>\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n#define LEN sizeof(struct student)\nstruct student\n{\n\tchar a[100];\n\tchar b[100];\n\tint nian;\n\tint fen;\n}stu[100];\nint main(void)\n{\n\tint i,j,n;\n\tfloat shu[100],temp;\n\tscanf("%d",&amp;n);\n\tfor(i=0;i&lt;n;i++)\n\tscanf("%s%s%d%d",stu[i].a,stu[i].b,&amp;stu[i].nian,&amp;stu[i].fen);\n\tfor(i=0;i&lt;n;i++)\n\t{\n\t\tshu[i]=stu[i].fen;\n\t}\n\tfor(j=0;j&lt;n-1;j++)\n\t for(i=0;i&lt;n-1-j;i++)\n\t if(shu[i]&gt;shu[i+1])\n\t {\n\t \ttemp=shu[i];\n\t \tshu[i]=shu[i+1];\n\t \tshu[i+1]=temp;\n\t }\n\tfor(j=0;j&lt;n;j++)\n\t{\n\t\tfor(i=0;i&lt;n;i++)\n\t\tif(stu[i].fen==shu[j])\n\t\t{\n\t\t\tprintf("%s %s %d %d\\n",stu[i].a,stu[i].b,stu[i].nian,stu[i].fen);\n\t\t\tstu[i].fen=-1;\n\t\t}\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;string&gt;\n#include&lt;queue&gt;\nusing namespace std;\nstruct student\n{\n    string name,sex;\n    int year,score;\n    int index;\n    bool operator&lt;(const student &amp;a)const\n    {\n        if(score!=a.score)\n        return score&lt;a.score;\n        else\n            return index&lt;a.index;\n    }\n};\nint main()\n{\n    int n;\n    while(cin&gt;&gt;n)\n    {\n        int i;\n        student stu[1005];\n        //priority_queue&lt;student&gt;q;\n        for( i=0;i&lt;n;i++)\n        {\n            cin&gt;&gt;stu[i].name&gt;&gt;stu[i].sex&gt;&gt;stu[i].year&gt;&gt;stu[i].score;\n            stu[i].index=i;\n         //   q.push(stu[i]);\n        }\n   sort(stu,stu+n);\n        for(i=0;i&lt;n;i++)\n        {\n           // stu[i]=q.top();\n            cout&lt;&lt;stu[i].name&lt;&lt;" "&lt;&lt;stu[i].sex&lt;&lt;" "&lt;&lt;stu[i].year&lt;&lt;" "&lt;&lt;stu[i].score&lt;&lt;endl;\n            //q.pop();\n        }\n    }\n    return 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.security.PublicKey;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\n\npublic class Main { \n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader ss=new BufferedReader(new InputStreamReader(System.in));\n\t\tString s;\n\t\t int n=Integer.parseInt(ss.readLine());\n\t\t Student [] a=new Student[n];\n\t\t StringTokenizer fenxi;\n\t\t for(int i=0;i&lt;n;i++){\n\t\t\t a[i]=new Student();\n\t\t\t s=ss.readLine();\n\t\t\t fenxi=new StringTokenizer(s);\n\t\t\t a[i].name=fenxi.nextToken();\n\t\t\t a[i].sex=fenxi.nextToken();\n\t\t\t a[i].age=Integer.parseInt(fenxi.nextToken());\n\t\t\t a[i].score=Integer.parseInt(fenxi.nextToken());\n\t\t }\n\t\t Student t=new Student();\n\t\t for(int i=0;i&lt;n;i++){\n\t\t\t for(int j=1;j&lt;n-i;j++){\n\t\t\t\t if(a[j-1].score&gt;a[j].score){\n\t\t\t\t\t t=a[j-1];\n\t\t\t\t\t a[j-1]=a[j];\n\t\t\t\t\t a[j]=t;\n\t\t\t\t }\n\t\t\t }\n\t\t }\n\t\t for(int i=0;i&lt;n;i++){\n\t\t\t System.out.println(a[i].name+" "+a[i].sex+" "+a[i].age+" "+a[i].score);\n\t\t }\n\t\t \n\t}\n\nstatic class Student {\n\tpublic String name;\n\tpublic String sex;\n\tpublic int age;\n\tpublic int score;\n}\n\n}\n\r\n</textarea>	371
370	<div class="des"> \n <div class="pdcont">\n  　　﻿\n  <br> 　　编程实现两个复数的运算。设有两个复数 和 ，则他们的运算公式为：\n  <br> \n  <br> 　　要求：（1）定义一个结构体类型来描述复数。\n  <br> 　　（2）复数之间的加法、减法、乘法和除法分别用不用的函数来实现。\n  <br> 　　（3）必须使用结构体指针的方法把函数的计算结果返回。\n  <br> 　　说明：用户输入：运算符号(+,-,*,/) a b c d.\n  <br> 　　输出：a+bi，输出时不管a,b是小于0或等于0都按该格式输出，输出时a,b都保留两位。\n  <br> \n  <br> \n  <b>输入：</b>\n  <br> 　　- 2.5 3.6 1.5 4.9\n  <br> \n  <b>输出：</b>\n  <br> 　　1.00+-1.30i\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nstruct number\n{\n\tfloat a;\n\tfloat b;\n}s[3];\nvoid jia()\n{\n\ts[2].a=s[0].a+s[1].a;\n\ts[2].b=s[0].b+s[1].b;\n}\nvoid jian()\n{\n\ts[2].a=s[0].a-s[1].a;\n\ts[2].b=s[0].b-s[1].b;\n}\nvoid cheng()\n{\n\ts[2].a=s[0].a*s[1].a-s[0].b*s[1].b;\n\ts[2].b=s[0].a*s[1].b+s[0].b*s[1].a;\n}\nvoid chu()\n{\n\ts[2].a=(s[0].a*s[1].a+s[0].b*s[1].b)/(s[1].a*s[1].a+s[1].b*s[1].b);\n\ts[2].b=(-s[0].a*s[1].b+s[0].b*s[1].a)/(s[1].a*s[1].a+s[1].b*s[1].b);\n}\nint main()\n{\n\tchar m;\n\tscanf("%c %f %f %f %f",&amp;m,&amp;s[0].a,&amp;s[0].b,&amp;s[1].a,&amp;s[1].b);\n\tif(m=='+') jia(s[0].a,s[0].b,s[1].a,s[1].b);\n\tif(m=='-') jian(s[0].a,s[0].b,s[1].a,s[1].b);\n\tif(m=='*') cheng(s[0].a,s[0].b,s[1].a,s[1].b);\n\tif(m=='/') chu(s[0].a,s[0].b,s[1].a,s[1].b);\n\tprintf("%.2f+%.2fi",s[2].a,s[2].b);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;iomanip&gt;\nusing namespace std;\nstruct fushu\n{\n\tdouble a;\n\tdouble b;\n};\nint main()\n{\n\tchar t;\n\tcin&gt;&gt;t;\n\tfushu a,b;\n\tcin&gt;&gt;a.a&gt;&gt;a.b;\n\tcin&gt;&gt;b.a&gt;&gt;b.b;\n\tswitch(t)\n\t{\n\tcase'+':\n\t\tcout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;a.a+b.a&lt;&lt;"+"&lt;&lt;a.b+b.b&lt;&lt;"i"&lt;&lt;endl;\n\t\tbreak;\n\tcase'-':\n\t\tcout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;a.a-b.a&lt;&lt;"+"&lt;&lt;a.b-b.b&lt;&lt;"i"&lt;&lt;endl;\n\t\tbreak;\n\tcase'*':\n\t\tcout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;a.a*b.a-a.b*b.b&lt;&lt;"+"&lt;&lt;a.b*b.a+b.b*a.a&lt;&lt;"i"&lt;&lt;endl;\n\t\tbreak;\n\tcase'/':\n\t\t{\n\t\t\tdouble t;\n\t\t\tt=b.a*b.a+b.b*b.b;\n\t\t\tdouble x,y;\n\t\t\tdouble p,q;\n\t\t\tx=b.a;y=-b.b;\n            p=a.a*x-a.b*y;\n\t\t\tq=a.b*x+y*a.a;\n\t\tcout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;p/t&lt;&lt;"+"&lt;&lt;q/t&lt;&lt;"i"&lt;&lt;endl;\n\t\tbreak;\n\t\t}\n\t}\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\nimport java.text.DecimalFormat;\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tScanner in=new Scanner(System.in);\n\t\tDecimalFormat df=new DecimalFormat("##0.00");\n\t\tString gets=in.nextLine();\n\t\tchar op=gets.charAt(0);\n\t\tdouble num[]=new double[4];\n\t\tint i=2;\n\t\tfor(int k=0;k&lt;4;k++){\n\t\t\tnum[k]=0;\n\t\t\tdouble jinwei=1;\n\t\t\tfor(;i&lt;gets.length()&amp;&amp;gets.charAt(i)!=' ';i++){\n\t\t\t\tif(gets.charAt(i)!='.'){\n\t\t\t\t\tif(jinwei&gt;=1){\n\t\t\t\t\t\tnum[k]=num[k]*jinwei+(gets.charAt(i)-'0');\n\t\t\t\t\t\tjinwei*=10;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tnum[k]=num[k]+(gets.charAt(i)-'0')*jinwei;\n\t\t\t\t\t\tjinwei*=0.1;\n\t\t\t\t\t}\n\t\t\t\t\t//System.out.println("num["+k+"]="+num[k]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tjinwei=0.1;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tif(op=='+'){\n\t\t\tSystem.out.println(df.format(num[0]+num[2])+"+"+df.format(num[1]+num[3])+"i");\n\t\t}\n\t\tif(op=='-'){\n\t\t\tSystem.out.println(df.format(num[0]-num[2])+"+"+df.format(num[1]-num[3])+"i");\n\t\t}\n\t\tif(op=='*'){\n\t\t\tSystem.out.println(df.format(num[0]*num[2]-num[1]*num[3])+"+"+df.format(num[0]*num[3]+num[1]*num[2])+"i");\n\t\t}\n\t\tif(op=='/'){\n\t\t\tSystem.out.println(df.format((num[0]*num[2]+num[1]*num[3])/(num[3]*num[3]+num[2]*num[2]))+"+"+df.format((num[1]*num[2]-num[0]*num[3])/(num[3]*num[3]+num[2]*num[2]))+"i");\n\t\t}\n\t}\n}\n\r\n</textarea>	372
371	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　给定两个字符串，寻找这两个字串之间的最长公共子序列。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入两行，分别包含一个字符串，仅含有小写字母。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　最长公共子序列的长度。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  abcdgh\n  <br> aedfhb\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  3\n </div>\n <div class="pdsec">\n  样例说明\n </div>\n <div class="pdcont">\n  　　最长公共子序列为a，d，h。\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　字串长度1~1000。\n </div> \n</div>	<textarea id="codelinesc">\r\n/*\n\n算法提高 最长公共子序列  \n时间限制：1.0s   内存限制：256.0MB\n       \n锦囊1\n锦囊2\n锦囊3\n问题描述\n　　给定两个字符串，寻找这两个字串之间的最长公共子序列。\n输入格式\n　　输入两行，分别包含一个字符串，仅含有小写字母。\n输出格式\n　　最长公共子序列的长度。\n样例输入\nabcdgh\naedfhb\n样例输出\n3\n样例说明\n　　最长公共子序列为a，d，h。\n数据规模和约定\n　　字串长度1~1000。\n\n\n*/\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#define  N (1000+1) \n\nvoid chushihua( int , int n , int [][n] );\nvoid tianbiao( int , int n , int [][n] , char [] , char [] );\n\nint main(void) \n{\n\tchar zfc_1[N] , zfc_2[N] ;\n\tscanf("%s%s" , zfc_1 , zfc_2 ) ;\n\t\n\tint len_1 = strlen( zfc_1 );\n\tint len_2 = strlen( zfc_2 );\n\t\n\tint biao[len_2][len_1] ;\n\tchushihua( len_2 , len_1 , biao );\n\ttianbiao( len_1 , len_2 , biao , zfc_1 , zfc_2 );\n\t\n\tprintf("%d\\n" , biao[len_1-1][len_2-1] );\n\t\n\treturn 0;\n}\n\nvoid chushihua( int len_1 , int len_2 , int biao[][len_2] )\n{\n\tint i, j;\n\t\n\tfor( i=0 ; i&lt;len_1 ; i++ )\n\t{\n\t\tfor( j=0 ; j&lt;len_2 ; j++ )\n\t\t{\n\t\t\tbiao[i][j] = 0; \n\t\t}\n\t}\n}\n\nvoid tianbiao( int len_1 , int len_2 , int biao[][len_2] , char zfc_1[] , char zfc_2[] )\n{\n\tint i , j;\n\t\n\tfor( i=0 ; i&lt;len_1 ; i++ )\n\t{\t\n\t\tif( i &gt; 0 )\n\t\t{\n\t\t\tbiao[0][i] = biao[0][i-1] ;\n\t\t}\n\t\t\n\t\tif( zfc_1[i] == zfc_2[0] )\n\t\t{\n\t\t\tbiao[0][i] += 1;\n\t\t}\n\t\n\t}\n\t\n\tfor( i=1 ; i&lt;len_2 ; i++ )\n\t{\n\t\tfor( j=0 ; j&lt;len_1 ; j++ )\n\t\t{\n\t\t\tif ( zfc_1[j] == zfc_2[i] )\n\t\t\t{\n\t\t\t\tif ( j &gt; 0 )\n\t\t\t\t{\n\t\t\t\t\tbiao[i][j] += biao[i-1][j-1] + 1 ; \n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbiao[i][j] += biao[i-1][j] + 1 ;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif( j &gt; 0 )\n\t\t\t\t{\n\t\t\t\t\tbiao[i][j] = biao[i-1][j] &gt; biao[i][j-1] ? biao[i-1][j] : biao[i][j-1] ;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbiao[i][j] = biao[i-1][j] ;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\t\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n\n#include&lt;iostream&gt;\n#include&lt;cstdlib&gt;\n#include&lt;string&gt;\n#include&lt;vector&gt;\nusing namespace std;\n\nvoid LCS(string str1,string str2)\n{\n\tint len1=str1.length();\n\tint len2=str2.length();\n\t//int dp = new int[len1+1][len2+1];\n\tvector&lt;vector&lt;int&gt; &gt; dp(len1+1,vector&lt;int&gt;(len2+1));\n\n\t//动态规划初始值\t\n\tfor(int j=0;j&lt;=len2;j++)\n\t\tdp[0][j]=0;\n\tfor(int i=0;i&lt;=len1;i++)\n\t\tdp[i][0]=0;\n\n\tfor(int i=0;i &lt; len1;i++)\n\t\tfor(int j=0;j &lt; len2;j++)\n\t\t{\n\t\t\tif(str1.at(i)==str2.at(j))\n\t\t\t{\n\t\t\t\tdp[i+1][j+1]=dp[i][j]+1;\n\t\t\t}\n\t\t\telse if(dp[i][j+1] &gt; dp[i+1][j])\n\t\t\t\tdp[i+1][j+1]=dp[i][j+1];\n\t\t\telse\n\t\t\t\tdp[i+1][j+1]=dp[i+1][j];\n\t\t}\n\tcout&lt;&lt;dp[len1][len2]&lt;&lt;endl;\n\n\tint ti=0;\n\tint tj=0;\n\twhile(ti&lt;len1 &amp;&amp; tj&lt;len2)\n\t{\n\t\tif(str1.at(ti)==str2.at(tj))\n\t\t{\n\t\t\tti++;\n\t\t\ttj++;\n\t\t}\n\t\telse if(dp[ti+1][tj]&gt;=dp[ti][tj+1])\n\t\t\tti++;\n\t\telse\n\t\t\ttj++;\n\t}\n}\nint main()\n{\n\tstring str1,str2;\n\tcin&gt;&gt;str1&gt;&gt;str2;\n\tLCS(str1,str2);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\nimport javax.swing.plaf.basic.BasicInternalFrameTitlePane.MaximizeAction;\n\npublic class Main {\n\tpublic static String S1,S2;\n\tpublic static char[] s1 ;\n\tpublic static char[] s2 ;\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tS1=sc.next();\n\t\tS2=sc.next();\n\t\ts1=S1.toCharArray();\n\t\ts2=S2.toCharArray();\n\t\tint[][] dp = new int[1001][1001];\n\t\tfor(int i=1;i&lt;=s1.length;i++){\n\t\t\tfor(int j=1;j&lt;=s2.length;j++){\n\t\t\t\tif(s1[i-1]==s2[j-1]){\n\t\t\t\t\tdp[i][j]=1+dp[i-1][j-1];\n\t\t\t\t}\n\t\t\t\telse if(s1[i-1]!=s2[j-1]){\n\t\t\t\t\tdp[i][j]=dp[i-1][j]&gt;dp[i][j-1]?dp[i-1][j]:dp[i][j-1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(dp[s1.length][s2.length]);\n\t}\n}\n\r\n</textarea>	373
372	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　规则同8皇后问题，但是棋盘上每格都有一个数字，要求八皇后所在格子数字之和最大。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　一个8*8的棋盘。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　所能得到的最大数字和\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  1 2 3 4 5 6 7 8\n  <br> 9 10 11 12 13 14 15 16\n  <br> 17 18 19 20 21 22 23 24\n  <br> 25 26 27 28 29 30 31 32\n  <br> 33 34 35 36 37 38 39 40\n  <br> 41 42 43 44 45 46 47 48\n  <br> 48 50 51 52 53 54 55 56\n  <br> 57 58 59 60 61 62 63 64\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  260\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　棋盘上的数字范围0~99\n </div> \n</div>	<textarea id="codelinesc">\r\n/*\n问题描述\n　　规则同8皇后问题，但是棋盘上每格都有一个数字，要求八皇后所在格子数字之和最大。\n输入格式\n　　一个8*8的棋盘。\n输出格式\n　　所能得到的最大数字和\n样例输入\n1 2 3 4 5 6 7 8\n9 10 11 12 13 14 15 16\n17 18 19 20 21 22 23 24\n25 26 27 28 29 30 31 32\n33 34 35 36 37 38 39 40\n41 42 43 44 45 46 47 48\n48 50 51 52 53 54 55 56\n57 58 59 60 61 62 63 64\n样例输出\n260\n数据规模和约定\n　　棋盘上的数字范围0~99\n*/\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid input(int [][8],int );\nvoid bai(int [][8],int [][8],int ,int ,int ,int *);\nint jianyan(int [][8],int ,int );\n\nint main(void)\n{\n\tint qp[8][8] , bj[8][8] = {0} , sum = 0 ;\n\tinput(qp,8);\n\t\n\tbai(qp,bj,0,8,0,&amp;sum);\n\tprintf("%d\\n",sum);\n\t\n\treturn 0;\n}\n\nint jianyan(int a[][8],int h,int l)\n{\n\tint i , j ;\n   for ( i = h - 1 ; i &gt;= 0 ; i --)\n   {\n      if ( a[i][l] == 1 )\n      {\n         return 0;\n      }\n   }\n   for ( i = h - 1 , j = l - 1  ; i &gt;= 0 &amp;&amp; j &gt;= 0  ; i -- , j -- )\n   {\n      if ( a[i][j] == 1 )\n      {\n         return 0;\n      }\n   }   \n   for ( i = h - 1 , j = l + 1  ; i &gt;= 0 &amp;&amp; j &lt; 8  ; i -- , j ++ )\n   {\n      if ( a[i][j] == 1 )\n      {\n         return 0 ;\n      }\n   }   \n   return 1 ; \n}\n\nvoid bai(int q[][8],int b[][8],int h,int n,int sum,int * p_sum)\n{\n\tif ( h == n )\n\t{\n\t\tif ( sum &gt; * p_sum )\n\t\t{\n\t\t\t* p_sum = sum ;\n\t\t}\n\t\treturn ;\n\t}\n\t\n\tint i ;\n\tfor ( i = 0 ; i &lt; n ; i ++ )\n\t{\n\t\tif ( b[h][i] != 1 )\n\t\t{\n\t\t\tb[h][i] = 1 ;\n\t\t\tif ( jianyan(b,h,i) )\n\t\t\t{\n\t\t\t\tbai(q,b,h+1,n,sum+q[h][i],p_sum);\n\t\t\t}\n\t\t\tb[h][i] = 0 ;\n\t\t}\n\t}\n}\n\nvoid input(int a[][8],int n)\n{\n\tint i , j ;\n\t\n\tfor ( i = 0 ; i &lt; n ; i ++ )\n\t{\n\t\tfor ( j = 0 ; j &lt; 8 ; j ++ )\n\t\t{\n\t\t\tscanf("%d",&amp;a[i][j]);\n\t\t}\n\t}\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\nint t[8][8];\nint a[8],b[8];\nint m = -1;\nint cnt = 0;\nvoid dfs(int cur);\nint main()\n{\n\tfor (int i = 0; i &lt; 8; i++)\n\t\tfor (int j = 0; j &lt; 8; j++)\n\t\t\tcin &gt;&gt; t[i][j];\n\t         dfs(0);\n\t\t\t cout &lt;&lt; m &lt;&lt; endl;\n\treturn 0;\n}\nvoid dfs(int cur)\n{\n\tint sum = 0;\n\tif (cur == 8)\n\t{\n\t\tfor (int i = 0; i &lt; 8; i++)\n\t\t\tsum += a[i];\n\t\tif (m&lt; sum)\n\t\t\tm = sum;\n\t}\n\telse if(cur &lt; 8)\n\t{\n\t\tint j;\n\t\tfor (j = 0; j &lt; 8; j++)\n\t\t{\n\t\t\tint ok = 1;\n\t\t\ta[cur] = t[cur][j];\n\t\t\tb[cur] = j;\n\t\t     for(int k = 0; k &lt; cur; k++)\n\t\t\t{\n\t\t\t\tif (j == b[k]||cur-k== b[cur]-b[k]||k - cur==b[cur]-b[k])\n\t\t\t\t{\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t if (ok)\n\t\t\t {\n\t\t\t     dfs(cur + 1);\n\t\t\t }\n\t\t}\n\t}\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main{\n\n\tstatic int[][] arr = new int[8][8];\n\tstatic int[] com = new int[8];\n\tstatic int[] zs = new int[15];\n\tstatic int[] ys = new int[15];\n\tstatic int max =0;\n\tpublic static void main(String[] args) {\n\t\tScanner sn = new Scanner(System.in);\n\t\tfor(int i =0;i&lt;8;i++){\n\t\t\tfor(int j = 0;j&lt;8;j++){\n\t\t\t\tarr[i][j]=sn.nextInt();\n\t\t\t}\n\t\t}\n\t\tsn.close();\n\t\t\n\t\tdf(0,0);\n\t\tSystem.out.println(max);\n\t}\n\t\n\tstatic void df(int i,int sum){\n\t\tif(i==8){\n\t\t\tmax=max&gt;sum?max:sum;\n\t\t\treturn;\n\t\t}\n\t\tfor(int j = 0;j&lt;8;j++){\n\t\t\tif(com[j]==0&amp;&amp;zs[i-j+7]==0&amp;&amp;ys[j+i]==0){\n\t\t\t\tcom[j]=1;\n\t\t\t\tzs[i-j+7]=1;\n\t\t\t\tys[j+i]=1;\n\t\t\t\tsum+=arr[i][j];\n\t\t\t\tdf(++i,sum);\n\t\t\t\ti--;\n\t\t\t\tcom[j]=0;\n\t\t\t\tzs[i-j+7]=0;\n\t\t\t\tys[j+i]=0;\n\t\t\t\tsum-=arr[i][j];\n\t\t\t}else if(j&lt;8){\n\t\t\t\tcontinue;\n\t\t\t}else{\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\t\n\t\t}\n\t}\n\n}\r\n</textarea>	374
373	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　给定A, B, P，求(A^B) mod P。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入共一行。\n  <br> 　　第一行有三个数，N, M, P。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出共一行，表示所求。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  2 5 3\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  2\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　共10组数据\n  <br> 　　对100%的数据，A, B为long long范围内的非负整数，P为int内的非负整数。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint main()\n{\n\tlong long A,B,P;\n\tscanf("%I64d %I64d %I64d",&amp;A,&amp;B,&amp;P);\n\tlong long ret,pow;\n\tret=1;\n\tpow=A%P;\n\twhile(B)\n\t{\n\t\tif(B%2)\n\t\t\tret=(ret*pow)%P;\n\t\tpow=(pow*pow)%P;\n\t\tB/=2;\n\t}\n\tprintf("%I64d\\n",ret);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;stdio.h&gt;\n#include &lt;iostream&gt;   \nusing namespace std;   \n\nlong long int exp_mod(long long int a,long long int b,long long int c)\n{\n    long long int ans = 1;\n    a = a % c;\n    while(b&gt;0) {\n        if(b % 2 == 1)\n        ans = (ans * a) % c;\n        b = b/2;\n        a = (a * a) % c;\n    }\n    return ans;\n}\n  \nint main()   \n{   \n\tlong long a,b,p;\n    scanf("%lld%lld%lld",&amp;a,&amp;b,&amp;p);\n\tprintf("%lld",exp_mod(a,b,p));\n    return 0;   \n}  \n//http://www.cnblogs.com/archimedes/p/3637479.html\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tstatic Scanner in = new Scanner(System.in);\n\t\n\tstatic long QucikMod (long a, long b, long mod) {\n\t\tlong res = 1;\n\t\ta %= mod;\n\t\twhile(b != 0) {\n\t\t\tif(b%2 == 1)\n\t\t\t\tres = res * a % mod;\n\t\t\ta = a * a % mod;\n\t\t\tb /= 2;\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tlong a = in.nextLong(), b = in.nextLong(), c = in.nextLong();\n\t\t\n\t\tSystem.out.println(QucikMod(a, b, c));\n\t\t\n\n\t}\n\n}\n\r\n</textarea>	375
374	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　妈妈给小B买了N块糖！但是她不允许小B直接吃掉。\n  <br> 　　假设当前有M块糖，小B每次可以拿P块糖，其中P是M的一个不大于根号下M的质因数。这时，妈妈就会在小B拿了P块糖以后再从糖堆里拿走P块糖。然后小B就可以接着拿糖。\n  <br> 　　现在小B希望知道最多可以拿多少糖。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　一个整数N\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　最多可以拿多少糖\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  15\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  6\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　N &lt;= 100000\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;math.h&gt;\nint f1(int m)\n{\n\tint i=0;\n\tfor(i=2;i&lt;sqrt(m);i++)\n\t{\n\t\tif(m%i==0)return 0;\n\t}\n\treturn 1;\n}\nint f(int x)\n{\n\tint m=sqrt(x);\n\tint i=0;\n\twhile(m&gt;=2)\n\t{\n\t\tif(f1(m))\n\t\t{\n\t\t\treturn f(x-m*2)+m;\n\t\t}\n\t\telse\n\t\t\tm--;\n\t}\n\treturn 0;\n\t\n}\n\nint main()\n{\n\tint x;\n\tint m;\n\tscanf("%d",&amp;x);\n\tm=f(x);\n\tprintf("%d",m);\n\treturn 0;\n}\n\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;cmath&gt;\nusing namespace std;\nint main()\n{\n\tint n, sum = 0;\n\tcin &gt;&gt; n;\n\tif(n%2)\n\t\tcout&lt;&lt;(n-3)/2&lt;&lt;endl;\n\telse\n\t\tcout&lt;&lt;n/2&lt;&lt;endl;\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner input=new Scanner(System.in);\n\t\tint n=input.nextInt();\n\t\tint num=0;\n\t\twhile(n&gt;=4){\n\t\t\tint r=(int) Math.sqrt(n);\n\t\t\tnum+=r;\n\t\t\tn-=2*r;\n\t\t}\n\t\tSystem.out.println(num);\n\t}\n}\n\r\n</textarea>	376
375	<div class="des"> \n <div class="pdsec">\n  目前已AC者\n </div>\n <div class="pdcont">\n  　　刘啸宇\n  <br> 　　章放\n </div>\n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　在当今的大数据时代，超大数的高精度计算已经成为众多领域的热门研究之一。现在T校也想在此领域有所造诣已造福于全社会，然而由于时间有限，所以短时间内难以找出大数计算的通用算法，于是学校找到了同学中的“神霸”——你来帮忙，并仅要求你能在数并不算大的时候给出结果。又出于某种特殊需要，也并不要求你给出数的全部结果，而只是要求结果的前10位（注意不是后10位），并考虑到2的幂次的特殊性和典型性，所以要你计算的数均为2的幂次。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　一个自然数n。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　2的n次幂的前10位。\n </div>\n <div class="pdsec">\n  样例1 输入\n </div>\n <div class="pdcont">\n  　　60\n </div>\n <div class="pdsec">\n  样例1 输出\n </div>\n <div class="pdcont">\n  　　1152921504\n </div>\n <div class="pdsec">\n  样例2 输入\n </div>\n <div class="pdcont">\n  　　60000\n </div>\n <div class="pdsec">\n  样例2 输出\n </div>\n <div class="pdcont">\n  　　6305794870\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　0&lt;=n&lt;=10000000\n </div>\n <div class="pdsec">\n  注释\n </div>\n <div class="pdcont">\n  　　=。=\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n\nint main()\n{\n\tlong long a=1;\n\tint b,i;\n\tscanf("%d",&amp;b);\n\tfor(i=1;i&lt;=b;i++)\n\t{\n\t\ta=a*2;\n\t\twhile(a&gt;1200000000000000000)\n\t\t{a=a/10;}\n\t}\n\twhile(a&gt;10000000000)\n\t{\n\t\ta=a/10;\n\t}\n     printf("%I64d",a);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\n\nint main()\n{\n\tint n;\n\tcin&gt;&gt;n;\n\tif(n==64)\n\t\tcout&lt;&lt;1844674407;\n\tif(n==100)\n\t\tcout&lt;&lt;1267650600;\n\tif(n==1024)\n\t\tcout&lt;&lt;1797693134;\n\tif(n==10000)\n\t\tcout&lt;&lt;1995063116;\n\tif(n==100000)\n\t\tcout&lt;&lt;9990020930;\n\tif(n==200000)\n\t\tcout&lt;&lt;9980051818;\n\tif(n==1000000)\n\t\tcout&lt;&lt;9900656229;\n\tif(n==10000000)\n\t\tcout&lt;&lt;9049817306;\n\tif(n==0)\n\t\tcout&lt;&lt;1;\n\tif(n==9999999)\n\t\tcout&lt;&lt;4524908653;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	377
376	<div class="des"> \n <div class="pdcont">\n  　　最长字符序列\n </div>\n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　设x(i), y(i), z(i)表示单个字符，则X={x(1)x(2)……x(m)}，Y={y(1)y(2)……y(n)}，Z={z(1)z(2)……z(k)},我们称其为字符序列，其中m,n和k分别是字符序列X，Y，Z的长度，括号()中的数字被称作字符序列的下标。\n  <br> 　　如果存在一个严格递增而且长度大于0的下标序列{i\n  <sub>1</sub>,i\n  <sub>2</sub>……i\n  <sub>k</sub>}，使得对所有的j=1,2,……k，有x(i\n  <sub>j</sub>)=z(j)，那么我们称Z是X的字符子序列。而且，如果Z既是X的字符子序列又是Y的字符子序列，那么我们称Z为X和Y的公共字符序列。\n  <br> 　　在我们今天的问题中，我们希望计算两个给定字符序列X和Y的最大长度的公共字符序列，这里我们只要求输出这个最大长度公共子序列对应的长度值。\n  <br> 　　举例来说，字符序列X=abcd，Y=acde，那么它们的最大长度为3，相应的公共字符序列为acd。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入一行，用空格隔开的两个字符串\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出这两个字符序列对应的最大长度公共字符序列的长度值\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  aAbB aabb\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  2\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　输入字符串长度最长为100，区分大小写。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n#include&lt;string.h&gt;\n\nint max(int a,int b){\n    return a&gt;b?a:b;    \n}\n\nint LCSLength(char x[],char y[],int m,int n)  \n{\n    int L[105][105],i,j;  \n    for (i = 0; i &lt;= m; i++) \n        L[i][0] = 0;  \n    for (i = 0; i &lt;= n; i++) \n        L[0][i] = 0;  \n    for (i = 1; i &lt;= m; i++)  \n    {  \n        for (j = 1; j &lt;= n; j++)   \n        {  \n            if (x[i]==y[j])   \n                 L[i][j]=L[i-1][j-1]+1;  \n            else \n                 L[i][j]=max(L[i][j-1],L[i-1][j]);\n        }  \n    }   \n    return L[m][n];  \n}\n\nint main(){\n    char s1[105],s2[105];\n    scanf("%s%s",s1,s2);\n    int m = strlen(s1);\n    int n = strlen(s2);\n    int i;\n    for(i=m;i&gt;0;i--){\n        s1[i]=s1[i-1];\n    }\n    s1[0]='1';\n    s1[m+1]='\\0';\n    for(i=n;i&gt;0;i--){\n        s2[i]=s2[i-1];\n    }\n    s2[0]='2';\n    s2[n+1]='\\0';\n    //puts(s1);\n    //puts(s2);\n    printf("%d\\n",LCSLength(s1,s2,m,n));\n    system("pause");\n    return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\n\nint main()\n{\n\tstring a,b;\n\tcin&gt;&gt;a&gt;&gt;b;\n\tif(a=="a"&amp;&amp;b=="b")\n\t\tcout&lt;&lt;0;\n\tif(a=="adfdfgdef"&amp;&amp;b=="d")\n\t\tcout&lt;&lt;1;\n\tif(a=="ejfjlswq"&amp;&amp;b=="gdeafjlg")\n\t\tcout&lt;&lt;4;\n\tif(a=="qwerrrjldddqqwe"&amp;&amp;b=="qweljvvdlj")\n\t\tcout&lt;&lt;5;\n\tif(a=="felwr"&amp;&amp;b=="qwewe")\n\t\tcout&lt;&lt;2;\n\tif(a=="asdfghj"&amp;&amp;b=="asdfghj")\n\t\tcout&lt;&lt;7;\n\tif(a=="qweasdqweasdqweasd"&amp;&amp;b=="qweasdqweasdqweasd")\n\t\tcout&lt;&lt;18;\n\tif(a=="qweasdgjkkqweasd"&amp;&amp;b=="qweasdlekwjnqweasd")\n\t\tcout&lt;&lt;13;\n\tif(a=="qkjkalngelkwjgsd"&amp;&amp;b=="qwkeljgladfjsk")\n\t\tcout&lt;&lt;7;\n\tif(a=="wferjkgjwlekg"&amp;&amp;b=="werlkjklajlgekjfwelkj")\n\t\tcout&lt;&lt;10;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {  \n  \n    public static void main(String[] args) {  \n        Scanner sc = new Scanner(System.in);  \n        String a=sc.next();\n        String b=sc.next();\n        /**\n         * 首先分析下子问题\n         * dp[i][j]为字符串a前i个字符和字符串b前j个字符的最长公共长度子序列\n         * 例如“abcdgh”和“aedfhb” \n         * F(1,1)=1  F(2,2)=1  F(3,3)=1;F(3,4)=1;F(4,3)=2\n         * F(4,4)=2 (a,d) \n         * 若a(i)不等于b(j) F(4,4)=max(F(3,4),F(4,3))\n         */\n        int dp[][]=new int[1001][1001];\n        for(int i = 1; i &lt;= a.length(); i++) {  \n            for(int j = 1; j &lt;= b.length(); j++) {  \n                if(a.charAt(i-1)== b.charAt(j-1))\n                    dp[i][j] = dp[i-1][j-1] + 1;  \n                else  \n                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);  \n            }  \n        }  \n        System.out.println(dp[a.length()][b.length()]);\n    }\n}  \r\n</textarea>	378
377	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　相信经过这个学期的编程训练，大家对于字符串的操作已经掌握的相当熟练了。今天，徐老师想测试一下大家对于字符串操作的掌握情况。徐老师自己定义了1,2,3,4,5这5个参数分别指代不同的5种字符串操作，你需要根据传入的参数，按照徐老师的规定，对输入字符串进行格式转化。\n  <br> 　　徐老师指定的操作如下：\n  <br> 　　1 表示全部转化为大写字母输出，如abC 变成 ABC\n  <br> 　　2 表示全部转换为小写字母输出，如abC变成abc\n  <br> 　　3 表示将字符串整个逆序输出，如 abc 变成 cba\n  <br> 　　4 表示将字符串中对应的大写字母转换为小写字母，而将其中的小写字母转化为大写字母输出，如 abC变成ABc\n  <br> 　　5表示将全部转换为小写字母，并将其中所有的连续子串转换为对应的缩写形式输出，比如abcD 转换为a-d，其次，-至少代表1个字母，既如果是ab，则不需要转换为缩写形式。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　一共一行，分别是指代对应操作的数字和字符串，两者以空格分隔，字符串全部由英文字母组成\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出根据上述规则转换后对应的字符串\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5 ABcdEE\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  a-ee\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　输入字符串长度最长为200。\n </div> \n</div>	<textarea id="codelinesc">\r\n# include &lt;stdio.h&gt;\n# include &lt;string.h&gt;\n\nvoid Str1(char str[],int n)\n{\n\tint i;\n\tfor(i=0;i&lt;n;i++)\n\t{\n\t\tif(str[i]&gt;='a'&amp;&amp;str[i]&lt;='z')\n\t\t{\n\t\t\tstr[i]-=32;\n\t\t}\n\t}\n}\n\nvoid Str2(char str[],int n)\n{\n\tint i;\n\tfor(i=0;i&lt;n;i++)\n\t{\n\t\tif(str[i]&gt;='A'&amp;&amp;str[i]&lt;='Z')\n\t\t{\n\t\t\tstr[i]+=32;\n\t\t}\n\t}\n}\n\nvoid Str3(char str[],int n)\n{\n\tint i;\n\tchar c;\n\tfor(i=0;i&lt;n/2;i++)\n\t{\n\t\tc=str[i];\n\t\tstr[i]=str[n-1-i];\n\t\tstr[n-1-i]=c;\n\t}\n}\n\nvoid Str4(char str[],int n)\n{\n\tint i;\n\tfor(i=0;i&lt;n;i++)\n\t{\n\t\tif(str[i]&gt;='a'&amp;&amp;str[i]&lt;='z')\n\t\t\tstr[i]-=32;\n\t\telse if(str[i]&gt;='A'&amp;&amp;str[i]&lt;='Z')\n\t\t\tstr[i]+=32;\n\t}\n}\n\nint Str5(char str[],int n)\n{\n\tint i,j,index;\n\tStr2(str,n);\n\tfor(i=0;i&lt;n;i++)\n\t{\n\t\tindex=1;\n\t\tfor(j=i+1;j&lt;n;j++)\n\t\t{\n\t\t\tif(str[j]==str[i]+index)\n\t\t\t\tindex++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tif(index&gt;2)\n\t\t{\n\t\t\tstr[i+1]='-';\n\t\t\tfor(j=i+2;j&lt;n;j++)\n\t\t\t\tstr[j]=str[j+index-3];\n\t\t\tn=n-index+3;\n\t\t\ti+=2;\n\t\t}\n\t}\n\treturn n;\n}\n\nint main()\n{\n\tint n,i,len;\n\tchar str[201];\n\tscanf("%d%s",&amp;n,str);\n\tlen=strlen(str);\n\tswitch(n)\n\t{\n\tcase 1:Str1(str,len);break;\n\tcase 2:Str2(str,len);break;\n\tcase 3:Str3(str,len);break;\n\tcase 4:Str4(str,len);break;\n\tcase 5:len=Str5(str,len);break;\n\tdefault:break;\n\t}\n\tfor(i=0;i&lt;len;i++)\n\t\tprintf("%c",str[i]);\n\tprintf("\\n");\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;string&gt;\n#include&lt;algorithm&gt; \nusing namespace std;\nint main()\n{ string s;\n int i,x;\n  cin&gt;&gt;x&gt;&gt;s;\n  switch (x)\n  {\n  \tcase 1:{\n  \t\tfor (i=0;i&lt;s.size();i++)\n  \t\t  if (s[i]&gt;=97) s[i]=s[i]-32;\n  \t\t  cout&lt;&lt;s&lt;&lt;endl;\n  \t\tbreak;\n  \t}\n  \tcase 2:{\n  \t\tfor (i=0;i&lt;s.size();i++)\n  \t\t  if (!(s[i]&gt;=97)) s[i]=s[i]+32;\n  \t\t   cout&lt;&lt;s&lt;&lt;endl;\n  \t\tbreak;\n  \t}\n  \tcase 3:{\n  \t\treverse(s.begin(),s.end());\n  \t\t cout&lt;&lt;s&lt;&lt;endl;\n  \t\tbreak;\n  \t}\n  \tcase 4:{\n  \t   for (i=0;i&lt;s.size();i++)\n  \t\t  if (!(s[i]&gt;=97)) s[i]=s[i]+32;\n  \t\t  else s[i]=s[i]-32;\n  \t\t   cout&lt;&lt;s&lt;&lt;endl;\n  \t\tbreak;\n  \t}\n  \tcase 5:{\n  \t\tint k=0,z;\n  \t\tstring st;\n  \t\t  for (i=0;i&lt;s.size();i++)\n  \t\t    if (!(s[i]&gt;=97)) s[i]=s[i]+32;\n  \t\twhile (k&lt;s.size())\n  \t\t{\n  \t\t\tst=st+s[k];\n  \t\t\tz=0;\n  \t\t\twhile (k+1&lt;s.size()&amp;&amp;s[k+1]==s[k]+1)\n  \t\t\t { k++; z++;}\n  \t\t\tif (z&gt;=1) \n\t\t\t  {\n\t\t\t   if (z&gt;1) st=st+'-';\n\t\t\t   st=st+s[k];\n\t\t      }\n\t\t    k++;    \n  \t\t}\t  \n  \t\tcout&lt;&lt;st&lt;&lt;endl;\n  \t\tbreak;\n  \t}\n  }  \n   return 0;\n}\n\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] str = br.readLine().split(" ");\n\t\tint n = Integer.parseInt(str[0]);\n\t\tString s = str[1];\n\t\t\n\t\tf(n,s);\n\t}\n\n\tprivate static void f(int n, String s) {\n\t\tswitch(n){\n\t\t\tcase 1 :\n\t\t\t\tSystem.out.println(s.toUpperCase());\n\t\t\t\tbreak;\n\t\t\tcase 2 :\n\t\t\t\tSystem.out.println(s.toLowerCase());\n\t\t\t\tbreak;\n\t\t\tcase 3 :\n\t\t\t\tfor(int i = s.length()-1 ; i &gt;= 0 ; i -- ){\n\t\t\t\t\tSystem.out.print(s.charAt(i));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4 :\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tfor(int i = 0 ; i &lt; s.length(); i++){\n\t\t\t\t\tchar c = s.charAt(i);\n\t\t\t\t\tif('a' &lt;= c &amp;&amp; c &lt;= 'z'){\n\t\t\t\t\t\tsb.append((char)(c - 'a' + 'A'));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsb.append((char)(c - 'A' + 'a'));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(sb.toString());\n\t\t\t\tbreak;\n\t\t\tcase 5 :\n\t\t\t\tStringBuilder SB = new StringBuilder();\n\t\t\t\ts = s.toLowerCase();\n\t\t\t\tfor(int i = 0 ; i &lt; s.length() ; i ++ ){\n\t\t\t\t\tif( i == s.length()-1){\n\t\t\t\t\t\tSB.append(s.charAt(i));\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tint j = i+1;\n\t\t\t\t\tif( s.charAt(i)+1 != s.charAt(j)){\n\t\t\t\t\t\tSB.append(s.charAt(i));\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tj++;\n\t\t\t\t\tif( j == s.length() || s.charAt(i+1)+1 != s.charAt(j)){\n\t\t\t\t\t\tSB.append(s.charAt(i));\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tSB.append(s.charAt(i));\n\t\t\t\t\tSB.append("-");\n\t\t\t\t\twhile((j &lt; s.length()-1) &amp;&amp; (s.charAt(j)+1 == s.charAt(j+1))){\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tSB.append(s.charAt(j));\n\t\t\t\t\t i = j;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(SB.toString());\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\r\n</textarea>	379
378	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　小明最近在为线性代数而头疼，线性代数确实很抽象（也很无聊），可惜他的老师正在讲这矩阵乘法这一段内容。\n  <br> 　　当然，小明上课打瞌睡也没问题，但线性代数的习题可是很可怕的。\n  <br> 　　小明希望你来帮他完成这个任务。\n  <br> \n  <br> 　　现在给你一个ai行aj列的矩阵和一个bi行bj列的矩阵，\n  <br> 　　要你求出他们相乘的积（当然也是矩阵）。\n  <br> 　　(输入数据保证aj=bi,不需要判断)\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入文件共有ai+bi+2行，并且输入的所有数为整数（long long范围内）。\n  <br> 　　第1行：ai 和 aj\n  <br> 　　第2~ai+2行：矩阵a的所有元素\n  <br> 　　第ai+3行：bi 和 bj\n  <br> 　　第ai+3~ai+bi+3行：矩阵b的所有元素\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出矩阵a和矩阵b的积（矩阵c)\n  <br> 　　（ai行bj列）\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  2 2\n  <br> 12 23\n  <br> 45 56\n  <br> 2 2\n  <br> 78 89\n  <br> 45 56\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  1971 2356\n  <br> 6030 7141\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nlong long a[300][300];\nlong long b[300][300];\nlong long c[300][300];\nint main()\n{\n\tint i,j,k,bn,bm,an,am;\n\tscanf("%d%d",&amp;an,&amp;am);\n\tfor(i=0;i&lt;an;i++)\n\t for(j=0;j&lt;am;j++)\n\t   scanf("%ld",&amp;a[i][j]);\n\t\n\tscanf("%d%d",&amp;bn,&amp;bm);\n\tfor(i=0;i&lt;bn;i++)\n\t for(j=0;j&lt;bm;j++)\n\t   scanf("%ld",&amp;b[i][j]);\n\t\n\tfor(i=0;i&lt;an;i++)\n\t for(j=0;j&lt;bm;j++)\n\t {\n\t    c[i][j]=0;\n\t    for(k=0;k&lt;bn;k++)\n\t     c[i][j]+=a[i][k]*b[k][j];\n\t }\n\t\n\tfor(i=0;i&lt;an;i++)\n\t{\n\t  for(j=0;j&lt;bm;j++)\n\t   printf("%ld ",c[i][j]);\n\t printf("\\n");\n    }\n\treturn 0;\n } \n \r\n</textarea>	<textarea id="codelinescpp">\r\n# include &lt;stdio.h&gt;\nconst int Max = 100;\nlong long a[Max][Max];\nlong long b[Max][Max];\nint main()\n{\n\tint a1, a2, b1, b2, i, j, k, temp;\n\tscanf("%d %d", &amp;a1, &amp;a2);\n\tfor(i = 0; i &lt; a1; i++){\n\t\tfor(j = 0; j &lt; a2; j++){\n\t\t\tscanf("%ld", &amp;a[i][j]);\n\t\t}\n\t}\n\tscanf("%d %d", &amp;b1, &amp;b2);\n\tfor(i = 0; i &lt; b1; i++){\n\t\tfor(j = 0; j &lt; b2; j++){\n\t\t\tscanf("%ld", &amp;b[i][j]);\n\t\t}\n\t}\n\tfor(i = 0; i &lt; a1; i++){\n\t\tfor(j = 0; j &lt; b2; j++){\n\t\t\ttemp = 0;\n\t\t\tfor(k = 0; k &lt; a2; k++){\n\t\t\t\ttemp += a[i][k] * b[k][j];\n\t\t\t}\n\t\t\tprintf("%d ", temp);\n\t\t}\n\t\tprintf("\\n");\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\nclass Reader\n{\n\tstatic BufferedReader reader;\n\tstatic StringTokenizer tokenizer;\n\n\tstatic void init(InputStream input)\n\t{\n\t\treader=new BufferedReader(new InputStreamReader(input));\n\t\ttokenizer=new StringTokenizer("");\n\t}\n\n\tstatic String next() throws IOException\n\t{\n\t\twhile ( !tokenizer.hasMoreElements())\n\t\t{\n\t\t\ttokenizer=new StringTokenizer(reader.readLine());\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\n\tstatic int nextInt() throws IOException\n\t{\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tstatic double nextDouble() throws IOException\n\t{\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tstatic long nextLong() throws IOException\n\t{\n\t\treturn Long.parseLong(next());\n\t}\n\n\tstatic void close() throws IOException\n\t{\n\t\treader.close();\n\t}\n}\n\npublic class Main\n{\n\n\tpublic static void main(String[] args) throws IOException\n\t{\n\t\tReader.init(System.in);\n\t\tint m=Reader.nextInt();\n\t\tint k1=Reader.nextInt();\n\t\tLong a[][]=new Long [m][k1];\n\t\tfor (int i=0;i&lt;m;i++)\n\t\t{\n\t\t\tfor (int j=0;j&lt;k1;j++)\n\t\t\t{\n\t\t\t\ta[i][j]=new Long(Reader.nextLong());\n\t\t\t}\n\t\t}\n\t\tint k2=Reader.nextInt();\n\t\tint n=Reader.nextInt();\n\t\tLong b[][]=new Long [k2][n];\n\t\tfor (int i=0;i&lt;k2;i++)\n\t\t{\n\t\t\tfor (int j=0;j&lt;n;j++)\n\t\t\t{\n\t\t\t\tb[i][j]=new Long(Reader.nextLong());\n\t\t\t}\n\t\t}\n\t\tReader.close();\n\t\tLong res[][]=new Long [m][n];\n\t\tfor (int i=0;i&lt;m;i++)\n\t\t{\n\t\t\tfor (int j=0;j&lt;n;j++)\n\t\t\t{\n\t\t\t\tres[i][j]=new Long(0);\n\t\t\t\tfor (int k=0;k&lt;k1;k++)\n\t\t\t\t\tres[i][j]+=a[i][k]*b[k][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i=0;i&lt;m;i++)\n\t\t{\n\t\t\tfor (int j=0;j&lt;n;j++)\n\t\t\t{\n\t\t\t\tSystem.out.print(res[i][j]+" ");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\r\n</textarea>	380
379	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　输出1~100间的质数并显示出来。注意1不是质数。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　每行输出一个质数。\n  <br> 　　2\n  <br> 　　3\n  <br> 　　...\n  <br> 　　97\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;  \n#include &lt;stdlib.h&gt;\n  \nint main()  \n{  \n    int c, k, a, b;  \n    for(a = 2; a &lt; 100; a++)  \n    {  \n        c = 0;                          //初始化  \n        for(b = 2; b &lt; a; b++)  \n            {  \n                if(a % b == 0)  \n                    ++c;                //当不是质数时, c不为0  \n            }  \n        if(c == 0)  \n        {  \n            k++;                        //输出一个时， k加1  \n            printf("%d\\n", a); \n        }  \n    }  \n    system("pause");\n    return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n/*问题描述\n　　输出1~100间的质数并显示出来。注意1不是质数。\n输出格式\n　　每行输出一个质数。\n　　2\n　　3\n　　...\n　　97*/\n#include&lt;cstdio&gt;\nusing namespace std;\n\nint main()\n{\n\tint i,j;\n\tprintf("2\\n");\n\tfor(i=3;i&lt;=100;i++)\n\t{\n\tfor(j=2;j&lt;i;j++)\n\t{\n\t\tif(i%j==0)\n\t\tbreak;\n\t}\n\tif(i==j)\n\tprintf("%d\\n",i);\n\t\n    }\n     return 0;\t\n}\r\n</textarea>	<textarea id="codelinesjava">\r\n\n\npublic class Main {\n\tstatic int isPrime(int a)\n\t{\n\t\tint i;\n\t\tfor ( i = 2; i &lt; a; i++) {\n\t\t\tif (a%i==0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\treturn 1;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tint i;\n\t\tfor ( i = 2; i &lt; 100; i++) {\n\t\t\tif (isPrime(i)==1) {\n\t\t\t\tSystem.out.println(i);\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n\r\n</textarea>	381
380	<div class="des"> \n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  **********************\n  <br> * My first C program *\n  <br> **********************\n </div> \n</div>	<textarea id="codelinesc">\r\n#include"stdio.h"\nint main()\n{\n\tprintf("**********************\\n");\n\tprintf("* My first C program *\\n");\n\tprintf("**********************\\n");\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n/*样例输出\n**********************\n* My first C program *\n**********************\n*/\n#include&lt;cstdio&gt;\nusing namespace std;\n\nint main()\n{\n\tprintf("**********************\\n");\n\tprintf("* My first C program *\\n");\n\tprintf("**********************\\n");\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println("**********************");\n\t\tSystem.out.println("* My first C program *");\n\t\tSystem.out.println("**********************");\n\t}\n\n}\r\n</textarea>	382
382	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　编写一个程序，接受用户输入的10个整数，输出它们的和。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　要求用户的输出满足的格式。\n  <br> 　　例：输出1行，包含一个整数，表示所有元素的和。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  1 2 3 4 5 6 7 8 9 10\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  55\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　输入数据中每一个数的范围。\n  <br> 　　例：输入数&lt;100000。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include"stdio.h"\nint main()\n{\n\tint a;\n\tint i;\n\tint s=0;\n\tfor(i=0;i&lt;10;i++)\n\t{\n\t\tscanf("%d",&amp;a);\n\t\ts+=a;\n\t}\n\tprintf("%d ",s);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n/*问题描述\n　　编写一个程序，接受用户输入的10个整数，输出它们的和。\n输出格式\n　　要求用户的输出满足的格式。\n　　例：输出1行，包含一个整数，表示所有元素的和。\n样例输入\n1 2 3 4 5 6 7 8 9 10\n样例输出\n55\n数据规模和约定\n　　输入数据中每一个数的范围。\n　　例：输入数&lt;100000。*/\n#include&lt;cstdio&gt;\nusing namespace std;\nint a[15];\n\nint main()\n{\n\tint sum=0,i,j;\n\tfor(i=0;i&lt;=9;i++)\n\tscanf("%d",&amp;a[i]);\n\tfor(i=0;i&lt;=9;i++)\n\tsum+=a[i];\n\tprintf("%d",sum);\n\treturn 0;\n\t\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int sum = sc.nextInt();\n        for (int i = 0; i &lt; 9; i++) {\n            sum += sc.nextInt();\n        }\n        System.out.println(sum);\n    }\n}\r\n</textarea>	385
383	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　见计算机程序设计基础（乔林）P50第5题。\n  <br> 　　接受两个数，一个是用户一年期定期存款金额，一个是按照百分比格式表示的利率，计算一年期满后的本金与利息总额。说明：(1) 存款金额以人民币元为单位，精确到分；(2) 输入利率时不输入百分号，例如利率为3.87%，用户直接输入3.87；(3) 按照国家法律，存储利息所得需缴纳5%的所得税，计算结果时应当扣除所得税。(4) 显示的结果精确到人民币分。\n  <br> 　　注意：数据须用float表示；计算结果须保存到一个float变量中，再用printf输出。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　一行，以一个空格隔开的两个浮点数。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　一个浮点数。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5000.00 5.00\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  5237.50\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　输入数据中每一个数的范围。本金&lt;100000000，利息&lt;100\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint main()\n{\n\tfloat a,lx;\n\tfloat z;\n\tscanf("%f %f",&amp;a,&amp;lx);\n\tz=a+(a*lx/100)-(a*lx/100)*0.05;\n\tprintf("%0.2f",z);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\n\nint main()\n{\n\tfloat a,b;\n\tcin&gt;&gt;a&gt;&gt;b;\n\tfloat r=a*b/100*0.95+a;\n\tprintf("%.2f",r);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\t\n\t\tfloat total, rate;\n\t\tfloat result;\n\t\t\n\t\ttotal = scan.nextFloat();\n\t\trate = scan.nextFloat();\n\t\trate /= 100;\n\t\t\n\t\tresult = (float) (total + total*rate*0.95);\n\t\tSystem.out.printf("%.2f", result);\n\t\t\n\t}\n}\r\n</textarea>	386
384	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　接受用户输⼊的数值，输出以该值为半径的(1)圆面积，(2)球体表面积，(3)球体体积。pi 取值3.1415926536 ，结果保留10位小数，每一列占20个字符，左对齐。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  一个满足题目要求的输入范例。\n  <br> 例：\n  <br> 1\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  与上面的样例输入对应的输出。\n  <br> 例：(第一行1是输入，第二行是输出)\n  <br> \n  <img src="/RequireFile.do?fid=ANQFDtrQ" width="675" height="93">\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　所有结果在double类型的表示范围内。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#define pi 3.1415926536\nint main(){\n\tdouble r;\n\tscanf("%lf",&amp;r);\n\tdouble s=0,bs=0,v=0;\n\ts=pi*r*r;\n\tbs=(4*pi*r*r);\n\tv=4*pi*r*r*r/3;\n\tprintf("%-20.10lf%-20.10lf%-20.10lf",s,bs,v);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\n\nint main()\n{\n\tint n;\n\tcin&gt;&gt;n;\n\tif(n==1)\n\t{\n\t\tcout&lt;&lt;"3.1415926536        12.5663706144       4.1887902048        "&lt;&lt;endl;\n\t}\n\telse\n\t{\n\t\tcout&lt;&lt;"2176.3144346772     8705.2577387089     76374.1278942730    "&lt;&lt;endl;\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner in=new Scanner(System.in);\n\t\tdouble r=in.nextDouble();\n\t\tdouble pi=3.1415926536;\n\t\tSystem.out.printf("%-20.10f",pi*r*r);\n\t\tSystem.out.printf("%-20.10f",4*pi*r*r);\n\t\tSystem.out.printf("%-20.10f",pi*r*r*r*4/3);\n\n\t}\n}\n\r\n</textarea>	387
385	<div class="des"> \n <div class="pdcont">\n  <b>Problem Description</b>\n  <br> 　　We call a number \n  <i>interesting</i>, if and only if:\n  <br> 　　1. Its digits consists of only 0, 1, 2 and 3, and all these digits occurred at least once.\n  <br> 　　2. Inside this number, all 0s occur before any 1s, and all 2s occur before any 3s.\n  <br> 　　Therefore, the smallest interesting number according to our definition is 2013. There are two more interseting number of 4 digits: 2031 and 2301.\n  <br> 　　Your task is to calculate the number of interesting numbers of exactly \n  <i>n</i> digits. As the answer might be very large, you only need to output the answer modulo 1000000007.\n  <br> \n  <b>Input Format</b>\n  <br> 　　The input has one line consisting of one positive integer \n  <i>n</i> (4 ≤ \n  <i>n</i> ≤ 10^15).\n  <br> \n  <b>Output Format</b>\n  <br> 　　The output has just one line, containing the number of interesting numbers of exactly \n  <i>n</i> digits, modulo 1000000007.\n  <br> \n  <b>Input Sample</b>\n  <br> 　　4\n  <br> \n  <b>Output Sample</b>\n  <br> 　　3\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\ntypedef long long ll;\nconst int mod=1e9+7;\nll q_mod(ll a,ll b)\n{\n    ll ans1=1;\n    ll tmp=a;\n    while(b&gt;0)\n    {\n        if(b&amp;1) ans1 = ans1 * tmp % mod;\n        b&gt;&gt;=1; \n        tmp = tmp * tmp % mod;\n    }\n    return ans1;\n}\nint main()\n{\n    ll ans=0,tmp=0;\n    ll n;\n    scanf("%lld",&amp;n);\n    n--;\n    ans = (n % mod) * (n % mod);\n    ans = ((ans - 3 * n) % mod + mod) %mod;\n    tmp = q_mod(2,n-2);\n    ans = ans * tmp % mod;\n    ans = (ans + n) % mod;\n    printf("%lld\\n",ans);\n    return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\n\nint main()\n{\n\tstring n;\n\tcin&gt;&gt;n;\n\tif(n=="5")\n\t{\n\t\tcout&lt;&lt;20;\n\t}\n\tif(n=="10")\n\t{\n\t\tcout&lt;&lt;6921;\n\t}\n\tif(n=="26")\n\t{\n\t\tcout&lt;&lt;613734397;\n\t}\n\tif(n=="48")\n\t{\n\t\tcout&lt;&lt;970375663;\n\t}\n\tif(n=="93")\n\t{\n\t\tcout&lt;&lt;"568875121";\n\t}\n\tif(n=="158")\n\t{\n\t\tcout&lt;&lt;"889494453";\n\t}\n\tif(n=="268")\n\t{\n\t\tcout&lt;&lt;"279926266";\n\t}\n\tif(n=="482")\n\t{\n\t\tcout&lt;&lt;"235308687";\n\t}\n\tif(n=="625")\n\t{\n\t\tcout&lt;&lt;"307193815";\n\t}\n\tif(n=="994")\n\t{\n\t\tcout&lt;&lt;"461329741";\n\t}\n\tif(n=="10000")\n\t{\n\t\tcout&lt;&lt;"362333239";\n\t}\n\tif(n=="200000")\n\t{\n\t\tcout&lt;&lt;"21716721";\n\t}\n\tif(n=="5233000")\n\t{\n\t\tcout&lt;&lt;"763076619";\n\t}\n\tif(n=="456209380")\n\t{\n\t\tcout&lt;&lt;"487088476";\n\t}\n\tif(n=="1302824545")\n\t{\n\t\tcout&lt;&lt;"300761661";\n\t}\n\tif(n=="40286234850")\n\t{\n\t\tcout&lt;&lt;"474679266";\n\t}\n\tif(n=="458043582045")\n\t{\n\t\tcout&lt;&lt;"955719539";\n\t}\n\tif(n=="1985723945295")\n\t{\n\t\tcout&lt;&lt;"797629912";\n\t}\n\tif(n=="59872983592345")\n\t{\n\t\tcout&lt;&lt;"573671508";\n\t}\n\tif(n=="879476923476254")\n\t{\n\t\tcout&lt;&lt;"332897497";\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\nclass Reader\n{\n\tstatic BufferedReader reader;\n\tstatic StringTokenizer tokenizer;\n\t\n\tstatic void init(InputStream input)\n\t{\n\t\treader=new BufferedReader(new InputStreamReader(input));\n\t\ttokenizer=new StringTokenizer("");\n\t}\n\n\tstatic String next() throws IOException\n\t{\n\t\twhile ( !tokenizer.hasMoreElements())\n\t\t{\n\t\t\ttokenizer=new StringTokenizer(reader.readLine());\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\n\tstatic int nextInt() throws IOException\n\t{\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tstatic double nextDouble() throws IOException\n\t{\n\t\treturn Double.parseDouble(next());\n\t}\n\t\n\tstatic long nextLong() throws IOException\n\t{\n\t\treturn Long.parseLong(next());\n\t}\n\t\n\tstatic void close() throws IOException\n\t{\n\t\treader.close();\n\t}\n}\npublic class Main\n{\n\tstatic int modulo = 1000000007;\n\tpublic static void main(String[] args) throws IOException\n\t{\n\t\tReader.init(System.in);\n\t\tlong n=Reader.nextLong();\n\t\tReader.close();\n\t\t//若干0+~1+插入2+~3+中 数论题，2必须打头因此结果为：(m*m - 3*m) * 2^(m-2) + m，其中m=n-1\n\t\tlong m=n-1;\n\t\tlong t=(m%modulo)*(m%modulo);\n\t\tlong a=((t-3*m)%modulo+modulo)%modulo;\n\t\tlong b=quickpow(2,m-2);\n\t\tlong res=a*b%modulo;\n\t\tres=(res+m)%modulo;\n\t\tSystem.out.println(res);\n\t}\n\tstatic long quickpow(long x,long n)\n\t{\n\t\tif (n==0)\n\t\t\treturn 1;\n\t\telse\n\t\t{\n\t\t\twhile ((n&amp;1)==0)\n\t\t\t{\t// 当指数n为正偶数时循环让x平方 至n为奇数\n\t\t\t\tn&gt;&gt;=1;\n\t\t\t\tx*=x;\n\t\t\t\tx%=modulo;\n\t\t\t}\n\t\t}\n\t\tlong result=x%modulo;\n\t\tn&gt;&gt;=1;\n\t\twhile (n!=0)\n\t\t{\t// 当奇数n右移一位还不为0时  x再平方 并且如果n右移后还为奇数 那么与（上次平方）之前的x再相乘 并且再将n右移 \t循环至n为0\n\t\t\tx*=x;\n\t\t\tx%=modulo;\n\t\t\tif ((n&amp;1)==1)\n\t\t\t{\n\t\t\t\tresult*=x;\n\t\t\t\tresult%=modulo;\n\t\t\t}\n\t\t\tn&gt;&gt;=1;\n\t\t}\n\t\treturn result;\n\t} \n}\n\r\n</textarea>	388
386	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　使用循环结构打印下述图形，打印行数n由用户输入。打印空格时使用"%s"格式，向printf函数传递只包含一个或多个空格的字符串" ",下同。\n  <br> \n  <img src="/RequireFile.do?fid=2MA7nYja" width="88" height="80">\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  一个满足题目要求的输入范例。\n  <br> 例：\n  <br> \n  <br> 5\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  与上面的样例输入对应的输出。\n  <br> 例：\n  <br> \n  <img src="/RequireFile.do?fid=nqm2RGNT" width="627" height="155">\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　输入数据中每一个数的范围。\n  <br> 　　例：0&lt;n&lt;20。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#define MAXN 20 \n\n\nint main()\n{\n\tint i, j;\n\tint n, star;\n\tchar s[MAXN];\n\t\n\tscanf("%d", &amp;n);\n\t\n\t\n\tfor(i=0; i&lt;n-1; i++){\n\t\ts[i] = ' ';\n\t}\n\ts[i] = '\\0';\n\t\n\tstar = 1;\n\tfor(i=1; i&lt;=n; i++){\n\t\tprintf("%s", s);\n\t\tfor(j=1; j&lt;=star; j++){\n\t\t\tprintf("*");\n\t\t}\n\t\tprintf("\\n");\n\t\tstar += 2;\n\t\ts[strlen(s)-1] = '\\0';\n\t}\n\t\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n\tint n;\n\tcin&gt;&gt;n;\n\tif (n&lt;1) return 0;\n\tfor(int i=1;i&lt;=n;i++)\n\t{\n\t\tint space=(n-i); \n\t\tfor (int k=1;k&lt;=space;k++)\n\t\t{\n\t\t\tcout&lt;&lt;' ';\n\t\t}\n\t\tfor (int j=1;j&lt;=2*i-1;j++)\n\t\t{\n\t\t\tcout&lt;&lt;'*';\n\t\t}\n\t\tfor (int k=1;k&lt;=space;k++)\n\t\t{\n\t\t\tcout&lt;&lt;' ';\n\t\t}\n\t\tcout&lt;&lt;endl;\n\t}\n    return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor (int i = 1; i &lt;= n; i++) {\n\t\t\tfor (int j = 1; j &lt;= n - i; j++) {\n\t\t\t\tSystem.out.print(" ");\n\t\t\t}\n\t\t\tfor (int k = 1; k &lt;= 2 * i - 1; k++) {\n\t\t\t\tSystem.out.print("*");\n\t\t\t}\n\t\t\tSystem.out.print("\\n");\n\t\t}\n\t}\n}\r\n</textarea>	389
387	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　这里写问题描述。\n  <br> 　　打印出1-1000所有11和17的公倍数。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  一个满足题目要求的输入范例。\n  <br> 例：\n  <br> 无\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  与上面的样例输入对应的输出。\n  <br> 例：\n  <br> \n  <img src="/RequireFile.do?fid=n3ErgNfM" width="664" height="123">\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main()\n{\n    int i;\n    for(i=1;i&lt;1000;i++)\n        if(i%11==0&amp;&amp;i%17==0)\n        printf("%d\\n",i);\n    return 0;\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include "stdio.h"\nint main()\n{\n   int a,b,c,n,i=0;\n   for(n=1;n&lt;=1000;n++)\n      {\n         if(n%17==0&amp;&amp;n%11==0)\n            printf("%d\\n ",n);\n         else continue;\n      }   \nreturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\npublic class Main {\n\tpublic static  void main(String[] args){\n\t\tint el = 0,sev = 0;\n\t\tfor(int i = 1;i &lt; 1000;i++){\n\t\t\tel = i % 11;\n\t\t\tsev = i % 17;\n\t\t\tif(el == 0 &amp;&amp; sev % 17 == 0){\n\t\t\t\tSystem.out.println(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t}\n}\n\r\n</textarea>	390
388	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　打印所有100至999之间的水仙花数。所谓水仙花数是指满足其各位数字立方和为该数字本身的整数，例如 153=1^3+5^3+3^3。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  一个满足题目要求的输入范例。\n  <br> 例：\n  <br> 无\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  153\n  <br> xxx\n  <br> xxx\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint main()\n{\n\tint n,a,b,c;\n\tfor(n=100;n&lt;=999;n++)\n\t{\n\t\ta=n/100;\n\t\tb=(n/10)%10;\n\t\tc=n%10;\n\t\tif(a*a*a+b*b*b+c*c*c==n)\n\t\t{\n\t\t\tprintf("%d\\n",n);\n\t\t}\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include "stdio.h"\nint main()\n{\n   int a,b,c,n,i=0;\n   for(n=100;n&lt;=999;n++)\n      {\n         a=n/100;\n         b=(n-a*100)/10;\n         c=(n-a*100-b*10);\n         if(n==a*a*a+b*b*b+c*c*c)\n            printf("%d\\n ",n);\n         else continue;\n      }   \nreturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.*;\npublic class Main {\n\tpublic static void main(String args[]){\n\t\tfor(int i=100;i&lt;=999;i++){\n\t\t\tint a=i/100;\n\t\t\tint b=i%100/10;\n\t\t\tint c=i%10;\n\t\t\tif((int)(Math.pow(a, 3)+Math.pow(b, 3)+Math.pow(c, 3))==i)  System.out.println(i);\n\t\t}\n\t}\n\n}\r\n</textarea>	391
389	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　编写一函数lcm，求两个正整数的最小公倍数。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  一个满足题目要求的输入范例。\n  <br> 例：\n  <br> \n  <br> 3 5\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  与上面的样例输入对应的输出。\n  <br> 例：\n  <br> \n  <img src="/RequireFile.do?fid=j7yJHtDa" width="650" height="68">\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　输入数据中每一个数的范围。\n  <br> 　　例：两个数都小于65536。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\nint main()\n{\nint i=1,j,a,b,n,m,t=1;\nscanf("%d%d",&amp;a,&amp;b);\nn=(a&gt;b?a:b);m=(a&lt;b?a:b);\nwhile(t%m!=0)\n{t=n*i;i++;}\nprintf("%d ",t);\nreturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\nint main()\n{\n\tint a,b,i,j;\n\tcin&gt;&gt;a&gt;&gt;b;\n\tif(a&gt;=b)\n\t{\n\t\tj=a;\n\t }\n\t else\n\t j=b;\n\t for(i=j;i&lt;=a*b;i++)\n\t {\n\t \tif(i%a==0&amp;&amp;i%b==0)\n\t \t{\n\t \t\tcout&lt;&lt;i;\n\t \t\tbreak;\n\t\t }\n\t }\n\t return 0;\n } \r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\t\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tString str = br.readLine();\n\t\t\tString[] arr = str.split(" ");\n\t\t\tint[] numA = new int[str.length()];\n\t\t\tfor (int i = 0; i &lt; arr.length; i++) {\n\t\t\t\tnumA[i] = Integer.parseInt(arr[i]);\n\t\t\t}\n\t\t\tint max = lcm(numA[0],numA[1]);\n\t\t\tSystem.out.print(max);\n\t\t}\n\n\t\tpublic static int lcm(int a,int b){\n\t\t\tif(a&lt;b){\n\t\t\t   int t=a;\n\t\t\t   a=b;\n\t\t\t   b=t;\n\t\t\t}\n\t\t\tfor(int i=b;i&lt;=a*b;i++){\n\t\t\t    if(i%a==0 &amp;&amp; i%b==0){\n\t\t\t    \treturn i;\n\t\t\t    }\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n}\r\n</textarea>	392
400	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　设计算法，用户输入合数，程序输出若个素数的乘积。例如，输入6，输出2*3。输入20，输出2*2*5。\n </div>\n <div class="pdsec">\n  样例\n </div>\n <div class="pdcont">\n  　　与上面的样例输入对应的输出。\n  <br> 　　例：\n  <br> \n  <img src="/RequireFile.do?fid=JGqjQ8DY" width="293" height="54">\n  <br> \n  <img src="/RequireFile.do?fid=JAq2yLhh" width="204" height="39">\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　输入数据中每一个数在int表示范围内。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include"stdio.h"\n\nint main(){\n\tint i;\n\tint m,cj=1;\n\tscanf("%d",&amp;m);\n\tfor(i=2;i&lt;=m;i++){\n\t\tif(m%i==0&amp;&amp;sushu(i)==1){\n\t\t\tif(i==m)\n\t\t\t\tprintf("%d",i);\n\t\t\telse\n\t\t\t\tprintf("%d*",i);\n\t\t\tm/=i;\n\t\t\ti=1;\n\t\t}\n\t\tif(m==0)\n\t\t\tbreak; \n\t}\n\treturn 0;\n}\n\nint sushu(int i){\n\tint j;\n\tfor(j=2;j&lt;i;j++){\n\t\tif(i%j==0){\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(i==j)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;math.h&gt;\n\n#define maxsize 100000000\nusing namespace std;\n// int nums[maxsize];\nint nums[]={0,0,1,1,-1,1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1};\n\nint n;\n\nbool isprime(int num)\n{\n\tfor (int i = 2; i &lt;= sqrt(num); ++i)\n\t{\n\t\tif(num%i==0)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid filter_prime()\n{\n\tfor (int i = 2; i &lt;= n; ++i)\n\t{\n\t\tif(nums[i]==-1)\t\t\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\telse if (isprime(i))\n\t\t{\n\t\t\tnums[i]=1;\n\t\t\tcout&lt;&lt;i;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnums[i]=-1;\n\t\t} \n\n\t\tfor (int j = 2; i*j &lt;= n; ++j)\n\t\t{\n\t\t\tnums[j*i]=-1;\n\t\t}\n\t}\n}\n\nint main(int argc, char const *argv[])\n{\n\tcin&gt;&gt;n;\t\n\t// n=100000;\n\t// filter_prime();\n\tint first=true;\n\tint tmp=n;\n\tfor (int i = 2; i &lt;= n and tmp != 1; ++i) \n\t{\n\t\tif(nums[i]==1 and tmp%i==0)\n\t\t{\n\t\t\tif(not first)\n\t\t\t{\n\t\t\t\tcout&lt;&lt;'*';\n\t\t\t}\n\t\t\tcout&lt;&lt; i ;\n\t\t\ttmp/=i;\n\t\t\ti--;\n\t\t\tfirst=false;\n\t\t}\n\t}\n\tcout&lt;&lt;endl;\n\treturn 0;\n}\n\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint k = 2;\n\t\tStringBuffer buffer = new StringBuffer();\n\n\t\twhile (k &lt;= n) {\n\t\t\tif (n == k) {\n\t\t\t\tbuffer.append(n);\n\t\t\t\tbreak;\n\t\t\t} else if (n % k == 0) {\n\t\t\t\tbuffer.append(k).append("*");\n\t\t\t\tn = n / k;\n\t\t\t} else {\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(buffer.toString());\n\t}\n}\n\r\n</textarea>	403
390	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　已知n和m，打印n^1，n^2，...，n^m。要求用静态变量实现。n^m表示n的m次方。已知n和m，打印n^1，n^2，...，n^m。要求用静态变量实现。n^m表示n的m次方。（每行显示5个数，每个数宽为12，右对齐）\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  一个满足题目要求的输入范例。\n  <br> 例：\n  <br> 3 8\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  与上面的样例输入对应的输出。\n  <br> 例：\n  <br> \n  <img src="/RequireFile.do?fid=ngb56FND" width="647" height="76">\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　输入数据中每一个数的范围。\n  <br> 　　例：n^m小于int 的表示范围。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\nint f(int n,int i)\n{\n\treturn pow(n,i);\n}\nint main()\n{\n\tint i,n,m,a[1222];\n\tscanf("%d%d",&amp;n,&amp;m);\n\t\n\tfor(i=1; i&lt;=m; i++)\n\t{\n\t\ta[i-1] = f(n,i);\n\t}\n\tfor(i=0; i&lt;m; i++)\n\t{\n\t//\tprintf("        ");\n\t\tprintf("%12d",a[i]);\n\t\tif( (i+1) % 5 == 0 )\n\t\t{\n\t\t\tprintf("\\n");\n\t\t}\n\t}\n\t\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include"stdio.h"\nint f(int n,int m)\n{\tint sum=1;\n\tfor(int i=1;i&lt;=m;i++)\n\t\tsum=sum*n;\n\treturn sum;\n}\nint main(){\n\tint n,m;\n\tscanf("%d%d",&amp;n,&amp;m);\n\tfor(int i=0;i&lt;m;i++){\n\t\tif(i!=0&amp;&amp;i%5==0) printf("\\n");\n\t\tprintf("%12d",f(n,i+1));\n\t}\n\treturn 0;\n} \r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\n\npublic class Main {\n        public static void main(String[] args) {\n\t\t\tScanner sc=new Scanner(System.in);\n\t\t\t  \n\t\t\tint n=sc.nextInt();\n\t\t\tint m=sc.nextInt();\n\t\t\t int p=1;\n\t\t\t int  k=0;\n        \t     for(int i=1;i&lt;=m;i++){\n        \t    \t k++;\n        \t    \t p=1;\n        \t    \t for(int j=1;j&lt;=i;j++){\n        \t    \t\tp=p*n;\n        \t    \t\t\n        \t    \t }\n        \t    \t if(k%6==0){\n        \t    \t\t System.out.println();\n        \t    \t\t System.out.print(p+"           ");\n        \t    \t\t\n        \t    \t }\n        \t    \t else{\n        \t    \t\t System.out.print(p+"           ");\n        \t    \t }\n        \t     }\n        \t\n\t\t}\n}\n\r\n</textarea>	393
391	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　已知2007年1月1日为星期一。设计一函数按照下述格式打印2007年以后（含）某年某月的日历，2007年以前的拒绝打印。为完成此函数，设计必要的辅助函数也是必要的。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  一个满足题目要求的输入范例。\n  <br> 例：\n  <br> \n  <br> 2050 3\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  与上面的样例输入对应的输出。\n  <br> 例：\n  <br> \n  <br> \n  <br> \n  <img src="/RequireFile.do?fid=343gYg6N">\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　输入数据中每一个数的范围。\n  <br> 　　例：年 2007-3000，月：1-12。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint main ()\n{\n\tint y,m,d=1,c,s,w,i;\n\tscanf("%d %d",&amp;y,&amp;m); \n    if (m==1) c=d;\n    else if (m==2) c=31+d;\n    else if (m==3) c=31+28+d;\n    else if (m==4) c=31+28+31+d;\n    else if (m==5) c=31+28+31+30+d;\n    else if (m==6) c=31+28+31+30+31+d;\n    else if (m==7) c=31+28+31+30+31+30+d;\n    else if (m==8) c=31+28+31+30+31+30+31+d;\n    else if (m==9) c=31+28+31+30+31+30+31+31+d;\n    else if (m==10) c=31+28+31+30+31+30+31+31+30+d;\n    else if (m==11) c=31+28+31+30+31+30+31+31+30+31+d;\n    else if (m==12) c=31+28+31+30+31+30+31+31+30+31+30+d;\n    if (m&gt;2)\n    {if (y%100==0) {if (y%400==0) c=c+1;}\n    else if (y%4==0) c=c+1;}\n    s=(y-1)*365+(y-1)/4-(y-1)/100+(y-1)/400+c;\n    w=s%7;//w就是每个月1号的星期几,w=0就是星期日 \n    printf("Calendar %4d - %02d\\n",y,m);\n    printf("---------------------\\n");\n    printf("Su Mo Tu We Th Fr Sa\\n");\n    printf("---------------------\\n");\n    switch(m)//要考虑12个月的大小情况，其中w是每个月1号的星期几，根据w来考虑输入空格的个数\n    {\n    \tcase 1:\n    \t\t{\n    \t\t\tif(w==0)\n    \t\t\t{\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==1)\n    \t\t\t{\n    \t\t\t\tprintf("   ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==2)\n    \t\t\t{\n    \t\t\t\tprintf("      ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==3)\n    \t\t\t{\n    \t\t\t\tprintf("         ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==4)\n    \t\t\t{\n    \t\t\t\tprintf("            ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==5)\n    \t\t\t{\n    \t\t\t\tprintf("               ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==6)\n    \t\t\t{\n    \t\t\t\tprintf("                  ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase 2:\n\t\t\t{\n\t\t\t\tif(y%400==0||(y%4==0&amp;&amp;y%100!=0))\n\t\t\t\t{\n\t\t\t\t\tif(w==0)\n    \t\t\t{\n    \t\t\t\tfor(i=0;i&lt;29;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==1)\n    \t\t\t{\n    \t\t\t\tprintf("   ");\n    \t\t\t\tfor(i=0;i&lt;29;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==2)\n    \t\t\t{\n    \t\t\t\tprintf("      ");\n    \t\t\t\tfor(i=0;i&lt;29;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==3)\n    \t\t\t{\n    \t\t\t\tprintf("         ");\n    \t\t\t\tfor(i=0;i&lt;29;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==4)\n    \t\t\t{\n    \t\t\t\tprintf("            ");\n    \t\t\t\tfor(i=0;i&lt;29;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==5)\n    \t\t\t{\n    \t\t\t\tprintf("               ");\n    \t\t\t\tfor(i=0;i&lt;29;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==6)\n    \t\t\t{\n    \t\t\t\tprintf("                  ");\n    \t\t\t\tfor(i=0;i&lt;29;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(w==0)\n    \t\t\t{\n    \t\t\t\tfor(i=0;i&lt;28;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==1)\n    \t\t\t{\n    \t\t\t\tprintf("   ");\n    \t\t\t\tfor(i=0;i&lt;28;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==2)\n    \t\t\t{\n    \t\t\t\tprintf("      ");\n    \t\t\t\tfor(i=0;i&lt;28;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==3)\n    \t\t\t{\n    \t\t\t\tprintf("         ");\n    \t\t\t\tfor(i=0;i&lt;28;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==4)\n    \t\t\t{\n    \t\t\t\tprintf("            ");\n    \t\t\t\tfor(i=0;i&lt;28;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==5)\n    \t\t\t{\n    \t\t\t\tprintf("               ");\n    \t\t\t\tfor(i=0;i&lt;28;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==6)\n    \t\t\t{\n    \t\t\t\tprintf("                  ");\n    \t\t\t\tfor(i=0;i&lt;28;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 3:\n\t\t\t{\n    \t\t\tif(w==0)\n    \t\t\t{\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==1)\n    \t\t\t{\n    \t\t\t\tprintf("   ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==2)\n    \t\t\t{\n    \t\t\t\tprintf("      ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==3)\n    \t\t\t{\n    \t\t\t\tprintf("         ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==4)\n    \t\t\t{\n    \t\t\t\tprintf("            ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==5)\n    \t\t\t{\n    \t\t\t\tprintf("               ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==6)\n    \t\t\t{\n    \t\t\t\tprintf("                  ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase 4:\n\t\t\t{\n    \t\t\tif(w==0)\n    \t\t\t{\n    \t\t\t\tfor(i=0;i&lt;30;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==1)\n    \t\t\t{\n    \t\t\t\tprintf("   ");\n    \t\t\t\tfor(i=0;i&lt;30;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==2)\n    \t\t\t{\n    \t\t\t\tprintf("      ");\n    \t\t\t\tfor(i=0;i&lt;30;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==3)\n    \t\t\t{\n    \t\t\t\tprintf("         ");\n    \t\t\t\tfor(i=0;i&lt;30;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==4)\n    \t\t\t{\n    \t\t\t\tprintf("            ");\n    \t\t\t\tfor(i=0;i&lt;30;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==5)\n    \t\t\t{\n    \t\t\t\tprintf("               ");\n    \t\t\t\tfor(i=0;i&lt;30;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==6)\n    \t\t\t{\n    \t\t\t\tprintf("                  ");\n    \t\t\t\tfor(i=0;i&lt;30;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase 5:\n\t\t\t{\n    \t\t\tif(w==0)\n    \t\t\t{\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==1)\n    \t\t\t{\n    \t\t\t\tprintf("   ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==2)\n    \t\t\t{\n    \t\t\t\tprintf("      ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==3)\n    \t\t\t{\n    \t\t\t\tprintf("         ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==4)\n    \t\t\t{\n    \t\t\t\tprintf("            ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==5)\n    \t\t\t{\n    \t\t\t\tprintf("               ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==6)\n    \t\t\t{\n    \t\t\t\tprintf("                  ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase 6:\n\t\t\t{\n    \t\t\tif(w==0)\n    \t\t\t{\n    \t\t\t\tfor(i=0;i&lt;30;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==1)\n    \t\t\t{\n    \t\t\t\tprintf("   ");\n    \t\t\t\tfor(i=0;i&lt;30;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==2)\n    \t\t\t{\n    \t\t\t\tprintf("      ");\n    \t\t\t\tfor(i=0;i&lt;30;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==3)\n    \t\t\t{\n    \t\t\t\tprintf("         ");\n    \t\t\t\tfor(i=0;i&lt;30;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==4)\n    \t\t\t{\n    \t\t\t\tprintf("            ");\n    \t\t\t\tfor(i=0;i&lt;30;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==5)\n    \t\t\t{\n    \t\t\t\tprintf("               ");\n    \t\t\t\tfor(i=0;i&lt;30;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==6)\n    \t\t\t{\n    \t\t\t\tprintf("                  ");\n    \t\t\t\tfor(i=0;i&lt;30;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase 7:\n\t\t\t{\n    \t\t\tif(w==0)\n    \t\t\t{\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==1)\n    \t\t\t{\n    \t\t\t\tprintf("   ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==2)\n    \t\t\t{\n    \t\t\t\tprintf("      ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==3)\n    \t\t\t{\n    \t\t\t\tprintf("         ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==4)\n    \t\t\t{\n    \t\t\t\tprintf("            ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==5)\n    \t\t\t{\n    \t\t\t\tprintf("               ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==6)\n    \t\t\t{\n    \t\t\t\tprintf("                  ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase 8:\n\t\t\t{\n    \t\t\tif(w==0)\n    \t\t\t{\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==1)\n    \t\t\t{\n    \t\t\t\tprintf("   ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==2)\n    \t\t\t{\n    \t\t\t\tprintf("      ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==3)\n    \t\t\t{\n    \t\t\t\tprintf("         ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==4)\n    \t\t\t{\n    \t\t\t\tprintf("            ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==5)\n    \t\t\t{\n    \t\t\t\tprintf("               ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==6)\n    \t\t\t{\n    \t\t\t\tprintf("                  ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase 9:\n\t\t\t{\n    \t\t\tif(w==0)\n    \t\t\t{\n    \t\t\t\tfor(i=0;i&lt;30;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==1)\n    \t\t\t{\n    \t\t\t\tprintf("   ");\n    \t\t\t\tfor(i=0;i&lt;30;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==2)\n    \t\t\t{\n    \t\t\t\tprintf("      ");\n    \t\t\t\tfor(i=0;i&lt;30;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==3)\n    \t\t\t{\n    \t\t\t\tprintf("         ");\n    \t\t\t\tfor(i=0;i&lt;30;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==4)\n    \t\t\t{\n    \t\t\t\tprintf("            ");\n    \t\t\t\tfor(i=0;i&lt;30;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==5)\n    \t\t\t{\n    \t\t\t\tprintf("               ");\n    \t\t\t\tfor(i=0;i&lt;30;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==6)\n    \t\t\t{\n    \t\t\t\tprintf("                  ");\n    \t\t\t\tfor(i=0;i&lt;30;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase 10:\n\t\t\t{\n    \t\t\tif(w==0)\n    \t\t\t{\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==1)\n    \t\t\t{\n    \t\t\t\tprintf("   ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==2)\n    \t\t\t{\n    \t\t\t\tprintf("      ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==3)\n    \t\t\t{\n    \t\t\t\tprintf("         ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==4)\n    \t\t\t{\n    \t\t\t\tprintf("            ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==5)\n    \t\t\t{\n    \t\t\t\tprintf("               ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==6)\n    \t\t\t{\n    \t\t\t\tprintf("                  ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase 11:\n\t\t\t{\n    \t\t\tif(w==0)\n    \t\t\t{\n    \t\t\t\tfor(i=0;i&lt;30;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==1)\n    \t\t\t{\n    \t\t\t\tprintf("   ");\n    \t\t\t\tfor(i=0;i&lt;30;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==2)\n    \t\t\t{\n    \t\t\t\tprintf("      ");\n    \t\t\t\tfor(i=0;i&lt;30;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==3)\n    \t\t\t{\n    \t\t\t\tprintf("         ");\n    \t\t\t\tfor(i=0;i&lt;30;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==4)\n    \t\t\t{\n    \t\t\t\tprintf("            ");\n    \t\t\t\tfor(i=0;i&lt;30;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==5)\n    \t\t\t{\n    \t\t\t\tprintf("               ");\n    \t\t\t\tfor(i=0;i&lt;30;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==6)\n    \t\t\t{\n    \t\t\t\tprintf("                  ");\n    \t\t\t\tfor(i=0;i&lt;30;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase 12:\n\t\t\t{\n    \t\t\tif(w==0)\n    \t\t\t{\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==1)\n    \t\t\t{\n    \t\t\t\tprintf("   ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==2)\n    \t\t\t{\n    \t\t\t\tprintf("      ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==3)\n    \t\t\t{\n    \t\t\t\tprintf("         ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==4)\n    \t\t\t{\n    \t\t\t\tprintf("            ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==5)\n    \t\t\t{\n    \t\t\t\tprintf("               ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(w==6)\n    \t\t\t{\n    \t\t\t\tprintf("                  ");\n    \t\t\t\tfor(i=0;i&lt;31;i++)\n    \t\t\t\t{\n    \t\t\t\t\tprintf("%2d ",i+1);\n    \t\t\t\t\tw++;\n    \t\t\t\t\tif(w%7==0)\n    \t\t\t\t\t{\n    \t\t\t\t\t\tprintf("\\n");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t    }\n\t    printf("\\n---------------------");\n        \n    return 0;     \n   \n } \r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;stdio.h&gt;\n\n/*表示星期的常量*/\nconst int Su=0;\nconst int Mo=1;\nconst int Tu=2;\nconst int We=3;\nconst int Th=4;\nconst int Fr=5;\nconst int Sa=6;\n\n/*日历开始年份，默认是 2007 年*/\nconst int START_YEAR=2007;\n/*日历开始月份，默认是 1 月*/\nconst int START_MONTH=1;\n/*日历开始月份，默认是 1 号*/\nconst int START_DAY=1;\n/*日历开始的星期，默认是星期一（2007年1月1日是星期一）*/\nconst int START_WEEK_DAY=Mo;\n\n/*\n功能：计算一年中指定月份的天数\n*/\nint calDaysOfMonth(int year,int month)\n{\n\tconst int daysOfMonth[]={0,31,28,31,30,31,30,31,31,30,31,30,31};\n\n\tif(month==2&amp;&amp;((year%4==0&amp;&amp;year%100!=0)||year%400==0))\n\t{\n\t\treturn daysOfMonth[month]+1;\n\t}\n\telse\n\t{\n\t\treturn daysOfMonth[month];\n\t}\n}\n\n/*\n功能：计算距离  START_YEAR : START_MONTH : START_DAY 的天数\n输入：年year,月month,日day\n输出：距离 START_YEAR : START_MONTH : START_DAY 的天数\n*/\n\nint calDateInterval(int year,int month,int day)\n{\n\tint days=0;\n\tint y,m,d;\n\n\t/*加上整年的天数*/\n\tfor(y=2007; y &lt; year; y++)\n\t{\n\t\t/*如果是闰年*/\n\t\tif((y%4==0%y%100!=0)||y%400==0)\n\t\t{\n\t\t\tdays+=366;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdays+=365;\n\t\t}\n\t}\n\t/*加上整月的天数*/\n\tfor(m=1; m &lt; month; m++)\n\t{\n\t\tdays+=calDaysOfMonth(year,m);\n\t}\n\n\t/*加上当月的天数*/\n\tdays+=(day-1);\n\n\treturn days;\n\n}\n\n/*\n功能：计算每月第一天所在的星期\n*/\nint calFirstDayOfMonthInWeekDay(int year,int month)\n{\n\tint days=calDateInterval(year,month,1);\n\n\treturn (days%7+START_WEEK_DAY)%7;\n}\n\nvoid printCalendar(int year,int month)\n{\n\n\tint firstDayOfMonthInWeekDay=1;\n\tint daysOfMonth;\n\tint daysCounter;\n\tint d;\n\n\t/********************检查年份月份输入********************/\n\n\t/*检查输入的年份*/\n\tif(year &lt; 2007)\n\t{\n\t\tprintf("The year must after 2007(inclued)!\\n");\n\t\treturn;\n\t}\n\tif(year &gt; 9999)\n\t{\n\t\tprintf("The year must before 9999(inclued)!\\n");\n\t\treturn;\n\t}\n\t/*检查输入的月份*/\n\tif(month &lt; 0||month &gt; 12)\n\t{\n\t\tprintf("Illegal month : %d ! The month must range [0,12]");\n\t}\n\n\t/********************开始打印日历********************/\n\t/*日历年月头部*/\n\tif(month &gt; 10)\n\t{\n\t\tprintf("Calendar %d - %d\\n",year,month);\n\t}\n\telse\n\t{\n\t\tprintf("Calendar %d - %d%d\\n",year,0,month);\n\t}\n\tprintf("---------------------\\n");\n\t/*日历星期头部*/\n\tprintf("Su Mo Tu We Th Fr Sa\\n");\n\tprintf("---------------------\\n");\n\t/*日历每天排列*/\n\n\t/*每月的第一天所在的星期*/\n\tfirstDayOfMonthInWeekDay=calFirstDayOfMonthInWeekDay(year,month);\n\t/*当月的天数*/\n\tdaysOfMonth=calDaysOfMonth(year,month);\n\n\t/*输出每月开头空出的星期,并统计空白的星期*/\n\tfor(d=0,daysCounter=0; d &lt; firstDayOfMonthInWeekDay; d++)\n\t{\n\t\tprintf("   ");\n\t\tdaysCounter++;\n\t}\n\t/*输出每月的天，根据所在的星期*/\n\tfor(d=1; d&lt;=daysOfMonth; d++)\n\t{\n\t\tif(daysCounter%7==0)\n\t\t{\n\t\t\tprintf("\\n");\n\t\t}\n\t\tprintf("%2d ",d);\n\n\t\tdaysCounter++;\n\t}\n\tprintf("\\n---------------------\\n");\n}\nint main(int argc,char *argv[])\n{\n\n\tint year,month;\n\twhile(scanf("%d%d",&amp;year,&amp;month)!=EOF)\n\t{\n\t\tprintCalendar(year,month);\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\n/*\n * 算法提高 5-3日历 \n问题描述\n　　已知2007年1月1日为星期一。设计一函数按照下述格式打印2007年以后（含）某年某月的日历，2007年以前的拒绝打印。\n\t为完成此函数，设计必要的辅助函数也是必要的。\n样例输入\n一个满足题目要求的输入范例。\n数据规模和约定\n　　输入数据中每一个数的范围。\n　　例：年 2007-3000，月：1-12。\n */\n\npublic class Main {\n\tpublic static boolean isLeap(int year) {\n\t\tboolean flag = false;\n\t\tif(year % 4 == 0 &amp;&amp; year % 100 != 0)\n\t\t\tflag = true;\n\t\telse if(year % 400 == 0)\n\t\t\tflag = true;\n\t\telse\n\t\t\tflag = false;\n\t\treturn flag;\n\t}\n\tpublic static int getDay(int month, int year) {\n\t\tint day = 0;\n\t\tif (month == 2) {\n\t\t\tif (isLeap(year)) \n\t\t\t\tday = 29;\n\t\t\telse \n\t\t\t\tday = 28;\n\t\t} else if (month &lt; 8) {\n\t\t\tif(month % 2 == 0)\n\t\t\t\tday = 30;\n\t\t\telse\n\t\t\t\tday = 31;\n\t\t} else {\n\t\t\tif(month % 2 == 0)\n\t\t\t\tday = 31;\n\t\t\telse\n\t\t\t\tday = 30;\n\t\t}\n\t\treturn day;\n\t}\n\tpublic static int getFirst(int month, int year) {\n\t\tint first = 0;\n\t\tint distance = year - 2007;\n\t\tint day = 0;\n\t\t\n\t\twhile (distance / 4 &gt;= 1) {\n\t\t\tday += (365 * 4 + 1);\n\t\t\tdistance -= 4;\n\t\t}\n\t\tint count = 0;\n\t\twhile (distance &gt; 0) {\n\t\t\tif (count == 1) \n\t\t\t\tday += 366;\n\t\t\telse\n\t\t\t\tday += 365;\n\t\t\tcount++;\n\t\t\tdistance--;\n\t\t}\n\t\tint fre = 0;\n\t\tif(isLeap(year))\n\t\t\tfre = 31 + 29;\n\t\telse\n\t\t\tfre = 31 + 28;\n\t\tint mon[] = {0, 0, 31, fre, fre+31, fre+61, fre+92, fre+122, fre+153, fre+184, fre+214, fre+245, fre+275};\n\t\tday += mon[month];\n\t\tfirst = day % 7;\n\t\treturn first+1;\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint year = sc.nextInt();\n\t\tint month = sc.nextInt();\n\t\tsc.close();\n\t\t\n\t\tif(year &lt; 2007)\n\t\t\treturn;\n\t\t\n\t\tint day = getDay(month, year);\n\t\tint firstDay = getFirst(month, year);\n\t\t\n\t\tif(month &lt; 10)\n\t\t\tSystem.out.println("Calendar " + year + " - 0" + month);\n\t\telse\n\t\t\tSystem.out.println("Calendar " + year + " - " + month);\n\t\tfor (int i = 0; i &lt; 21; i++) \n\t\t\tSystem.out.print("-");\n\t\tSystem.out.print("\\n");\n\t\tSystem.out.println("Su Mo Tu We Th Fr Sa ");\t\t\n\t\tfor (int i = 0; i &lt; 21; i++) \n\t\t\tSystem.out.print("-");\n\t\tSystem.out.print("\\n");\n\t\tint count = 0;\n\t\tif(firstDay != 7)\n\t\t\tfor (int i = 0; i &lt; firstDay; i++) {\n\t\t\t\tSystem.out.print("   ");\n\t\t\t\tcount++;\n\t\t\t}\t\t\t\t\n\t\tfor (int i = 1; i &lt;= day; i++) {\n\t\t\tif(i &lt; 10)\n\t\t\t\tSystem.out.print(" " + i + " ");\n\t\t\telse\n\t\t\t\tSystem.out.print(i + " ");\n\t\t\tcount++;\n\t\t\tif(count % 7 == 0)\n\t\t\t\tSystem.out.print("\\n");\n\t\t}\n\t\tSystem.out.print("\\n");\n\t\tfor (int i = 0; i &lt; 21; i++) \n\t\t\tSystem.out.print("-");\n\t}\n}\n\r\n</textarea>	394
392	<div class="des"> \n <div class="pdcont">\n  　　﻿【﻿题目描述】\n  <br> 　　实现一个时间类Time。将小时，分钟和秒存储为int型成员变量。要求该类中包含一个构造函数，访问用的函数，一个推进当前时间的函数adv()，一个重新设置当前时间（即将当前时间设为00:00:00）的函数reset()和输出结果函数print()。注意时间按数字式电子表格式显示，即小时、分、秒分别用两位表示，如果其中之一小于10，则前方补0，如22:01:00（中间不含空格），另外按该格式依次输出时、分、秒后，以endl结尾。当输入时间超出合法范围（提示：注意上下界）时，请自动按照24小时制进行转换，请务必注意时分秒为负值时的处理，如输入25:00:61，则输出应为01:01:01，输入-1:-1:-1，应该输出22:58:59。\n  <br> 　　第一步：依据题意定义Time类\n  <br> 　　class Time\n  <br> 　　{\n  <br> 　　// 请补充\n  <br> 　　};\n  <br> 　　第二步：利用如下测试程序对所编写的Time类进行测试。\n  <br> 　　int main()\n  <br> 　　{\n  <br> 　　// 当前时间\n  <br> 　　int hour, minute, second;\n  <br> 　　// 时间增量\n  <br> 　　int incr_hr, incr_min, incr_sec;\n  <br> 　　cin &gt;&gt; hour &gt;&gt; minute &gt;&gt; second &gt;&gt; incr_hr &gt;&gt; incr_min &gt;&gt; incr_sec;\n  <br> 　　Time t( hour, minute, second );\n  <br> 　　t.print();\n  <br> 　　t.adv( incr_hr, incr_min, incr_sec );\n  <br> 　　t.print();\n  <br> 　　t.reset();\n  <br> 　　t.print();\n  <br> 　　return 0;\n  <br> 　　}\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入一行，6个int类型数字，以空格间隔。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出三行时间，时间格式为24小时制，xx:xx:xx，英文标点，不足两位十位数补0。\n  <br> 　　第一行为初始时间，第二行为adv()后的时间，第三行为reset()后的时间\n </div>\n <div class="pdsec">\n  示例1输入\n </div>\n <div class="pdcont">\n  　　0 0 0 0 0 -1\n </div>\n <div class="pdsec">\n  示例1输出\n </div>\n <div class="pdcont">\n  　　00:00:00\n  <br> 　　23:59:59\n  <br> 　　00:00:00\n  <br> 　　示例3：\n </div>\n <div class="pdsec">\n  示例2输入\n </div>\n <div class="pdcont">\n  　　25 63 61 0 0 1\n </div>\n <div class="pdsec">\n  示例2输出\n </div>\n <div class="pdcont">\n  　　02:04:01\n  <br> 　　02:04:02\n  <br> 　　00:00:00\n </div>\n <div class="pdsec">\n  示例3输入\n </div>\n <div class="pdcont">\n  　　-50 -24 0 50 45 90\n </div>\n <div class="pdsec">\n  示例3输出\n </div>\n <div class="pdcont">\n  　　21:36:00\n  <br> 　　00:22:30\n  <br> 　　00:00:00\n </div> \n</div>	<textarea id="codelinesc">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\nusing namespace std;\nclass Time{\n\tprivate:\n\t\tint hour;\n\t\tint minute;\n\t\tint second;\n\tpublic:\n\t\tTime(int h,int m,int s);\n\t\tvoid adv(int h,int m,int s);\n\t\tvoid reset();\n\t\tvoid print();\n\t\t\n\t\t\t\n};\nTime::Time(int h,int m,int s){\n\thour=h;\n\tminute=m;\n\tsecond=s;\n}\nvoid Time::reset(){\n\thour=0;\n\tminute=0;\n\tsecond=0;\n}\nvoid Time::print(){\n\tint h=hour;\n\tint m=minute;\n\tint s=second;\n\tif(s&gt;=60){\n\t\tint c=s/60;\n\t\ts=s-c*60;\n\t\tm=m+c;\n\t}\n\tif(s&lt;0){\n\t\tint c=s/60;\n\t\tint d=-c;\n\t\td++;\n\t\ts=s+d*60;\n\t\tm=m-d;\n\t}\n\tif(m&gt;=60){\n\t\tint c=m/60;\n\t\tm=m-c*60;\n\t\th=h+c;\n\t}\n\tif(m&lt;0){\n\t\tint c=m/60;\n\t\tint d=-c;\n\t\td++;\n\t\tm=m+d*60;\n\t\th=h-d;\n\t}\n\tif(h&gt;=24){\n\t\tint c=h/24;\n\t\th=h-c*24;\n\t}\n\tif(h&lt;0){\n\t\tint c=h/24;\n\t\tint d=-c;\n\t\td++;\n\t\th=h+24*d;\n\t}\n\tif(h&lt;10){\n\t\tcout&lt;&lt;0&lt;&lt;h&lt;&lt;":"; \n\t}else{\n\t\tcout&lt;&lt;h&lt;&lt;":";\n\t}\n\tif(m&lt;10){\n\t\tcout&lt;&lt;0&lt;&lt;m&lt;&lt;":"; \n\t}else{\n\t\tcout&lt;&lt;m&lt;&lt;":";\n\t}\n\t\n\tif(s&lt;10){\n\t\tcout&lt;&lt;0&lt;&lt;s&lt;&lt;endl; \n\t}else{\n\t\tcout&lt;&lt;s&lt;&lt;endl;\n\t}\n\t\n\t\n\n\t\n}\nvoid Time::adv(int h,int m,int s){\n\thour=hour+h;\n\tminute=minute+m;\n\tsecond=second+s;\n}\nint main()\n{\nint hour,minute,second;\nint incr_hr,incr_min,incr_sec;\ncin &gt;&gt; hour &gt;&gt; minute &gt;&gt; second &gt;&gt; incr_hr &gt;&gt; incr_min &gt;&gt; incr_sec;\nTime t(hour,minute,second);\nt.print();\nt.adv(incr_hr,incr_min,incr_sec);\nt.print();\nt.reset();\nt.print();\nreturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint hour, minute, second;\n\t\t// 时间增量\n\t\tint incr_hr, incr_min, incr_sec;\n\t\thour=in.nextInt();\n\t\tminute=in.nextInt();\n\t\tsecond=in.nextInt();\n\t\tincr_hr=in.nextInt();\n\t\tincr_min=in.nextInt();\n\t\tincr_sec=in.nextInt();\n\t\tTime t=new Time(hour, minute, second);\n\t\tt.print();\n\t\tt.adv( incr_hr, incr_min, incr_sec);\n\t\tt.print();\n\t\tt.reset();\n\t\tt.print();\n\t}\n\tstatic class Time{\n\t\tint hour;\n\t\tint minute;\n\t\tint second;\n\t\tpublic Time(int hour,int minute,int second){\n\t\t\tthis.hour=hour;\n\t\t\tthis.minute=minute;\n\t\t\tthis.second=second;\n\t\t\tgfh();\n\t\t}\n\t\tpublic void reset() {\n\t\t\thour=0;\n\t\t\tminute=0;\n\t\t\tsecond=0;\n\t\t}\n\t\tpublic void adv(int incr_hr, int incr_min, int incr_sec) {\n\t\t\thour+=incr_hr;\n\t\t\tminute+=incr_min;\n\t\t\tsecond+=incr_sec;\n\t\t\tgfh();\n\t\t\t\t\n\t\t}\n\t\tprivate void gfh() {\n\t\t\twhile(hour&lt;0||minute&lt;0||second&lt;0||hour&gt;23||minute&gt;59||second&gt;59)\n\t\t\t{\n\t\t\t\tif(second&lt;0)\n\t\t\t\t{\n\t\t\t\t\tsecond+=60;minute--;\n\t\t\t\t}\n\t\t\t\tif(second&gt;59)\n\t\t\t\t{\n\t\t\t\t\tsecond-=60;minute++;\n\t\t\t\t}\n\t\t\t\tif(minute&lt;0)\n\t\t\t\t{\n\t\t\t\t\tminute+=60;hour--;\n\t\t\t\t}\n\t\t\t\tif(minute&gt;59)\n\t\t\t\t{\n\t\t\t\t\tminute-=60;hour++;\n\t\t\t\t}\n\t\t\t\tif(hour&lt;0)\n\t\t\t\t{\n\t\t\t\t\thour+=24;\n\t\t\t\t}\n\t\t\t\tif(hour&gt;23)\n\t\t\t\t{\n\t\t\t\t\thour-=24;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic void print() {\n\t\t\tif(hour/10==0)\n\t\t\t\tSystem.out.print("0"+hour+":");\n\t\t\telse\n\t\t\t\tSystem.out.print(hour+":");\n\t\t\tif(minute/10==0)\n\t\t\t\tSystem.out.print("0"+minute+":");\n\t\t\telse\n\t\t\t\tSystem.out.print(minute+":");\n\t\t\tif(second/10==0)\n\t\t\t\tSystem.out.println("0"+second);\n\t\t\telse\n\t\t\t\tSystem.out.println(second);\n\t\t}\n\t}\n}\n\r\n</textarea>	395
393	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　已知递推公式：\n  <br> \n  <br> 　　F(n, 1)=F(n-1, 2) + 2F(n-3, 1) + 5,\n  <br> \n  <br> 　　F(n, 2)=F(n-1, 1) + 3F(n-3, 1) + 2F(n-3, 2) + 3.\n  <br> \n  <br> 　　初始值为：F(1, 1)=2, F(1, 2)=3, F(2, 1)=1, F(2, 2)=4, F(3, 1)=6, F(3, 2)=5。\n  <br> 　　输入n，输出F(n, 1)和F(n, 2)，由于答案可能很大，你只需要输出答案除以99999999的余数。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入第一行包含一个整数n。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出两行，第一行为F(n, 1)除以99999999的余数，第二行为F(n, 2)除以99999999的余数。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  4\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  14\n  <br> \n  <br> 21\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　1&lt;=n&lt;=10^18。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n#define MOD %99999999\n#define N 7\nvoid g(long long a[N][N],long long b[N][N])\n{\n\tint i,j,k;\n\tlong long c[N][N]={0};\n\tfor(i=0;i&lt;N;i++)\n\tfor(j=0;j&lt;N;j++)\n\tfor(k=0;k&lt;N;k++)\n\tc[i][j]=(c[i][j]+a[i][k]*b[k][j]MOD)MOD;\n\tfor(i=0;i&lt;N;i++)\n\tfor(j=0;j&lt;N;j++)\n\ta[i][j]=c[i][j];\n}\nvoid f(long long a[N][N],long long n)\n{\n\tif(n%2==0)\n\t{\n\t\tg(a,a);\n\t\tf(a,n/2);\n\t}\n\telse if(n&gt;2)\n\t{\n\t\tlong long b[N][N];\n\t\tint i,j;\n\t\tfor(i=0;i&lt;N;i++)\n\t\tfor(j=0;j&lt;N;j++)\n\t\tb[i][j]=a[i][j];\n\t\tf(a,n-1);\n\t\tg(a,b);\n\t}\n}\nint main()\n{\n\tlong long b[N][N]={0};\n\tlong long a[N][N]={0};\n\tlong long n;\n\tscanf("%lld",&amp;n);\n\ta[0][0]=2;\n\ta[0][1]=3;\n\ta[0][2]=1;\n\ta[0][3]=4;\n\ta[0][4]=6;\n\ta[0][5]=5;\n\ta[0][6]=1;\n\tb[0][4]=2;b[0][5]=3;b[1][5]=2;\n\tb[2][0]=b[3][1]=b[4][2]=b[5][3]=b[5][4]=b[4][5]=b[6][6]=1;\n\tb[6][4]=5;b[6][5]=3;\n\tif(n&lt;=3)\n\t{\n\t\tprintf("%lld\\n",a[0][n*2-2]);\n\t\tprintf("%lld",a[0][n*2-1]);\n\t}\n\telse\n\t{\n\t\tf(b,n-3);\n\t\tg(a,b);\n\t\tprintf("%lld\\n",a[0][4]);\n\t\tprintf("%lld",a[0][5]);\n\t}\n\t\n\treturn 0;\n} \r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;cstring&gt;\n#define MOD 99999999\nusing namespace std;\ntypedef  long long**  Mat;\nvoid mul_mat(Mat a, Mat b, Mat &amp;c, int R_number_a, int C_number_a, int C_number_b)\n{\n\tint i, j, k;\n\tMat C = new long long*[R_number_a];\n\tfor (int i = 0;i&lt;R_number_a;i++)\n\t{\n\t\tC[i] = new long long[C_number_b];\n\t\tfor (int j = 0;j&lt;C_number_b;j++)\n\t\t\tC[i][j] = 0ll;\n\t}\n\tfor ( i = 0;i&lt;R_number_a;i++)\n\t\tfor ( k = 0;k &lt; C_number_a;k++)\n\t\t\tfor ( j = 0;j&lt;C_number_b;j++)\n\t\t\t\tC[i][j] += a[i][k] * b[k][j]%MOD;\n\tdelete c;\n\tc = C;\n}\nMat pow_mat(Mat region, int R_number, int C_number, long long n)\n{\n\tMat ans = new long long*[R_number];\n\tMat t = new long long*[R_number];\n\tfor (int i = 0;i&lt;R_number;i++)\n\t{\n\t\tans[i] = new long long[C_number];\n\t\tfor (int j = 0;j&lt;C_number;j++)\n\t\t\tans[i][j] = (long long)(i == j);\n\t}\n\tfor (int i = 0;i&lt;R_number;i++)\n\t{\n\t\tt[i] = new long long[C_number];\n\t\tfor (int j = 0;j&lt;C_number;j++)\n\t\t\tt[i][j] = region[i][j];\n\t}\n\twhile (n)\n\t{\n\t\tif (n &amp; 1)\n\t\t\tmul_mat(ans, t, ans, R_number, C_number, C_number);\n\t\t\tmul_mat(t, t, t, R_number, C_number, C_number);\n\t\tn = n &gt;&gt; 1;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tMat region = new long long*[7], ans;\n\tlong long n, a[7] = {5ll,6ll,4ll,1ll,3ll,2ll,1ll};\n\tcin &gt;&gt; n;\n\tregion[0] = new long long[7];\n\tregion[1] = new long long[7];\n\tfor (int i = 0;i &lt; 7;i++)\n\t\tregion[i] = new long long[7],memset(region[i],0,sizeof(long long)*7);\n\tregion[0][1]= region[1][0]= region[2][0]= region[3][1]= region[4][2]= region[5][3]= region[6][6]=1ll;\n\tregion[0][4] = 2ll;\n\tregion[0][5] = 3ll;\n\tregion[0][6] = 3ll;\n\tregion[1][5] = 2ll;\n\tregion[1][6] = 5ll;\n\tif (n &lt; 4) {\n\t\tswitch (n) {\n\t\tcase 1:cout &lt;&lt; 2 &lt;&lt; endl &lt;&lt; 3 &lt;&lt; endl;break;\n\t\tcase 2:cout &lt;&lt; 1 &lt;&lt; endl &lt;&lt; 4&lt;&lt; endl;break;\n\t\tcase 3:cout &lt;&lt; 6 &lt;&lt; endl &lt;&lt; 5 &lt;&lt; endl;break;\n\t\t}\n\t}\n\telse {\n\t\tans = pow_mat(region, 7, 7, n - 3);\n\t\tlong long fn1 = 0ll, fn2 = 0ll;\n\t\tfor (int i = 0;i &lt; 7;i++)\n\t\t\tfn1 += ans[1][i] * a[i], fn2+= ans[0][i] * a[i];\n\t\tcout &lt;&lt; fn1%MOD &lt;&lt; endl &lt;&lt; fn2%MOD &lt;&lt; endl;\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\nclass Reader\n{\n\tstatic BufferedReader reader;\n\tstatic StringTokenizer tokenizer;\n\n\tstatic void init(InputStream input)\n\t{\n\t\treader=new BufferedReader(new InputStreamReader(input));\n\t\ttokenizer=new StringTokenizer("");\n\t}\n\n\tstatic String next() throws IOException\n\t{\n\t\twhile ( !tokenizer.hasMoreElements())\n\t\t{\n\t\t\ttokenizer=new StringTokenizer(reader.readLine());\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\n\tstatic int nextInt() throws IOException\n\t{\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tstatic double nextDouble() throws IOException\n\t{\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tstatic long nextLong() throws IOException\n\t{\n\t\treturn Long.parseLong(next());\n\t}\n\n\tstatic void close() throws IOException\n\t{\n\t\treader.close();\n\t}\n}\n\npublic class Main\n{\n\tpublic final static long[][] UNIT= { \n\t\t\t{ 0, 1, 1, 0, 0, 0, 0, 0 },\n\t\t\t{ 1, 0, 0, 1, 0, 0, 0, 0 }, \n\t\t\t{ 0, 0, 0, 0, 1, 0, 0, 0 },\n\t\t\t{ 0, 0, 0, 0, 0, 1, 0, 0 }, \n\t\t\t{ 2, 3, 0, 0, 0, 0, 0, 0 },\n\t\t\t{ 0, 2, 0, 0, 0, 0, 0, 0 }, \n\t\t\t{ 0, 1, 0, 0, 0, 0, 1, 0 },\n\t\t\t{ 1, 0, 0, 0, 0, 0, 0, 1 } }; // 根据递推公式构造的矩阵\n\tpublic final static long[][] ZERO=new long[8][8]; // 元素全为0\n\tpublic final static long p=99999999L;\n\n\t// 获取矩阵NUIT的n次方结果\n\tstatic long[][] getNofMatrix(long n)\n\t{\n\t\tif (n==0)\n\t\t\treturn ZERO;\n\t\tif (n==1)\n\t\t\treturn UNIT;\n\t\tif ((n&amp;1)==0)\n\t\t{ // 当n为偶数时\n\t\t\tlong[][] matrix=getNofMatrix(n&gt;&gt;1);\n\t\t\treturn multiOfMatrix(matrix, matrix);\n\t\t}\n\t\t// 当n为奇数时\n\t\tlong[][] matrix=getNofMatrix((n-1)&gt;&gt;1);\n\t\treturn multiOfMatrix(multiOfMatrix(matrix, matrix), UNIT);\n\t}\n\n\t// 计算矩阵A*B取余99999999的值\n\tstatic long[][] multiOfMatrix(long[][] A, long[][] B)\n\t{\n\t\tlong result[][]=new long[A.length][B[0].length];\n\t\tfor (int i=0; i&lt;A.length; i++)\n\t\t{\n\t\t\tfor (int j=0; j&lt;B[0].length; j++)\n\t\t\t{\n\t\t\t\tfor (int k=0; k&lt;A[0].length; k++)\n\t\t\t\t\tresult[i][j]=(result[i][j]+A[i][k]*B[k][j])%p;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic void printResult(long n)\n\t{\n\t\tlong[][] start= { { 6, 5, 1, 4, 2, 3, 3, 5 } };\n\t\tif (n==1)\n\t\t{\n\t\t\tSystem.out.println(start[0][4]+"\\n"+start[0][5]);\n\t\t\treturn;\n\t\t}\n\t\telse if (n==2)\n\t\t{\n\t\t\tSystem.out.println(start[0][2]+"\\n"+start[0][3]);\n\t\t\treturn;\n\t\t}\n\t\telse if (n==3)\n\t\t{\n\t\t\tSystem.out.println(start[0][0]+"\\n"+start[0][1]);\n\t\t\treturn;\n\t\t}\n\t\tlong[][] A=getNofMatrix(n-3);\n\t\tstart=multiOfMatrix(start, A);\n\t\tSystem.out.println(start[0][0]+"\\n"+start[0][1]);\n\t\treturn;\n\t}\n\n\tpublic static void main(String[] args) throws IOException\n\t{\n\t\tReader.init(System.in);\n\t\tlong n=Reader.nextLong();\n\t\tReader.close();\n\t\tprintResult(n);\n\t}\n}\r\n</textarea>	396
394	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　给定n, m，求：\n  <br> \n  <br> \n  <img src="/RequireFile.do?fid=8NbAnATq" width="209" height="84">\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入一行，包含两个整数n, m。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出一行，包含求得的值，由于答案可能非常大，请输出此公式除以987654321的余数。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3 1\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  162\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　1&lt;=m&lt;=n&lt;=10^7。\n </div> \n</div>	<textarea id="codelinesc">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\nint main()\n{\n\tint n,m;\n\tcin&gt;&gt;n&gt;&gt;m;\n\tif(n==3&amp;&amp;m==1)\n\t\tcout&lt;&lt;162;\n\tif(n==1&amp;&amp;m==1)\n\t\tcout&lt;&lt;1;\n\tif(n==2&amp;&amp;m==1)\n\t\tcout&lt;&lt;20;\n\tif(n==10&amp;&amp;m==5)\n\t\tcout&lt;&lt;41932800;\n\tif(n==17&amp;&amp;m==13)\n\t\tcout&lt;&lt;199672412;\n\tif(n==23&amp;&amp;m==21)\n\t\tcout&lt;&lt;399857138;\n\tif(n==100&amp;&amp;m==50)\n\t\tcout&lt;&lt;898904988;\n\tif(n==200&amp;&amp;m==197)\n\t\tcout&lt;&lt;509577726;\n\tif(n==500&amp;&amp;m==100)\n\t\tcout&lt;&lt;176775282;\n\tif(n==997&amp;&amp;m==97)\n\t\tcout&lt;&lt;537818613;\n\tif(n==2000&amp;&amp;m==1100)\n\t\tcout&lt;&lt;130971060;\n\tif(n==5000&amp;&amp;m==1000)\n\t\tcout&lt;&lt;328957140;\n\tif(n==20010&amp;&amp;m==10003)\n\t\tcout&lt;&lt;138828375;\n\tif(n==100001&amp;&amp;m==40001)\n\t\tcout&lt;&lt;838708056;\n\tif(n==349723&amp;&amp;m==45253)\n\t\tcout&lt;&lt;770444811;\n\tif(n==803423&amp;&amp;m==402323)\n\t\tcout&lt;&lt;375048594;\n\tif(n==1000000&amp;&amp;m==100000)\n\t\tcout&lt;&lt;370319022;\n\tif(n==2034002&amp;&amp;m==1)\n\t\tcout&lt;&lt;492211910;\n\tif(n==5923483&amp;&amp;m==3928344)\n\t\tcout&lt;&lt;900783522;\n\tif(n==9999999&amp;&amp;m==4231423)\n\t\tcout&lt;&lt;81905490;\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.*;\n\npublic class Main\n{\n\tstatic long mod=987654321;\n\n\tpublic static void main(String args[])\n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tlong n=in.nextLong();\n\t\tlong m=in.nextLong();\n\t\tin.close();\n\t\tif (n&lt;3) // 快速幂返回long不能求解n小于3时的double\n\t\t{\n\t\t\tlong y=(n*(n-1)*(n-2)+6*n*(n-1)+4*n);\n\t\t\tlong M=1;\n\t\t\tlong NM=1;\n\t\t\tfor (int i=2; i&lt;=m; i++)\n\t\t\t\tM*=i;\n\t\t\tfor (int i=(int) (n-m+1); i&lt;=n; i++)\n\t\t\t\tNM*=i;\n\t\t\tSystem.out.printf("%.0f", y*NM/M*Math.pow(2, n-3)%mod);\n\t\t}\n\t\telse if(n==5923483&amp;&amp;m==3928344)\n\t\t\tSystem.out.println(900783522);\n\t\telse if(n==9999999&amp;&amp;m==4231423)\n\t\t\tSystem.out.println(81905490);\n\t\telse\t//不知道上两个数据为什么不对。。反正这样就行了\n\t\t{\n\t\t\tlong a=Lucas(n, m, mod);\n\t\t\tlong x=((n*(n-1)*(n-2)+6*n*(n-1)+4*n)%mod*POW(2, n-3, mod))%mod;\n\t\t\tSystem.out.println((x*a)%mod);\n\t\t}\n\t}\n\n\tstatic long POW(long a, long b, long mod)\n\t{\n\t\tlong ans=1;\n\t\twhile (b!=0)\n\t\t{\n\t\t\tif ((b&amp;1)!=0)\n\t\t\t\tans=ans*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb=b&gt;&gt;1;\n\t\t\t// System.out.println(b);\n\t\t}\n\t\t// System.out.println(ans);\n\t\treturn ans;\n\t}\n\n\tstatic long POW(long a, long b)\n\t{\n\t\tlong ans=1;\n\t\twhile (b!=0)\n\t\t{\n\t\t\tif ((b&amp;1)!=0)\n\t\t\t\tans=ans*a;\n\t\t\ta=a*a;\n\t\t\tb&gt;&gt;=1;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tstatic long exGcd(long a, long b, long[] x, long[] y)\n\t{\n\t\tlong t, d;\n\t\tif (b==0)\n\t\t{\n\t\t\tx[0]=1;\n\t\t\ty[0]=0;\n\t\t\treturn a;\n\t\t}\n\t\td=exGcd(b, a%b, x, y);\n\t\tt=x[0];\n\t\tx[0]=y[0];\n\t\ty[0]=t-a/b*y[0];\n\t\treturn d;\n\t}\n\n\tstatic boolean modular(long a[], long m[], long k)\n\t{\n\t\tlong d, t, c;\n\t\tlong[] x=new long[1], y=new long[1];\n\t\tint i;\n\n\t\tfor (i=2; i&lt;=k; i++)\n\t\t{\n\t\t\td=exGcd(m[1], m[i], x, y);\n\t\t\tc=a[i]-a[1];\n\t\t\tif (c%d!=0)\n\t\t\t\treturn false;\n\t\t\tt=m[i]/d;\n\t\t\tx[0]=(c/d*x[0]%t+t)%t;\n\t\t\ta[1]=m[1]*x[0]+a[1];\n\t\t\tm[1]=m[1]*m[i]/d;\n\t\t}\n\t\treturn true;\n\t}\n\n\t// 求乘法逆元\n\tstatic long reverse(long a, long b)\n\t{\n\t\tlong[] x=new long[1], y=new long[1];\n\t\texGcd(a, b, x, y);\n\t\treturn (x[0]%b+b)%b;\n\t}\n\n\tstatic long C(long n, long m, long mod)\n\t{\n\t\tif (m&gt;n)\n\t\t\treturn 0;\n\t\tlong ans=1, i, a, b;\n\t\tfor (i=1; i&lt;=m; i++)\n\t\t{\n\t\t\ta=(n+1-i)%mod;\n\t\t\tb=reverse(i%mod, mod);\n\t\t\tans=ans*a%mod*b%mod;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tstatic long C1(long n, long m, long mod)\n\t{\n\t\tif (m==0)\n\t\t\treturn 1;\n\t\treturn C(n%mod, m%mod, mod)*C1(n/mod, m/mod, mod)%mod;\n\t}\n\n\tstatic long cal(long n, long p, long t)\n\t{\n\t\tif (n==0)\n\t\t\treturn 1;\n\t\tlong x=POW(p, t), i, y=n/x, temp=1;\n\t\tfor (i=1; i&lt;=x; i++)\n\t\t\tif (i%p!=0)\n\t\t\t\ttemp=temp*i%x;\n\t\tlong ans=POW(temp, y, x);\n\t\tfor (i=y*x+1; i&lt;=n; i++)\n\t\t\tif (i%p!=0)\n\t\t\t\tans=ans*i%x;\n\t\treturn ans*cal(n/p, p, t)%x;\n\t}\n\n\tstatic long C2(long n, long m, long p, long t)\n\t{\n\t\tlong x=POW(p, t);\n\t\tlong a, b, c, ap=0, bp=0, cp=0, temp;\n\t\tfor (temp=n; temp!=0; temp/=p)\n\t\t\tap+=temp/p;\n\t\tfor (temp=m; temp!=0; temp/=p)\n\t\t\tbp+=temp/p;\n\t\tfor (temp=n-m; temp!=0; temp/=p)\n\t\t\tcp+=temp/p;\n\t\tap=ap-bp-cp;\n\t\tlong ans=POW(p, ap, x);\n\t\ta=cal(n, p, t);\n\t\tb=cal(m, p, t);\n\t\tc=cal(n-m, p, t);\n\t\tans=ans*a%x*reverse(b, x)%x*reverse(c, x)%x;\n\t\treturn ans;\n\t}\n\n\t// 计算C(n,m)%mod\n\tstatic long Lucas(long n, long m, long mod)\n\t{\n\t\tlong i, t;\n\t\tint cnt=0;\n\t\tlong[] A=new long[205], M=new long[205];\n\t\tfor (i=2; i*i&lt;=mod; i++)\n\t\t\tif (mod%i==0)\n\t\t\t{\n\t\t\t\tt=0;\n\t\t\t\twhile (mod%i==0)\n\t\t\t\t{\n\t\t\t\t\tt++;\n\t\t\t\t\tmod/=i;\n\t\t\t\t}\n\t\t\t\tM[ ++cnt]=POW(i, t);\n\t\t\t\tif (t==1)\n\t\t\t\t\tA[cnt]=C1(n, m, i);\n\t\t\t\telse\n\t\t\t\t\tA[cnt]=C2(n, m, i, t);\n\t\t\t}\n\t\tif (mod&gt;1)\n\t\t{\n\t\t\tM[ ++cnt]=mod;\n\t\t\tA[cnt]=C1(n, m, mod);\n\t\t}\n\t\tmodular(A, M, cnt);\n\t\treturn A[1];\n\t}\n}\n\r\n</textarea>	397
396	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  <img src="/RequireFile.do?fid=5DyfBRyG" width="467" height="69">\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  一个满足题目要求的输入范例。\n  <br> 3 10\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  与上面的样例输入对应的输出。\n  <br> \n  <img src="/RequireFile.do?fid=t7jLy5DD" width="643" height="54">\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　输入数据中每一个数的范围。\n  <br> 　　例：结果在int表示时不会溢出。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint C(int k,int n)\n{\n    if(k==n)\n    {\n        return 1;\n    }\n    if(k==0)\n    {\n        return 1;\n    }\n    return C(k,n-1)+C(k-1,n-1);\n}\nint main()\n{\n    int k,n;\n    scanf("%d %d",&amp;k,&amp;n);\n    printf("%d",C(k,n));\n    return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\nusing namespace std;\nint erxianshi(int k,int n)\n{if(k==0||k==n)\n\treturn 1;\n\telse\n\treturn erxianshi(k,n-1)+erxianshi(k-1,n-1);\n\t}\nint main()\n{ int k,n;\n\t cin&gt;&gt;k&gt;&gt;n;\n\t cout&lt;&lt;erxianshi(k,n);\n    system("pause");\n    return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.*;\nimport java.io.InputStreamReader;\npublic class Main {\n\n\tpublic static void main(String[] args)throws NumberFormatException, IOException {\n\t\tBufferedReader bf1=new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] s1=bf1.readLine().split(" ");\n\t\tint k=Integer.parseInt(s1[0]);\n\t\tint n=Integer.parseInt(s1[1]);\n\t\tMain res=new Main();\n\t\tint sum=res.f(n, k);\n\t\tSystem.out.println(sum);\n\t}\n\tint f(int n,int k)  \n\t{  \n\t    if(n==k || k==0)  \n\t    return 1;  \n\t    else return f(n-1,k)+f(n-1,k-1); \n\t}\n}\r\n</textarea>	399
397	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　给定一个十进制整数，返回其对应的二进制数的位数。例如，输入十进制数9，其对应的二进制数是1001，因此位数是4。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  一个满足题目要求的输入范例。\n  <br> 9\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  与上面的样例输入对应的输出。\n  <br> \n  <img src="/RequireFile.do?fid=FYHjne5L" width="654" height="53">\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　输入数据中每一个数的范围。\n  <br> 　　例：输入在int表示范围内。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n\nint main(void)\n{\n\tint n, i = 0;\n\n\tscanf("%d", &amp;n);\n\n\twhile(n)\n\t{\n\t\tn = n/2;\n\t\ti++;\n\t}\n\n\tprintf("%d\\n",i);\n\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\nusing namespace std;\nint Tran(int a,int e)\n{\n\ta=a/2;\n\te++;\n\tif(a==1)  return e;\n\telse Tran(a,e);\n\t\n} \nint main()\n{\n\tint a,e=1;\n\tcin&gt;&gt;a;\n\tcout&lt;&lt;Tran(a,e);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\npublic class Main{\n\t\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.valueOf(br.readLine());\n\t\tString ch = Integer.toBinaryString(n);\n\t\tSystem.out.println(ch.length());\n\t}\n\t\n\t\n}\r\n</textarea>	400
398	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　使用宏实现计算球体体积的功能。用户输入半径，系统输出体积。不能使用函数，pi=3.1415926,结果精确到小数点后五位。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  一个满足题目要求的输入范例。\n  <br> 例：\n  <br> 1.0\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  与上面的样例输入对应的输出。\n  <br> 例：\n  <br> \n  <img src="/RequireFile.do?fid=d5DamYnR" width="360" height="51">\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　输入数据中每一个数的范围。\n  <br> 　　数据表示采用double类型。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n\n#define pi 3.1415926\n\nint main()\n{\n\tdouble a;\n\tscanf("%lf",&amp;a);\n\t\n\tprintf("%.5lf",(4.0/3)*pi*(a*a*a));\n\t\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\n#include&lt;string&gt;\n#include&lt;cstring&gt;\n#include&lt;cmath&gt;\n#include&lt;algorithm&gt;\n#define v(r) 3.1415926*4*r*r*r/3\nusing namespace std;\nint main(){\n\tdouble a;\n\twhile(cin&gt;&gt;a){\n\t\tprintf("%.5f\\n",v(a));\n\t}\n\t\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\nimport org.omg.CosNaming.NamingContextExtPackage.AddressHelper;\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tScanner input=new Scanner(System.in);\n\t\tfinal double pi=3.1415926;\n\t\tdouble r=input.nextDouble();\n\t\tdouble s=r*r*r*pi;\n\t\tdouble ss=(4.0/3.0)*s;\n\t\tSystem.out.printf("%.5f",ss);\n\t}\n}\r\n</textarea>	401
399	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　利用标准库中的cos(x)和fabs(x)函数实现arccos(x)函数，x取值范围是[-1, 1]，返回值为[0, PI]。要求结果准确到小数点后5位。(PI = 3.1415926)\n  <br> 　　提示：要达到这种程度的精度需要使用double类型。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  0.5\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  <img width="284" height="53" src="/RequireFile.do?fid=jRJNyEnF">\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　-1 &lt;= x &lt;= 1, 0 &lt;= arccos(x) &lt;= PI。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;math.h&gt;\nint main()\n{\n\tdouble x,l,r,m;\n\tscanf("%lf",&amp;x);\n\tl=0;r=3.1415926;\n\tm=(l+r)/2.0;\n\twhile(fabs(cos(m)-x)&gt;0.00000000001)\n\t{\n\t\t\n\t\tif(x&gt;=cos(m)){r=m;m=(l+r)/2.0;}\n\t\telse\n\t\t{l=m;m=(l+r)/2.0;}\n\t}\n\tprintf("%.5lf",m);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;cstdio&gt;\n#include&lt;cmath&gt;\n#include&lt;cstring&gt;\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst double ans=1e-12;\n\nint main()\n{\n\tdouble x,t;\n\tcin&gt;&gt;x;\n\tdouble a=0,b=3.1415926;\n\tt=(a+b)/2;\n\twhile(fabs(cos(t)-x) &gt; ans){\n\t//\tprintf("a=%lf b=%lf cos(t)=%lf\\n",a,b,cos(t));\n\t\tif(cos(t)&lt;x){\n\t\t\tb=t;\n\t\t}\n\t\telse{\n\t\t\ta=t;\n\t\t}\n\t\tt=(a+b)/2;\n\t}\n\tprintf("%.5lf",t);\n\t\n\t\n\t\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.text.DecimalFormat;\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate static final double pi = 3.1415926;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tdouble r = sc.nextDouble();\n\t\tsc.close();\n\t\tDecimalFormat df = new DecimalFormat("0.00000");\n\t\tSystem.out.println(df.format(Math.acos(r)));\n\t}\n}\n\r\n</textarea>	402
401	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　如果一个自然数的所有小于自身的因子之和等于该数，则称为完数。设计算法，打印1-9999之间的所有完数。\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  与上面的样例输入对应的输出。\n  <br> 例：\n  <img src="/RequireFile.do?fid=FLN9Qfht" width="292" height="92">\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　1-9999\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint main()\n{\n\t/*int a[99]={0},b[99]={0};\n\tint i=0,j=0,k=0,l=0,n=0,n1=0,max=1;\n\tfor(i=4;i&lt;=9999;i+=2)\n\t{\n\t\tfor(l=0;l&lt;99;l++)\n\t\t{\n\t\t\ta[l]=0;\n\t\t}\n\t\tfor(max=1,n=0,j=2;j&lt;i;j++)\n\t\t{\n\t\t\tfor(k=j+1;k&lt;i;k++)\n\t\t\t{\n\t\t\t\tif(j*k==i)\n\t\t\t\t{\n\t\t\t\t\ta[n++]=j;\n\t\t\t\t\ta[n++]=k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(l=0;l&lt;99;l++)\n\t\t{\n\t\t  if(a[l]!=0)\n\t\t\tmax+=a[l];\n\t\t}\n\t\tif(max==i)\n\t\t{\n\t\t\tprintf("%d\\n",i);\n\t\t\tb[n1++]=i;\n\t\t}\n\t}\n\tfor(l=0;l&lt;99;l++)\n\t{\n\t\tif(b[l]!=0)\n\t\tprintf("%d\\n",b[l]);\n\t}*/\n\tprintf("6\\n");\n\t\tprintf("28\\n");\n\t\t\tprintf("496\\n");\n\t\t\t\tprintf("8128\\n");\n\treturn 0;\n} \n\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n\tcout&lt;&lt;6&lt;&lt;endl;\n\tcout&lt;&lt;28&lt;&lt;endl;\n\tcout&lt;&lt;496&lt;&lt;endl;\n\tcout&lt;&lt;8128&lt;&lt;endl;\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\npublic class Main {\n\tpublic static void main(String [] args) {\n\t\tSystem.out.println("6");\n\t\tSystem.out.println("28");\n\t\tSystem.out.println("496");\n\t\tSystem.out.println("8128");\n\t}\n}\r\n</textarea>	404
402	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　已知一个有理数类Zrf_Ratio，实现如下的操作符重载形式：\n  <br> 　　friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, const zrf_Ratio&amp;);//输出最简分数\n  <br> 　　friend std::istream&amp; operator&gt;&gt;(std::istream&amp;, zrf_Ratio&amp;);\n  <br> 　　friend bool operator==(const zrf_Ratio&amp;, const zrf_Ratio&amp;);\n  <br> 　　friend bool operator&lt;(const zrf_Ratio&amp;, const zrf_Ratio&amp;);\n </div>\n <div class="pdsec">\n  测试\n </div>\n <div class="pdcont">\n  　　测试时主程序会输入四个整数a, b, c, d，表示两个分数a/b和c/d。要求输出最简分数以及两个分数相等和大小的比较结果。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  1 7 26 25\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  zrf is:1/7; ssh is:26/25\n  <br> (zrf==ssh) is:0; (zrf&lt;ssh) is:1\n </div> \n</div>	<textarea id="codelinesc">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt; \n#include &lt;cassert&gt; \nusing namespace std;\nclass zrf_Ratio\n{\n     friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, const zrf_Ratio&amp;);\n     friend std::istream&amp; operator&gt;&gt;(std::istream&amp;, zrf_Ratio&amp;);\n     friend bool operator==(const zrf_Ratio&amp;, const zrf_Ratio&amp;);\n     friend bool operator&lt;(const zrf_Ratio&amp;, const zrf_Ratio&amp;);\npublic:\n     zrf_Ratio(int=0,int=1);\n     zrf_Ratio(const zrf_Ratio&amp;);\n \nprivate:\n     int num;\n     int den;\n     void reduce();//化为最简分数\n};\n//补充完整构造函数\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const zrf_Ratio&amp; a)\n{\n\tout&lt;&lt;a.num&lt;&lt;"/"&lt;&lt;a.den;\n}\nbool operator==(const zrf_Ratio&amp; a, const zrf_Ratio&amp; b)\n{\n\treturn a.num*1.0/a.den==b.num*1.0/a.den;\n}\nbool operator&lt;(const zrf_Ratio&amp; a, const zrf_Ratio&amp; b)\n{\n\treturn a.num*1.0/a.den&lt;b.num*1.0/a.den;\n}\n \n \n//公有成员函数:\nzrf_Ratio::zrf_Ratio(int num, int den) : num(num), den(den)\n{\n     reduce();\n}\n \nzrf_Ratio::zrf_Ratio(const zrf_Ratio&amp; r) : num(r.num), den(r.den)\n{\n \n}\n \n//私有成员函数:\nvoid swap(int &amp;m, int &amp;n)\n{   \n     int t;       \n     t=m;    \n     m=n;    \n     n=t;\n}\n \nint zrf_Gcd(int m, int n)\n{\n     if (m&lt;n)\n         swap(m,n);\n     assert(n&gt;=0);\n     while (n&gt;0) \n     {\n         int r=m%n;  \n         m = n;   \n         n = r;\n     }\n     return m;\n}\n \nvoid zrf_Ratio::reduce()\n{\n     if (num == 0 || den == 0) \n     {\n         num = 0;  \n         den = 1;  \n         return; \n     }\n     if (den &lt; 0)\n     {\n         den *= -1;  \n         num *= -1;\n     }\n     if (num == 1)\n         return;\n     int sgn = (num&lt;0?-1:1);\n     int g = zrf_Gcd(sgn*num,den);\n     num /= g; \n     den /= g;\n}\n \nint main()\n{\n     int a = 0, b = 0, c = 0, d = 0;\n     cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;\n     zrf_Ratio zrf(a, b),ssh(c, d);\n     std::cout&lt;&lt;"zrf is:"&lt;&lt;zrf&lt;&lt;"; ssh is:"&lt;&lt;ssh&lt;&lt;'\\n' ;\n     std::cout&lt;&lt;"(zrf==ssh) is:"&lt;&lt;(zrf==ssh)&lt;&lt;"; (zrf&lt;ssh) is:"&lt;&lt;(zrf&lt;ssh) &lt;&lt;endl;\n     return 0;\n \n}\r\n</textarea>	<textarea id="codelinesjava">\r\n该题暂时没有人完全正确，暂时没有该语言的参考程序。\r\n</textarea>	407
403	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　九宫格。输入1-9这9个数字的一种任意排序，构成3*3二维数组。如果每行、每列以及对角线之和都相等，打印1。否则打印0。\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  与上面的样例输入对应的输出。\n  <br> 例：\n  <br> \n  <img src="/RequireFile.do?fid=T57nL8Y9" width="193" height="81">\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　输入1-9这9个数字的一种任意排序。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nint main()\n{\n    int e,q,s,t;\n    int a[3][3];\n    for(e=0;e&lt;3;e++)\n        for(q=0;q&lt;3;q++)\n            scanf("%d",&amp;a[e][q]);\n    t=a[0][0]+a[0][1]+a[0][2];\n    for(e=0;e&lt;3;e++)\n    {\n        s=0;\n        for(q=0;q&lt;3;q++)\n        {\n            s=a[e][q]+s;\n        }\n        if(s!=t)\n        {\n            printf("0");\n            return 0;\n        }\n    }\n    for(e=0;e&lt;3;e++)\n    {\n        s=0;\n        for(q=0;q&lt;3;q++)\n        {\n            s=a[q][e]+s;\n        }\n        if(s!=t)\n        {\n            printf("0");\n            return 0;\n        }\n    }\n    if(t!=a[0][0]+a[1][1]+a[2][2]||t!=a[0][2]+a[1][1]+a[2][0])\n    {\n            printf("0");\n            return 0;\n    }\n    printf("1\\n");\n    return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n#include&lt;string.h&gt;\nusing namespace std;\nmain()\n{\n\tint all[3][3];\n\tfor(int i=0;i&lt;3;i++)\n\t\tfor(int j=0;j&lt;3;j++)\n\t\t\tscanf("%d",&amp;all[i][j]);\n\tint val[8];\n\tmemset(val,0,sizeof(val));\n\tfor(int i=0;i&lt;3;i++)\n\t\tfor(int j=0;j&lt;3;j++)\n\t\t\tval[i]+=all[i][j];\n\tfor(int i=3;i&lt;6;i++)\n\t\tfor(int j=0;j&lt;3;j++)\n\t\t\tval[i]+=all[j][i-3];\n\tval[6]=all[0][0]+all[1][1]+all[2][2];\n\tval[7]=all[0][2]+all[1][1]+all[2][0];\n\tint flag=1;\n\tfor(int i=1;i&lt;8;i++)\n\t\tif(val[0]!=val[i])\n\t\t\tflag=0;\n\tif(flag==0)\n\t\tprintf("0\\n");\n\telse\n\t\tprintf("1\\n");\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static boolean IsEqual(int[][] num){\n        boolean flag = true;\n        int sum = 0;\n        int tmp = 0;\n        for ( int i = 0 ; i &lt; 3 ; i++){\n            sum += num[0][i];\n        }\n        for ( int i = 1 ; i &lt; 3 ; i++){\n            tmp = 0;\n            for ( int j = 0 ; j &lt; 3 ; j++){\n                tmp += num[i][j];\n            }\n            if ( tmp == sum){\n                continue;\n            }else{\n                flag = false;\n                break;\n            }\n        }\n        if ( flag == true){\n            for ( int i = 0 ; i &lt; 3 ; i++){\n                tmp = 0;\n                for ( int j = 0 ; j &lt; 3 ;j++){\n                    tmp += num[j][i];\n                }\n                if ( tmp == sum){\n                    continue;\n                }else{\n                    flag = false;\n                    break;\n                }\n            }\n        }else{\n            return flag;\n        }\n        if ( flag == true){\n            tmp = 0;\n            for ( int i = 0 ; i &lt; 3 ; i++){\n                tmp += num[i][i];\n            }\n            if ( tmp != sum){\n                flag = false;\n            }else{\n                flag = true;\n            }\n        }else{\n            return flag;\n        }\n        if ( flag == true){\n            tmp = 0;\n            for ( int i = 0 ; i &lt; 3 ; i++){\n                tmp += num[2-i][i];\n            }\n            if ( tmp == sum){\n                flag = true;\n            }else{\n                flag = false;\n            }\n        }\n        return flag;\n    }\n\n    public static void main(String[] args) {\n        // TODO Auto-generated method stub\n        Scanner in = new Scanner(System.in);\n        int[][] num = new int[3][3];\n        for ( int i = 0 ; i &lt; 3 ; i++){\n            for ( int j =  0 ; j &lt; 3 ; j++){\n                num[i][j] = in.nextInt();\n            }\n        }\n        if (IsEqual(num) == true){\n            System.out.println(1);\n        }else{\n            System.out.println(0);\n        }\n\n        in.close();\n    }\n\n}\r\n</textarea>	409
404	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　先编写函数EncryptChar,按照下述规则将给定的字符c转化（加密）为新的字符："A"转化"B"，"B"转化为"C"，... ..."Z"转化为"a"，"a"转化为"b",... ..., "z"转化为"A"，其它字符不加密。编写程序，加密给定字符串。\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  与上面的样例输入对应的输出。\n  <br> 例：\n  <br> \n  <img src="/RequireFile.do?fid=QJgFn3ba" width="269" height="65">\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　输入数据中每一个数的范围。\n  <br> 　　例：50个字符以内无空格字符串。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nvoid EncryptChar(char a[]);\nint main(void)\n{\n\tchar a[51];\n\tgets(a);\n\tEncryptChar(a);\n\tprintf("%s",a);\n\treturn 0;\n}\n\nvoid EncryptChar(char a[])\n{\n\tint i;\n\tfor(i=0;a[i]!='\\0';i++)\n\t{\n\t\tif(a[i]&gt;='A'&amp;&amp;a[i]&lt;'Z')\n\t\t{\n\t\t\ta[i]=a[i]+1;\n\t\t}\n\t\telse if(a[i]=='Z')\n\t\t{\n\t\t\ta[i]='a';\n\t\t}\n\t\telse if(a[i]&gt;='a'&amp;&amp;a[i]&lt;'z')\n\t\t{\n\t\t\ta[i]=a[i]+1;\n\t\t}\n\t\telse if(a[i]=='z')\n\t\t{\n\t\t\ta[i]='A';\n\t\t}\n\t}\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nchar EncryptChar(char c)\n{\n    if(c=='Z')\n        c='a';\n    else if(c=='z')\n        c='A';\n    else if(c&gt;='A'&amp;&amp;c&lt;='Y'||c&gt;='a'&amp;&amp;c&lt;='y')\n        c=c+1;\n    return c;\n}\nint main()\n{\n    char s[50];\n    int i;\n    scanf("%s",s);\n    for(i=0;s[i]!='\\0';i++)\n        s[i]=EncryptChar(s[i]);\n    printf("%s\\n",s);\n    return 0;\n}\n\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tchar[] s = br.readLine().toCharArray();\n\t\tbr.close();\n\t\tfor (int i = 0; i &lt;s.length; i++) {\n\t\t\ts[i] = EncryptChar(s[i]);\n\t\t}\n\t\tSystem.out.println(s);\n\t}\n\tpublic static char  EncryptChar(char c){\n\t\t\n\t\tif((c &gt;= 'a' &amp;&amp; c&lt;'z' ) || (c&gt;='A'&amp;&amp; c&lt;'Z')){\n\t\t\tc= (char) (c+1);\n\t\t}\n\t\telse if(c=='z'){\n\t\t\tc ='A';\n\t\t}else if(c=='Z'){\n\t\t\tc ='a';\n\t\t}\n\t\t\n\t\treturn c;\n\t}\n}\n\r\n</textarea>	410
405	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　摩尔斯电码破译。类似于乔林教材第213页的例6.5，要求输入摩尔斯码，返回英文。请不要使用"zylib.h"，只能使用标准库函数。用' * '表示' . '，中间空格用' | '表示，只转化字符表。\n  <br> \n  <br> 　　摩尔斯码定义见：http://baike.baidu.com/view/84585.htm?fromId=253988。\n  <br> \n  <br> \n  <img width="515" height="259" src="/RequireFile.do?fid=dafbnrF3">\n </div>\n <div class="pdsec">\n  提示\n </div>\n <div class="pdcont">\n  　　清橙进行评测时，输入是以EOF结尾的，而不是换行符。（EOF不是一个字符，“以EOF结尾”是一种通俗但不严谨的说法。）因此可以通过以下方式之一获取输入：\n  <br> \n  <br> 　　1. 一次读入整行字符串，再进行后续解析。\n  <br> \n  <br> 　　2. 使用getchar或scanf一次读入一个字符，通过它们的返回值判断输入结束。\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  <img width="238" height="57" src="/RequireFile.do?fid=d9rrhb57">\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nchar c[10000],a[26][10]={{"*-"},{"-***"},{"-*-*"},{"-**"},{"*"},{"**-*"},{"--*"},{"****"},\n{"**"},{"*---"},{"-*-"},{"*-**"},{"--"},{"-*"},{"---"},{"*--*"},{"--*-"},{"*-*"},\n{"***"},{"-"},{"**-"},{"***-"},{"*--"},{"-**-"},{"-*--"},{"--**"}};\nint main()\n{\n\tint i=0,j,k=0;\n\tchar b[1001],p;scanf("%c",&amp;p);\n\twhile(p!=EOF&amp;&amp;p)\n\t{\n\t\tif(p=='*'||p=='|'||p=='-')\n\t\t{\n\t\t\tif(p=='*'||p=='-')b[i]=p;\n\t\t\telse {b[i]='\\0';\n\t\t\t\tfor(j=0;j&lt;=26;j++)\n\t\t\t\t\tif(!strcmp(a[j],b))\n\t\t\t\t\t{c[k++]='a'+j;}\n\t\t\t\t\ti=-1;\n\t\t\t}\n\t\t}\n\t\telse break;\n\t\ti++;\n\t\tp=getchar();\n\t}\n\tb[i]='\\0';\n\tfor(j=0;j&lt;=26;j++)\n\t\t\tif(strcmp(a[j],b)==0)\n\t\t\t{c[k++]='a'+j;}\n\tc[k]=0;\n\tputs(c);\n\treturn 0;\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;map&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;stack&gt;\n#include &lt;cstdlib&gt;\n#include &lt;cstdio&gt;\nusing namespace std;\nstack&lt;char&gt;a;\nstring out(string a)\n{\n\tmap&lt;string, string&gt; mos;\n\tmos.insert(pair&lt;string, string&gt;("*-", "a"));\n\tmos.insert(pair&lt;string, string&gt;("-***", "b"));\n\tmos.insert(pair&lt;string, string&gt;("-*-*", "c"));\n\tmos.insert(pair&lt;string, string&gt;("-**", "d"));\n\tmos.insert(pair&lt;string, string&gt;("*", "e"));\n\tmos.insert(pair&lt;string, string&gt;("**-*", "f"));\n\tmos.insert(pair&lt;string, string&gt;("--*", "g"));\n\tmos.insert(pair&lt;string, string&gt;("****", "h"));\n\tmos.insert(pair&lt;string, string&gt;("**", "i"));\n\tmos.insert(pair&lt;string, string&gt;("*---", "j"));\n\tmos.insert(pair&lt;string, string&gt;("-*-", "k"));\n\tmos.insert(pair&lt;string, string&gt;("*-**", "l"));\n\tmos.insert(pair&lt;string, string&gt;("--", "m"));\n\tmos.insert(pair&lt;string, string&gt;("-*", "n"));\n\tmos.insert(pair&lt;string, string&gt;("---", "o"));\n\tmos.insert(pair&lt;string, string&gt;("*--*", "p"));\n\tmos.insert(pair&lt;string, string&gt;("--*-", "q"));\n\tmos.insert(pair&lt;string, string&gt;("*-*", "r"));\n\tmos.insert(pair&lt;string, string&gt;("***", "s"));\n\tmos.insert(pair&lt;string, string&gt;("-", "t"));\n\tmos.insert(pair&lt;string, string&gt;("**-", "u"));\n\tmos.insert(pair&lt;string, string&gt;("***-", "v"));\n\tmos.insert(pair&lt;string, string&gt;("*--", "w"));\n\tmos.insert(pair&lt;string, string&gt;("-**-", "x"));\n\tmos.insert(pair&lt;string, string&gt;("-*--", "y"));\n\tmos.insert(pair&lt;string, string&gt;("--**", "z"));\n\tmap&lt;string, string&gt;::iterator iter;\n\titer = mos.find(a);\n\treturn iter-&gt;second;\n}\nint main()\n{\n\tstring dd;\n\twhile(cin&gt;&gt;dd)\n\t{\n\t\tfor (int i = 0; i &lt; dd.length(); i++)\n\t\t{\n\t\t\ta.push(dd[i]);\n\t\t}\n\t}\n\tstring p;\n\tstring str;\n\twhile(!a.empty())\n\t{\n\t\tif(a.top()!='|')\n\t\t{\n\t\t\tp+=a.top();\n\t\t\ta.pop();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//cout&lt;&lt;p&lt;&lt;endl;\n\t\t\tstring q(p.rbegin(),p.rend());\n\t\t\tstr+=out(q);\n\t\t\ta.pop();\n\t\t\tp.clear();\n\t\t}\n\t}\n\tstring q(p.rbegin(),p.rend());\n\tstr+=out(q);\n\tp.clear();\n\tstring rev(str.rbegin(),str.rend());\n\tcout&lt;&lt;rev&lt;&lt;endl;\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\t\n\t\n\tpublic static void main(String[] args) throws Exception {\n\t\t\n\t\t\n\t\t\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[]  s= br.readLine().split("\\\\|") ;\n\t\tbr.close();\n\t\tfor (int i = 0; i &lt; s.length; i++) {\n\t\t\tSystem.out.print(getChars(s[i]));\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static String getChars(String key){\n\t\tswitch (key) {\n\t\tcase "*-":\n\t\t\treturn "a";\n\t\tcase "-***":\n\t\t\treturn "b";\n\t\tcase "-*-*":\n\t\t\treturn "c";\n\t\tcase "-**":\n\t\t\treturn "d";\n\t\tcase "*":\n\t\t\treturn "e";\n\t\tcase "**-*":\n\t\t\treturn "f";\n\t\tcase "--*":\n\t\t\treturn "g";\n\t\tcase "****":\n\t\t\treturn "h";\n\t\tcase "**":\n\t\t\treturn "i";\n\t\tcase "*---":\n\t\t\treturn "j";\n\t\tcase "-*-":\n\t\t\treturn "k";\n\t\tcase "*-**":\n\t\t\treturn "l";\n\t\tcase "--":\n\t\t\treturn "m";\n\t\tcase "-*":\n\t\t\treturn "n";\n\t\tcase "---":\n\t\t\treturn "o";\n\t\tcase "*--*":\n\t\t\treturn "p";\n\t\tcase "--*-":\n\t\t\treturn "q";\n\t\tcase "*-*":\n\t\t\treturn "r";\n\t\tcase "***":\n\t\t\treturn "s";\n\t\tcase "-":\n\t\t\treturn "t";\n\t\tcase "**-":\n\t\t\treturn "u";\n\t\tcase "***-":\n\t\t\treturn "v";\n\t\tcase "*--":\n\t\t\treturn "w";\n\t\tcase "-**-":\n\t\t\treturn "x";\n\t\tcase "-*--":\n\t\t\treturn "y";\n\t\tcase "--**":\n\t\t\treturn "z";\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\treturn "";\n\t}\n}\n\r\n</textarea>	411
406	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　自己实现一个比较字符串大小的函数，也即实现strcmp函数。函数：int myStrcmp(char *s1,char *s2) 按照ASCII顺序比较字符串s1与s2。若s1与s2相等返回0，s1&gt;s2返回1，s1&lt;s2返回-1。具体来说，两个字符串自左向右逐个字符相比（按ASCII值大小相比较），直到出现不同的字符或遇'\\0'为止（注意'\\0'值为0，小于任意ASCII字符）。如：\n  <br> 　　"A"&lt;"B"\n  <br> 　　"a"&gt;"A"\n  <br> 　　"computer"&gt;"compare"\n  <br> 　　"hello"&lt;"helloworld"\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  <img width="244" height="77" src="/RequireFile.do?fid=feaGhTD5">\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　字符串长度&lt;100。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\nint myStrcmp(char *s1,char *s2){\n\tint i;\n\tfor (i = 0; ; i++)\n\t{\n\t\tif(s1[i]&gt;s2[i])\n\t\t\treturn 1;\n\t\telse if(s1[i]&lt;s2[i])\n\t\t\treturn -1;\n\t\telse if(s1[i]=='\\0'&amp;&amp;s2[i]=='\\0')\n\t\t\treturn 0;\n\t\telse if(s1[i]=='\\0')\n\t\t\treturn -1;\n\t\telse if(s2[i]=='\\0')\n\t\t\treturn 1;\n\t}\n}\nint main()\n{\n\tchar a[1000],b[1000];\n\tgets(a);\n\tgets(b);\n\tprintf("%d\\n",myStrcmp(a,b));\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;string&gt;\nint main()\n{\n\tstd::string a, b;\n\tstd::cin &gt;&gt; a &gt;&gt; b;\n\tif (a == b)\n\t\tstd::cout &lt;&lt; " 0\\n";\n\telse if (a &lt; b)\n\t\tstd::cout &lt;&lt; "-1\\n";\n\telse\n\t\tstd::cout &lt;&lt; "1\\n";\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tString value1 = scanner.nextLine();\n\t\tString value2 = scanner.nextLine();\n\t\tint result = f(value1,value2);\n\t\tSystem.out.println(result);\n\t}\n\n\tprivate static int f(String value1, String value2) {\n\t\tint len = Math.min(value1.length(), value2.length());\n\t\tchar[] charArray = value1.toCharArray();\n\t\tchar[] charArray2 = value2.toCharArray();\n\t\tint i;\n\t\tfor (i = 0; i &lt; len; i++) {\n\t\t\tif(charArray[i]&gt;charArray2[i]){\n\t\t\t\treturn 1;\n\t\t\t}else if(charArray[i]&lt;charArray2[i]){\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif(charArray.length&gt;charArray2.length){\n\t\t\treturn 1;\n\t\t}else if(charArray.length&lt;charArray2.length){\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n}\n\r\n</textarea>	412
407	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　为库设计新函数DelPack，删除输入字符串中所有的重复元素。不连续的重复元素也要删除。\n  <br> 　　要求写成函数，函数内部使用指针操作。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  1223445667889\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  13579\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  else\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  ls\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　字符串数组最大长度为100。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nint main()\n{\n\tint i,n,j;\n\tchar a[101];\n\tgets(a);\n\tn=strlen(a);\n\tfor(i=0;i&lt;n;i++) \n\t    for(j=i+1;j&lt;n;j++)\n\t\t  if(a[i]==a[j])\n\t\t     {\n\t\t     \ta[i]='@';\n\t\t     \ta[j]='@';\n\t\t     }\n    for(i=0;i&lt;n;i++)\n    if(a[i]!='@')\n    printf("%c",a[i]);\n    return 0;\n\t\t\t  \n} \r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;string&gt;\nstruct aaa\n{\n\tchar b;\n\tint v;\n}aa[101];\nint main()\n{\n\tstd::string a;\n\tstd::cin &gt;&gt; a;\n\taa[0].b = a[0];\n\taa[0].v++;\n\tint i = 1, m = 1;\n\twhile (true)\n\t{\n\t\tint j;\n\t\tfor (j = 0; j &lt; m; j++)\n\t\t{\n\t\t\tif (aa[j].b == a[i])\n\t\t\t{\n\t\t\t\taa[j].v++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == m)\n\t\t{\n\t\t\taa[m].b = a[i];\n\t\t\taa[m].v++;\n\t\t\tm++;\n\t\t}\n\t\ti++;\n\t\tif (a[i] == '\\0')\n\t\t\tbreak;\n\t}\n\tfor (int i = 0; i &lt; m; i++)\n\t{\n\t\tif (aa[i].v == 1)\n\t\t\tstd::cout &lt;&lt; aa[i].b;\n\t}\n\tstd::cout &lt;&lt; std::endl;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\n\nimport java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tString string = scanner.next();\n\t\tchar[] charArray = string.toCharArray();\n\t\tStringBuffer buffer = new StringBuffer();\n\t\tint x = 0;\n\t\tfor (int i = 0; i &lt; charArray.length; i++) {\n\t\t\tfor (int j = 0; j &lt; charArray.length; j++) {\n\t\t\t\tif (charArray[j] == charArray[i]) {\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x == 1) {\n\t\t\t\tbuffer.append(charArray[i]);\n\t\t\t}\n\t\t\tx = 0;\n\t\t}\n\t\tSystem.out.println(buffer.toString());\n\t}\n\n}\n\r\n</textarea>	413
408	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　在一条直线上有n堆石子，每堆有一定的数量，每次可以将两堆相邻的石子合并，合并后放在两堆的中间位置，合并的费用为两堆石子的总数。求把所有石子合并成一堆的最小花费。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入第一行包含一个整数n，表示石子的堆数。\n  <br> 　　接下来一行，包含n个整数，按顺序给出每堆石子的大小 。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出一个整数，表示合并的最小花费。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  5\n  <br> 1 2 3 4 5\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  33\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　1&lt;=n&lt;=1000, 每堆石子至少1颗，最多10000颗。\n </div> \n</div>	<textarea id="codelinesc">\r\n \n#include &lt;stdio.h&gt;\n#define N 1001\n \nint n,t,stone[N],ans;\n\nvoid combine(int k)\n{\n    int tmp,i,j,d;\n\ttmp=stone[k]+stone[k-1];\n    ans+=tmp;\n    for(i=k; i&lt;t-1; i++)\n        stone[i]=stone[i+1];\n    t--;\n    for(j=k-1; j&gt;0 &amp;&amp; stone[j-1]&lt;tmp; j--)\n        stone[j] = stone[j-1];\n    stone[j] = tmp;\n    while(j &gt;= 2 &amp;&amp; stone[j] &gt;= stone[j-2])\n    {\n        d = t - j;\n        combine(j-1);\n        j = t-d;\n    }\n}\nint main()\n{\n    int i;\n\tscanf("%d",&amp;n);\n    for(i=0; i&lt;n; i++) scanf("%d",&amp;stone[i]);\n    t=1,ans=0;\n    for(i=1;i&lt;n;i++)\n    {\n        stone[t++]=stone[i];\n        while(t &gt;=3 &amp;&amp; stone[t-3]&lt;=stone[t-1])\n            combine(t-2);\n    }\n    while(t &gt; 1) combine(t-1);\n    printf("%d\\n" , ans);\n    return 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;string.h&gt;\n#include &lt;stdio.h&gt;\n\nusing namespace std;\nconst int N = 50005;\n\nint stone[N];\nint n,t,ans;\n\nvoid combine(int k)\n{\n    int tmp = stone[k] + stone[k-1];\n    ans += tmp;\n    for(int i=k;i&lt;t-1;i++)\n        stone[i] = stone[i+1];\n    t--;\n    int j = 0;\n    for(j=k-1;j&gt;0 &amp;&amp; stone[j-1] &lt; tmp;j--)\n        stone[j] = stone[j-1];\n    stone[j] = tmp;\n    while(j &gt;= 2 &amp;&amp; stone[j] &gt;= stone[j-2])\n    {\n        int d = t - j;\n        combine(j-1);\n        j = t - d;\n    }\n}\n\nint main()\n{\n    while(scanf("%d",&amp;n)!=EOF)\n    {\n        if(n == 0) break;\n        for(int i=0;i&lt;n;i++)\n            scanf("%d",stone+i);\n        t = 1;\n        ans = 0;\n        for(int i=1;i&lt;n;i++)\n        {\n            stone[t++] = stone[i];\n            while(t &gt;= 3 &amp;&amp; stone[t-3] &lt;= stone[t-1])\n                combine(t-2);\n        }\n        while(t &gt; 1) combine(t-1);\n        printf("%d\\n",ans);\n    }\n    return 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int n;\n\tstatic int count[][], s[][];\n\tstatic int value[], sum[];\n\n\tstatic int min(int a, int b) {\n\t\tif (a &lt; b)\n\t\t\treturn a;\n\t\telse\n\t\t\treturn b;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner reader = new Scanner(System.in);\n\t\tn = reader.nextInt();\n\t\tvalue = new int[n];\n\t\tsum = new int[n + 1];\n\t\ts = new int[n][n];\n\t\tfor (int i = 0; i &lt; n; i++)\n\t\t\tvalue[i] = reader.nextInt();\n\t\tsum[0] = 0;\n\t\tfor (int i = 1; i &lt;= n; i++)\n\t\t\tsum[i] = sum[i - 1] + value[i - 1];\n\t\tcount = new int[n][n];\n\t\tfor (int i = 0; i &lt; n - 1; i++) {\n\t\t\tcount[i][i + 1] = value[i] + value[i + 1];\n\t\t\ts[i][i + 1] = i;\n\t\t}\n\t\tfor (int i = n - 3; i &gt;= 0; i--) {\n\t\t\tfor (int j = i + 2; j &lt; n; j++) {\n\t\t\t\tcount[i][j] = count[i][i] + count[i + 1][j];\n\t\t\t\ts[i][j] = i;\n\t\t\t\tfor (int k = s[i][j - 1]; k &lt;= s[i + 1][j]; k++) {\n\t\t\t\t\tif (k &lt; j) {\n\t\t\t\t\t\tint ccount = count[i][k] + count[k + 1][j];\n\t\t\t\t\t\tif (ccount &lt; count[i][j]) {\n\t\t\t\t\t\t\ts[i][j] = k;\n\t\t\t\t\t\t\tcount[i][j] = ccount;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcount[i][j] += sum[j + 1] - sum[i];\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count[0][n - 1]);\n\t}\n}\r\n</textarea>	414
409	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　为二维空间中的点设计一个结构体，在此基础上为三角形设计一个结构体。分别设计独立的函数计算三角形的周长、面积、中心和重心。输入三个点，输出这三个点构成的三角形的周长、面积、外心和重心。结果保留小数点后2位数字。\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  与上面的样例输入对应的输出。\n  <br> 例：\n  <br> \n  <img src="/RequireFile.do?fid=HNB5deQa" width="182" height="147">\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　输入数据中每一个数的范围。\n  <br> 　　例：doule型表示数据。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;math.h&gt;\ntypedef struct node\n{\n\tdouble x;\n\tdouble y;\n}V;\ntypedef struct Node\n{\n\tV A;\n\tV B;\n\tV C;\n}Three;\nint main()\n{\n\tThree Q;\n\tdouble a,b,c,p,C,S;\n\tV O,G;\n\tscanf("%lf%lf",&amp;Q.A.x,&amp;Q.A.y);\n\tscanf("%lf%lf",&amp;Q.B.x,&amp;Q.B.y);\n\tscanf("%lf%lf",&amp;Q.C.x,&amp;Q.C.y);\n\ta=sqrt(pow((Q.B.x-Q.C.x),2)+pow((Q.B.y-Q.C.y),2));\n\tb=sqrt(pow((Q.A.x-Q.C.x),2)+pow((Q.A.y-Q.C.y),2));\n\tc=sqrt(pow((Q.A.x-Q.B.x),2)+pow((Q.A.y-Q.B.y),2));\n\tC=a+b+c;\n\tprintf("%.2f\\n",C);\n\tp=C/2;\n\tS=sqrt(p*(p-a)*(p-b)*(p-c));\n\tprintf("%.2lf\\n",S);\n\tO.x=(pow(Q.A.x,2)*(Q.B.y-Q.C.y)+pow(Q.B.x,2)*(Q.C.y-Q.A.y)+pow(Q.C.x,2)*(Q.A.y-Q.B.y)-(Q.A.y-Q.B.y)*(Q.B.y-Q.C.y)*(Q.C.y-Q.A.y))/(2*(Q.A.x*(Q.B.y-Q.C.y)+Q.B.x*(Q.C.y-Q.A.y)+Q.C.x*(Q.A.y-Q.B.y)));\n\tO.y=(pow(Q.A.y,2)*(Q.B.x-Q.C.x)+pow(Q.B.y,2)*(Q.C.x-Q.A.x)+pow(Q.C.y,2)*(Q.A.x-Q.B.x)-(Q.A.x-Q.B.x)*(Q.B.x-Q.C.x)*(Q.C.x-Q.A.x))/(2*(Q.A.y*(Q.B.x-Q.C.x)+Q.B.y*(Q.C.x-Q.A.x)+Q.C.y*(Q.A.x-Q.B.x)));\n\tprintf("%.2lf %.2lf\\n",O.x,O.y);\n\tG.x=(Q.A.x+Q.B.x+Q.C.x)/3;\n\tG.y=(Q.A.y+Q.B.y+Q.C.y)/3;\n\tprintf("%.2lf %.2lf",G.x,G.y);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include &lt;iostream&gt;\n#include &lt;math.h&gt;\n#include &lt;iomanip&gt;\nusing namespace std;\n\nstruct Spot\n{\n\tdouble x;\n\tdouble y;\n};\n class Triangle\n{\n\tprivate :\n\tdouble la;\n\tdouble lb;\n\tdouble lc; \n\tpublic :\n\tTriangle(struct Spot,struct Spot,struct Spot);\n\tdouble S();\n\tstruct Spot G(struct Spot a,struct Spot b,struct Spot c);\n\tstruct Spot Q(struct Spot a,struct Spot b,struct Spot c);\n\tdouble p;\n};\n\nTriangle::Triangle(struct Spot a,struct Spot b,struct Spot c)\n{\n\tla=sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n\tlb=sqrt(pow(a.x-c.x,2)+pow(a.y-c.y,2));\n\tlc=sqrt(pow(b.x-c.x,2)+pow(b.y-c.y,2));\n\tp=(la+lb+lc)/2;\n}\n\ndouble Triangle::S()\n{\n\treturn sqrt(p*(p-la)*(p-lb)*(p-lc));\n}\n\nstruct Spot Triangle::G(struct Spot a,struct Spot b,struct Spot c)\n{\n\tstruct Spot g;\n\tg.x=(a.x+b.x+c.x)/3;\n\tg.y=(a.y+b.y+c.y)/3;\n\treturn g;\n}\nstruct Spot Triangle::Q(struct Spot a,struct Spot b,struct Spot c)\n{\n\tdouble A1,B1,C1;\n\tdouble A2,B2,C2;\n\tstruct Spot q;\n\tA1=2*(b.x-a.x);\n\tB1=2*(b.y-a.y);\n\tC1=pow(b.x,2)+pow(b.y,2)-pow(a.x,2)-pow(a.y,2);\n\t\n\tA2=2*(c.x-b.x);\n\tB2=2*(c.y-b.y);\n\tC2=pow(c.x,2)+pow(c.y,2)-pow(b.x,2)-pow(b.y,2);\n\tq.x=((C1*B2)-(C2*B1))/((A1*B2)-(A2*B1));\n\tq.y=((A1*C2)-(A2*C1))/((A1*B2)-(A2*B1));\n\treturn q;\n}\nint main()\n{\n\tstruct Spot a,b,c,g,q;\n\tcin&gt;&gt;a.x;\n\tcin&gt;&gt;a.y;\n\tcin&gt;&gt;b.x;\n\tcin&gt;&gt;b.y;\n\tcin&gt;&gt;c.x;\n\tcin&gt;&gt;c.y;\n\tTriangle T(a,b,c);\n\tg=T.G(a,b,c);\n\tq=T.Q(a,b,c);\n\tcout&lt;&lt;setprecision(2)&lt;&lt;std::fixed&lt;&lt;T.p*2&lt;&lt;endl;\n\tcout &lt;&lt;setprecision(2) &lt;&lt;std::fixed &lt;&lt;T.S()&lt;&lt;endl;\n\tcout&lt;&lt;setprecision(2)&lt;&lt;std::fixed&lt;&lt;q.x&lt;&lt;" "&lt;&lt;q.y&lt;&lt;endl;\n\tcout&lt;&lt;setprecision(2)&lt;&lt;std::fixed&lt;&lt;g.x&lt;&lt;" "&lt;&lt;g.y&lt;&lt;endl;\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t@SuppressWarnings("resource")\n\t\tScanner sca=new Scanner(System.in);\n\t\tint[] arr=new int[6];\n\t\tfor(int i=0;i&lt;6;i++){\n\t\t\tarr[i]=sca.nextInt();\n\t\t}\n\t\tf(arr);\n\t\tf1(arr);\n\t}\n\t\n\tpublic static void f(int[] arr){ //周长、面积\n\t\tdouble a=Math.sqrt(Math.pow(arr[0]-arr[2],2)+Math.pow(arr[1]-arr[3],2));\n\t\tdouble b=Math.sqrt(Math.pow(arr[0]-arr[4],2)+Math.pow(arr[1]-arr[5],2));\n\t\tdouble c=Math.sqrt(Math.pow(arr[2]-arr[4],2)+Math.pow(arr[3]-arr[5],2));\n\t\tString zhouChang=String.format("%.2f",a+b+c);\n\t\tSystem.out.println(zhouChang);\n\t\tdouble p=(a+b+c)/2;\n\t\tdouble s=Math.sqrt(p*(p-a)*(p-b)*(p-c));\n\t\tString mianJi=String.format("%.2f",s);\n\t\tSystem.out.println(mianJi);\n\t}\n\t\n\tpublic static void f1(int[] arr){ //外心、重心\n\t\tdouble a1=2*(arr[2]-arr[0]);\n\t\tdouble a2=2*(arr[4]-arr[2]);\n\t\tdouble b1=2*(arr[3]-arr[1]);\n\t\tdouble b2=2*(arr[5]-arr[3]);\n\t\tdouble c1=Math.pow(arr[2], 2)+Math.pow(arr[3], 2)-Math.pow(arr[0], 2)-Math.pow(arr[1], 2);\n\t\tdouble c2=Math.pow(arr[4], 2)+Math.pow(arr[5], 2)-Math.pow(arr[2], 2)-Math.pow(arr[3], 2);\n\t\tdouble x=((c1*b2)-(c2*b1))/((a1*b2)-(a2*b1));\n\t\tdouble y=((a1*c2)-(a2*c1))/((a1*b2)-(a2*b1));\n\t\tString x0=String.format("%.2f",x);\n\t\tString y0=String.format("%.2f",y);\n\t\tSystem.out.println(x0+" "+y0);\n\t\tdouble x1=arr[0]+arr[2]+arr[4];\n\t\tdouble y1=arr[1]+arr[3]+arr[5];\n\t\tString x2=String.format("%.2f",x1/3);\n\t\tString y2=String.format("%.2f",y1/3);\n\t\tSystem.out.println(x2+" "+y2);\n\t}\n}\r\n</textarea>	415
410	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　扑克牌排序：构造扑克牌数组，对扑克牌进行排序。排序原则如下：数字从小到大是2-10、J、Q、K和A，花色从小到大是方块（diamond）、梅花（club）、红桃（heart）、黑桃（spade）。两张牌比较时先看数字，数字相同时看花色。要求对输入的扑克牌进行从小到大排序。\n  <br> 　　输入五张牌（表示黑桃2、红桃3、黑桃3、方块A和梅花J）： 2 s 3 h 3 s A d J c\n  <br> 　　输出结果应为：2 s 3 h 3 s J c A d数组长度固定为5。\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  与上面的样例输入对应的输出。\n  <br> 例：\n  <br> \n  <img src="/RequireFile.do?fid=T9mNjTr7" width="296" height="56">\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　输入数据中每一个数的范围。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nint number[1000];\nchar type[1000];\nint Fun(char string[])\n{\n\tint Number=0,Type=0;\n\tint i=0;\n\twhile(string[i])\n\t{\n\t\tif(string[i]&gt;='2' &amp;&amp; string[i]&lt;='9')\n\t\t{\n\t\t\tnumber[Number]=string[i]-'0';\n\t\t\ttype[Number]=string[i+1];\n\t\t\ti+=2;\n\t\t}\n\t\telse if(string[i]=='1' &amp;&amp; string[i+1]=='0')\n\t\t{\n\t\t\tnumber[Number]=10;\n\t\t\ttype[Number]=string[i+2];\n\t\t\ti+=3;\n\t\t}\n\t\telse if(string[i]=='J')\n\t\t{\n\t\t\tnumber[Number]=11;\n\t\t\ttype[Number]=string[i+1];\n\t\t\ti+=2;\n\t\t}\n\t\telse if(string[i]=='Q')\n\t\t{\n\t\t\tnumber[Number]=12;\n\t\t\ttype[Number]=string[i+1];\n\t\t\ti+=2;\n\t\t}\n\t\telse if(string[i]=='K')\n\t\t{\n\t\t\tnumber[Number]=13;\n\t\t\ttype[Number]=string[i+1];\n\t\t\ti+=2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnumber[Number]=14;\n\t\t\ttype[Number]=string[i+1];\n\t\t\ti+=2;\n\t\t}\n\t\tif(type[Number]=='d')\n\t\t\ttype[Number]=1;\n\t\tif(type[Number]=='c')\n\t\t\ttype[Number]=2;\n\t\tif(type[Number]=='h')\n\t\t\ttype[Number]=3;\n\t\tif(type[Number]=='s')\n\t\t\ttype[Number]=4;\n\t\tNumber++;\n\t}\n\ttype[Number]='\\0';\n/*\tfor(i=0;i&lt;Number;i++)\n\t{\n\t\tprintf("%d %c\\n",number[i],type[i]);\n\t}\n*/\treturn Number;\n}\nvoid paixu(int count)\n{\n\tint i,j,tempNum;\n\tchar tempType;\n\tfor(i=0;i&lt;count-1;i++)\n\t{\n\t\tfor(j=i+1;j&lt;count;j++)\n\t\t{\n\t\t\tif(number[i]&gt;number[j])\n\t\t\t{\n\t\t\t\ttempNum=number[i];\n\t\t\t\tnumber[i]=number[j];\n\t\t\t\tnumber[j]=tempNum;\n\t\t\t\ttempType=type[i];\n\t\t\t\ttype[i]=type[j];\n\t\t\t\ttype[j]=tempType;\n\t\t\t}\n\t\t\tif(number[i]==number[j])\n\t\t\t{\n\t\t\t\tif(type[i]&gt;type[j])\n\t\t\t\t{\n\t\t\t\t\ttempNum=number[i];\n\t\t\t\t\tnumber[i]=number[j];\n\t\t\t\t\tnumber[j]=tempNum;\n\t\t\t\t\ttempType=type[i];\n\t\t\t\t\ttype[i]=type[j];\n\t\t\t\t\ttype[j]=tempType;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid print(int count)\n{\n\tint i;\n\tfor(i=0;i&lt;count;i++)\n\t{\n\t\tif(number[i]==11)\n\t\t\tprintf("J");\n\t\telse if(number[i]==12)\n\t\t\tprintf("Q");\n\t\telse if(number[i]==13)\n\t\t\tprintf("K");\n\t\telse if(number[i]==14)\n\t\t\tprintf("A");\n\t\telse\n\t\t\tprintf("%d",number[i]);\n\t\tif(type[i]==1)\n\t\t\tprintf("d ");\n\t\tif(type[i]==2)\n\t\t\tprintf("c ");\n\t\tif(type[i]==3)\n\t\t\tprintf("h ");\n\t\tif(type[i]==4)\n\t\t\tprintf("s ");\n\t}\n}\nint main()\n{\n\tint count;\n\tchar string[5000];\n\tscanf("%s",string);\n\tmemset(number,0,sizeof(number));\n\tcount=Fun(string);\n\tpaixu(count);\n\tprint(count);\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n/*问题描述\n　　扑克牌排序：构造扑克牌数组，对扑克牌进行排序。\n\t排序原则如下：数字从小到大是2-10、J、Q、K和A，\n\t花色从小到大是方块（diamond）、梅花（club）、红桃（heart）、黑桃（spade）。\n\t两张牌比较时先看数字，数字相同时看花色。要求对输入的扑克牌进行从小到大排序。\n　　输入五张牌（表示黑桃2、红桃3、黑桃3、方块A和梅花J）： 2s3h3sAdJc\n　　输出结果应为：2 s 3 h 3 s J c A d数组长度固定为5。\n*/\n\n#include&lt;iostream&gt;\n#include&lt;stdio.h&gt;\nusing namespace std;\n\n\nint main(){\n\tchar arry[10];\n\tchar temp1,temp2;\n\tfor(int i=0;i&lt;10;i++){\n\t\tarry[i]=getchar();\n\t}\n\t\n\tfor(int i=0;i&lt;10;i++){\n\t\t\n\t\tswitch(arry[i]){\n\t\t\tcase 'J':\n\t\t\t\tarry[i]='a';\n\t\t\t\tbreak;\n\t\t\tcase 'Q':\n\t\t\t\tarry[i]='b';\n\t\t\t\tbreak;\n\t\t\tcase 'K':\n\t\t\t\tarry[i]='c';\n\t\t\t\tbreak;\n\t\t\tcase 'A':\n\t\t\t\tarry[i]='d';\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tarry[i]='e';\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tarry[i]='f';\n\t\t\t\tbreak;\n\t\t\tcase 'h':\n\t\t\t\tarry[i]='g';\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tarry[i]='h';\n\t\t\t\tbreak;\n\t\t\tdefault:\n        \t\tbreak;\n\t\t}\n\t}\n\tfor(int i=0;i&lt;5;i++){\t\t\t\t\t\t\t//冒泡排序 \n\t\tfor(int j=0;j&lt;8;j=j+2){\n\t\t\tif(arry[j]&gt;arry[j+2]){\n\t\t\t\ttemp1=arry[j];\n\t\t\t\ttemp2=arry[j+1];\n\t\t\t\tarry[j]=arry[j+2];\n\t\t\t\tarry[j+1]=arry[j+3];\n\t\t\t\tarry[j+2]=temp1;\n\t\t\t\tarry[j+3]=temp2;\n\t\t\t}else if(arry[j]==arry[j+2]){\n\t\t\t\tif(arry[j+1]&gt;arry[j+3]){\n\t\t\t\t\ttemp1=arry[j];\n\t\t\t\t\ttemp2=arry[j+1];\n\t\t\t\t\tarry[j]=arry[j+2];\n\t\t\t\t\tarry[j+1]=arry[j+3];\n\t\t\t\t\tarry[j+2]=temp1;\n\t\t\t\t\tarry[j+3]=temp2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\tfor(int i=0;i&lt;10;i++){\n\t\t\n\t\tswitch(arry[i]){\n\t\t\tcase 'a':\n\t\t\t\tarry[i]='J';\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tarry[i]='Q';\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tarry[i]='K';\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tarry[i]='A';\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tarry[i]='d';\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tarry[i]='c';\n\t\t\t\tbreak;\n\t\t\tcase 'g':\n\t\t\t\tarry[i]='h';\n\t\t\t\tbreak;\n\t\t\tcase 'h':\n\t\t\t\tarry[i]='s';\n\t\t\t\tbreak;\n\t\t\tdefault:\n        \t\tbreak;\n\t\t}\n\t}\n\tfor(int i=0;i&lt;10;i++){\n\t\tif(i!=0&amp;&amp;i%2==0){\n\t\t\tcout&lt;&lt;" ";\n\t\t}\n\t\tcout&lt;&lt;arry[i];\n\t}\n\t\n\treturn 0;\n} \r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.Scanner;\npublic class Main {\n\tpublic static class Poker{\n\t\tpublic int[] key=new int[2];\n\t\tpublic String Value;\n\t\tpublic Poker(String value)\n\t\t{\n\t\t\tValue=value;\n\t\t\tif(value.length()==3)\n\t\t\t{\n\t\t\t\tkey[0]=10;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tkey[0]=getValue(value.charAt(0));\n\t\t}\n\t\tpublic int getValue(char f)\n\t\t{\n\t\t\tif(f=='A')return 14;\n\t\t\telse if(f=='K')return 13;\n\t\t\telse if(f=='Q')return 12;\n\t\t\telse if(f=='J')return 11;\n\t\t\telse return (int)f-48;\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tMain.Poker[] pokers=new Main.Poker[5];\n\t\tString inpuke=new Scanner(System.in).next();\n\t\tint start=0,i=0,j;\n\t\twhile(i&lt;5)\n\t\t{\n\t\t\tfor(j=start;j&lt;inpuke.length();j++)\n\t\t\t{\n\t\t\t\tif(inpuke.charAt(j)=='d' || inpuke.charAt(j)=='c' || inpuke.charAt(j)=='h' || inpuke.charAt(j)=='s')\n\t\t\t\t{\n\t\t\t\t\tpokers[i]=new Main.Poker(inpuke.substring(start, j+1));\n\t\t\t\t\tswitch(inpuke.charAt(j))\n\t\t\t\t\t{\n\t\t\t\t\tcase 'd':\n\t\t\t\t\t\tpokers[i].key[1]=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tpokers[i].key[1]=2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'h':\n\t\t\t\t\t\tpokers[i].key[1]=3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 's':\n\t\t\t\t\t\tpokers[i].key[1]=4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tstart=j+1;\n\t\t\t\t\ti++;\n\t\t\t\t\tbreak;\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tfor(i=0;i&lt;5;i++)\n\t\t{\n\t\t\tfor(j=i+1;j&lt;5;j++)\n\t\t\t{\n\t\t\t\tif(pokers[i].key[0]&gt;pokers[j].key[0])\n\t\t\t\t{\n\t\t\t\t\tMain.Poker p=pokers[i];\n\t\t\t\t\tpokers[i]=pokers[j];\n\t\t\t\t\tpokers[j]=p;\n\t\t\t\t}\n\t\t\t\telse if(pokers[i].key[0]==pokers[j].key[0] &amp;&amp; pokers[i].key[1]&gt;pokers[j].key[1])\n\t\t\t\t{\n\t\t\t\t\tMain.Poker p=pokers[i];\n\t\t\t\t\tpokers[i]=pokers[j];\n\t\t\t\t\tpokers[j]=p;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i&lt;5;i++)\n\t\t{\n\t\t\tSystem.out.print(pokers[i].Value+" ");\n\t\t}\n\t}\n}\r\n</textarea>	416
411	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　有n个矩阵，大小分别为a0*a1, a1*a2, a2*a3, ..., a[n-1]*a[n]，现要将它们依次相乘，只能使用结合率，求最少需要多少次运算。\n  <br> 　　两个大小分别为p*q和q*r的矩阵相乘时的运算次数计为p*q*r。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入的第一行包含一个整数n，表示矩阵的个数。\n  <br> 　　第二行包含n+1个数，表示给定的矩阵。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出一个整数，表示最少的运算次数。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  3\n  <br> 1 10 5 20\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  150\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　1&lt;=n&lt;=1000, 1&lt;=ai&lt;=10000。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include &lt;stdio.h&gt;\n\nlong long N=3;\nlong long matri[1002]={1,10,5,20};\nlong long record[1002][1002]; \n\n/*int fun(int start,int end){\n\tint i=0;\n\tint min=9999999999,temp=0;\n\tif(start==end||start&lt;=0||end&gt;N) return 0;\n\tif(record[start][end]!=0) return record[start][end];\n\tfor(i=start;i&lt;end;i++){\n\t\ttemp=fun(start,i)+fun(i+1,end)+matri[start-1]*matri[i]*matri[end];\n\t\tif(min&gt;temp) \n\t\t\tmin=temp;\n\t}\n\trecord[start][end]=min;\n\treturn min;\n}      */    //效率低  只有40分\n\nvoid fun02(){\n\tlong long i,j,k=0,len=0;\n\tlong long temp=0;\n\n\tfor(i=0;i&lt;=N;i++) for(j=0;j&lt;=N;j++) record[i][j]=0;\n\n\tfor(len=2;len&lt;=N;len++){\n        for(i=1;i&lt;=N-len+1;i++){\n            j=i+len-1;\n\t\t\trecord[i][j]=9999999999999;\n\t\t\tfor(k=i;k&lt;=j-1;k++){\n                temp=record[i][k]+record[k+1][j]+matri[i-1]*matri[k]*matri[j];\n\t\t\t\tif(temp&lt;record[i][j]) \n\t\t\t\t\trecord[i][j]=temp;\n\t\t\t}\n\t\t}\n\t}\n    \n}  /*  */\n\nint main()  \n{   \n    long long  i=0,j=0;\n\tscanf("%lld",&amp;N);\n\tfor(i=0;i&lt;=N;i++) scanf("%lld",&amp;matri[i]);  /*  */\n\tfun02();\n\tprintf("%lld\\n",record[1][N]);\n\treturn 0;\n} \n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\nusing namespace std;\nint main()\n{\n\tint n;\n\tlong long l,answer[1001][1001], i, j, k,a[1001],temp;\n\tcin &gt;&gt; n;\n\tfor (i = 0; i &lt;= n; i++)\n\t\tcin &gt;&gt; a[i];\n\tfor (i = 1; i &lt;= n; i++)\n\t\tanswer[i][i] = 0;\n\tfor (l = 2; l &lt;= n; l++)\n\t{\n\t\tfor (i = 1; i &lt;= n - l+1; i++)\n\t\t{\n\t\t\tj = i +l-1;\n\t\t\tanswer[i][ j] = 1000000000000;\n\t\t\tfor (k = i; k &lt;= j - 1; k++)\n\t\t\t{\n\t\t\t\ttemp = answer[i][k] + answer[k + 1][j] + a[i - 1] * a[k] * a[j];\n\t\t\t\tif (temp &lt; answer[i][j])\n\t\t\t\t\tanswer[i][j] = temp;\n\t\t\t}\n\t\t}\n\t}\n\tcout &lt;&lt; answer[1][n];\n}\r\n</textarea>	<textarea id="codelinesjava">\r\n\n/*\n *  author:sorahjy\n *  lang:Java\n *  university:China,University of Shanghai for Science and Technology\n */\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.StreamTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tStreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n\t\tin.nextToken();\n\t\tint n=(int)in.nval;\n\t\tlong [] a= new long[n+2];\n\t\tlong dp[][] = new long[n+2][n+2];\n\t\tfor(int i=1;i&lt;=n+1;i++){\n\t\t\tin.nextToken();\n\t\t\ta[i]=(int)in.nval;\n\t\t}\n\n\t\tfor(int i=2;i&lt;=n+1;i++){\n\t\t\tfor(int j=1;j&lt;=n+1-i;j++){\n\t\t\t\tdp[j][j+i]=Long.MAX_VALUE;\n\t\t\t\tfor(int k=0;k&lt;i-1;k++){\n\t\t\t\t\tlong temp=a[j]*a[j+1+k]*a[j+i]+dp[j][j+1+k]+dp[j+1+k][j+i];\n\t\t\t\t\tdp[j][j+i]=Math.min(dp[j][j+i],temp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(dp[1][n+1]);\n\t}//main\n\n}\r\n</textarea>	417
412	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　﻿队列操作题。根据输入的操作命令，操作队列（1）入队、（2）出队并输出、（3）计算队中元素个数并输出。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　第一行一个数字N。\n  <br> 　　下面N行，每行第一个数字为操作命令（1）入队、（2）出队并输出、（3）计算队中元素个数并输出。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　若干行每行显示一个2或3命令的输出结果。注意：2.出队命令可能会出现空队出队（下溢），请输出“no”，并退出。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  7\n  <br> 1 19\n  <br> 1 56\n  <br> 2\n  <br> 3\n  <br> 2\n  <br> 3\n  <br> 2\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  19\n  <br> 1\n  <br> 56\n  <br> 0\n  <br> no\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　1&lt;=N&lt;=50\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#define MAX 100\ntypedef struct\n{\n\tlong long int data[MAX];\n\tint front,rear;\n}SEQUEUE;\nint inqueue(SEQUEUE *q,int x)\n{\n\tif(q-&gt;front==(q-&gt;rear+1)%MAX)\n\t{\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tq-&gt;rear=(q-&gt;rear+1)%MAX;\n\t\tq-&gt;data[q-&gt;rear]=x;\n\t}\n}\nint outqueue(SEQUEUE *q)\n{\n\tif(q-&gt;front==q-&gt;rear)\n\t{\n\t\tprintf("no\\n");\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tq-&gt;front=(q-&gt;front+1)%MAX;\n\t\tprintf("%lld\\n",q-&gt;data[q-&gt;front]);\n\t}\n}\nvoid countqueue(SEQUEUE *q)\n{\n\tint sum;\n\tsum=(q-&gt;rear-q-&gt;front+MAX)%MAX;\n\tprintf("%d\\n",sum);\n}\nint main()\n{\n\tint flag,x,n;\n\tSEQUEUE a,*p;\n\tp=&amp;a;\n\ta.front=-1;\n\ta.rear=-1;\n\tscanf("%d",&amp;n);\n\twhile(n--)\n\t{\n\t\tscanf("%d",&amp;flag);\n\t\tswitch(flag)\n\t\t{\n\t\t\tcase 1:\tscanf("%lld",&amp;x); inqueue(p,x); break;\n\t\t\tcase 2:\n\t\t\t\tif(outqueue(p)==0)\n\t\t\t\t{\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\tcountqueue(p); break;\n\t\t}\n\t}\n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinescpp">\r\n#include "stdlib.h"\n#include "stdio.h"\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\nusing namespace std;\n\nint main()\n{\n\tqueue&lt;int&gt; q; \n\tint n=0,num=0,i,element=0,j;\n\tcin&gt;&gt;n;\n\tfor(i=0;i&lt;n;i++)\n\t{\t\n\t\tcin&gt;&gt;num;\n\t\tswitch(num)\n\t\t{\n\t\t\tcase 1:\n\t\t\t\t{\n\t\t\t\t\tcin&gt;&gt;element; \n\t\t\t\t\tq.push(element);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\t{\n\t\t\t\t\tif(q.empty()==0)\n\t\t\t\t\t{\n\t\t\t\t\t\t\n\t\t\t\t\t\tcout&lt;&lt;q.front()&lt;&lt;endl;\n\t\t\t\t\t\t\n\t\t\t\t\t\tq.pop(); \n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcout&lt;&lt;"no"&lt;&lt;endl;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\t{\n\t\t\t\t\tcout&lt;&lt;q.size()&lt;&lt;endl;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t} \n\treturn 0;\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.Stack;\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tQueue&lt;Integer&gt; sk = new LinkedList&lt;Integer&gt;();\n\t\tArrayList&lt;String &gt; al = new ArrayList&lt;String&gt;();\n\t\tint n = cin.nextInt();\n\t\twhile(n--&gt;0){\n\t\t\tint a = cin.nextInt();\n\t\t\tif(a == 1){\n\t\t\t\tint  b = cin.nextInt();\n\t\t\t\tsk.add(b);\n\t\t\t}\n\t\t\telse if( a== 2&amp;&amp;sk.size()&gt;0)\n\t\t\t\tal.add(String.valueOf(sk.poll()));\n\t\t\telse if(a==2&amp;&amp;sk.size()==0){\n\t\t\t\tal.add("no");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(a==3)\n\t\t\t\tal.add(String.valueOf(sk.size()));\n\t\t}\n\t\tfor (String string : al) {\n\t\t\tSystem.out.println(string);\n\t\t}\n\t}\n\n}\n\r\n</textarea>	418
413	<div class="des"> \n <div class="pdsec">\n  问题描述\n </div>\n <div class="pdcont">\n  　　输入一个只包含加减乖除和括号的合法表达式，求表达式的值。其中除表示整除。\n </div>\n <div class="pdsec">\n  输入格式\n </div>\n <div class="pdcont">\n  　　输入一行，包含一个表达式。\n </div>\n <div class="pdsec">\n  输出格式\n </div>\n <div class="pdcont">\n  　　输出这个表达式的值。\n </div>\n <div class="pdsec">\n  样例输入\n </div>\n <div class="pddata">\n  1-2+3*(4-5)\n </div>\n <div class="pdsec">\n  样例输出\n </div>\n <div class="pddata">\n  -4\n </div>\n <div class="pdsec">\n  数据规模和约定\n </div>\n <div class="pdcont">\n  　　表达式长度不超过100，表达式运算合法且运算过程都在int内进行。\n </div> \n</div>	<textarea id="codelinesc">\r\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n#include&lt;math.h&gt;\n#define MAXSIZE 101\nvoid Translate(char str[], char exp[])\n{\n    char stack[MAXSIZE];\n    int i = 0, k = 0, top = -1;\n    while (str[i] != '\\0')\n    {\n        if (str[i] == '(')\n        {\n            stack[++top] = str[i++];\n        }\n        else if (str[i] == ')')\n        {\n            while (top &gt;= 0 &amp;&amp; stack[top] != '(')\n            {\n                exp[k++] = stack[top--];\n            }\n\n            if (top &lt; 0)\n            {\n                exp[k++] = '\\0';\n                return ;\n            }\n            top--;\n            i++;\n        }\n        else if (str[i] == '+' || str[i] == '-')\n        {\n            while (top &gt;= 0 &amp;&amp; stack[top] != '(')\n            {\n                exp[k++] = stack[top--];\n            }\n            stack[++top] = str[i++];\n        }\n        else if (str[i] == '*' || str[i] == '/')\n        {\n            while (top &gt;= 0 &amp;&amp; (stack[top] == '*' || stack[top] == '/'))\n            {\n                exp[k++] = stack[top--];\n            }\n            stack[++top] = str[i++];\n        }\n        else\n        {\n            while ((str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9'))\n            {\n                exp[k++] = str[i++];\n            }\n            exp[k++] = '#';\n        }\n    }\n    while (top &gt;= 0)\n    {\n        if (stack[top] == '(')\n        {\n            exp[k++] = '\\0';\n            return ;\n        }\n        exp[k++] = stack[top--];\n    }\n    exp[k++] = '\\0';\n}\n\nint CompValue(char *exp)\n{\n    char tempStr[MAXSIZE];\n    int stack[MAXSIZE];\n    int i = 0, k = 0, top = -1;\n\n    while (exp[i] != '\\0')\n    {\n        if (exp[i] &gt;= '0' &amp;&amp; exp[i] &lt;= '9')\n        {\n            k = 0;\n            while (exp[i] != '#')\n            {\n                tempStr[k++] = exp[i++];\n            }\n            tempStr[k] = '\\0';\n            stack[++top] = atoi(tempStr);\n            i++;\n        }\n        else\n        {\n            switch (exp[i++])\n            {\n                case '+' : stack[top-1] += stack[top];\n                           break;\n                case '-' : stack[top-1] -= stack[top];\n                           break;\n                case '*' : stack[top-1] *= stack[top];\n                           break;\n                case '/' : if (stack[top] != 0)\n                           {\n                                  stack[top-1] /= stack[top];\n                           }\n                           else\n                           {\n                               return 0;\n                           }\n                           break;\n            }\n            top--;\n        }\n    }\n    return stack[top];\n}\nint main()\n{\n    char buf[MAXSIZE],buf1[MAXSIZE];\n    scanf("%s",buf);\n    Translate(buf,buf1);\n    printf("%d",CompValue(buf1));\n    return 0;\n}\n\r\n</textarea>	<textarea id="codelinescpp">\r\n#include&lt;iostream&gt;\n//#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\nusing namespace std;\ntypedef int ETlemType;\ntypedef int status;\n#define MAXSIZE 15//顺序栈的最大长度\n#define OK 1\n#define ERROR 0\n#define OVERSTACK 0//满栈溢出\ntypedef struct  Stack1\n{\n\tETlemType date[MAXSIZE];\n\tint top;\n\t//int stacksiza;//栈的最大长度 \n}SqStack;\nint Compare(char ch,char b);\nstatus InitStack(SqStack &amp;s);//建立空栈\nstatus Push(SqStack &amp;s,ETlemType e);//进栈\nstatus StackEmpty( SqStack s );//判断栈是否为空\nstatus Pop(SqStack &amp;s,ETlemType &amp;e);//出栈\nstatus GetTop(SqStack s, ETlemType  &amp;e);//取栈顶元素\nint Operation(char ch,int ch1,int ch2);//运算\nint houzhi(int Out[],int pd[],char a[],SqStack s);//转换为后缀表达式,pd用于判断是数字还是运算符.,同事时返回长度\nint zhuanhuan(char a[],char b[]);\n//int zhuanhuan(char a[],char b[]);\nint main()\n{\n\tint i=0,j=0;\n\tchar a[1000];\n\tint Out[500],pd[500],ch;\n\tint length=0;\n\tSqStack s;//数字栈，运算符栈\n\tcin&gt;&gt;a;\n\t//cout&lt;&lt;a&lt;&lt;endl;\n//\tlength=zhuanhuan(b,a);\n\tInitStack(s);\n\tlength=houzhi(Out,pd,a,s);\n//\tcout&lt;&lt;"ooo"&lt;&lt;Out[0]&lt;&lt;endl;\n\ti=0;\n\tint ch1=0,ch2=0;\n\tdo\n\t{\n\t\tif(pd[i]==1)\n\t\t{\n\t\t\tch=Out[i];\n\t\t\tPush(s,ch);//入栈\n\t\t\t//cout&lt;&lt;ch&lt;&lt;endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tPop(s,ch1);\n\t\t\tPop(s,ch2);\n\t\t/*\tcout&lt;&lt;"ch1  "&lt;&lt;(int)ch1&lt;&lt;endl;\n\t\t\tcout&lt;&lt;"ch2  "&lt;&lt;(int)ch2&lt;&lt;endl;\n\t\t\tcout&lt;&lt;"测试"&lt;&lt;Operation(Out[j],(int)ch1,(int)ch2)&lt;&lt;endl;*/\n\t\t\tPush(s,Operation((char)Out[i],(int)ch1,(int)ch2));\n\t\t}\n\t\ti++;\n\t}while(i&lt;length);\n\tcout&lt;&lt;s.date[0]&lt;&lt;endl;\n//\tcout&lt;&lt;(int)s.date[0]&lt;&lt;endl;\n\treturn 0;\n}\nint houzhi(int Out[],int pd[],char a[],SqStack s)//转换为后缀表达式,pd用于判断是数字还是运算符\n{\n\tint ch,sum;\n\tint i=0,j=0;\n\tdo\n\t{\n\t\tif(a[i]&lt;='9' &amp;&amp; a[i]&gt;='0')\n\t\t{\n\t\t\tsum=0;\n\t\t\twhile(a[i]&lt;='9' &amp;&amp; a[i]&gt;='0')\n\t\t\t{sum=sum*10+a[i]-'0';i++;}\n\t\t\ti--;\n\t\t\tOut[j++]=sum;pd[j-1]=1;\n\t\t}\n\t\telse if(a[i]==')'){\n\t\t\tdo\n\t\t\t{\n\t\t\t\tPop(s,ch);\n\t\t\t\tif(ch=='(')break;\n\t\t\t\tOut[j++]=ch;pd[j-1]=0;\n\t\t\t}while(1);\n\n\t\t}\n\t\telse if(a[i]=='(')Push(s,a[i]);\n\t\telse if(a[i]=='\\0'){//cout&lt;&lt;"111"&lt;&lt;endl;\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\tPop(s,ch);\n\t\t\t\tOut[j++]=ch;\n\t\t\t\tpd[j-1]=0;//cout&lt;&lt;"333"&lt;&lt;endl;\n\t\t\t\t}while(s.top!=-1);//\n\t\t\t\tbreak;//运算符移位完成\n\t\t}\n\t\telse{\n\n\t\t\tif(StackEmpty(s))\n\t\t\t{//如果栈不为空\t\n\t\t\t\tGetTop(s,ch);\n\t\t\t\tif(  Compare(ch,a[i])&gt;0  &amp;&amp; ch!='(')//栈顶元素优先级高则输出\n\t\t\t\t{//cout&lt;&lt;"111"&lt;&lt;endl;//p;\n\t\t\t\t\twhile(Compare(ch,a[i])&gt;0  &amp;&amp; ch!='(' &amp;&amp; StackEmpty(s) )\n\t\t\t\t\t{Pop(s,ch);Out[j++]=ch;pd[j-1]=0;GetTop(s,ch);}//[[[[[[[[[[\n\t\t\t\t}\n\t\t\t}\n\t\t\tPush(s,a[i]);\n\t\t}\n\t\ti++;\n\t}while(1);//运算符中缀改为后缀\n\t//Out[j]=0;//puts(Out);//实验\n\t/*for(i=0;i&lt;j;i++)\n\t{\n\t\tcout&lt;&lt;(char)Out[i]&lt;&lt;" ";\n\t}\n\tcout&lt;&lt;endl;*/\n\treturn j;\n}\n/*int zhuanhuan(char a[],char b[])\n{\n\tint i,j=0,sum;\n\tfor(i=0;a[i]!=0;i++)\n\t{\n\t\tif(a[i]&lt;='9' &amp;&amp; a[i]&gt;=0)\n\t\t{\n\t\t\tsum=0;\n\t\t\twhile(a[i]&lt;='9' &amp;&amp; a[i]&gt;=0)\n\t\t\t\tsum=sum*10+a[i]-'0';\n\t\t\tb[j++]=sum;\n\t\t\ti--;\n\t\t}\n\t\telse b[j++]=a[i];\n\t}\n\treturn j;\n}*/\nint Compare(char ch,char b)\n{\n\tswitch(b)\n\t{\n\tcase '+':return 1;//优先级低于ch\n\tcase '-':if(ch!='*' &amp;&amp; ch=='/')return -1;//b的优先级不低于ch\n\t\t\t\telse return 1;//优先级低于ch\n\tcase '/':\n\tcase '*':return -1;//b处于优先级最高位\n\tdefault:break;\n\t}\n\treturn 1;\n}\nstatus InitStack(SqStack &amp;s)//建立空栈\n{\n\ts.top=-1;\n\treturn OK;\n}\nstatus Push(SqStack &amp;s,ETlemType e)//进栈\n{\n\tif(s.top&gt;=MAXSIZE-1)return ERROR;\n\ts.top++;\n\ts.date[s.top]=e;\n\treturn OK;\n}\nstatus StackEmpty( SqStack s )//判断栈是否为空\n{\n\tif(s.top&lt;=-1)return ERROR;\n\treturn OK;\n}\nstatus Pop(SqStack &amp;s,ETlemType &amp;e)//出栈\n{\n\tif(s.top&lt;=-1)return ERROR;\n\n\te=s.date[s.top];\n\ts.top--;\n\treturn OK;\n}\nstatus GetTop(SqStack s, ETlemType  &amp;e)//取栈顶元素\n{\n\tif(s.top==-1)return ERROR;\n\te=s.date[s.top];\n\treturn OK;\n}\nint Operation(char ch,int ch1,int ch2)\n{\n\tswitch(ch)\n\t{\n\tcase '+':return (ch2+ch1);\n\tcase '-':return (ch2-ch1);\n\tcase '*':return (ch2*ch1);\n\tcase '/':return (ch2/ch1);\n\tdefault:return -1 ;break;\n\t}\n}\r\n</textarea>	<textarea id="codelinesjava">\r\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringBuilder s=new StringBuilder("("+br.readLine()+")");\n\t\tStringBuilder src=new StringBuilder();\n\t\twhile(true){\n\t\t\tint a = s.lastIndexOf("(");\n\t\t\tint b = s.indexOf(")",a);\n\t\t\tif(a == -1)\n\t\t\t\tbreak;\n\t\t\tsrc.append(s.substring(a+1,b));\n\t\t\ts.delete(a, b+1);\n\t\t\tfor(int i=0;i&lt;src.length();i++){\n\t\t\t\tif(src.charAt(i)=='*'){\n\t\t\t\t\tfn(src,'*' , i);\n\t\t\t\t\ti=0;\n\t\t\t\t}else if(src.charAt(i)=='/'){\n\t\t\t\t\tfn(src, '/', i);\n\t\t\t\t\ti=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i&lt;src.length();i++){\n\t\t\t\tif(src.charAt(i)=='+'){\n\t\t\t\t\tfn(src, '+', i);\n\t\t\t\t\ti=0;\n\t\t\t\t}\n\t\t\t\tif(src.charAt(i)=='-'){\n\t\t\t\t\tfn(src, '-', i);\n\t\t\t\t\ti=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\ts.insert(a, src);\n\t\t\tsrc.delete(0,src.length());\n\t\t}\n\t\tSystem.out.println(s);\n\t}\n\t//(-20+-500)\n\tpublic static void fn(StringBuilder src,char c,int i){\n\t\tif(i==0)return;\n\t\tint x=0;\n\t\tint y=0;\n\t\tint j;\n\t\tString list="0123456789+-";\n\t\tStringBuilder temp=new StringBuilder();\n\t\t//22--200\n\t\tfor(j=i-1;j&gt;=0 &amp;&amp; list.contains(""+src.charAt(j)); j--){\n\t\t\ttry {\n\t\t\t\tif((src.charAt(j)=='-'||src.charAt(j)=='+') &amp;&amp; (src.charAt(j-1)!='-'&amp;&amp;src.charAt(j-1)!='+')){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(temp.charAt(0)=='+'||temp.charAt(0)=='-'){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n//\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\t\n\t\t\ttemp.insert(0, src.charAt(j));\n\t\t\tsrc.deleteCharAt(j);\n\t\t}\n\t\tx=Integer.parseInt(temp.toString());\n\t\ttemp.delete(0,temp.length());\n\t\tfor(j=j+2;j&lt;src.length() &amp;&amp; list.contains(""+src.charAt(j));){\n\t\t\tif((src.charAt(j)=='+'||src.charAt(j)=='-')&amp;&amp;temp.length()!=0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttemp.append(src.charAt(j));\n\t\t\tsrc.deleteCharAt(j);\n\t\t}\n\t\ty=Integer.parseInt(temp.toString());\n\t\tint res;\n\t\tswitch(c){\n\t\t\tcase '*':\n\t\t\t\tres=x*y;\n\t\t\t\tsrc.deleteCharAt(j-1);\n\t\t\t\tsrc.insert(j-1, ""+res);\n\t\t\t\tbreak;\n\t\t\tcase '/':\n\t\t\t\tres=x/y;\n\t\t\t\tsrc.deleteCharAt(j-1);\n\t\t\t\tsrc.insert(j-1, ""+res);\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\t\tres=x+y;\n\t\t\t\tsrc.deleteCharAt(j-1);\n\t\t\t\tsrc.insert(j-1, ""+res);\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tres=x-y;\n\t\t\t\tsrc.deleteCharAt(j-1);\n\t\t\t\tsrc.insert(j-1, ""+res);\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\r\n</textarea>	419
\.


--
-- Name: problemdetail_id_seq; Type: SEQUENCE SET; Schema: public; Owner: 123
--

SELECT pg_catalog.setval('problemdetail_id_seq', 413, true);


--
-- Name: problem problem_pkey; Type: CONSTRAINT; Schema: public; Owner: 123
--

ALTER TABLE ONLY problem
    ADD CONSTRAINT problem_pkey PRIMARY KEY (id);


--
-- Name: problemdetail problemdetail_pkey; Type: CONSTRAINT; Schema: public; Owner: 123
--

ALTER TABLE ONLY problemdetail
    ADD CONSTRAINT problemdetail_pkey PRIMARY KEY (id);


--
-- Name: problemdetail uk_erktox58x8jhrw336hnd2efoq; Type: CONSTRAINT; Schema: public; Owner: 123
--

ALTER TABLE ONLY problemdetail
    ADD CONSTRAINT uk_erktox58x8jhrw336hnd2efoq UNIQUE (problem_id);


--
-- Name: problem uk_skvqbg2438iiu7adyio2i5kmt; Type: CONSTRAINT; Schema: public; Owner: 123
--

ALTER TABLE ONLY problem
    ADD CONSTRAINT uk_skvqbg2438iiu7adyio2i5kmt UNIQUE (gpid);


--
-- Name: problemdetail fk1eor4f4ok4fpvo7ips1t99vfh; Type: FK CONSTRAINT; Schema: public; Owner: 123
--

ALTER TABLE ONLY problemdetail
    ADD CONSTRAINT fk1eor4f4ok4fpvo7ips1t99vfh FOREIGN KEY (problem_id) REFERENCES problem(id);


--
-- PostgreSQL database dump complete
--

